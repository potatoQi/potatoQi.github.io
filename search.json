[{"title":"0. 引言","url":"/2023/10/05/0-%E5%BC%95%E8%A8%80/","content":"<p>在阅读一篇关于多智能体强化学习的论文时，发现涉及到凸优化的知识我不会。于是打算自学，参考的教程是<a\r\nhref=\"https://www.bilibili.com/video/BV19M411T7S7?p=1&amp;vd_source=2501060da9b4bef86e2b8ec8a8d880b5\">中科大凌青老师的教学视频</a>。</p>\r\n<p>文中的笔记是我看完课程后的思考与总结，可能有错误还请指出！我速速修改=w=</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n","categories":["4. 大学","数学","凸优化"]},{"title":"2. 几种重要的凸集-上","url":"/2023/10/05/2-%E5%87%A0%E7%A7%8D%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%B8%E9%9B%86-%E4%B8%8A/","content":"<p>介绍了一个点、空集、超平面、半空间、球、椭球。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n<p><img src=\"2.jpg\" /></p>\r\n","categories":["4. 大学","数学","凸优化"]},{"title":"1. 仿射集/凸集/凸锥","url":"/2023/10/05/1-%E4%BB%BF%E5%B0%84%E9%9B%86-%E5%87%B8%E9%9B%86-%E5%87%B8%E9%94%A5/","content":"<p>介绍了仿射集、凸集、凸锥的概念，以及三者之间的联系。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n<p><img src=\"2.jpg\" /></p>\r\n","categories":["4. 大学","数学","凸优化"]},{"title":"2024上半年算法竞赛游记","url":"/2024/06/22/2024%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%B8%B8%E8%AE%B0/","content":"<p>内容包括：ccpc全国邀请赛（山东）、ccpc重庆市塞、ccpc四川省赛</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"ccpc全国邀请赛山东\">ccpc全国邀请赛（山东）</h3>\r\n<p>赛后没有第一时间写游记，题目忘了。</p>\r\n<p>酒店不错，比赛场地很大队伍很多，中午的塔斯汀很好吃，题目也能给我们这些菜鸡做对个五六道。</p>\r\n<p>我记得有俩签到，一个二分，一个模拟。</p>\r\n<p>然后一个贪心，做过类似的题：<a\r\nhref=\"https://www.acwing.com/problem/content/907/\">区间选点</a></p>\r\n<p>一个普通的最小生成树变式，一个涉及到后缀和的思维题，一个找规律填空题。</p>\r\n<p>我们应该是做了6题，最后是铜。</p>\r\n<p>尽力了，从高二以来已经3年没打算法了，这个结果对我来说挺满意。</p>\r\n<h3 id=\"ccpc重庆市赛\">ccpc重庆市赛</h3>\r\n<p>赛后没有第一时间写游记，题目忘了。</p>\r\n<p>志愿者培训没做好，在比赛的时候发出了“讨论请安静点！”的逆天言论，以及比赛开始后才一个个发纸质版题目，差评。以及测评网站用的一个免费的网站，比赛中出现了账号无法登录的问题，差评。</p>\r\n<p>仨签到。</p>\r\n<p>然后一个前缀和，做过类似的题，牛客训练赛里的，找不到了。</p>\r\n<p>然后一个贪心题+简单dfs题。</p>\r\n<p>还有一题队友写的，不知道是啥算法的题，好像是一道思维题。</p>\r\n<p>最后金尾。</p>\r\n<p>遗憾的是有一题hash+二分+dfs的题做了很久没调出来，事后证明思路是正确的，debug能力差了点没弄出来，可惜。</p>\r\n<h3 id=\"ccpc四川省赛\">ccpc四川省赛</h3>\r\n<p>赛后没有第一时间写游记，题目忘了。</p>\r\n<p>场地偏小但凑合，中午的食物质量正常，比赛发的衣服不错，赛后奖品还行。</p>\r\n<p>但是是上半年发挥最差的一场。</p>\r\n<p>上去先把仨签到迅速切了，此时的我们是金的排名。</p>\r\n<p>后面4个小时一题没开出来，难蚌。</p>\r\n<p>我和另一个队友卡在一个非常非常简单的计算几何，另一个队友卡在一道简单的贪心。</p>\r\n<p>如果状态好的话，就是5题，银首。</p>\r\n<p>但世界上没那么多如果，菜就是菜了，最后铜。</p>\r\n","categories":["3. 竞赛"]},{"title":"2024数学建模国赛游记","url":"/2024/09/09/2024%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9B%BD%E8%B5%9B%E6%B8%B8%E8%AE%B0/","content":"<p>2024年数学建模国赛游记</p>\r\n<span id=\"more\"></span>\r\n<p>其实也没啥好写的，总结就是队友给力，大家尽力，传奇论文手、天使建模手。</p>\r\n<p>打数模这事也是和舍友偶然一次聊天，了解到他打数模，没找到队友，于是我说可以一起打啊，便这样组好了队（两个建模手）。后来，他又拉到我们班一同班同学（传奇论文手）。于是三人队就此形成。</p>\r\n<p>在正赛之前我们进行过两次正式训练，一次校赛，一次自己打的训练赛。其余日常的小训练就不说了。说来惭愧，日常的数模学习我其实并没有学非常多数模知识，大多数只是泛泛而谈，即了解一下概念，学习一下原理就过了。所以日常训练中其实并没有学到成体系的知识，只是知道了许多名词，以及看了一些国奖论文，知道国奖的论文大概是如何包装的。</p>\r\n<p>校赛是我们第一次正式训练，总的来说，我觉得作为我们第一次正式写论文的经历比赛，效果还是很不错的。虽然从结果上来说，最终只是个校赛二等奖，建模也自我感觉建的很普通，但是至少我们做出了一份可以看的过去的成品。</p>\r\n<p>然后就到训练赛了。讲实话训练赛我没有怎么参与，因为当时时间和论文ddl撞了。所以我负责的部分写的很垃圾（自我感觉）。最终，虽然论文的编排有进步（传奇论文手还在进步），但建模效果我认为还不如校赛。</p>\r\n<p>ok到国赛了。国赛大家从一开始就很上心，特地申请了一间小房子，3天比赛时间几乎全天泡在里头搞数模。第一天晚上我们主要把B题浏览并分析了个大概，把前三问的模型搭建了一个最初步的模型，然后分配了下任务，我负责（1）（4）问，另一个建模手负责（2）（3）问，然后就睡觉了。</p>\r\n<p>第二天，仔细思考后我们觉得建的模型不对，于是反复思考后在之前模型基础上，进行了大量修改，最终有了全部问题的思路。这中间的过程非常复杂，尤其另一个建模手的（2）（3）问，数学推导十分严谨，效果很好。</p>\r\n<p>这一天我把第一问模型也建好了，用了俩方法去解决第一问，反正就ChatGPT辅助呗。他给你思路，你理解消化后修正它思路，他再给你思路，你再修正...\r\n...反反复复，最终建立好了（1）问的模型，并写出了代码。</p>\r\n<p>第三天，我花了点时间把问题（4）的模型也建完了。但是觉得不够高级，于是加了点trick加速模型求解速度。我的建模任务到此基本结束。另一位建模手负责的（2）（3）问在这一天也修正了一点点小问题，建模也基础结束。论文手开始进入除（1）问的论文编写，最终论文手加班到凌晨4点，我们的论文基本成型（太敬业了，给队友点赞）。</p>\r\n<p>最后一天，把摘要写了，然后缝缝补补修修论文，晚上就交了。</p>\r\n<hr />\r\n<p>国赛经历其实平平淡淡，按部就班。但是我们三个人是非常尽力的，所以最终的效果我们都比较满意。无论结果如何，至少我们交出了一份问心无愧的答案。</p>\r\n<p>结果留个坑，到时候出成绩再更新... ...</p>\r\n<p>为什么没写详细的思路过程？我觉得没啥必要，游记嘛本来就随便写写。</p>\r\n<p>大概讲讲吧，思路第一问俩方法。法一直接暴力迭代求解，法二序贯检验。第二三问，建立完备的数学期望模型。第四问用自适应蒙特卡罗求解。</p>\r\n<p>详细的思路也不适合在游记写，有兴趣的到时候去看我github仓库里的论文吧，有什么问题欢迎大家一起交流学习呀。</p>\r\n<hr />\r\n<p>其实，数模比赛我认为是一个“成分复杂“的比赛。你说它水，但是它还真需要一些逻辑和思考才能建出模型和写出代码；你说它严谨，其实部分论文都是瞎编甚至造假的，写论文的人自己都不知道自己在干啥...\r\n...总之，我对数学建模比赛持中立态度。我的建议是，如果是为了培养写论文的能力以及快速学习能力，那欢迎你参加数模。如果是为了培养所谓数学思维和提高专业水平能力的，打数模浪费时间，不如去搞正儿八经的科研。</p>\r\n<hr />\r\n<p>最后，如果你决定了要参加数模比赛。别忘了找俩好队友，三个臭皮匠或许顶不了一个诸葛亮，但是一颗老鼠屎绝对会坏了整锅汤。<del>这是最重要的，参考我们队的传奇论文手和天使建模手</del>，开玩笑hhhh。赞扬我队友那么多，不是说我是混子，其实我的实力非常受到队友认可。而是第一次遇到这么负责且有实力，思维统一的队友，感叹于自己的幸运有感而发。以前大大小小的比赛太多太多是我一个人单打独斗了。</p>\r\n<p>最后，祝大家身体健康，学业顺利！</p>\r\n","categories":["3. 竞赛"]},{"title":"2024华为软件精英挑战赛游记","url":"/2024/03/24/2024%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%E6%B8%B8%E8%AE%B0/","content":"<p>初赛正式赛35名，遗憾离场，略微可惜。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"第一周\">第一周</h3>\r\n<p>参加这个比赛也是心血来潮。\r\n一方面想着现在已经大二了，保研之前要丰富一下自己的简历，另一方面我还从没参加过企业举办的大型赛事，而且去看了下历年的题目，都是用算法去解决实际问题，对我来说蛮有吸引力。所以拉上我们班一位同学就去参加了。（比赛要求三个人所以去网上又找了一个重邮研二的）</p>\r\n<p>报了名之后就没管了，一直到赛题发布的那一天。</p>\r\n<p>第一眼看到赛题感觉有点难蚌，我之前去看了22、23年的华为软挑真题，认为23年既然已经考过这种控制机器人移动做任务的题目，那么24年考这个的概率就不大了。24考的题应该更接近于22年这种调度问题。没成想，24年居然还是机器人移动（当然也是包括调度问题的）。</p>\r\n<p>第一天，看了看题目，下午和队友在线上开了个会，每个人分别讲了讲自己对赛题的理解。大致确定下了本题核心任务：调度\r\n+ 控制。</p>\r\n<p>调度即为考虑机器人搬哪些货物，去哪个泊位；船去哪个泊位，什么时候回家，什么时候转运。调度问题为了简单起见，都是选择的编码难度最容易的调度方式。即机器人选最贵的物品，机器人选有船要来且最近的泊位，船满了就走先不考虑转运情况。</p>\r\n<p>控制即操控机器人在最短时间内走到目标点。因为地图数据规模不大，所以我们选用每一步每一个机器人bfs一遍的策略。</p>\r\n<p>晚上，我根据上面的思路，写了一个文字框架以及如何维护关键参数的思路：</p>\r\n<p><img src=\"1.png\" /></p>\r\n<p>写完框架后就摆烂了几天，主要那几天刚好事特别多... ...</p>\r\n<p>最后在周末的时候，拉着我同学，花了大概2个多小时，一起对着上面的文字框架实现了一个基本的代码框架。并确定好了分工，他负责最短路算法以及机器人的运动，我负责船以及泊位的调度部分。</p>\r\n<p>（P.S.\r\n考虑到因为第三个队友跟我们不在同一个学校，不方便同时维护一份代码，所以让他根据自己想法写一个版本，无需受我写的文字框架的约束。兵分两路策略。）</p>\r\n<h3 id=\"第二周\">第二周</h3>\r\n<p>到了比赛第二个星期，首先星期一星期二熬大夜把我负责的部分写完了。然后周末同学把他负责的那一部分也写完了。可是不能跑，机器人跑了几百帧就卡死了。于是周末的两个晚上，继续熬大夜，修复代码中的小BUG。最后成功让代码跑起来了，第一次有分。</p>\r\n<p><img src=\"2.png\" /></p>\r\n<p>跑出分说明代码框架已经没问题了，但是仍然存在跑了几百帧后几个机器人撞一块再也不动的情况。说明碰撞部分还是存在BUG。</p>\r\n<p>于是我改变了原先解决碰撞的策略，在原先只有等待机制的情况下，引入失控机制：</p>\r\n<ol type=\"1\">\r\n<li>俩机器人即将碰撞时，其中一个机器人进行等待模式，另一个机器人继续动</li>\r\n<li>俩机器人若在同一个地方死锁，其中一个机器人进入等待模式，另一个机器人进入失控模式</li>\r\n<li>等待模式的机器人原地不动，失控模式的机器人乱走</li>\r\n</ol>\r\n<p>最后解决了碰撞问题，确定了我们组的baseline代码，8w分。</p>\r\n<p><img src=\"3.png\" /></p>\r\n<h3 id=\"第三周\">第三周</h3>\r\n<p>最忙的一周。几乎每天都熬到3、4点。主要问题就是优化baseline。其实优化之处还是非常多的。我按照我们的代码版本顺序来讲讲每个版本优化了哪些地方吧。</p>\r\n<ul>\r\n<li><p>v1.0</p>\r\n<ul>\r\n<li>baseline版本</li>\r\n</ul></li>\r\n<li><p>v2.0</p>\r\n<ul>\r\n<li>机器人挑选物品由原先的挑最贵的，变为挑val（物品价值） /\r\ndis（机器人与物品的最短距离）最大的</li>\r\n<li>机器人由原先的锁定泊位，改为了锁定泊位的具体坐标</li>\r\n</ul></li>\r\n<li><p>v3.0</p>\r\n<ul>\r\n<li><p>我同学想出了一个“革命性”的优化，不用每一步都对每个机器人求最短路，只需在机器人每次改变目标点时或者碰撞后求一个最短路就好了。将时间由原先的几乎一半时间都掉帧，优化到了几乎不掉帧</p></li>\r\n<li><p>完善了失控机制，原地等待wait_max_tim帧后同样进入失控状态，解决死锁</p></li>\r\n<li><p>调整了失控策略，由原先的4个方向顺序去搜变为4个方向随机数去走，避免来回踱步</p></li>\r\n<li><p>新增更换目标机制，若机器人road_tim帧内没到达目标\r\n，则会更换目标，解决死锁</p></li>\r\n</ul></li>\r\n<li><p>v3.5</p>\r\n<ul>\r\n<li>规范了v3.0的代码风格和缩进</li>\r\n<li>略微调整了参数</li>\r\n</ul></li>\r\n<li><p>v4.0</p>\r\n<ul>\r\n<li>初始时令每个机器人去到离他自己最近的泊位，将十个机器人分配到十个泊位上，避免陷入局部最优解</li>\r\n<li>改变了机器人确定目标泊位的策略：由原先的去已blocked的最近泊位改为去最近的泊位</li>\r\n<li>增加了船转运的功能，如果超过最低容量且一定时间内没装载，则去别的泊位装货</li>\r\n</ul></li>\r\n<li><p>v5.0</p>\r\n<ul>\r\n<li>每个泊位里新增了一个队列q，可以统计泊位上的货物情况</li>\r\n<li>优化了船挑选目标泊位的策略，由原先的去最大价值泊位变成去能取到最大价值的泊位</li>\r\n</ul></li>\r\n<li><p>v6.0</p>\r\n<ul>\r\n<li>增加了泊位聚类功能，可设置距离阈值控制聚类范围（这是个负优化，悲）</li>\r\n<li>增加了船排队功能，可设置每个泊位最多等待船数</li>\r\n</ul></li>\r\n</ul>\r\n<p>当写完这7个版本的代码后，还剩2天就正式赛了。此时的代码在练习赛排行榜处于44名。于是剩下两天试图继续优化代码，可是我们写了很多优化最后都是负优化并无很大提升。于是最后一天用ChatGpt写了一个python调参程序开始炼丹。</p>\r\n<h3 id=\"正式赛\">正式赛</h3>\r\n<p>正式赛在第三周的周六。上午队友交了一发13名。后面大家陆陆续续起床了，排名就被刷到20多名了。正式赛这一天我们继续改了改泊位的调度思路，可是没啥正优化。最后排名被刷到30名。最后几个小时没有啥思路了，于是对着两个地图开始炼丹。最后交了几发提升了几千分，封榜前，排名上升到了29名（笑。</p>\r\n<p>周天晚8点多去看了看晋级名单，35名。看来差一点。</p>\r\n<p><img src=\"4.png\" /></p>\r\n<h3 id=\"后记\">后记</h3>\r\n<p>第一次参加软挑，然后蛮有收获的。首先，第一次维护那么长（臭）的代码，接近1k行代码。极大了提高了我编码和debug能力。其次让我知道了面向对象的重要性。下次再写这种大型项目最好用面向对象。其次，团队之间的合作也是非常重要的，就像这次比赛有两个突破性的难点都是我同学大佬想出来的。</p>\r\n<p>最后，希望大家身体健康，学业顺利！</p>\r\n","categories":["3. 竞赛"]},{"title":"3. 几种重要的凸集-下","url":"/2023/10/05/3-%E5%87%A0%E7%A7%8D%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%B8%E9%9B%86-%E4%B8%8B/","content":"<p>介绍了多面体、单纯形、多面体与单纯形的关系、对称矩阵集合、对称半正定矩阵集合、对称正定矩阵集合。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n<p><img src=\"2.jpg\" /></p>\r\n","categories":["4. 大学","数学","凸优化"]},{"title":"4. 保凸运算","url":"/2023/11/19/4-%E4%BF%9D%E5%87%B8%E8%BF%90%E7%AE%97/","content":"<p>介绍了4种不改变集合凸性的运算：集合交、仿射函数、透视函数、线性分数函数。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.png\" /></p>\r\n<p><img src=\"2.png\" /></p>\r\n<p><img src=\"3.png\" /></p>\r\n<p><img src=\"4.png\" /></p>\r\n","categories":["4. 大学","数学","凸优化"]},{"title":"5. 凸函数的定义","url":"/2023/11/19/5-%E5%87%B8%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89/","content":"<p>介绍了凸函数的四种定义：直接定义、降维定义、一阶可微下的定义、二阶可微下的定义。以及补充了若A为对称矩阵条件下，<span\r\nclass=\"math inline\">\\(x^TAx \\ge 0 \\iff A \\succeq 0\\)</span>的证明。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.png\" /></p>\r\n<p><img src=\"2.png\" /></p>\r\n<p><img src=\"3.png\" /></p>\r\n<p><img src=\"4.png\" /></p>\r\n","categories":["4. 大学","数学","凸优化"]},{"title":"FROST—Fast row-stochastic optimization with uncoordinated step-sizes","url":"/2023/12/04/FROST%E2%80%94Fast-row-stochastic-optimization-with-uncoordinated-step-sizes/","content":"<p>中文翻译是：非协调步长行随机优化</p>\r\n<p>个人认为在仔细研读了Distributed那篇文章后，再看这篇文章时，会对双随机、列随机、行随机的算法分别有哪些有一个很好的认识。</p>\r\n<span id=\"more\"></span>\r\n<hr />\r\n<h3 id=\"abstract\">Abstract</h3>\r\n<p>本文讨论了构造不出双随机权值的有向图上的分布优化问题。</p>\r\n<p>现有算法大多采用推和共识算法，利用列随机权值来克服这一问题。列随机权值的形成要求每个代理(至少)知道其输出度，这在诸如基于广播的通信协议中可能是不切实际的。</p>\r\n<p>与此相反，我们描述了一种适用于不要求出度知识的有向图的快速行随机优化算法。</p>\r\n<p>该方法的实现很简单，因为每个代理在本地为传入的信息分配权重，并在本地选择合适的步长。我们证明了对于光滑且强凸函数，在最大步长为正且足够小的前提下，算法线性收敛到最优解。</p>\r\n<hr />\r\n<h3 id=\"introduction\">1. Introduction</h3>\r\n<p>第2节阐述了问题和假设。第3节回顾了使用双随机或列随机权值的相关算法，并展示了这些类型算法分析背后的直觉。在第4节中，我们提供了本文提出的主要算法FROST。在第5节中，我们发展了FROST的收敛性质。第6节给出了仿真结果，第7节总结了本文。</p>\r\n<p>下面是Notation：</p>\r\n<p>对于行随机矩阵<span\r\nclass=\"math inline\">\\(\\underline{A}\\)</span>，<span\r\nclass=\"math inline\">\\(\\pi_r,\r\n1_n\\)</span>分别是其左右Perron特征向量，满足<span\r\nclass=\"math inline\">\\(\\pi_r^T1_n = 1\\)</span></p>\r\n<p>对于列随机矩阵<span class=\"math inline\">\\(\\underline{B}\\)</span>\r\n，<span class=\"math inline\">\\(1_n,\r\n\\pi_c\\)</span>分别是其左右Perron特征向量，满足<span\r\nclass=\"math inline\">\\(1_n^T\\pi_c = 1\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\|\\|_F\\)</span>是Frobenius范数，<span\r\nclass=\"math inline\">\\(\\|\\|_2\\)</span>是欧几里得范数，<span\r\nclass=\"math inline\">\\(\\|\\|\\)</span>也是一个范数，具体含义看具体那部分的文章</p>\r\n<p><span class=\"math inline\">\\({\\otimes}\\)</span>表示Kronecker积。</p>\r\n<hr />\r\n<h3 id=\"problem-formulation\">2. Problem formulation</h3>\r\n<p>如果 j 连向 i ，则<span class=\"math inline\">\\((i, j) \\in\r\n\\mathcal{E}\\)</span> 另外，目标是最小化总花费，即： <span\r\nclass=\"math display\">\\[\r\n\\min_{\\mathbf{x}}F(\\mathbf{x})\\triangleq\\frac{1}{n}\\sum_{i=1}^{n}f_{i}(\\mathbf{x})\r\n\\]</span></p>\r\n<h4 id=\"assumption-1\">Assumption 1</h4>\r\n<p>图G是无向联通图。</p>\r\n<h4 id=\"assumption-2\">Assumption 2</h4>\r\n<p>图G是有向强连通图。</p>\r\n<h4 id=\"assumption-3\">Assumption 3</h4>\r\n<p><span\r\nclass=\"math inline\">\\(f_i\\)</span>是凸函数，且具有有界次梯度。</p>\r\n<h4 id=\"assumption-4\">Assumption 4</h4>\r\n<p><span\r\nclass=\"math inline\">\\(f_i\\)</span>是光滑，且强凸的。（光滑定义：具有连续的导数）</p>\r\n<p>即满足以下式子： <span class=\"math display\">\\[\r\n\\left\\|\\nabla f_i(\\mathbf{x})-\\nabla f_i(\\mathbf{y})\\right\\|_2\\leq\r\nl\\|\\mathbf{x}-\\mathbf{y}\\|_2 \\\\\r\nf_i(\\mathbf{y})\\geq f_i(\\mathbf{x})+\\nabla\r\nf_i(\\mathbf{x})^\\top(\\mathbf{y}-\\mathbf{x})+\\frac{\\mu}{2}\\|\\mathbf{x}-\\mathbf{y}\\|_2^2\r\n\\]</span> 第一个就是导数满足Lipschitz连续，所以<span\r\nclass=\"math inline\">\\(f_i\\)</span>肯定光滑。</p>\r\n<p>第二个就是凸函数的定义，因为有不等号右边最后一项的存在，所以<span\r\nclass=\"math inline\">\\(f_i\\)</span>是个强凸函数。</p>\r\n<h4 id=\"assumption-5\">Assumption 5</h4>\r\n<p>网络中的每个玩家都知道自己的编号。</p>\r\n<h4 id=\"assumption-6\">Assumption 6</h4>\r\n<p>每个玩家知道它的出度。</p>\r\n<hr />\r\n<h3 id=\"补充\">补充</h3>\r\n<p>看到这里。我想先停一下。来看一道题：假设每个玩家有一个初始值xi。如果他们都想知道所有玩家初始值的平均值是多少，应该怎么做？</p>\r\n<p>如果图是平衡的，则用平均一致性算法即可。即类似于：<span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_i^{k+1}=\\sum_{j=1}^Na_{ij}\\tilde{\\sigma}_j^k\\)</span>。</p>\r\n<p>如果图不平衡，则采用推和算法。 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;\\nu_{k+1}^{i} =\\sum_{j=1}^nb_{ij}\\nu_k^j,  \\\\\r\n&amp;\\mathbf{x}_{k+1}^{i} =\\sum_{j=1}^nb_{ij}\\mathbf{x}_k^j  \\\\\r\n&amp;\\mathbf{z}_{k+1}^{i} =\\frac{\\mathbf{x}_{k+1}^i}{\\nu_{k+1}^i},\r\n\\end{aligned}\r\n\\]</span> 每一个点维护两个值：x、v（都是一维的）。所谓推，就是点 j\r\n把值xj / 出度推给邻居，把权重vj / 出度推给邻居。所谓和，就是点 i\r\n把所有邻居 j 推来的值加一起得到vi，把所有邻居 j\r\n推来的权重加一起得到xi。</p>\r\n<p>注意到，对于任意时刻k，有：<span\r\nclass=\"math inline\">\\(\\frac{\\sum{x_i}}{\\sum{v_i}} = \\frac{x1 + x2 + ...\r\n+ xn}{n} = avg\\)</span></p>\r\n<p>当迭代的次数足够大时，信息已经在网络中充分流转。第 i 个点的<span\r\nclass=\"math inline\">\\(x_i\\)</span>会收敛到<span\r\nclass=\"math inline\">\\(n[\\boldsymbol{\\pi}_c]_i * avg\\)</span>，<span\r\nclass=\"math inline\">\\(v_i\\)</span>会收敛到<span\r\nclass=\"math inline\">\\(n[\\pi_c]_i\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\frac{x_i}{v_i} = avg\\)</span>。（<span\r\nclass=\"math inline\">\\(\\pi_c\\)</span>是列随机矩阵的右Perron特征向量）</p>\r\n<p>即每个点的xi / vi都收敛到全局平均值。</p>\r\n<p>这是一维的情况。</p>\r\n<p>如果每个玩家的初始值是一个向量xi（权重vi仍然不变初始值为1），则一样的，经过推和算法后，每个玩家的zi都收敛到avg（此时avg就是一个向量）。</p>\r\n<p>在推和共识上稍加改动，就可以得到下面这个算法： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;\\nu_{k+1}^{i} =\\sum_{j=1}^nb_{ij}\\nu_k^j,  \\\\\r\n&amp;\\mathbf{x}_{k+1}^{i}\r\n=\\sum_{j=1}^nb_{ij}\\mathbf{x}_k^j-\\alpha_k\\nabla\r\nf_i\\left(\\mathbf{z}_k^i\\right),  \\\\\r\n&amp;\\mathbf{z}_{k+1} =\\frac{\\mathbf{x}_{k+1}^i}{\\nu_{k+1}^i},\r\n\\end{aligned}\r\n\\]</span> 下面这个算法只在更新x时加了一个梯度项。</p>\r\n<p>这样的话，当迭代次数足够多时，第 i 个点的<span\r\nclass=\"math inline\">\\(x_i\\)</span>会收敛到<span\r\nclass=\"math inline\">\\([\\boldsymbol{\\pi}_c]_i * x^*\\)</span>，<span\r\nclass=\"math inline\">\\(v_i\\)</span>会收敛到<span\r\nclass=\"math inline\">\\(n[\\pi_c]_i\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\frac{x_i}{v_i} = x^*\\)</span>。</p>\r\n<h3 id=\"personal-summary\">Personal Summary</h3>\r\n<p>首先是由推和协议衍生出来的算法，推和协议用列随机矩阵可以求出全局平均值（如果玩家动作是动态更新的话，更新sigma时记得+x[i]\r\n- xx[i]）。</p>\r\n<p>因此套一个梯度下降就可以解决聚合游戏问题。</p>\r\n<p>如果已知最优解都会收敛到一个值的话，可以直接在推和协议中修改加一个梯度项，使得收敛到最优解。为了加快速度，还可以将普通的梯度项改为考虑全局的梯度项。</p>\r\n","categories":["1. 科研","分布式"]},{"title":"Distributed Nash Equilibrium Seeking for...","url":"/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/","content":"<p>标题全称为：Distributed Nash Equilibrium Seeking for Aggregative\r\nGames With Directed Communication Graphs</p>\r\n<p>中文翻译为：在使用有向图结构的聚合博弈中寻找离散式纳什均衡</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"abstract\">Abstract</h3>\r\n<p>在聚合博弈中寻找分布式纳什均衡的关键点就是聚合博弈采取什么样的图结构。</p>\r\n<p>若采取无向图或者权衡平衡图结构，则这个问题已经被前人解决。</p>\r\n<p>如果采取有向图，则这仍然是个无人解决的问题。</p>\r\n<p>本文解决的是当图结构采取“固定有向图”或者“时变有向图”时的分布式NE寻找问题。</p>\r\n<p>使用了两种算法来分别解决上面所提到的两种图结构时的分布式NE寻找问题。</p>\r\n<p>创新点是受凸优化中重球法的启发，向玩家策略的更新规范中引入了“动量项”，使得加速了算法寻找NE的收敛速度。</p>\r\n<p>对于强连通固定图和b强连通时变图，从理论上证明，如果代价函数和参与人的集合满足一定条件，在步长减小的情况下，参与人的行动将收敛到集合博弈的NE上。</p>\r\n<p>本文最后将该算法运用于插电式混合动力汽车的能耗控制，检验了算法的正确性。</p>\r\n<hr />\r\n<h3 id=\"section-1-introduction\">Section 1: Introduction</h3>\r\n<h4 id=\"研究背景\">1-1: 研究背景</h4>\r\n<ul>\r\n<li><p>本文研究的是聚合游戏，也就是每个玩家的花费除了依赖自身动作还依赖所有玩家的聚合行为。在聚合游戏中寻找NE是个有挑战性的问题，因为每个玩家只能与自己的邻居通信。</p></li>\r\n<li><p>在分布式通信计算领域，一些解决聚合游戏中NE寻找问题的分布式算法已经被提出。具体分为“分布式离散时间算法”[6],\r\n[7]和“分布式连续时间算法”[8]-[15]</p></li>\r\n</ul>\r\n<p>[6]：在这篇文章中，作者专注于研究有向图中的两种特殊的聚合游戏，分别叫做“network\r\naggregative games” 和 \"average aggregative games\"。使用\"optimal response\r\nstrategy\"方法去研究的。而且，在图的加权邻接矩阵为双随机矩阵的条件下，<span\r\nclass=\"math inline\">\\(\\varepsilon-NE\\)</span>在average aggregative\r\ngames的寻找得以被解决。</p>\r\n<p>[7]：在这篇文章中，作者专注于研究无向图中的聚合游戏。并相应提出了几种分布式同步和异步算法。</p>\r\n<p>[8]：在这篇文章中，作者专注于研究权重平衡有向图中的聚合游戏，其中玩家的dynamics\r\nwere described by disturbed first-order systems.\r\n为了寻找寻找外部干扰下具有coupled equality\r\nconstraint的聚合游戏的NE，作者在文中提出了一种利用内部模型排斥外部干扰来找NE的分布式算法。同时利用dynamic\r\naverage consensus来估计所有玩家的总和。</p>\r\n<p>[9]：在这篇文章中，研究了玩家成本函数非光滑，同时玩家动作受到局部可行性约束和线性耦合约束时的情况。具体来说，作者利用微分包含和微分投影算子，提出了一种基于连续时间分布投影的算法来找权重平衡有向图上的非光滑聚合游戏的NE。</p>\r\n<p>[10]：在这篇文章中，作者研究了无向连通图上具有耦合约束的聚合游戏。</p>\r\n<p>[11]：结合projected gradient dynamics 和 consensus tracking\r\ndynamics，本文讨论了无向连通图上的聚合游戏。</p>\r\n<p>[12]：结合projected gradient dynamics 和 consensus tracking\r\ndynamics，本文讨论了权重平衡有向图上的聚合游戏。</p>\r\n<p>[13]：研究了存在对通信链路持续攻击的网络上的聚合游戏。其中玩家的动态是受未知时变干扰和未建模项影响的双积分器。</p>\r\n<p>[14]：研究了聚合游戏在智能电网能耗控制中的运用。其中玩家采用平均共识协议来估计总能耗，并且表明玩家的行为以指数形式收敛于NE。</p>\r\n<p>[15]：将PHEVs建模成一个无向连通图上的聚合游戏，并对NE的稳定性进行了分析。</p>\r\n<ul>\r\n<li>可以发现上面的文章大多都是在无向图或者权重平衡有向图上的工作。在一般有向图上利用分布式离散时间算法来寻找NE仍然是一个未解决的问题。因为难点就在于玩家之间的通信结构不平衡。</li>\r\n<li>但是到目前为止，关于在不平衡有向图上的分布式优化问题已经被广泛研究。例如下面几篇文章：</li>\r\n</ul>\r\n<p>[16]：提出了一种连续时间算法来解决权重不平衡图上的聚合游戏的NE寻找问题。</p>\r\n<p>[17]：通过结合(子)梯度下降和推和共识协议开发了分布式(子)梯度推算法，其中双随机矩阵的要求可被推广到列随机矩阵。</p>\r\n<p>[18]：为了不需要提前知道列-随机矩阵的出度，这篇文章仅使用行-随机矩阵，通过估计行-随机矩阵的左Perron特征向量来求解具有不平衡有向图的分布无约束优化问题。</p>\r\n<p>[19],\r\n[20]：通过估计行随机矩阵的左Perron特征向量，研究有向图的分布式约束优化问题。</p>\r\n<ul>\r\n<li>所以本文受到上述文章中处理不平衡有向图的方法启发，分别运用行随机矩阵（algorithm\r\n1）和列随机矩阵（algorithm\r\n2）来研究不平衡有向图上（两种算法分别对应fixed digraph和time-varying\r\ndigraph）的聚合游戏。</li>\r\n<li>具体来说，通过估计与拓扑相关的行随机矩阵的左特征向量，成功消除了这种拓扑相关行随机矩阵对所有玩家聚合行为估计的不平衡影响。此外，针对时变有向图下的聚集博弈，提出了一种基于推和协议的分布式算法来寻找NE。而且由于玩家的动作受到设定的约束，因此采用投影梯度法根据聚集的局部估计更新玩家的动作。</li>\r\n<li>另一方面，考虑到步长恒定的投影梯度法只能在存在集合约束的情况下使玩家的动作收敛到NE的一个邻域，所以本文采用步长递减的方法来保证收敛到准确的NE，并且允许参与者采用不协调的步长。</li>\r\n<li>然而，步长递减也带来了另一个挑战，即收敛速度慢。受到[21]中重球法的启发下，本文在玩家行为更新规律中引入动量项，以加快算法的收敛速度。证明了所提出的步长递减离散NE搜索算法能够保证收敛到精确NE。</li>\r\n<li>此外，还分析了在步长递减时所提出的NE搜索算法的收敛速度。最后，将所提出的算法应用于有向图上的插电式混合动力汽车系统能耗博弈的求解，数值结果表明，动量项加速了算法的收敛速度。</li>\r\n</ul>\r\n<blockquote>\r\n<p>看了上面的introduction，个人感觉其实就是说：</p>\r\n<p>不平衡有向图上的聚合问题没人解决，因为玩家之间通信结构不平衡。</p>\r\n<p>然后本文用[18] ~\r\n[20]“估计行随机矩阵左特征向量”的方法解决上面这个难点。</p>\r\n<p>另外，本文还讨论了时变有向图下的聚集博弈，用的是[17]的方法，但是在他基础上把步长固定改为步长递减从而使NE收敛更精确。另外还加了一个[21]里的重球法中的动量项来加快收敛速度。</p>\r\n</blockquote>\r\n<h4 id=\"大致目录-基础公式\">1-2: 大致目录 &amp; 基础公式</h4>\r\n<p>Section 2：图论的基础结论、问题建模、算法引入</p>\r\n<p>Section 3、4：算法的收敛性证明</p>\r\n<p>Section 5：验证算法在插电式混合动力汽车能耗控制的正确性</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\mathbb{R,\r\nN_+}\\)</span>：分别是实数集和正整数集</li>\r\n<li><span class=\"math inline\">\\(e_i ∈ \\mathbb{R^n}\\)</span>\r\n：n维列向量，其中第i项为1，其余项为0</li>\r\n<li><span class=\"math inline\">\\(1_n ∈ \\mathbb{R^n}\\)</span>\r\n：n维列向量，每一项都是1</li>\r\n<li><span class=\"math inline\">\\(I_n\\)</span>：n维单位矩阵</li>\r\n<li><span class=\"math inline\">\\(\\|\\cdot\\|\\)</span>：欧几里得范式</li>\r\n<li><span class=\"math inline\">\\(\\|x\\|_H, H \\in \\mathbb{R^{n \\times\r\nn}}\\)</span>：加权范数（weighed norm）（结果为一个常数），定义为：<span\r\nclass=\"math inline\">\\(\\|x\\|_H = \\sqrt{x^THx}\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\Omega \\in\r\n\\mathbb{R^n}\\)</span>：n维的非空闭凸集，里面每个元素都是n维列向量</li>\r\n<li><span class=\"math inline\">\\(P_{\\Omega}[x]\\)</span>: x(<span\r\nclass=\"math inline\">\\(\\Omega\\)</span>外一点)在<span\r\nclass=\"math inline\">\\(\\Omega\\)</span>上的投影点(结果为一个n维列向量),\r\n定义为: <span class=\"math inline\">\\(P_{\\Omega}[x] = argmin_{y \\in\r\n\\Omega}\\|x - y\\| = y^*, y^* \\in \\Omega\\)</span>\r\n<ul>\r\n<li>具有非扩张性，即：<span\r\nclass=\"math inline\">\\(\\|P_{\\Omega}[x]-P_{\\Omega}[z]\\| \\le\r\n\\|x-z\\|\\)</span></li>\r\n</ul></li>\r\n<li><span\r\nclass=\"math inline\">\\([x]_i\\)</span>：x这个n维向量中的第i项</li>\r\n<li><span\r\nclass=\"math inline\">\\(H_{ij}\\)</span>：矩阵H的i行j列那个元素</li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"section-2-preliminary-knowledge\">Section 2: Preliminary\r\nknowledge</h3>\r\n<h4 id=\"图理论\">2-1: 图理论</h4>\r\n<p><span class=\"math inline\">\\(\\mathcal{N}=\\{1, 2, ...,\r\nN\\}\\)</span>：玩家集合</p>\r\n<p><span class=\"math inline\">\\(\\varepsilon(k) \\subseteq \\{(i, j), i, j\r\n\\in \\mathcal{N}\\}\\)</span>：时刻为k时的边集 <span\r\nclass=\"math inline\">\\((i, j) \\in \\varepsilon(k)\\)</span> means that\r\nplayer i can receive information from player j at time j.</p>\r\n<p><span class=\"math inline\">\\(\\mathcal{G}(k) = \\{\\mathcal{N},\r\n\\varepsilon(k)\\}\\)</span>：时刻为k时的图</p>\r\n<p><span class=\"math inline\">\\(N^{in}_{i}(k) = \\{i\\} \\cup \\{j | (j, i)\r\n\\in \\varepsilon(k)\\}\\)</span>：时刻为k时，点i的入点集合</p>\r\n<p><span class=\"math inline\">\\(N^{out}_{i}(k) = \\{i\\} \\cup \\{j | (i, j)\r\n\\in \\varepsilon(k)\\}\\)</span>：时刻为k时，点i的出点集合</p>\r\n<p><span\r\nclass=\"math inline\">\\(d_i^k=|N^{out}_{i}(k)|\\)</span>：时刻为k时，点i的出度</p>\r\n<p>strongly connected fixed digraph：强连通有向图。即任意俩点可通</p>\r\n<p>For the time-varying digraph <span\r\nclass=\"math inline\">\\(\\mathcal{G}(k), \\{\\mathcal{G}(k)\\}\\)</span> is\r\nsaid to be B-strongly connected if there exists a <span\r\nclass=\"math inline\">\\(B \\in \\mathbb{N_+}\\)</span> such that the union\r\ndigraph <span\r\nclass=\"math inline\">\\(\\cup_{t=kB}^{(k+1)B}\\mathcal{G}(t)\\)</span> is\r\nstrongly connected for any <span class=\"math inline\">\\(k \\in\r\n\\mathbb{N_+}\\)</span>\r\n换句话说，如果一定时间段内的所有时变图的并（边并起来，边权不相加）为强连通，则这些时变图的集合是B-连通的。</p>\r\n<p>后面依次类推。</p>\r\n<h4 id=\"问题建模\">2-2: 问题建模</h4>\r\n<p>每个玩家的动作集合定义为<span\r\nclass=\"math inline\">\\(\\Omega_i\\)</span>，动作定义为<span\r\nclass=\"math inline\">\\(x_i\\)</span>。每个玩家的花费函数定义为<span\r\nclass=\"math inline\">\\(J_i(x), x = [x_1, x_2, ...,\r\nx_n]^T\\)</span>，通过这个表达式可以看出来，每个玩家的花费函数跟所有玩家的动作相关。</p>\r\n<p><span class=\"math inline\">\\(J_i(x)\\)</span>还有几种等价的定义：</p>\r\n<p>定义1：<span class=\"math display\">\\[J_i(x) = f_i(x_i, \\sigma(x)), \\\\\r\n\\sigma(x)=\\sum_{j=1}^{N}\\phi_{j}(x_j) \\qquad (1)\\]</span></p>\r\n<p>定义2：<span class=\"math inline\">\\(J_i(x)=J_i(x_i, x_{-i}),\r\nx_{-i}=[x_1, ..., x_{i-1}, x_{i+1}, ..., x_n]\\)</span></p>\r\n<p>要解决的问题是最小化每一个玩家的花费函数，即：</p>\r\n<p><span class=\"math inline\">\\(min \\, f_i(x_i, \\sigma(x)), \\forall{i}\r\n\\in \\mathcal{N} \\qquad (2)\\)</span></p>\r\n<p>实际上就是求一个纳什均衡问题，因为纳什均衡就是任何一个玩家改变它的动作都不能使得它的花费函数更小。如果纳什均衡的观点表达上面的式子，就是：</p>\r\n<p>假如<span class=\"math inline\">\\(x^*\\)</span>是NE，当且仅当<span\r\nclass=\"math inline\">\\(J_i(x_i^*, x_{-i}^*) \\le J_i(x_i, x_{-i}^*),\r\n\\forall{x_i} \\in \\Omega_i, \\forall{i} \\in \\mathcal{N}\\)</span></p>\r\n<blockquote>\r\n<p>Note that the players in the considered game have no knowledge of the\r\naggregation <span class=\"math inline\">\\(\\sigma(x)\\)</span> due to the\r\nprivacy of <span class=\"math inline\">\\(\\phi_j(x_j), j \\in\r\n\\mathcal{N}\\)</span>。</p>\r\n<p>也就是说，<span\r\nclass=\"math inline\">\\(\\phi_i(x_i)\\)</span>函数是每个人特有的，只有自己知道，别人不知道。但是可以通过有向图与邻居交换信息。</p>\r\n</blockquote>\r\n<p>下面是论文的几个假设，论文解决的问题都是基于这几个假设作为前提的。</p>\r\n<h5 id=\"assumption-1\">Assumption 1</h5>\r\n<ul>\r\n<li>论文讨论的图不是一般有向图，而是两类。分别是固定有向图（fixed\r\ndigraph）和时变有向图（time-varying digraph）。</li>\r\n<li>而且fixed digraph一定满足强连通，time-varying\r\ndigraph一定满足B-强连通。</li>\r\n</ul>\r\n<h5 id=\"assumption-2\">Assumption 2</h5>\r\n<ul>\r\n<li><p>对于所有玩家的动作集合<span\r\nclass=\"math inline\">\\(\\Omega_{i}\\)</span>，都是非空、紧致、凸的。</p></li>\r\n<li><p>定义<span class=\"math inline\">\\(\\Omega_{-i}=\\Omega_{1} \\times\r\n\\Omega_{2} \\times ... \\times \\Omega_{i-1} \\times \\Omega_{i+1} \\times ...\r\n\\times \\Omega_{N}\\)</span>。More over, for given <span\r\nclass=\"math inline\">\\(x_{-i} \\in \\Omega_{-i}, J_i(x_i, x_{-i})\\)</span>\r\nis convex about <span class=\"math inline\">\\(x_i\\)</span> on <span\r\nclass=\"math inline\">\\(\\Omega_{i}\\)</span></p></li>\r\n<li><p><span class=\"math inline\">\\(J_i(x_i, x_{-i})\\)</span>对<span\r\nclass=\"math inline\">\\(x\\)</span>连续可微，<span\r\nclass=\"math inline\">\\(\\phi_i(x_i)\\)</span>对<span\r\nclass=\"math inline\">\\(x_i\\)</span>连续可微。</p>\r\n<ul>\r\n<li>定义<span class=\"math inline\">\\(\\nabla_z{f(z,\r\ny)}\\)</span>为对z求一阶偏导</li>\r\n<li>按照此定义，将<span class=\"math inline\">\\(J_i(x_i,\r\nx_{-i})\\)</span>对<span\r\nclass=\"math inline\">\\(x_i\\)</span>求导，将得到<span\r\nclass=\"math inline\">\\(\\nabla_{x_i}J_i(x_i, x_{-i}) =\\nabla_{x_i}f_i(x_i,\r\n\\sigma(x)) + \\nabla_{\\sigma}f_i(x_i, \\sigma(x)) \\,\r\n\\nabla_{x_i}\\phi_i(x_i)\\)</span>。这里实际上是有点歧义的，作者想表达的意思就是关注玩家i的动作对其花费函数的影响。</li>\r\n<li>定义<span class=\"math inline\">\\(\\Gamma(x)=[\\nabla_{x_1}J_1(x_1,\r\nx_{-1}), ..., \\nabla_{x_N}J_N(x_N,\r\nx_{-N})]^T\\)</span>，即每个玩家花费函数对自身动作求导组成的一个列向量</li>\r\n<li>定义<span class=\"math inline\">\\(G_i(x_i, \\tilde{\\sigma_i}) =\r\n\\nabla_{x_i}f_i(x_i, \\sigma(x))|_{\\sigma(x)=\\tilde{\\sigma_i}} +\r\n\\nabla_{\\sigma}f_i(x_i, \\sigma(x)) \\,\r\n\\nabla_{x_i}\\phi_i(x_i)|_{\\sigma(x)=\\tilde{\\sigma_i}}\\)</span>。不是把每个花费函数对动作求导嘛，这里就是把求导结果里的<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>赋值为<span\r\nclass=\"math inline\">\\(\\tilde{\\sigma_i}\\)</span>了。</li>\r\n</ul></li>\r\n</ul>\r\n<h5 id=\"assumption-3\">Assumption 3</h5>\r\n<ul>\r\n<li><span\r\nclass=\"math inline\">\\(\\Gamma(x)\\)</span>满足下列俩条件之一：</li>\r\n<li><span class=\"math inline\">\\(\\Gamma(x)\\)</span>在<span\r\nclass=\"math inline\">\\(\\Omega\\)</span>上是严格单调的，也就是说，<span\r\nclass=\"math inline\">\\((\\Gamma(x)-\\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,\r\n\\forall{x, x&#39;} \\in \\Omega, x \\ne x&#39;\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\Gamma(x)\\)</span>在<span\r\nclass=\"math inline\">\\(\\Omega\\)</span>上是强单调的，也就是说，存在一个常数<span\r\nclass=\"math inline\">\\(\\mu &gt; 0\\)</span>使得<span\r\nclass=\"math inline\">\\((\\Gamma(x)-\\Gamma(x&#39;))^T(x-x&#39;) \\ge\r\n\\mu\\|x-x&#39;\\|^2, \\forall{x, x&#39;} \\in \\Omega, x \\ne\r\nx&#39;\\)</span></li>\r\n</ul>\r\n<h5 id=\"assumption-4\">Assumption 4</h5>\r\n<ul>\r\n<li><p>The mapping <span class=\"math inline\">\\(G_i(x_i, \\sigma) is\r\nL_1-Lipschitz\\)</span> continuous with repect to <span\r\nclass=\"math inline\">\\(\\sigma \\in \\mathbb{R}\\)</span> and <span\r\nclass=\"math inline\">\\(\\phi_i(x_i)\\)</span> is <span\r\nclass=\"math inline\">\\(L_2-Lipschitz\\)</span> continuous with repect to\r\n<span class=\"math inline\">\\(x_i \\in \\Omega_i\\)</span> for all <span\r\nclass=\"math inline\">\\(i \\in \\mathcal{N}\\)</span>, i.e.,</p></li>\r\n<li><p>(<span class=\"math inline\">\\(L_1, L_2\\)</span> are two positive\r\nconstants) <span class=\"math display\">\\[\r\n\\begin{aligned}\\|G_i(x_i,\\sigma_1)-G_i(x_i,\\sigma_2)\\|_2&amp;\\le\r\nL_1\\left\\|\\sigma_1-\\sigma_2\\right\\|,&amp;\\forall\\sigma_1,\\sigma_2\\in\\mathbb{R},\\\\\\|\\phi_i(z_1)-\\phi_i(z_2)\\|&amp;\\le\r\nL_2\\left\\|z_1-z_2\\right\\|,&amp;\\forall z_1,z_2\\in\\Omega_i,\\end{aligned}\r\n\\]</span></p></li>\r\n</ul>\r\n<h4 id=\"算法引入\">2-3: 算法引入</h4>\r\n<h5\r\nid=\"algorithm-1-ne-seeking-with-row-stochastic-adjacency-matrix\">Algorithm\r\n1 NE Seeking With Row-Stochastic Adjacency Matrix</h5>\r\n<ul>\r\n<li>Initialization: <span class=\"math inline\">\\(x_i^0=x_i^1 \\in\r\n\\Omega_i, v_i^1=e_i, \\tilde\\sigma_i^1=\\phi_i(x_i^1)\\)</span></li>\r\n<li>for <span class=\"math inline\">\\(k \\in \\mathbb{N}_+\\)</span> do\r\n<ul>\r\n<li>for each player <span class=\"math inline\">\\(i \\in\r\n\\mathcal{N}\\)</span> do\r\n<ul>\r\n<li><span class=\"math inline\">\\(x_i^{k+1}=P_{\\Omega_i}[x_i^k -\r\n\\alpha_i^kG_i(x_i^k, \\tilde\\sigma_i^k) + \\lambda_i(x_i^k-x_i^{k-1})]\r\n\\qquad (3a)\\)</span></li>\r\n<li><span class=\"math inline\">\\(v_i^{k+1}=\\sum_{j=1}^Na_{ij}v_j^k \\qquad\r\n(3b)\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{i}^{k+1}=\\sum_{j=1}^{N}a_{ij}\\tilde{\\sigma}_{j}^{k}+\\frac{\\phi_{i}\\left(x_{i}^{k+1}\\right)}{\\left[v_{i}^{k+1}\\right]_{i}}-\\frac{\\phi_{i}\\left(x_{i}^{k}\\right)}{\\left[v_{i}^{k}\\right]_{i}}\r\n\\qquad (3c)\\)</span></li>\r\n</ul></li>\r\n<li>end for</li>\r\n</ul></li>\r\n<li>end for</li>\r\n</ul>\r\n<p>行随机邻接矩阵记为<span\r\nclass=\"math inline\">\\(A=[a_{ij}]\\)</span>，其中<span\r\nclass=\"math inline\">\\(a_{ii}&gt;0\\)</span>，且若<span\r\nclass=\"math inline\">\\((j, i) \\in \\varepsilon\\)</span>则<span\r\nclass=\"math inline\">\\(a_{ij}&gt;0\\)</span>, 否则<span\r\nclass=\"math inline\">\\(a_{ij}=0\\)</span>。另外，行随机矩阵的特征就是每一行元素和为1。</p>\r\n<p><span\r\nclass=\"math inline\">\\(x_i^k\\)</span>表示第i个玩家在时刻k的动作</p>\r\n<p><span class=\"math inline\">\\(v_i^k \\in\r\n\\mathbb{R}^N\\)</span>用来estimate the left eigenvector <span\r\nclass=\"math inline\">\\(v\\)</span> associated with eigenvalue <span\r\nclass=\"math inline\">\\(1\\)</span> of the matrix A.</p>\r\n<p><span class=\"math inline\">\\(\\tilde\\sigma_i^k\\)</span> be the player\r\ni's estimate on the aggregation <span\r\nclass=\"math inline\">\\(\\sigma(x_k)\\)</span> at iteration <span\r\nclass=\"math inline\">\\(k\\)</span>, <span\r\nclass=\"math inline\">\\(x_k=[x_1^k, ..., x_N^k]^T\\)</span></p>\r\n<p><span\r\nclass=\"math inline\">\\(\\alpha_i^k\\)</span>表示步长，它遵循下面三个限制：</p>\r\n<ol type=\"1\">\r\n<li>每个玩家在任意时刻的步长都是大于0的，且对于每个玩家，其<span\r\nclass=\"math inline\">\\(\\{\\alpha_i^k\\}\\)</span>单调不增加</li>\r\n<li><span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\alpha_{i}^{k}=\\infty,\\sum_{k=1}^{\\infty}(\\alpha_{i}^{k})^{2}&lt;\\infty\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\sum\\limits_{k=1}^{\\infty}(\\overline{\\alpha}_{k}-\\underline{\\alpha}_{k})&lt;\\infty,\\text{\r\nwhere\r\n}\\overline{\\alpha}_{k}=\\max\\limits_{j\\in\\mathcal{N}}\\{\\alpha_{j}^{k}\\}\\text{\r\nand\r\n}\\underline{\\alpha}_{k}=\\min\\limits_{j\\in\\mathcal{N}}\\{\\alpha_{j}^{k}\\}.\\)</span></li>\r\n</ol>\r\n<p>在algorithm 1中，玩家使用非精确梯度<span\r\nclass=\"math inline\">\\(G_i(x_i^k,\r\n\\tilde\\sigma_i^k)\\)</span>来更新自身动作。为了消除不精确梯度带来的误差，引入递减的步长而不是固定的步长，从而保证精确收敛到NE。另外，动量项<span\r\nclass=\"math inline\">\\(\\lambda_i(x_i^k-x_i^{k-1})]\\)</span>可以加速算法的收敛，<span\r\nclass=\"math inline\">\\(0&lt;\\lambda_i&lt;1\\)</span>是动量参数。以上就是对于(3a)的解释。</p>\r\n<p>在(3c)中的第二项和第三项，其存在的目的是为了解决矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>可能不是列随机的问题。</p>\r\n<p>可以看出，(3b)和(3c)都用到了<span\r\nclass=\"math inline\">\\(a_{ij}\\)</span>，所以algorithm 1只适用于fixed\r\ndigraph。</p>\r\n<h5\r\nid=\"algorithm-2-ne-seeking-with-column-stochastic-adjacency-matrix\">Algorithm\r\n2 NE Seeking With Column-Stochastic Adjacency Matrix</h5>\r\n<p>这个算法是针对time-varying\r\ndigraph的。在算法2中，每个玩家需要知道自己在每次交流中的出度，因为不同时刻每个点的出度会变化。</p>\r\n<ul>\r\n<li>Initialization: <span\r\nclass=\"math inline\">\\(x_{i}^{0}=x_{i}^{1}\\in\\Omega_{i},y_{i}^{1}=1,\\tilde{\\sigma}_{i}^{1}=\\phi_{i}(x_{i}^{1})\\)</span></li>\r\n<li>for <span class=\"math inline\">\\(k \\in \\mathbb{N}_+\\)</span> do\r\n<ul>\r\n<li>for each player <span class=\"math inline\">\\(i \\in\r\n\\mathcal{N}\\)</span> do\r\n<ul>\r\n<li><span class=\"math inline\">\\(w_i^{k+1}=\\sum_{j\\in\r\nN_i^{in}(k)}\\frac{\\tilde{\\sigma}_j^k}{d_j^k} \\qquad (4a)\\)</span></li>\r\n<li><span class=\"math inline\">\\(y_i^{k+1}=\\sum_{j\\in\r\nN_i^{in}(k)}\\frac{y_j^k}{d_j^k} \\qquad (4b)\\)</span></li>\r\n<li><span class=\"math inline\">\\(z_i^{k+1}=\\frac{w_i^{k+1}}{y_i^{k+1}}\r\n\\qquad (4c)\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(x_i^{k+1}=P_{\\Omega_i}\\left[x_i^k-\\alpha_i^kG_i(x_i^k,Nz_i^{k+1})+\\lambda_i(x_i^k-x_i^{k-1})\\right]\r\n\\qquad (4d)\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_i^{k+1}=w_i^{k+1}+\\phi_i\\left(x_i^{k+1}\\right)-\\phi_i\\left(x_i^k\\right)\r\n\\qquad (4e)\\)</span></li>\r\n</ul></li>\r\n<li>end for</li>\r\n</ul></li>\r\n<li>end for</li>\r\n</ul>\r\n<p>可以发现，这里求<span\r\nclass=\"math inline\">\\(x_i^{k+1}\\)</span>第二项<span\r\nclass=\"math inline\">\\(G_i\\)</span>中并没用<span\r\nclass=\"math inline\">\\(\\tilde\\sigma_i^k\\)</span>，而是用的<span\r\nclass=\"math inline\">\\(Nz_i^{k+1}\\)</span>。z是w跟y的比值，w与y又与点的入点和(入点的出度)有关。</p>\r\n<blockquote>\r\n<p>Note: 在algorithm 1中，若把\"若<span class=\"math inline\">\\((j, i) \\in\r\n\\varepsilon\\)</span>则<span\r\nclass=\"math inline\">\\(a_{ij}&gt;0\\)</span>\"改为“若<span\r\nclass=\"math inline\">\\((j, i) \\in \\varepsilon\\)</span>则<span\r\nclass=\"math inline\">\\(a_{ij}=\\frac{1}{d_j^k}\\)</span>”，则(3c)与(4e)等价</p>\r\n</blockquote>\r\n<hr />\r\n<h3 id=\"section-3-convergence-analysis-of-algorithm-1\">Section 3:\r\nConvergence analysis of algorithm 1</h3>\r\n<h4 id=\"theorem-1\">3-1: Theorem 1</h4>\r\n<p>条件：</p>\r\n<ol type=\"1\">\r\n<li><p>采用固定有向图结构</p></li>\r\n<li><p><span class=\"math inline\">\\(\\nabla_{x_i}J_i(x_i, x_{-i})\r\n=\\nabla_{x_i}f_i(x_i, \\sigma(x)) + \\nabla_{\\sigma}f_i(x_i, \\sigma(x)) \\,\r\n\\nabla_{x_i}\\phi_i(x_i)\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\Gamma(x)=[\\nabla_{x_1}J_1(x_1, x_{-1}),\r\n..., \\nabla_{x_N}J_N(x_N, x_{-N})]^T\\)</span></p>\r\n<p><span class=\"math inline\">\\(G_i(x_i, \\tilde{\\sigma_i}) =\r\n\\nabla_{x_i}f_i(x_i, \\sigma(x))|_{\\sigma(x)=\\tilde{\\sigma_i}} +\r\n\\nabla_{\\sigma}f_i(x_i, \\sigma(x)) \\,\r\n\\nabla_{x_i}\\phi_i(x_i)|_{\\sigma(x)=\\tilde{\\sigma_i}}\\)</span></p></li>\r\n<li><p><span\r\nclass=\"math inline\">\\((\\Gamma(x)-\\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,\r\n\\forall{x, x&#39;} \\in \\Omega, x \\ne x&#39;\\)</span></p></li>\r\n<li><p><span class=\"math display\">\\[\r\n\\begin{aligned}\\|G_i(x_i,\\sigma_1)-G_i(x_i,\\sigma_2)\\|_2&amp;\\le\r\nL_1\\left\\|\\sigma_1-\\sigma_2\\right\\|,&amp;\\forall\\sigma_1,\\sigma_2\\in\\mathbb{R},\\\\\\|\\phi_i(z_1)-\\phi_i(z_2)\\|&amp;\\le\r\nL_2\\left\\|z_1-z_2\\right\\|,&amp;\\forall z_1,z_2\\in\\Omega_i,\\end{aligned}\r\n\\]</span></p></li>\r\n<li><p>对于<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>步长，满足下面三条性质(C1-C3)</p>\r\n<ol type=\"1\">\r\n<li><span\r\nclass=\"math inline\">\\(\\{\\alpha_i^k\\}\\)</span>不严格递减，且<span\r\nclass=\"math inline\">\\(\\alpha_i^k&gt;0\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\alpha_{i}^{k}=\\infty,\\sum_{k=1}^{\\infty}(\\alpha_{i}^{k})^{2}&lt;\\infty\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\sum\\limits_{k=1}^{\\infty}(\\overline{\\alpha}_{k}-\\underline{\\alpha}_{k})&lt;\\infty,\\text{\r\nwhere\r\n}\\overline{\\alpha}_{k}=\\max\\limits_{j\\in\\mathcal{N}}\\{\\alpha_{j}^{k}\\}\\text{\r\nand\r\n}\\underline{\\alpha}_{k}=\\min\\limits_{j\\in\\mathcal{N}}\\{\\alpha_{j}^{k}\\}.\\)</span></li>\r\n</ol></li>\r\n<li><p><span\r\nclass=\"math inline\">\\(\\begin{matrix}0&amp;&lt;&amp;\\lambda_i&amp;&lt;&amp;\\frac{\\sqrt{2}}{2}\\end{matrix}\\)</span></p></li>\r\n</ol>\r\n<p>结论：all players' actions converge to the unique NE <span\r\nclass=\"math inline\">\\(x^*\\)</span> under algorithm 1.</p>\r\n<h4 id=\"preliminary-analysis-about-algorithm-1\">3-2: Preliminary\r\nanalysis about algorithm 1</h4>\r\n<p>先来求一下algorithm 1里的<span\r\nclass=\"math inline\">\\(v_i^k\\)</span></p>\r\n<p>定义：<span\r\nclass=\"math inline\">\\(\\left.V_{k}=\\left[\\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\\ldots,v_{N}^{k}}\\end{array}\\right.\\right]^{T}\\)</span></p>\r\n<p>所以<span class=\"math inline\">\\(v_i^{k+1}=\\sum_{j=1}^Na_{ij}v_j^k\r\n\\qquad (3b)\\)</span>等价于<span\r\nclass=\"math inline\">\\(V_{k+1}=AV_{k}\\qquad (5)\\)</span></p>\r\n<p>因为<span class=\"math inline\">\\(V_1 = [v_1, v_2, ..., v_N]^T =\r\nI_N\\)</span>，即<span class=\"math inline\">\\(v_i =\r\ne_i\\)</span>（条件）</p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}V_k=\\operatorname*{lim}_{k\\to\\infty}A^{k-1}V_1=\\operatorname*{lim}_{k\\to\\infty}A^{k}\\)</span></p>\r\n<p>因为A是行随机矩阵，所以显然<span\r\nclass=\"math inline\">\\(1_n\\)</span>是特征值为1时的一个特征向量。</p>\r\n<p>所以得出<span\r\nclass=\"math inline\">\\(\\operatorname*{lim}_{k\\to\\infty}A^{k}=1_Nv^T\\)</span>\r\n（根据Perron-Frobenius定理）, where <span\r\nclass=\"math inline\">\\(v\\)</span> 是A关于特征值1的左特征向量且<span\r\nclass=\"math inline\">\\(v\\)</span>每一项大于0，且<span\r\nclass=\"math inline\">\\(v^T1_N=1\\)</span>。</p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}\\left.V_{k}=\\left[\\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\\ldots,v_{N}^{k}}\\end{array}\\right.\\right]^{T}\r\n= 1_Nv^T\\)</span>。又<span class=\"math inline\">\\(1_Nv^T=[v, v, ...,\r\nv]^T\\)</span>。</p>\r\n<p>也就是说，当k趋近于无穷大时，每个玩家的<span\r\nclass=\"math inline\">\\(v_i\\)</span>都收敛于<span\r\nclass=\"math inline\">\\(v\\)</span>。</p>\r\n<p>再来求一下algorithm 1里的<span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{i}^{k}\\)</span></p>\r\n<p>首先<span\r\nclass=\"math inline\">\\(V_k\\)</span>对角线上的元素都是正的，通过<span\r\nclass=\"math inline\">\\(V_{k+1}=AV_{k}\\)</span>可看出。首先<span\r\nclass=\"math inline\">\\(V_1\\)</span>是单位阵肯定对角线为正，然后A的对角线元素都是正的（这是algorithm\r\n1引入时提到的条件）。所以他俩乘出来的对角线也是正的。不断递推，对角线上都是正的。</p>\r\n<p>所以现在我定义一个<span\r\nclass=\"math inline\">\\(\\left.\\hat{V}_k=\\operatorname{diag}\\left(\\begin{bmatrix}v_1^k\\end{bmatrix}\\right._1,\\begin{bmatrix}v_2^k\\end{bmatrix}_2,\\ldots,\\begin{bmatrix}v_N^k\\end{bmatrix}_N\\right)\\)</span></p>\r\n<p>上面这个<span\r\nclass=\"math inline\">\\(\\hat{V}_k\\)</span>其实就是取了<span\r\nclass=\"math inline\">\\(V_k\\)</span>的对角线，其余地方都是0。</p>\r\n<p>因为前面说了对角线都是正的嘛，所以<span\r\nclass=\"math inline\">\\(\\hat{V_k}\\)</span>是满秩可逆的。而且我们知道最终<span\r\nclass=\"math inline\">\\(V_k\\)</span>是收敛的，所以<span\r\nclass=\"math inline\">\\(\\hat{V_k}\\)</span>最终也是收敛的。</p>\r\n<p>最后我再定义<span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{k}=\\left[\\tilde{\\sigma}_{1}^{k},\\tilde{\\sigma}_{2}^{k},\\ldots,\\tilde{\\sigma}_{N}^{k}\\right]^{T}\\)</span>和<span\r\nclass=\"math inline\">\\(\\phi_k =\r\n\\left[\\phi_{1}(x_{1}^{k}),\\phi_{2}(x_{2}^{k}),\\ldots,\\phi_{N}(x_{N}^{k})\\right]^{T}\\)</span></p>\r\n<p>则<span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{i}^{k+1}=\\sum_{j=1}^{N}a_{ij}\\tilde{\\sigma}_{j}^{k}+\\frac{\\phi_{i}\\left(x_{i}^{k+1}\\right)}{\\left[v_{i}^{k+1}\\right]_{i}}-\\frac{\\phi_{i}\\left(x_{i}^{k}\\right)}{\\left[v_{i}^{k}\\right]_{i}}\r\n\\qquad (3c)\\)</span>可改写为：</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{k+1}=A\\tilde{\\sigma}_k+\\hat{V}_{k+1}^{-1}\\Phi_{k+1}-\\hat{V}_k^{-1}\\Phi_k\r\n\\qquad (6)\\)</span></p>\r\n<h4 id=\"lemmas\">3-3: Lemmas</h4>\r\n<p>为了接下来的叙述方便，定义<span\r\nclass=\"math inline\">\\(V_{\\infty}=\\lim\\limits_{k\\to\\infty}V_{k}=1_{N}v^{T}\\)</span>和<span\r\nclass=\"math inline\">\\(\\hat{V}_{\\infty}=\\operatorname{diag}([v]_1,\\ldots,[v]_N)\\)</span></p>\r\n<h5 id=\"lemma-1\">Lemma 1</h5>\r\n<p>因为<span\r\nclass=\"math inline\">\\(\\hat{V}_{k}\\)</span>是收敛的，所以会有<span\r\nclass=\"math inline\">\\(\\|\\hat{V}_{k}^{-1}\\|\\leq \\varrho, \\varrho &gt;\r\n0\\)</span></p>\r\n<blockquote>\r\n<p>矩阵的二范式从几何意义上来说就是单位圆在经过矩阵变换后离原点最远的距离。假设要求<span\r\nclass=\"math inline\">\\(\\|A\\|\\)</span>，则先求<span\r\nclass=\"math inline\">\\(A^TA\\)</span>，然后再求<span\r\nclass=\"math inline\">\\(A^TA\\)</span>的特征值，取最大的特征值开方就是矩阵A的二范数</p>\r\n</blockquote>\r\n<p>引理1：<span\r\nclass=\"math inline\">\\(\\|\\hat{V}_{k}^{-1}-\\hat{V}_{\\infty}^{-1}\\|\\leq\\varrho^{2}\\gamma\\theta^{k},\r\nk \\in \\mathbb{N_+}, \\gamma &gt; 0, 0 &lt; \\theta &lt; 1, \\varrho &gt;\r\n0\\)</span></p>\r\n<p>证明：</p>\r\n<p>因为<span class=\"math inline\">\\((\\hat{V_k}^{-1})(\\hat{V_k} -\r\n\\hat{V}_\\infty)(\\hat{V}_\\infty^{-1}) =\r\n(\\hat{V}_{k}^{-1}-\\hat{V}_{\\infty}^{-1})\\)</span></p>\r\n<p>两边取范数，得：<span\r\nclass=\"math inline\">\\(\\|\\hat{V}_{k}^{-1}-\\hat{V}_{\\infty}^{-1}\\| =\r\n\\|(\\hat{V_k}^{-1})(\\hat{V_k} - \\hat{V}_\\infty)(\\hat{V}_\\infty^{-1})\\|\r\n\\le \\|\\hat{V_k}^{-1}\\|\\|\\hat{V_k} -\r\n\\hat{V}_\\infty\\|\\|\\hat{V}_\\infty^{-1}\\|\\)</span></p>\r\n<p>定义<span class=\"math inline\">\\(\\varrho =\r\n{sup}_{k}\\left\\|\\widetilde{V}_{k}^{-1}\\right\\|_{2}\\)</span>，则<span\r\nclass=\"math inline\">\\(\\|\\hat{V_k}^{-1}\\|\\|\\hat{V}_\\infty^{-1}\\| \\le\r\n\\varrho^2\\)</span></p>\r\n<p>又<span class=\"math inline\">\\(\\|\\hat{V}_k - \\hat{V}_\\infty\\| \\le\r\n\\gamma\\theta^{k}\\)</span>, [17]。</p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\|\\hat{V}_{k}^{-1}-\\hat{V}_{\\infty}^{-1}\\| \\le\r\n\\varrho^{2}\\gamma\\theta^{k}\\)</span>，得证。</p>\r\n<h5 id=\"lemma-2\">Lemma 2</h5>\r\n<p>引理2：<span\r\nclass=\"math inline\">\\(V_{\\infty}\\tilde{\\sigma}_{k}=V_{\\infty}\\hat{V}_{k}^{-1}\\Phi_{k},\r\nk \\in \\mathbb{N_+}\\)</span></p>\r\n<p>证明如下：</p>\r\n<p><img src=\"1.png\" /></p>\r\n<h5 id=\"lemma-3\">Lemma 3</h5>\r\n<p>先来点前置知识</p>\r\n<p>因为<span\r\nclass=\"math inline\">\\(\\operatorname*{lim}_{k\\to\\infty}\\left(A-1_{N}v^{T}\\right)^{k}=\\operatorname*{lim}_{k\\to\\infty}A^{k}-1_{N}v^{T}=0\\)</span>（这个极限推导可以先放着不管），所以根据谱半径的知识，可以知道<span\r\nclass=\"math inline\">\\(\\rho(A-1_Nv^T)~&lt;~1\\)</span></p>\r\n<p>又因为<span class=\"math inline\">\\(\\rho(A-1_Nv^T) \\le \\|A -\r\n1_Nv^T\\|\\)</span></p>\r\n<p>所以必然存在一个矩阵范数<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|_\\epsilon\\)</span>，使得<span\r\nclass=\"math inline\">\\(\\rho(A-1_{N}v^{T})\\leq\\|A-1_{N}v^{T}\\|_{\\epsilon}\\leq\r\n\\rho(A-1_{N}v^{T})+\\epsilon&lt;1\\)</span></p>\r\n<p>另外，又因为所有的矩阵范式都是等价的，所以有：</p>\r\n<p><span class=\"math inline\">\\(\\|\\cdot\\|_{\\epsilon}\\leq\r\nc\\|\\cdot\\|\\)</span> and <span class=\"math inline\">\\(\\|\\cdot\\|\\leq\r\nd\\|\\cdot\\|_{\\epsilon}\\)</span></p>\r\n<p>接下来再定义两个东西</p>\r\n<p><span class=\"math inline\">\\(\\rho_1=\\left\\|A-1_Nv^T\\right\\|_\\epsilon,\r\n\\rho_1 &lt; 1 \\qquad (7)\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\rho_2=\\left\\|I_N-1_Nv^T\\right\\| \\qquad\r\n(8)\\)</span></p>\r\n<p>引理3：Under Assumption 1(a), 2 and 4, <span\r\nclass=\"math inline\">\\(\\|\\tilde{\\sigma}_i^k-v^T\\tilde{\\sigma}_k\\|\\)</span>\r\nis bounded, i.e., there exists a constant <span\r\nclass=\"math inline\">\\(\\hat{C} &gt; 0\\)</span> such that <span\r\nclass=\"math inline\">\\(\\|\\tilde{\\sigma}_{i}^{k}-v^{T}\\tilde{\\sigma}_{k}\\|\\leq\\hat{C}\\)</span></p>\r\n<p>证明如下：</p>\r\n<p><img src=\"5.png\" /></p>\r\n<p><img src=\"6.png\" /></p>\r\n<h5 id=\"lemma-4\">Lemma 4</h5>\r\n<p>引理4：<span\r\nclass=\"math inline\">\\(\\|G_i\\left(x_i^k,\\sigma(x_k)\\right)\\|\\le M,\r\n\\|G_i(x_i^k, \\tilde{\\sigma}_i^k) \\| \\le M, M &gt; 0\\)</span></p>\r\n<p>证明如下：</p>\r\n<p><img src=\"2.png\" /></p>\r\n<h5 id=\"lemma-5\">Lemma 5</h5>\r\n<p>定义<span\r\nclass=\"math inline\">\\(\\overline{\\lambda}=\\max_{j\\in\\mathcal{N}}\\{\\lambda_j\\}\\)</span>，若<span\r\nclass=\"math inline\">\\(0&lt;\\overline{\\lambda}&lt;\\frac{\\sqrt{2}}2\\)</span>，则下面三条性质将会满足：</p>\r\n<ol type=\"a\">\r\n<li><p><span\r\nclass=\"math inline\">\\(\\left\\|x_{i}^{k+1}-x_{i}^{k}\\right\\|\\leq\r\nM\\sum_{s=1}^{k}\\overline{\\lambda}^{k-s}\\overline{\\alpha}_{s},\\forall\r\nk\\in\\mathbb{N}_{+}\\)</span></p></li>\r\n<li><p><span\r\nclass=\"math inline\">\\(\\lim\\limits_{k\\to\\infty}\\left\\|x_{i}^{k+1}-x_{i}^{k}\\right\\|=0\\)</span></p></li>\r\n<li><p><span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\|x_{i}^{k+1}-x_{i}^{k}\\|^{2}&lt;\\infty\\)</span></p></li>\r\n</ol>\r\n<p>where <span class=\"math inline\">\\(M\\)</span> is given in Lemma 4, and\r\n<span\r\nclass=\"math inline\">\\(\\overline{\\alpha}_{k}=\\max_{j\\in\\mathcal{N}}\\{\\alpha_{j}^{k}\\}\\)</span></p>\r\n<p>证明如下：</p>\r\n<p><img src=\"3.png\" /></p>\r\n<p><img src=\"4.png\" /></p>\r\n<p>补充：因为所有动作<span\r\nclass=\"math inline\">\\(x_i^k\\)</span>都属于compact的<span\r\nclass=\"math inline\">\\(\\Omega_i\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\{x_k\\}\\)</span>是有界的，又由Lemma\r\n5(b)和柯西收敛准测可容易推出<span\r\nclass=\"math inline\">\\(\\{x_k\\}\\)</span>是收敛的。</p>\r\n<h5 id=\"lemma-6\">Lemma 6</h5>\r\n<ol type=\"a\">\r\n<li><p>For any <span class=\"math inline\">\\(k \\geq 2\\)</span>, one has\r\n<span\r\nclass=\"math display\">\\[\\left\\|\\tilde{\\sigma}_{k}-V_{\\infty}\\tilde{\\sigma}_{k}\\right\\|\\leq\r\ndc\\rho_{1}^{k-1}\\left\\|\\tilde{\\sigma}_{1}-1_{N}v^{T}\\tilde{\\sigma}_{1}\\right\\|\r\n+\r\nD_1\\sum_{l=1}^{k-1}\\rho_1^{k-l-1}\\beta_l+D_2\\sum_{l=1}^{k-1}\\rho_1^{k-l-1}\\theta^l\r\n\\qquad (9)\\]</span>where <span\r\nclass=\"math inline\">\\(D_{1}=dc\\rho_{2}\\varrho\r\nL_{2}\\sqrt{N}M,D_{2}=2dc\\rho_{2}C\\varrho^{2}\\gamma,\r\n\\beta_l=\\sum_{s=1}^{l}\\overline{\\lambda}^{l-s}\\overline{\\alpha}_{s}\\)</span>and<span\r\nclass=\"math inline\">\\(0&lt;\\theta&lt;1\\)</span> is given in Lemma\r\n1.</p></li>\r\n<li><p>For step-size sequence <span\r\nclass=\"math inline\">\\(\\{\\alpha_i^k\\}\\)</span> satisfying conditions\r\nC1-C3, one has <span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\overline{\\alpha}_{k}\\left\\|\\tilde{\\sigma}_{k}-V_{\\infty}\\tilde{\\sigma}_{k}\\right\\|&lt;\\infty\\)</span></p></li>\r\n</ol>\r\n<p>证明如下：</p>\r\n<p><img src=\"7.png\" /></p>\r\n<p><img src=\"8.png\" /></p>\r\n<h4 id=\"proof-of-theorem-1\">3-4: Proof of theorem 1</h4>\r\n<p><img src=\"9.png\" /></p>\r\n<p><img src=\"10.png\" /></p>\r\n<p><img src=\"11.png\" /></p>\r\n<p><img src=\"12.png\" /></p>\r\n<p><img src=\"13.png\" /></p>\r\n<p><img src=\"14.png\" /></p>\r\n<p><img src=\"15.png\" /></p>\r\n<p><img src=\"16.png\" /></p>\r\n<h4 id=\"theorem-2\">3-5: Theorem 2</h4>\r\n<p>在满足Assumption 1(a), 2, 3(b) and 4的前提下。令<span\r\nclass=\"math inline\">\\(\\alpha_{i}^{k}=\\frac{1}{\\sqrt{k}}=\\alpha_{k}\\)</span>。且<span\r\nclass=\"math inline\">\\(0&lt;\\lambda_i&lt;\\frac{\\sqrt{2}}{2}\\)</span>，则<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速率为<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln t}{\\sqrt{t}})\\)</span>。 <span\r\nclass=\"math display\">\\[\r\nq_t=\\frac{\\sum\\limits_{k=1}^t\\alpha_k\\|x_k-x^*\\|^2}{\\sum\\limits_{k=1}^t\\alpha_k}\r\n\\]</span> 证明：暂略</p>\r\n<h4 id=\"convergence-rate-analysis-of-algorithm-1\">3-6: Convergence rate\r\nanalysis of algorithm 1</h4>\r\n<p>如果<span\r\nclass=\"math inline\">\\(\\Gamma(x)\\)</span>是强单调，且步长满足<span\r\nclass=\"math inline\">\\(\\alpha_{i}^{k}=\\frac{1}{\\sqrt{k}}\\)</span>。则可以分析algorithm\r\n1的收敛速率。</p>\r\n<p>结论就是<span class=\"math inline\">\\(x_k\\)</span>收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span>的速率与<span\r\nclass=\"math inline\">\\(q_t\\)</span>收敛到0的速率相同。证明如下：</p>\r\n<p><img src=\"17.png\" /></p>\r\n<hr />\r\n<h3 id=\"section-4-convergence-analysis-of-algorithm-2\">Section 4:\r\nConvergence analysis of algorithm 2</h3>\r\n<p>对于之前的algorithm 2中的公式(4a) - (4c)，用矩阵表示如下： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;w_{k+1} =A\\left(k\\right)\\tilde{\\sigma}_{k},  \\\\\r\n&amp;y_{k+1} =A\\left(k\\right)y_{k},  \\\\\r\n&amp;z_{i}^{k+1} =\\frac{w_{i}^{k+1}}{y_{i}^{k+1}},\\quad i=1,\\ldots,N,\r\n&amp; (24)\r\n\\end{aligned}\r\n\\]</span> (4e)则可以表达为以下形式：</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{k+1}=A\\left(k\\right)\\tilde{\\sigma}_{k}+\\Phi_{k+1}-\\Phi_{k},\\quad(25)\\)</span></p>\r\n<p>其中A矩阵是一个列随机矩阵，如果点j连向i，则A(i, j) = 1 /\r\n(点j的出度)。如果j不连向i，则A(i, j) = 0。</p>\r\n<p>定义<span\r\nclass=\"math inline\">\\(\\epsilon_{k}=[\\epsilon_{1}^{k},\\ldots,\\epsilon_{N}^{k}]^{T}=\\Phi_{k+1}-\\Phi_{k}\\)</span>，这个是。再定义<span\r\nclass=\"math inline\">\\(\\epsilon_{i}^{k}=\\phi_{i}(x_{i}^{k+1})-\\phi_{i}(x_{i}^{k})\\)</span>。</p>\r\n<p>因为A是列随机矩阵，所以<span\r\nclass=\"math inline\">\\(1_{N}^{T}A({k})=1_{N}^{T}\\)</span>。所以(25)左右同乘一个<span\r\nclass=\"math inline\">\\(1_N^T\\)</span>，然后移项得到递推式，通过递推式可得<span\r\nclass=\"math inline\">\\(1_{N}^{T}\\tilde{\\sigma}_{k} - 1_N^T\\phi_k =\r\n1_N^T\\tilde{\\sigma}_1 - 1_N^T\\phi_1 = 0\\)</span></p>\r\n<p>所以<span class=\"math inline\">\\(1_N^T\\tilde{\\sigma}_k = 1_N^T\\phi_k =\r\n\\phi_1(x_1^k) + \\phi_2(x_2^k) + ... + \\phi_n(x_n^k) =\r\n\\sigma(x_k)\\)</span></p>\r\n<h4 id=\"lemmas-1\">4-1: Lemmas</h4>\r\n<h5 id=\"lemma-7\">Lemma 7</h5>\r\n<p>定理：在满足Assumptions 1(b), 2, 4的前提下，there exists a constant\r\n<span class=\"math inline\">\\(\\tilde{M} &gt; 0\\)</span>, s.t, <span\r\nclass=\"math inline\">\\(\\|G_{i}(x_{i}^{k},\\sigma(x_{k}))\\|\\leq\\tilde{M}\\)</span>\r\nand <span\r\nclass=\"math inline\">\\(\\|G_{i}(x_{i}^{k},Nz_{i}^{k+1})\\|\\leq\\tilde{M}\\)</span></p>\r\n<p>证明：</p>\r\n<p>Lemma 4已经证出了<span\r\nclass=\"math inline\">\\(\\left\\|G_i\\left(x_i^k,\\sigma(x_k)\\right)\\right\\|\\leq\r\nM_1\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\|G_{i}(x_{i}^{k},\\sigma(x_{k}))\\|\\leq\\tilde{M}\\)</span>就不用证了。主要证后面那个。</p>\r\n<p><span\r\nclass=\"math display\">\\[\\begin{Vmatrix}G_i(x_i^k,Nz_i^{k+1})\\end{Vmatrix}\\le\\begin{Vmatrix}G_i(x_i^k,Nz_i^{k+1})-G_i(x_i^k,1_N^T\\tilde{\\sigma}_k)\\end{Vmatrix}+\\left\\|G_{i}(x_{i}^{k},1_{N}^{T}\\tilde{\\sigma}_{k})\\right\\|\r\n\\\\ \\qquad \\le L_{1}\\left\\Vert\r\nNz_{i}^{k+1}-1_{N}^{T}\\tilde{\\sigma}_{k}\\right\\Vert+\\left\\Vert\r\nG_{i}(x_{i}^{k},1_{N}^{T}\\tilde{\\sigma}_{k})\\right\\Vert \\]</span></p>\r\n<p>显然，<span\r\nclass=\"math inline\">\\(\\|G_{i}(x_{i}^{k},1_{N}^{T}\\tilde{\\sigma}_{k})\\|\\)</span>就是<span\r\nclass=\"math inline\">\\(\\|G_i(x_i^k,\\sigma(x_k))\\|\\)</span>，所以其有界。</p>\r\n<p>由[17, lemma 1(a)]可知，k &gt;=2 时，有：</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\left|z_{i}^{k+1}-\\frac{1_{N}^{T}\\tilde{\\sigma}_{k}}{N}\\right|\\le\\frac{8}{\\delta}\\Bigg(\\iota^{k-1}\\|\\tilde{\\sigma}_{1}\\|_{1}+\\sum_{s=1}^{k-1}\\iota^{k-s-1}\\|\\epsilon_{s}\\|_{1}\\Bigg)\r\n\\quad (26)\\)</span></p>\r\n<p>with <span class=\"math inline\">\\(\\delta &gt; 0, 0 &lt; \\iota &lt;\r\n1\\)</span></p>\r\n<p>因为<span class=\"math inline\">\\(\\|\\epsilon_{s}\\|_{1}\\le\r\nN\\|\\epsilon_{s}\\|=N\\|\\Phi_{s+1}-\\Phi_{s}\\|\\leq2NC\\)</span></p>\r\n<p>所以不难证出：<span\r\nclass=\"math inline\">\\(L_{1}\\left\\|Nz_{i}^{k+1}-1_{N}^{T}\\tilde{\\sigma}_{k}\\right\\|\\)</span>有界</p>\r\n<p>所以<span class=\"math inline\">\\(\\|\r\nG_i(x_i^k,Nz_i^{k+1})\\|\\)</span>有界，即<span\r\nclass=\"math inline\">\\(\\parallel G_i(x_i^k,Nz_i^{k+1})\\parallel \\le\r\n\\tilde{M}_2\\)</span></p>\r\n<p>令<span class=\"math inline\">\\(\\tilde{M} = max (M_1,\r\n\\tilde{M}_2)\\)</span>，得证。</p>\r\n<blockquote>\r\n<p>Note: 如果<span\r\nclass=\"math inline\">\\(\\overline{\\lambda}=\\operatorname*{max}_{j\\in\\mathcal{N}}\\{\\lambda_{j}\\}\\)</span>\r\nsatisfies <span class=\"math inline\">\\(0 &lt; \\overline{\\lambda} &lt;\r\n\\frac{\\sqrt{2}}{2}\\)</span>，则Lemma\r\n5中的结论和证明过程仍然成立，只需要将其中涉及到的M换成<span\r\nclass=\"math inline\">\\(\\tilde{M}\\)</span></p>\r\n</blockquote>\r\n<h5 id=\"lemma-8\">Lemma 8</h5>\r\n<p>定理：如果<span\r\nclass=\"math inline\">\\(\\overline{\\lambda}=\\max_{j\\in\\mathcal{N}}\\{\\lambda_{j}\\}\\)</span>\r\nsatisfies <span class=\"math inline\">\\(0 &lt; \\overline{\\lambda} &lt;\r\n\\frac{\\sqrt{2}}{2}\\)</span>，且<span\r\nclass=\"math inline\">\\(\\alpha_i^k\\)</span> satisfies conditions\r\nC1-C3。则<span\r\nclass=\"math inline\">\\(\\lim_{k\\rightarrow\\infty}\\epsilon_{i}^{k}=0\\)</span>，且\r\n<span\r\nclass=\"math inline\">\\(\\sum_{k=1}^\\infty\\overline{\\alpha}_k\\|\\epsilon_i^k\\|&lt;\\infty\\)</span></p>\r\n<p>证明：</p>\r\n<p>由于上面的Note存在，所以Lemma 5的结论可以直接用于Lemma 8的证明。</p>\r\n<p>先证第一个：</p>\r\n<p>因为<span class=\"math inline\">\\(\\phi_i(x_i)\\)</span>是L2-Lipschitz\r\ncontinuous，所以<span class=\"math inline\">\\(\\|\\epsilon_{i}^{k}\\|\\le\r\nL_{2}\\|x_{i}^{k+1}-x_{i}^{k}\\|\\)</span></p>\r\n<p>而且由Lemma 5(b)知：<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}\\|x_{i}^{k+1}-x_{i}^{k}\\|=0\\)</span></p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}\\epsilon_{i}^{k}=0\\)</span></p>\r\n<p>再证第二个：</p>\r\n<p>由Lemma 5(a)知：<span\r\nclass=\"math inline\">\\(\\left\\|x_i^{k+1}-x_i^k\\right\\|\\leq\r\nM\\sum_{s=1}^k\\overline{\\lambda}^{k-s}\\overline{\\alpha}_s\\)</span></p>\r\n<p>所以：<span class=\"math inline\">\\(\\overline{\\alpha}_k||\\epsilon_i^k||\r\n\\le\r\n\\overline{\\alpha}_{k}L_{2}\\tilde{M}\\sum_{s=1}^{k}\\overline{\\lambda}^{k-s}\\overline{\\alpha}_{s}\r\n\\le\r\nL_{2}\\tilde{M}\\sum_{s=1}^{k}\\overline{\\lambda}^{k-s}\\overline{\\alpha}_{s}^{2}\\)</span></p>\r\n<p>又根据[31 Lemma 3.1(b)]，可得到：<span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\overline{\\alpha}_{k}||\\epsilon_{i}^{k}||\\leq\r\nL_{2}\\tilde{M}\\sum_{k=1}^{\\infty}\\sum_{s=1}^{k}\\overline{\\lambda}^{k-s}\\overline{\\alpha}_{s}^{2}&lt;\\infty\\)</span></p>\r\n<blockquote>\r\n<p>Note：通过Lemma 8证明的这两个结论，通过[17 Lemma\r\n1]，可以进一步证明出：</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\lim\\limits_{k\\to\\infty}\\left\\|z_i^{k+1}-\\frac{1_N^T\\tilde{\\sigma}_k}{N}\\right\\|=0,\\sum\\limits_{k=1}^{\\infty}\\overline{\\alpha}_k\\left\\|z_i^{k+1}-\\frac{1_N^T\\tilde{\\sigma}_k}{N}\\right\\|&lt;\\infty\\)</span></p>\r\n<p>因为<span\r\nclass=\"math inline\">\\(1_{N}^{T}\\tilde{\\sigma}_{k}\\)</span>就是<span\r\nclass=\"math inline\">\\(\\sigma\\left(x_{k}\\right)\\)</span></p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\overline{\\alpha}_{k}\\left\\Vert\r\nNz_{i}^{k+1}-\\sigma(x_{k})\\right\\Vert &lt; \\infty\\)</span></p>\r\n<p>上面这个公式在algorithm 2的收敛分析中有作用。</p>\r\n</blockquote>\r\n<h4 id=\"theorem-3\">4-2: Theorem 3</h4>\r\n<p>定理：在满足Assumptions 1(b), 2, 3(a), 4，以及<span\r\nclass=\"math inline\">\\(0 &lt; \\lambda_i &lt;\r\n\\frac{\\sqrt{2}}{2}\\)</span>，以及C1-C3的条件下。所有玩家的动作最终会收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span></p>\r\n<p>证明：</p>\r\n<p><img src=\"18.png\" /></p>\r\n<p><img src=\"19.png\" /></p>\r\n<h4 id=\"theorem-4\">4-3: Theorem 4</h4>\r\n<p>定理：在Assumptions 1(b), 2, 3(b), 4 are satisfied 的前提下，令<span\r\nclass=\"math inline\">\\(\\alpha_{i}^{k}=\\frac{1}{\\sqrt{k}}=\\alpha_{k}\\)</span>，且<span\r\nclass=\"math inline\">\\(0 &lt; \\lambda_i &lt;\r\n\\frac{\\sqrt{2}}{2}\\)</span>。则<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速率为<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln t}{\\sqrt{t}})\\)</span> <span\r\nclass=\"math display\">\\[\r\nq_t=\\frac{\\sum\\limits_{k=1}^t\\alpha_k\\|x_k-x^*\\|^2}{\\sum\\limits_{k=1}^t\\alpha_k}\r\n\\]</span> 证明：需要参考[17 Corollary 3]和Theorem 2的证明。</p>\r\n<blockquote>\r\n<p>Note：如果<span\r\nclass=\"math inline\">\\(\\Gamma(x)\\)</span>是强单调且步长满足<span\r\nclass=\"math inline\">\\(\\alpha_i^k=\\frac1{\\sqrt{k}}\\)</span>，则可分析algorithm\r\n2的收敛速度。结论也是<span class=\"math inline\">\\(x_k\\)</span>收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span>的速率与<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速率相同。</p>\r\n</blockquote>\r\n<hr />\r\n<h3 id=\"section-5-energy-consumption-control-of-phevs\">Section 5: Energy\r\nconsumption control of PHEVs</h3>\r\n<p>每个PHEV就是一个玩家。第 i 个PHEV的电量消耗为<span\r\nclass=\"math inline\">\\(x_i, x_i \\in [x_i^{min},\r\nx_i^{max}]\\)</span>。每台车的成本函数<span\r\nclass=\"math inline\">\\(J_i\\)</span>定义为： <span class=\"math display\">\\[\r\nJ_i(x_i,x_{-i})=x_i\\left(a\\sigma(x)+b\\right)+p_o\\left(\\kappa_i\\left(1-\\frac{x_i}{x_i^{\\max}}\\right)^2+d_i\\right)\r\n\\qquad (30)\r\n\\]</span> a &gt; 0，<span\r\nclass=\"math inline\">\\(\\sigma(x)=\\sum_{i=1}^N{x_i}\\)</span>，<span\r\nclass=\"math inline\">\\(p_0\\)</span>是油价，<span\r\nclass=\"math inline\">\\(\\kappa_{i}\\)</span>是油价的换算系数，<span\r\nclass=\"math inline\">\\(d_i\\)</span>是第 i 台车所需的基本油量。</p>\r\n<p>总结一下，按照我的理解，上面那个式子就是每台车的花费函数嘛。花费分为俩部分：电费、油费。电费不仅跟自己的耗电量有关，也跟所有人的耗电量有关，所以是第\r\ni\r\n台车的电费是两者相乘。对于油费，首先一台车的油量分为两部分，第一是<span\r\nclass=\"math inline\">\\(x_i^{max} -\r\nx_i\\)</span>剩下的用油来跑，第二是一台车最起码要存储的油量<span\r\nclass=\"math inline\">\\(d_i\\)</span>。分别就对应着上面括号里的两项。乘个油价就为油费了。</p>\r\n<p>这个实际问题建模后显然满足Assumption 2,\r\n4。而且值得注意的是，其成本函数还具有一个势函数<span\r\nclass=\"math inline\">\\(F(x)\\)</span>： <span class=\"math display\">\\[\r\n\\begin{aligned}F(x)&amp;=\\frac12\\sum_{i=1}^Nax_i\\left(\\sigma(x)-x_i\\right)+\\sum_{i=1}^N\\left(ax_i^2+bx_i\\right)\\\\&amp;+\\sum_{i=1}^Np_o\\left(\\kappa_i\\left(1-\\frac{x_i}{x_i^{\\max}}\\right)^2+d_i\\right)\r\n\\qquad(31)\\end{aligned}\r\n\\]</span> （势函数就是指，对于所有i，有：<span\r\nclass=\"math inline\">\\(\\frac{\\partial{J}_{i}(x)}{\\partial\r\nx_{i}}=\\frac{\\partial{F}(x)}{\\partial x_{i}}\\)</span>）</p>\r\n<p>接下来，来验证这个建模满足Assumption 3(a)。即<span\r\nclass=\"math inline\">\\(\\Gamma(x)\\)</span>在<span\r\nclass=\"math inline\">\\(\\Omega\\)</span>上是严格单调的。</p>\r\n<h4 id=\"lemma-9\">Lemma 9</h4>\r\n<p>定理：如果<span class=\"math inline\">\\(N &gt; 3\\)</span>且a满足：\r\n<span class=\"math display\">\\[\r\na&lt;\\min_{i\\in\\mathcal{N}}\\frac{2p_{o}\\kappa_{i}}{\\left(N-3\\right)\\left(x_{i}^{\\max}\\right)^{2}}\r\n\\]</span> 则势函数<span\r\nclass=\"math inline\">\\(F(x)\\)</span>是严格凸的。</p>\r\n<p>证明：</p>\r\n<p>先求<span\r\nclass=\"math inline\">\\(\\nabla^2F(x)\\)</span>，不难求出，其对角元素为<span\r\nclass=\"math inline\">\\(2a+\\frac{2p_{o}\\kappa_{i}}{(x_{i}^{\\operatorname*{max}})^{2}}\\)</span>，非对角元素为<span\r\nclass=\"math inline\">\\(a\\)</span>。因为<span class=\"math inline\">\\(N &gt;\r\n3\\)</span>且a满足<span\r\nclass=\"math inline\">\\(a&lt;\\min_{i\\in\\mathcal{N}}\\frac{2p_{o}\\kappa_{i}}{\\left(N-3\\right)\\left(x_{i}^{\\max}\\right)^{2}}\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\nabla^2F(x)\\)</span>是一个严格对角占优矩阵（严格对角占有矩阵就是对于每一行其对角线上元素的绝对值大于该行中其它所有元素绝对值之和）。所以由[30]中的Gershgorin’s\r\ndisctheorem可知<span\r\nclass=\"math inline\">\\(\\nabla^2F(x)\\)</span>是一个正定矩阵。那么凸函数的第四种定义即可知道<span\r\nclass=\"math inline\">\\(F(x)\\)</span>是一个严格凸函数。证毕。</p>\r\n<p>所以，这个建模在满足<span class=\"math inline\">\\(N &gt; 3,\r\na&lt;\\min_{i\\in\\mathcal{N}}\\frac{2p_{o}\\kappa_{i}}{\\left(N-3\\right)\\left(x_{i}^{\\max}\\right)^{2}}\\)</span>的时候，就满足<span\r\nclass=\"math inline\">\\(F(x)\\)</span>是个凸函数，即：<span\r\nclass=\"math inline\">\\((x-y)^{T}(\\nabla F(x)-{\\nabla F(y)})&gt;0, x \\ne\r\ny\\)</span> 。又因为<span\r\nclass=\"math inline\">\\(\\frac{\\partial{J}_{i}(x)}{\\partial\r\nx_{i}}=\\frac{\\partial{F}(x)}{\\partial x_{i}}\\)</span>，所以Assumption\r\n3(a)满足（这里的<span\r\nclass=\"math inline\">\\(F(x)\\)</span>其实就是Assumption 3中的<span\r\nclass=\"math inline\">\\(\\Gamma(x)\\)</span>）。</p>\r\n<p>至此，满足了Assumption 1, 2, 3(a), 4。只要控制好动量系数满足<span\r\nclass=\"math inline\">\\(0&lt;\\lambda_i&lt;\\frac{\\sqrt{2}}2\\)</span>，以及步长系数<span\r\nclass=\"math inline\">\\(\\lambda_i\\)</span>满足C1-C3，那么这个建模就满足Algorithm\r\n1、2的使用条件了。</p>\r\n<h4 id=\"numerical-simulations\">Numerical simulations</h4>\r\n<p>下面，分别通过两个实际的数值模拟来验证Algorithm 1、2。</p>\r\n<p>考虑有8台车，5种不同类型的车分别用不同颜色表示。每台车的具体参数见下表：</p>\r\n<p><img src=\"26.png\" /></p>\r\n<p>先来验证Algorithm 1。</p>\r\n<p><img src=\"20.png\" /></p>\r\n<p>可以看到，这个图是强连通的且不是一个权重平衡图。通过计算，<span\r\nclass=\"math inline\">\\(x^* =\r\n[17.6859,17.6859,15.5682,15.5682,12.5484,12.5484, 16.587,\r\n16.3481]\\)</span>。</p>\r\n<p>设置步长为<span\r\nclass=\"math inline\">\\(\\alpha_{i}^{k}=\\frac{1}{k^{0.6}}+\\frac{1}{k^{1.2}}\\)</span>。</p>\r\n<p>Fig 2是在不同<span\r\nclass=\"math inline\">\\(\\lambda_i\\)</span>下，使用Algorithm 1收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span>的迭代次数。</p>\r\n<p><img src=\"21.png\" /></p>\r\n<p>可以看到，加了动量项收敛速度确实会快一些。而且动量系数越大速度越快。而且虽然理论要求<span\r\nclass=\"math inline\">\\(0&lt;\\lambda_i&lt;\\frac{\\sqrt{2}}2\\)</span>，但是<span\r\nclass=\"math inline\">\\(\\frac{\\sqrt{2}}{2} &lt; \\lambda_i &lt;\r\n1\\)</span>时在数值仿真中仍然可以收敛。</p>\r\n<p>再来验证Algorithm 2。</p>\r\n<p><img src=\"22.png\" /></p>\r\n<p>如图Fig. 3，考虑车子的通信图周期性地在Fig. 3中的两个状态中切换。</p>\r\n<p>Fig. 4是在不同<span\r\nclass=\"math inline\">\\(\\lambda_i\\)</span>下，使用Algorithm 2收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span>的迭代次数。</p>\r\n<p><img src=\"23.png\" /></p>\r\n<p>可以发现，加了动量项收敛速度确实会快一些。而且动量系数越大速度越快。而且<span\r\nclass=\"math inline\">\\(\\lambda_i\\)</span>也是可以大于<span\r\nclass=\"math inline\">\\(\\frac{\\sqrt{2}}{2}\\)</span> ，小于1。</p>\r\n<p>最后通过数值模拟证明一下<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速率为<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln t}{\\sqrt{t}})\\)</span>。</p>\r\n<p>下面两幅图就是分别用了Algorithm 1和2（<span\r\nclass=\"math inline\">\\(\\alpha_{i}^{k}=\\frac{1}{\\sqrt{k}}, \\lambda_i =\r\n0.6\\)</span>）。其中<span class=\"math inline\">\\(c_t = \\frac{\\ln\r\nt}{\\sqrt{t}}\\)</span>。</p>\r\n<p><img src=\"24.png\" /></p>\r\n<p><img src=\"25.png\" /></p>\r\n<p>可以发现，迭代次数越多的时候，<span\r\nclass=\"math inline\">\\(q_t\\)</span>与<span\r\nclass=\"math inline\">\\(c_t\\)</span>的比值越接近1。也就通过数值模拟证明了在Algorithm1或2下，它俩收敛到0的速度是一样的。</p>\r\n<hr />\r\n<h3 id=\"section-6-conclusion\">Section 6: Conclusion</h3>\r\n<p>本文提出了两种算法分别解决固定有向图和时变有向图上的NE寻找问题（且图不需要权重平衡）。这俩算法分别是基于行随机矩阵左特征向量估计法、列随机矩阵推和法。</p>\r\n<p>而且为了加速算法收敛，算法1、2中均加入了动量项。</p>\r\n<p>但是算法中采用的是学习率递减到0的方式，这种方式会导致收敛速度较慢，这是本算法的不足。</p>\r\n<p>最后，本文作者认为，进一步研究“在聚合游戏中采用分布式算法加速寻找NE”将是一件很有趣的课题。</p>\r\n<hr />\r\n<h3 id=\"personal-summary\">Personal summary</h3>\r\n<h4 id=\"分布式发展历史\">分布式发展历史</h4>\r\n<p>这篇文章是我在分布式领域看的第一篇文章，所以在这里写点关于分布式算法优化领域的发展过程：</p>\r\n<blockquote>\r\n<p>1960s，Everett Dantzig, Wolfe and Benders\r\n思考了关于严格凸问题的拉格朗日松弛和线性规范的分解方法。（分解方法是为了将大型优化问题分解为小问题）</p>\r\n<p>后来，拉格朗日松弛和Hestenes, Powell and\r\nMiele发展的增广拉格朗日技术相结合，解决了一些凸但非严格凸的问题。可以理解为现代ADMM算法的前身。</p>\r\n<p>2000年初，出现了为了适应大规模数据的分布式算法，例如SGD（分布式随机梯度下降）。</p>\r\n<p>2010年初，为了解决大规模机器学习问题，出现了ADMM（交替方向乘子法）等算法。</p>\r\n<p>至今，分布式优化算法在算法效率、鲁棒性、以及适应动态和不确定环境方面取得了显著进展。出现了更加高效的分布式在线优化方法，以及能够适应网络拓扑变化和通信不确定性的算法。</p>\r\n</blockquote>\r\n<h4 id=\"文章总结\">文章总结</h4>\r\n<p>本文就是研究了一种特殊的博弈——聚合博弈。</p>\r\n<p>每个玩家的花费不仅跟自身动作有关，还跟其他人的动作有关。</p>\r\n<p>本论文设计了两种算法，在作者规定的特定条件下，可以使得每个人的花费尽可能低。分别用于固定有向图和时变有向图。</p>\r\n<p>文章内容为：算法介绍、算法的正确性证明、收敛速度分析、在PHEVs上的应用。</p>\r\n<h5 id=\"算法介绍\">算法介绍</h5>\r\n<p><strong>Algorithm 1</strong> <span class=\"math display\">\\[\r\n\\begin{gathered}\r\nx_i^0=x_i^1\\in\\Omega_i,v_i^1=e_i,\\tilde{\\sigma}_i^1=\\phi_i(x_i^1) \\\\\r\nx_{k+1}=P_{\\Omega_{i}}[x_{k}-\\alpha_{k}G_{i}(x_{k},\\tilde{\\sigma}_{k})+\\lambda_{i}(x_{k}-x_{k-1})]\r\n\\\\\r\nV_{k+1}=AV_k \\\\\r\n\\tilde{\\sigma}_{k+1}=A\\tilde{\\sigma}_k+\\hat{V}_{k+1}^{-1}\\Phi_{k+1}-\\hat{V}_{k}^{-1}\\Phi_{k}\r\n\\end{gathered}\r\n\\]</span> 目的就是为了把<span\r\nclass=\"math inline\">\\(x_k\\)</span>收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span>。使得玩家动作为<span\r\nclass=\"math inline\">\\(x^*\\)</span>时，每个玩家的花费最少。</p>\r\n<p>因为动作<span class=\"math inline\">\\(x_i\\)</span>会对花费<span\r\nclass=\"math inline\">\\(J_i\\)</span>产生影响，故定义<span\r\nclass=\"math inline\">\\(G_i\\)</span>为<span\r\nclass=\"math inline\">\\(J_i\\)</span>对<span\r\nclass=\"math inline\">\\(x_i\\)</span>求导，用来评估<span\r\nclass=\"math inline\">\\(x_i\\)</span>对<span\r\nclass=\"math inline\">\\(J_i\\)</span>产生的影响。</p>\r\n<p>那么<span class=\"math inline\">\\(x_i^{k+1}\\)</span>就可以通过<span\r\nclass=\"math inline\">\\(x_i^k\\)</span>和<span\r\nclass=\"math inline\">\\(G_i(x_i^k,\r\n\\tilde{\\sigma}_i^k)\\)</span>来更新。</p>\r\n<p><span class=\"math inline\">\\(\\tilde{\\sigma}_i^k\\)</span>是什么？</p>\r\n<p>需要注意的是，花费函数<span\r\nclass=\"math inline\">\\(J_i\\)</span>除了要知道<span\r\nclass=\"math inline\">\\(i\\)</span>玩家的动作<span\r\nclass=\"math inline\">\\(x_i\\)</span>，还需要知道所有玩家的输出函数<span\r\nclass=\"math inline\">\\(\\phi_i\\)</span>。所以定义<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>为所有玩家的输出函数之和。但是因为每个玩家没有上帝视角，所以<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>是未知的，所以我们可以用<span\r\nclass=\"math inline\">\\(\\tilde\\sigma_i\\)</span>来代替<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>。即每个玩家都有一个对<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>的评估函数<span\r\nclass=\"math inline\">\\(\\tilde\\sigma_i\\)</span>（这个评估函数也是需要迭代更新的，最终要收敛于<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>）</p>\r\n<p>至于<span\r\nclass=\"math inline\">\\(V_k\\)</span>，个人目前觉得是一个辅助矩阵，在迭代更新<span\r\nclass=\"math inline\">\\(\\tilde\\sigma_k\\)</span>时会用到。</p>\r\n<p>至于<span\r\nclass=\"math inline\">\\(\\lambda_i\\)</span>，是动量项，加速收敛用的。</p>\r\n<p><strong>Algorithm 2</strong> <span class=\"math display\">\\[\r\n\\begin{gathered}\r\n\\\\\r\nx_i^0=x_i^1\\in\\Omega_i,y_i^1=1,\\tilde{\\sigma}_i^1=\\phi_i(x_i^1) \\\\\r\nw_{k+1}=A\\left(k\\right)\\tilde{\\sigma}_{k} \\\\\r\ny_{k+1}=A\\left(k\\right)y_{k} \\\\\r\nz_i^{k+1}=\\frac{w_i^{k+1}}{y_i^{k+1}} \\\\\r\nx_{k+1}=P_{\\Omega_i}\\left[x_k-\\alpha_kG_i(x_k,Nz_{k+1})+\\lambda_i(x_k-x_{k-1})\\right]\r\n\\\\\r\n\\begin{aligned}\\tilde{\\sigma}_{k+1}=w_{k+1}+\\phi_i\\left(x_{k+1}\\right)-\\phi_i\\left(x_k\\right)\\end{aligned}\r\n\\end{gathered}\r\n\\]</span> w是多余的，可以把<span\r\nclass=\"math inline\">\\(w_{k+1}\\)</span>那里合并到最后一个公式。</p>\r\n<p>本质就是推和协议。y是权重，<span\r\nclass=\"math inline\">\\(\\sigma\\)</span>是基于权重的平均值。</p>\r\n<p>经过迭代后，<span class=\"math inline\">\\(z =\r\n\\frac{\\sigma}{y}\\)</span>就是<span\r\nclass=\"math inline\">\\(\\phi\\)</span>的平均值。</p>\r\n<p>但是因为<span\r\nclass=\"math inline\">\\(\\phi\\)</span>初值不是定值，所以最后公式倒数俩项就是动态更新<span\r\nclass=\"math inline\">\\(\\sigma\\)</span></p>\r\n<h5 id=\"算法正确性证明\">算法正确性证明</h5>\r\n<p>本文大篇幅都是在证这个。</p>\r\n<p>本质就是证<span class=\"math inline\">\\(x_k\\)</span>最终收敛于<span\r\nclass=\"math inline\">\\(x^*\\)</span>。即<span class=\"math inline\">\\(\\|x_k\r\n- x^*\\|^2 \\rightarrow 0\\)</span>。</p>\r\n<p>具体内容过多不好总结 ，具体看下文证明。</p>\r\n<p>证明过程主要用到了：矩阵范数性质、范数的放缩、Cauchy-Schwarz。</p>\r\n<h5 id=\"收敛速度分析\">收敛速度分析</h5>\r\n<p>在作者规定的更多特定条件下（条件比它提出的俩算法更严格），Algorithm\r\n1、2的收敛速度跟<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速度一样： <span\r\nclass=\"math display\">\\[\r\nq_t=\\frac{\\sum\\limits_{k=1}^t\\alpha_k\\|x_k-x^*\\|^2}{\\sum\\limits_{k=1}^t\\alpha_k}\r\n\\]</span> 而<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速度经证明为：<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln t}{\\sqrt{t}})\\)</span></p>\r\n<h5 id=\"在phevs上的应用\">在PHEVs上的应用</h5>\r\n<p>这个部分论文中也没给出实现代码，只给出了数值模拟的结果和效果图。所以我自己复现了一遍论文的算法。</p>\r\n<p><strong>Algorithm 1的数值仿真</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Algorithm 1的数值仿真</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">8</span></span><br><span class=\"line\">x_best = [-<span class=\"number\">1</span>, <span class=\"number\">17.6859</span>, <span class=\"number\">17.6859</span>, <span class=\"number\">15.5682</span>, <span class=\"number\">15.5682</span>, <span class=\"number\">12.5484</span>, <span class=\"number\">12.5484</span>, <span class=\"number\">16.587</span>, <span class=\"number\">16.3481</span>]</span><br><span class=\"line\">x_min = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">x_max = [-<span class=\"number\">1</span>, <span class=\"number\">27.5</span>, <span class=\"number\">27.5</span>, <span class=\"number\">34.2</span>, <span class=\"number\">34.2</span>, <span class=\"number\">40.6</span>, <span class=\"number\">40.6</span>, <span class=\"number\">28.8</span>, <span class=\"number\">35.7</span>]</span><br><span class=\"line\">x = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">    x[i] = (x_min[i] + x_max[i]) / <span class=\"number\">2</span></span><br><span class=\"line\">p_0 = <span class=\"number\">5.6</span></span><br><span class=\"line\">a = <span class=\"number\">0.004</span></span><br><span class=\"line\">b = <span class=\"number\">0.1</span></span><br><span class=\"line\">k = [-<span class=\"number\">1</span>, <span class=\"number\">4.6</span>, <span class=\"number\">4.6</span>, <span class=\"number\">3.7</span>, <span class=\"number\">3.7</span>, <span class=\"number\">3.4</span>, <span class=\"number\">3.4</span>, <span class=\"number\">4.0</span>, <span class=\"number\">3.9</span>]</span><br><span class=\"line\">d = [-<span class=\"number\">1</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.8</span>]</span><br><span class=\"line\">alpha = <span class=\"number\">2</span></span><br><span class=\"line\">A = [</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>]</span><br><span class=\"line\">]   <span class=\"comment\"># 这里因为论文中没明确指定具体的值，只说是行随机，所以对于每行有值的位置我直接平均分了</span></span><br><span class=\"line\">v = [</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">]</span><br><span class=\"line\">sigma = [-<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">    sigma.append(x[i])</span><br><span class=\"line\"></span><br><span class=\"line\">xx = copy.deepcopy(x)</span><br><span class=\"line\">xxx = copy.deepcopy(x)</span><br><span class=\"line\">vv = copy.deepcopy(v)</span><br><span class=\"line\">ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#-----------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">G</span>(<span class=\"params\">i, x, sigma</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * (sigma + x) + b  - <span class=\"number\">2</span> * p_0 * k[i] / x_max[i] * (<span class=\"number\">1</span> - x / x_max[i])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_x</span>(<span class=\"params\">i, vec</span>):</span><br><span class=\"line\">    x[i] = xx[i] - alpha * G(i, xx[i], ssigma[i]) + vec * (xx[i] - xxx[i])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x[i] &lt; x_min[i]: x[i] = x_min[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x[i] &gt; x_max[i]: x[i] = x_max[i]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_v</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    vvv = copy.deepcopy(vv)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            vvv[j][l] *= A[i][j]</span><br><span class=\"line\">    res = [-<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"built_in\">sum</span> += vvv[l][j]</span><br><span class=\"line\">        res.append(<span class=\"built_in\">sum</span>)</span><br><span class=\"line\">    v[i] = res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_sigma</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    add_1 = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        add_1 += ssigma[j] * A[i][j]</span><br><span class=\"line\">    add_2 = x[i] / v[i][i]</span><br><span class=\"line\">    add_3 = xx[i] / vv[i][i]</span><br><span class=\"line\">    sigma[i] = add_1 + add_2 - add_3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">init</span>():</span><br><span class=\"line\">    <span class=\"keyword\">global</span> x, alpha, v, sigma, xx, xxx, vv, ssigma</span><br><span class=\"line\">    x = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        x[i] = (x_min[i] + x_max[i]) / <span class=\"number\">2</span></span><br><span class=\"line\">    alpha = <span class=\"number\">2</span></span><br><span class=\"line\">    v = [</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    sigma = [-<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        sigma.append(x[i])</span><br><span class=\"line\">    xx = copy.deepcopy(x)</span><br><span class=\"line\">    xxx = copy.deepcopy(x)</span><br><span class=\"line\">    vv = copy.deepcopy(v)</span><br><span class=\"line\">    ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">algorithm_1</span>(<span class=\"params\">iter_num, vec</span>):</span><br><span class=\"line\">    <span class=\"keyword\">global</span> xx, xxx, vv, ssigma, alpha</span><br><span class=\"line\">    init()</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    sum_1 = <span class=\"number\">0</span></span><br><span class=\"line\">    sum_2 = <span class=\"number\">0</span></span><br><span class=\"line\">    q = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 计算差距值</span></span><br><span class=\"line\">        <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"built_in\">sum</span> += (x[i] - x_best[i]) ** <span class=\"number\">2</span></span><br><span class=\"line\">        res.append(<span class=\"built_in\">sum</span> ** <span class=\"number\">0.5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 计算qt的分子（这里的alpha注意步长设置为1/sqrt(j)）</span></span><br><span class=\"line\">        sum_1 += (<span class=\"number\">1</span> / j ** <span class=\"number\">0.5</span>) * <span class=\"built_in\">sum</span></span><br><span class=\"line\">        sum_2 += (<span class=\"number\">1</span> / j ** <span class=\"number\">0.5</span>)</span><br><span class=\"line\">        q.append(sum_1 / sum_2)</span><br><span class=\"line\">        <span class=\"comment\"># Algorithm 1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            upd_x(i, vec)</span><br><span class=\"line\">            upd_v(i)</span><br><span class=\"line\">            upd_sigma(i)</span><br><span class=\"line\">        xxx = copy.deepcopy(xx)</span><br><span class=\"line\">        xx = copy.deepcopy(x)</span><br><span class=\"line\">        vv = copy.deepcopy(v)</span><br><span class=\"line\">        ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\">        alpha = <span class=\"number\">1</span> / (j + <span class=\"number\">1</span>) ** <span class=\"number\">0.6</span> + <span class=\"number\">1</span> / (j + <span class=\"number\">1</span>) ** <span class=\"number\">1.2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res, q</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\">%matplotlib inline</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot_results</span>(<span class=\"params\">iter_num, vecs, vecs_name</span>):</span><br><span class=\"line\">    x = []</span><br><span class=\"line\">    y = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, iter_num):</span><br><span class=\"line\">        x.append(i)</span><br><span class=\"line\">        y.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> T <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(vecs)):</span><br><span class=\"line\">        y = algorithm_1(iter_num, vecs[T])[<span class=\"number\">0</span>]</span><br><span class=\"line\">        plt.plot(x, y, label=vecs_name[T])</span><br><span class=\"line\">        plt.xlabel(<span class=\"string\">&#x27;Iterations k&#x27;</span>)</span><br><span class=\"line\">        plt.ylabel(<span class=\"string\">&#x27;||xk - x*||&#x27;</span>)</span><br><span class=\"line\">        plt.legend()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(vecs_name[T], end=<span class=\"string\">&#x27;: &#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;%.2f&#x27;</span>%y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">vecs = [<span class=\"number\">0.0</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.8</span>]</span><br><span class=\"line\">vecs_name = [<span class=\"string\">&#x27;vec=0.0&#x27;</span>, <span class=\"string\">&#x27;vec=0.2&#x27;</span>, <span class=\"string\">&#x27;vec=0.4&#x27;</span>, <span class=\"string\">&#x27;vec=0.6&#x27;</span>, <span class=\"string\">&#x27;vec=0.8&#x27;</span>]</span><br><span class=\"line\">plot_results(<span class=\"number\">1000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">2000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">3000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">4000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">5000</span>, vecs, vecs_name)</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot_results_convergence_1</span>(<span class=\"params\">iter_num</span>):</span><br><span class=\"line\">    x = []</span><br><span class=\"line\">    y = []</span><br><span class=\"line\">    z = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>, iter_num + <span class=\"number\">1</span> + <span class=\"number\">1</span>): <span class=\"comment\"># 第一项ct是0，所以从第二项开始</span></span><br><span class=\"line\">        x.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num + <span class=\"number\">1</span>):</span><br><span class=\"line\">        z.append(math.log(i) / (i ** <span class=\"number\">0.5</span>))</span><br><span class=\"line\">    y = algorithm_1(iter_num, <span class=\"number\">0.6</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># qt的图像</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.plot(x, y)</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        经过调整参数为(x_min + x_max) / 2, 初始差距值已经比论文还低一些</span></span><br><span class=\"line\"><span class=\"string\">        但是qt始终无法收敛到0, 这是为什么呢?</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        当迭代次数很大时, 分子中的差距值已经很小, 所以导致分子比分母小许多, 所以假设论文中的迭代次数是8w次, 我比它多10倍,</span></span><br><span class=\"line\"><span class=\"string\">        比它多那么多后, 即使我刚开始迭代时的分子很大, 分子也会被后面10倍迭代次数的分母追上来。</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 这是用来画qt / ct的图像</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num):</span><br><span class=\"line\">        y[i] = y[i] / z[i]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.plot(x[<span class=\"number\">1</span>:], y[<span class=\"number\">1</span>:])</span><br><span class=\"line\">    plt.xlabel(<span class=\"string\">&#x27;t&#x27;</span>)</span><br><span class=\"line\">    plt.ylabel(<span class=\"string\">&#x27;qt / ct&#x27;</span>)</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">plot_results_convergence_1(<span class=\"number\">80000</span>)</span><br></pre></td></tr></table></figure>\r\n<p>效果图如下：（最后一张图，第一行数字是qt的收敛值，第二行数字是qt/ct的收敛值）</p>\r\n<p><img src=\"27.png\" /></p>\r\n<p><strong>Algorithm 2的数值仿真</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Algorithm 2的数值仿真</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">8</span></span><br><span class=\"line\">x_best = [-<span class=\"number\">1</span>, <span class=\"number\">17.68591179305579</span>, <span class=\"number\">17.68591178894396</span>, <span class=\"number\">15.568177079669734</span>, <span class=\"number\">15.568176869116588</span>,</span><br><span class=\"line\">            <span class=\"number\">12.54841009221712</span>, <span class=\"number\">12.548433755340588</span>, <span class=\"number\">16.50869895275612</span>, <span class=\"number\">16.348072510972873</span>]</span><br><span class=\"line\">x_min = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">x_max = [-<span class=\"number\">1</span>, <span class=\"number\">27.5</span>, <span class=\"number\">27.5</span>, <span class=\"number\">34.2</span>, <span class=\"number\">34.2</span>, <span class=\"number\">40.6</span>, <span class=\"number\">40.6</span>, <span class=\"number\">28.8</span>, <span class=\"number\">35.7</span>]</span><br><span class=\"line\">x = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">    x[i] = (x_min[i] + x_max[i]) / <span class=\"number\">2</span></span><br><span class=\"line\">p_0 = <span class=\"number\">5.6</span></span><br><span class=\"line\">a = <span class=\"number\">0.004</span></span><br><span class=\"line\">b = <span class=\"number\">0.1</span></span><br><span class=\"line\">k = [-<span class=\"number\">1</span>, <span class=\"number\">4.6</span>, <span class=\"number\">4.6</span>, <span class=\"number\">3.7</span>, <span class=\"number\">3.7</span>, <span class=\"number\">3.4</span>, <span class=\"number\">3.4</span>, <span class=\"number\">4.0</span>, <span class=\"number\">3.9</span>]</span><br><span class=\"line\">d = [-<span class=\"number\">1</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.8</span>]</span><br><span class=\"line\">alpha = <span class=\"number\">2</span></span><br><span class=\"line\">A_1 = [</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>],</span><br><span class=\"line\">]</span><br><span class=\"line\">A_2 = [</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>],</span><br><span class=\"line\">]</span><br><span class=\"line\">A = copy.deepcopy(A_1)</span><br><span class=\"line\">sigma = [-<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">    sigma.append(x[i])</span><br><span class=\"line\">w = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">y = [-<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">z = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">xx = copy.deepcopy(x)</span><br><span class=\"line\">xxx = copy.deepcopy(x)</span><br><span class=\"line\">ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\">yy = copy.deepcopy(y)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">init</span>():</span><br><span class=\"line\">    <span class=\"keyword\">global</span> x, alpha, sigma, w, y, z, xx, xxx, ssigma, yy</span><br><span class=\"line\">    x = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        x[i] = (x_min[i] + x_max[i]) / <span class=\"number\">2</span></span><br><span class=\"line\">    alpha = <span class=\"number\">2</span></span><br><span class=\"line\">    sigma = [-<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        sigma.append(x[i])</span><br><span class=\"line\">    w = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    y = [-<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    z = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    xx = copy.deepcopy(x)</span><br><span class=\"line\">    xxx = copy.deepcopy(x)</span><br><span class=\"line\">    ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\">    yy = copy.deepcopy(y)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#----------------------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_w</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"built_in\">sum</span> += A[i][j] * ssigma[j]</span><br><span class=\"line\">    w[i] = <span class=\"built_in\">sum</span>    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_y</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"built_in\">sum</span> += A[i][j] * yy[j]</span><br><span class=\"line\">    y[i] = <span class=\"built_in\">sum</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_z</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    z[i] = w[i] / y[i]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">G</span>(<span class=\"params\">i, x, sigma</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * (sigma + x) + b  - <span class=\"number\">2</span> * p_0 * k[i] / x_max[i] * (<span class=\"number\">1</span> - x / x_max[i])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_x</span>(<span class=\"params\">i, vec</span>):</span><br><span class=\"line\">    x[i] = xx[i] - alpha * G(i, xx[i], n * z[i]) + vec * (xx[i] - xxx[i])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x[i] &lt; x_min[i]: x[i] = x_min[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x[i] &gt; x_max[i]: x[i] = x_max[i]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_sigma</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    sigma[i] = w[i] + x[i] - xx[i]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">algorithm_2</span>(<span class=\"params\">iter_num, vec</span>):</span><br><span class=\"line\">    <span class=\"keyword\">global</span> A, A_1, A_2, w, ssigma, y, yy, z, x, xx, alpha, xxx, sigma</span><br><span class=\"line\">    init()</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    sum_1 = <span class=\"number\">0</span></span><br><span class=\"line\">    sum_2 = <span class=\"number\">0</span></span><br><span class=\"line\">    q = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 计算差距</span></span><br><span class=\"line\">        <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"built_in\">sum</span> += (x[i] - x_best[i]) ** <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span> ** (<span class=\"number\">0.5</span>)</span><br><span class=\"line\">        res.append(<span class=\"built_in\">sum</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 计算qt的分子（这里的alpha注意步长设置为1/sqrt(j)）</span></span><br><span class=\"line\">        sum_1 += (<span class=\"number\">1</span> / j ** <span class=\"number\">0.5</span>) * <span class=\"built_in\">sum</span> * <span class=\"built_in\">sum</span></span><br><span class=\"line\">        sum_2 += (<span class=\"number\">1</span> / j ** <span class=\"number\">0.5</span>)</span><br><span class=\"line\">        q.append(sum_1 / sum_2)</span><br><span class=\"line\">        <span class=\"comment\"># 选择矩阵</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> j % <span class=\"number\">2</span>: A = copy.deepcopy(A_1)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>: A = copy.deepcopy(A_2)</span><br><span class=\"line\">        <span class=\"comment\"># Algorithm 2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            upd_w(i)</span><br><span class=\"line\">            upd_y(i)</span><br><span class=\"line\">            upd_z(i)</span><br><span class=\"line\">            upd_x(i, vec)</span><br><span class=\"line\">            upd_sigma(i)</span><br><span class=\"line\">        <span class=\"comment\"># 更新状态</span></span><br><span class=\"line\">        xxx = copy.deepcopy(xx)</span><br><span class=\"line\">        xx = copy.deepcopy(x)</span><br><span class=\"line\">        yy = copy.deepcopy(y)</span><br><span class=\"line\">        ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\">        alpha = <span class=\"number\">1</span> / (j + <span class=\"number\">1</span>) ** <span class=\"number\">0.6</span> + <span class=\"number\">1</span> / (j + <span class=\"number\">1</span>) ** <span class=\"number\">1.2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res, q</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\">%matplotlib inline</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot_results</span>(<span class=\"params\">iter_num, vecs, vecs_name</span>):</span><br><span class=\"line\">    x = []</span><br><span class=\"line\">    y = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, iter_num):</span><br><span class=\"line\">        x.append(i)</span><br><span class=\"line\">        y.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> T <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(vecs)):</span><br><span class=\"line\">        y = algorithm_2(iter_num, vecs[T])[<span class=\"number\">0</span>]</span><br><span class=\"line\">        plt.plot(x, y, label=vecs_name[T])</span><br><span class=\"line\">        plt.xlabel(<span class=\"string\">&#x27;Iterations k&#x27;</span>)</span><br><span class=\"line\">        plt.ylabel(<span class=\"string\">&#x27;||xk - x*||&#x27;</span>)</span><br><span class=\"line\">        plt.legend()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(vecs_name[T], end=<span class=\"string\">&#x27;: &#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;%.2f&#x27;</span>%y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">vecs = [<span class=\"number\">0.0</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.8</span>]</span><br><span class=\"line\">vecs_name = [<span class=\"string\">&#x27;vec=0.0&#x27;</span>, <span class=\"string\">&#x27;vec=0.2&#x27;</span>, <span class=\"string\">&#x27;vec=0.4&#x27;</span>, <span class=\"string\">&#x27;vec=0.6&#x27;</span>, <span class=\"string\">&#x27;vec=0.8&#x27;</span>]</span><br><span class=\"line\">plot_results(<span class=\"number\">1000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">2000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">3000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">4000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">5000</span>, vecs, vecs_name)</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot_results_convergence_2</span>(<span class=\"params\">iter_num</span>):</span><br><span class=\"line\">    x = []</span><br><span class=\"line\">    y = []</span><br><span class=\"line\">    z = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>, iter_num + <span class=\"number\">1</span> + <span class=\"number\">1</span>): <span class=\"comment\"># 第一项ct是0，所以从第二项开始</span></span><br><span class=\"line\">        x.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num + <span class=\"number\">1</span>):</span><br><span class=\"line\">        z.append(math.log(i) / (i ** <span class=\"number\">0.5</span>))</span><br><span class=\"line\">    y = algorithm_2(iter_num, <span class=\"number\">0.6</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># qt的图像</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.plot(x, y)</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        经过调整参数为(x_min + x_max) / 2, 初始差距值已经比论文还低一些</span></span><br><span class=\"line\"><span class=\"string\">        但是qt始终无法收敛到0, 这是为什么呢?</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        当迭代次数很大时, 分子中的差距值已经很小, 所以导致分子比分母小许多, 所以假设论文中的迭代次数是8w次, 我比它多10倍,</span></span><br><span class=\"line\"><span class=\"string\">        比它多那么多后, 即使我刚开始迭代时的分子很大, 分子也会被后面10倍迭代次数的分母追上来。</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 这是用来画qt / ct的图像</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num):</span><br><span class=\"line\">        y[i] = y[i] / z[i]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.plot(x[<span class=\"number\">1</span>:], y[<span class=\"number\">1</span>:])</span><br><span class=\"line\">    plt.xlabel(<span class=\"string\">&#x27;t&#x27;</span>)</span><br><span class=\"line\">    plt.ylabel(<span class=\"string\">&#x27;qt / ct&#x27;</span>)</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">plot_results_convergence_2(<span class=\"number\">80000</span>)</span><br></pre></td></tr></table></figure>\r\n<p>效果图如下：（最后一张图，第一行数字是qt的收敛值，第二行数字是qt/ct的收敛值）</p>\r\n<p><img src=\"28.png\" /></p>\r\n<hr />\r\n<p>这篇blog发表于2023.10.16，现在是2023.12.4，看了2个月，目前算是告一段落了。</p>\r\n<p>分布式领域读的第一篇论文，挺有趣的，算是跨过了一道入门槛。</p>\r\n<p>接下来阅读论文的速度就要加快了。同时要去原理上去思考为什么这样做以及还可以怎样去优化。</p>\r\n<p>假如您正在阅读这篇blog，如发现错误，恳请在评论区中指出。</p>\r\n","categories":["1. 科研","分布式"]},{"title":"Linear convergence in optimization over directed graphs with row-stochastic matrices","url":"/2023/10/31/Linear-convergence-in-optimization-over-directed-graphs-with-row-stochastic-matrices/","content":"<p>标题：Linear convergence in optimization over directed graphs with\r\nrow-stochastic matrices</p>\r\n<p>中文翻译：行随机矩阵有向图优化的线性收敛性</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"abstract\">Abstract</h3>\r\n<p>本文研究的是一个多智能体网络（有向图）上的分布式优化问题，其中目标函数是每个玩家成本函数的总和。</p>\r\n<p>现存的在有向图上的分布式优化算法都至少需要每个玩家知道其邻居的出度。但本文不需要。而且最佳收敛速度为<span\r\nclass=\"math inline\">\\(O(\\mu^{k}), 0 &lt; \\mu &lt; 1, k\\)</span> is the\r\nnumber of 迭代。</p>\r\n<p>前提是目标函数为强凸函数，且具有Lipschitz连续梯度。</p>\r\n<h3 id=\"introduction\">1. Introduction</h3>\r\n<p>近年来出现了许多分布式优化方法，最初的方法是基于梯度下降，这种方法直观且计算简单，但由于算法使用的步长逐渐减小，通常速度较慢。证明了任意凸函数的收敛速度为<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln\r\nk}{\\sqrt{k}})\\)</span>，强凸函数的收敛速度为<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln k}k)\\)</span>。</p>\r\n<p>后来，发展出基于拉格朗日对偶变量的方法，例如分布式对偶分解[15]、分布式实现交替方向乘法器[16\r\n- 18]。对于强凸函数收敛速度将达到<span\r\nclass=\"math inline\">\\(O(\\mu^k)\\)</span>，缺点是计算代价比较高。</p>\r\n<p>再后来，为了兼顾收敛速度和计算简易性，一些分布式算法在保持步长不变的前提下，不使用对偶变量。例如分布式Nesterov-based方法，对于任意满足有界和Lipschitz梯度的凸函数，收敛速度达到<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln k}{k^2})\\)</span>。还例如[20],\r\n[21]中的方法，用固定步长和历史梯度信息实现了对一般凸函数<span\r\nclass=\"math inline\">\\(O(\\frac{1}{k})\\)</span>，强凸函数<span\r\nclass=\"math inline\">\\(O(\\mu^k)\\)</span>的收敛速度。</p>\r\n<p>但是上面这些方法都是在基于无向图或者权重平衡图上考虑的。但是实际中更多的是权重不平衡有向图的情况，所以这篇论文就是来解决这个问题的。</p>\r\n<p>怎么解决呢？一般分布式优化中通常需要双随机矩阵，可是有向图中得不到双随机矩阵，只能得到行随机矩阵或者列随机矩阵。本文提出的算法参考了[36]。</p>\r\n<p>Notation：</p>\r\n<ul>\r\n<li><p>小写字母是标量，小写粗体是向量，大写字母是矩阵</p></li>\r\n<li><p>The spectral radius of a matrix A is <span\r\nclass=\"math inline\">\\(\\rho(A)\\)</span>。谱半径就是A的特征值绝对值的最大值</p></li>\r\n<li><p><span class=\"math inline\">\\(\\lambda_{i}(A)\\)</span> denotes the\r\n<span class=\"math inline\">\\(i-th\\)</span> largest eigenvalue of\r\nA.</p></li>\r\n<li><p>对于一个最简的行随机矩阵A，将其特征值1的右特征向量记为<span\r\nclass=\"math inline\">\\(1_n\\)</span>，左特征向量记为<span\r\nclass=\"math inline\">\\(\\pi ^T\\)</span>，使得<span\r\nclass=\"math inline\">\\(\\pi ^T \\cdot 1_n = 1\\)</span>。</p></li>\r\n<li><p><span\r\nclass=\"math inline\">\\(\\|\\cdot\\|\\)</span>被定义为一个特殊的矩阵范数，在Lemma2中会讲到</p></li>\r\n<li><p><span\r\nclass=\"math inline\">\\(\\|\\cdot\\|_2\\)</span>就是普通的向量或者矩阵的二范数</p></li>\r\n<li><p>有性质： <span class=\"math display\">\\[\r\n\\begin{aligned}c&#39;\\|\\cdot\\|\\leq\\|\\cdot\\|_2\\leq c\\|\\cdot\\|\r\n\\\\d&#39;\\|\\cdot\\|_2\\leq\\|\\cdot\\|\\leq d\\|\\cdot\\|_2\\end{aligned} \\\\\r\nc&#39;, c, d&#39;, d\\,are\\,some\\,positive\\,constants\r\n\\]</span></p></li>\r\n<li><p>更多关于向量和矩阵范数的知识，参考[37]</p></li>\r\n</ul>\r\n<h3 id=\"problem-assumptions-algorithm\">2. Problem, Assumptions,\r\nAlgorithm</h3>\r\n<p>Problem：</p>\r\n<p>把问题描述为一个强连通有n个玩家的有向图：<span\r\nclass=\"math inline\">\\(\\mathcal{G}=(\\mathcal{V},\\mathcal{E})\\)</span>。注意若<span\r\nclass=\"math inline\">\\((i, j) \\in \\mathcal{E}\\)</span>，则<span\r\nclass=\"math inline\">\\(j\\)</span>可以发信息给<span\r\nclass=\"math inline\">\\(i\\)</span>。定义<span\r\nclass=\"math inline\">\\(\\mathcal{N}_i^{in}\\)</span>为<span\r\nclass=\"math inline\">\\(i\\)</span>自己加上<span\r\nclass=\"math inline\">\\(i\\)</span>的邻居，这个集合也就是能发信息给<span\r\nclass=\"math inline\">\\(i\\)</span>的玩家集合。</p>\r\n<p>我们要的目标函数是这个：<span\r\nclass=\"math inline\">\\(min\\,f(\\mathbf{x})=\\sum_{i=1}^nf_i(\\mathbf{x})\\)</span></p>\r\n<p>需要注意<span\r\nclass=\"math inline\">\\(f_i\\)</span>是凸且可微的，并且只有玩家<span\r\nclass=\"math inline\">\\(i\\)</span>知道。</p>\r\n<p>Assumption 1：有向图是强连通的。</p>\r\n<p>Assumption 2：每个<span\r\nclass=\"math inline\">\\(f_i\\)</span>是可微且强凸的。且对x导数（梯度）具有Lipschitz连续。具体来说，<span\r\nclass=\"math inline\">\\(f_i\\)</span>满足如下两个定义：</p>\r\n<blockquote>\r\n<p><span\r\nclass=\"math inline\">\\(f_i(\\mathbf{x}_1)-f_i(\\mathbf{x}_2)\\leq\\nabla\r\nf_i(\\mathbf{x}_1)^\\top(\\mathbf{x}_1-\\mathbf{x}_2)-\\frac{s}{2}\\|\\mathbf{x}_1-\\mathbf{x}_2\\|_2^2\\)</span>，s是正整数</p>\r\n<p><span class=\"math inline\">\\(\\|\\nabla f_i(\\mathbf{x}_1)-\\nabla\r\nf_i(\\mathbf{x}_2)\\|_2\\leq\r\nl\\|\\mathbf{x}_1-\\mathbf{x}_2\\|_2\\)</span>，l是正整数</p>\r\n</blockquote>\r\n<p>因为<span class=\"math inline\">\\(f\\)</span>是所有<span\r\nclass=\"math inline\">\\(f_i\\)</span>之和，所以<span\r\nclass=\"math inline\">\\(f\\)</span>也是满足强凸和Lipschitz梯度连续的，也就是满足上面那俩式子。显然常数分别为<span\r\nclass=\"math inline\">\\(ns, nl\\)</span>。</p>\r\n<p>Algorithm： <span class=\"math display\">\\[\r\n\\begin{gathered}\r\n\\mathbf{x}_{k+1,i}\r\n=\\sum_{j=1}^{n}a_{ij}\\mathbf{x}_{k,j}-\\alpha\\mathbf{z}_{k,i},\r\n\\left.\\left(\\begin{matrix}{1}{\\mathrm{a}}\\\\\\end{matrix}\\right.\\right) \\\\\r\n\\mathbf{y}_{k+1,i} =\\sum_{j=1}^{n}a_{ij}\\mathbf{y}_{k,j}, (1\\mathrm{b})\r\n\\\\\r\n\\mathbf{z}_{k+1,i} =\\sum_{j=1}^{n}a_{ij}\\mathbf{z}_{k,j}+{\\frac{\\nabla\r\nf_{i}(\\mathbf{x}_{k+1,i})}{[\\mathbf{y}_{k+1,i}]_{i}}}-{\\frac{\\nabla\r\nf_{i}(\\mathbf{x}_{k,i})}{[\\mathbf{y}_{k,i}]_{i}}}\r\n\\left.\\left(\\begin{matrix}{1}{\\mathrm{c}}\\\\\\end{matrix}\\right.\\right)\r\n\\end{gathered}\r\n\\]</span> <span class=\"math inline\">\\(a_{ij}\\)</span> 满足下面这个条件：\r\n<span class=\"math display\">\\[\r\na_{ij}=\\begin{cases}&amp;&gt;0,&amp;j\\in\\mathcal{N}_i^\\mathrm{in},\\\\&amp;0,&amp;\\mathrm{otw.},\\end{cases}\\quad\\sum_{j=1}^na_{ij}=1,\\forall\r\ni\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(\\alpha &gt; 0\\)</span> is a constant\r\nstep-size</p>\r\n<p><span class=\"math inline\">\\(\\nabla\r\nf_{i}(\\mathbf{x}_{k,i})\\in\\mathbb{R}^{p}\\)</span> is the gradient of\r\n<span class=\"math inline\">\\(f_i\\)</span> at <span\r\nclass=\"math inline\">\\(x_{k, i}\\)</span></p>\r\n<p><span class=\"math inline\">\\(x_0\\)</span> is arbitrary, <span\r\nclass=\"math inline\">\\(\\mathbf{y}_{0,i}=\\mathbf{e}_i, \\quad\r\n\\mathbf{z}_{0,i}=\\nabla f_i(\\mathbf{x}_{0,i})\\)</span></p>\r\n<p>上面的算法中</p>\r\n<p>根据[38]中的Perron-Frobenius定理，(1b)将收敛到矩阵A的左特征向量<span\r\nclass=\"math inline\">\\(\\pi ^T\\)</span>。</p>\r\n<p>(1c)使用(1b)来缩放梯度，从而消除了行随机矩阵引起的不平衡。</p>\r\n<p>而且，为了简化证明，其实可以把<span class=\"math inline\">\\(x_{k, i},\r\nz_{k, i}, \\nabla\r\nf_i(x_{k,i})\\)</span>,$看成一维的。只要一维的得证了，后续套一个Kronecker\r\nproduction notation就可以把p维的证出来了。</p>\r\n<p>为了简化表达，我们定义下面式子： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\mathbf{x}_{k}&amp; =[x_{k,1},\\cdots,x_{k,n}]^{\\top},  \\\\\r\n\\mathbf{Z}_{k}&amp; =[z_{k,1},\\cdots,z_{k,n}]^{\\top},  \\\\\r\n\\nabla\\mathbf{f}_{k}&amp; =\\left[\\nabla f_1(x_{k,1}),\\cdots,\\nabla\r\nf_n(x_{k,n})\\right]^\\top,  \\\\\r\nY_{k}&amp; =[\\mathbf{y}_{k,1},\\cdots,\\mathbf{y}_{k,n}]^\\top,  \\\\\r\n\\widetilde{Y}_{k}&amp; =\\operatorname{diag}(Y_k).\r\n\\end{aligned}\r\n\\]</span> 则algorithm 1可以写成以下形式： <span class=\"math display\">\\[\r\n\\begin{gathered}\r\n\\mathbf{x}_{k+1}= A\\mathbf{x}_{k}-\\alpha\\mathbf{z}_{k}, (2\\mathrm{a}) \\\\\r\nY_{k+1}= AY_{k}, (2\\mathrm{b}) \\\\\r\n\\mathbf{z}_{k+1}= A\\mathbf{z}_{k}+\\widetilde\r\nY_{k+1}^{-1}\\nabla\\mathbf{f}_{k+1}-\\widetilde\r\nY_{k}^{-1}\\nabla\\mathbf{f}_{k}, \\text{(2c)}\r\n\\end{gathered}\r\n\\]</span></p>\r\n<h3 id=\"main-results\">3. Main results</h3>\r\n<p>定义：<span\r\nclass=\"math inline\">\\(Y_\\infty=\\lim_{k\\to\\infty}Y_k\\)</span></p>\r\n<p>因为<span class=\"math inline\">\\(Y_k = AY_{k-1} = A^2Y_{k-2} =\r\n...\\)</span></p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\operatorname*{lim}_{k\\to\\infty}Y_{k}=\\operatorname*{lim}_{k\\to\\infty}A^{k}\\)</span>（<span\r\nclass=\"math inline\">\\(Y_1=I_n\\)</span>）</p>\r\n<p>又由[38]中的Perron-Frobenius定理，<span\r\nclass=\"math inline\">\\(Y_k\\)</span>将收敛到<span\r\nclass=\"math inline\">\\(1_n\\pi ^ T\\)</span></p>\r\n<p>即<span\r\nclass=\"math inline\">\\(Y_\\infty=\\lim\\limits_{k\\to\\infty}Y_k=\\operatorname*{lim}\\limits_{k\\to\\infty}A^k=1_n\\pi^T\\)</span>\r\n继续定义： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\mathbf{x}^{*}&amp; =x^{*}\\mathbf{1}_{n},  \\\\\r\n\\widehat{\\mathbf{x}}_{k}&amp; =Y_{\\infty}\\mathbf{x}_{k},  \\\\\r\n\\widehat{z}_{k}&amp; =Y_{\\infty}\\mathbf{z}_{k},  \\\\\r\n\\nabla\\mathbf{f}^{*}&amp; =[\\nabla f_{1}(x^{*}),\\cdots,\\nabla\r\nf_{n}(x^{*})]^{\\top},  \\\\\r\n\\nabla\\widehat{\\mathbf{f}}_{k}&amp;\r\n=\\frac{1}{n}\\mathbf{1}_{n}\\mathbf{1}_{n}^{\\top}\\left[\\nabla\r\nf_{1}(\\widehat{x}_{k}),...,\\nabla f_{n}(\\widehat{x}_{k})\\right]^{\\top},\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;\\tau=\\left\\|A-I_{n}\\right\\|_{2}, \\\\\r\n&amp;\\epsilon=\\left\\|I_{n}-Y_{\\infty}\\right\\|_{2}, \\\\\r\n&amp;\\eta=\\operatorname*{max}\\left(\\left|1-\\alpha\r\nnl\\right|,\\left|1-\\alpha ns\\right|\\right)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(l, s\\)</span>出自这： $$\r\nf_i(_1)-f_i(_2)f_i(_1)^(_1-_2)-|_1-_2|_2^2$，s是正整数 \\</p>\r\n|f_i(_1)-f_i(_2)|_2l|_1-_2|_2$，l是正整数 <span class=\"math display\">\\[\r\n继续定义：\r\n\\]</span>\r\n<span class=\"math display\">\\[\\begin{aligned}\r\n&amp;y=\\operatorname*{sup}_{k}\\left\\|Y_{k}\\right\\|_{2}, \\\\\r\n&amp;\\widetilde{y}=\\operatorname*{sup}_{k}\\left\\|\\widetilde{Y}_{k}^{-1}\\right\\|_{2}.\r\n\\end{aligned}\\]</span>\r\n<p>$$</p>\r\n<h4 id=\"lemma-1\">Lemma 1</h4>\r\n<p><span class=\"math inline\">\\(\\left\\|Y_k-Y_\\infty\\right\\|_2\\leq\r\nT\\gamma_1^k,\\quad\\forall k.\\quad(3) \\\\ 0 &lt; \\gamma &lt; 1 \\, and \\, 0\r\n&lt; T &lt; \\infty\\)</span></p>\r\n<p>推导参考[22]</p>\r\n<h4 id=\"lemma-2\">Lemma 2</h4>\r\n<p>For any <span class=\"math inline\">\\(a \\in \\mathbb{R^n}\\)</span>,\r\ndefine <span\r\nclass=\"math inline\">\\(\\widehat{\\mathbf{a}}=Y_{\\infty}\\mathbf{a}\\)</span>.\r\nThen there exists <span class=\"math inline\">\\(0&lt;\\sigma&lt;1\\)</span>\r\nsuch that <span class=\"math display\">\\[\r\n\\left\\|A\\mathbf{a}-\\widehat{\\mathbf{a}}\\right\\|\\leq\\sigma\\left\\|\\mathbf{a}-\\widehat{\\mathbf{a}}\\right\\|\r\n\\qquad (4)\r\n\\]</span> Proof:</p>\r\n<p>由[38]中的Perron-Frobenius定理，得<span\r\nclass=\"math inline\">\\(\\rho(A)=1\\)</span> and every eigenvalue of A other\r\nthan 1 is strictly less than <span\r\nclass=\"math inline\">\\(\\rho(A)\\)</span>。</p>\r\n<p>We now have： <span class=\"math display\">\\[\r\n\\begin{array}{rcl}AY_\\infty&amp;=&amp;A\\mathbf{1}_n\\pi^\\top&amp;=&amp;\\mathbf{1}_n\\pi^\\top&amp;=&amp;Y_\\infty,\\\\Y_\\infty\r\nY_\\infty&amp;=&amp;\\mathbf{1}_n\\pi^\\top\\mathbf{1}_n\\pi^\\top&amp;=&amp;\\mathbf{1}_n\\pi^\\top&amp;=&amp;Y_\\infty,\\end{array}\r\n\\]</span> and thus <span\r\nclass=\"math inline\">\\(AY_{\\infty}-Y_{\\infty}Y_{\\infty}\\)</span> is a\r\nzero matrix. Therefore, <span class=\"math display\">\\[\r\nA\\mathbf{a}-Y_\\infty\\mathbf{a}\\quad=\\quad(A-Y_\\infty)(\\mathbf{a}-Y_\\infty\\mathbf{a}).\r\n\\]</span></p>\r\n<blockquote>\r\n<p>右边打开：Aa - AYa - Ya + Y^2a = Aa - AYa - Ya + Ya = Aa - AYa = Aa -\r\nYa = 左边</p>\r\n</blockquote>\r\n<p>所以 <span class=\"math display\">\\[\r\n\\left\\|A\\mathbf{a}-Y_\\infty\\mathbf{a}\\right\\|\\quad\\leq\\quad\\left\\|A-Y_\\infty\\right\\|\\left\\|\\mathbf{a}-Y_\\infty\\mathbf{a}\\right\\|,\\quad\\left(5\\right)\r\n\\]</span> 又<span class=\"math inline\">\\(\\|A - Y_\\infty\\| &lt; 1\\)</span>\r\n<strong><u>为啥</u></strong></p>\r\n<p>所以</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\left\\|A\\mathbf{a}-\\widehat{\\mathbf{a}}\\right\\|\\leq\\sigma\\left\\|\\mathbf{a}-\\widehat{\\mathbf{a}}\\right\\|\\)</span>，<span\r\nclass=\"math inline\">\\(\\sigma=\\left\\|A-Y_{\\infty}\\right\\|\\)</span>，且<span\r\nclass=\"math inline\">\\(0 &lt; \\sigma &lt; 1\\)</span></p>\r\n<h4 id=\"lemma-3\">Lemma 3</h4>\r\n<p>There exists some constant <span\r\nclass=\"math inline\">\\(\\widetilde{T}\\)</span> such that the following\r\ninequalities hold for all k &gt;= 1 <span class=\"math display\">\\[\r\n(a)\\left\\|\\widetilde{Y}_k^{-1}-\\widetilde{Y}_\\infty^{-1}\\right\\|_2\\leq\\widetilde{y}^2\\widetilde{T}\\gamma_1^k\r\n\\\\\r\n(b)\\left\\|\\widetilde{Y}_{k+1}^{-1}-\\widetilde{Y}_{k}^{-1}\\right\\|_{2}\\leq2\\widetilde{y}^{2}\\widetilde{T}\\gamma_{1}^{k}\r\n\\]</span> Proof:</p>\r\n<p>先推(a) <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\left\\|\\tilde{Y}_{k}^{-1}-\\tilde{Y}_{\\infty}^{-1}\\right\\|_{2}&amp;\r\n\\leq\\left\\|\\tilde{Y}_{k}^{-1}\\right\\|_{2}\\left\\|\\tilde{Y}_{k}-\\tilde{Y}_{\\infty}\\right\\|_{2}\\left\\|\\tilde{Y}_{\\infty}^{-1}\\right\\|_{2},  \\\\\r\n&amp;\\leq\\tilde{y}^{2}\\widetilde{T}\\gamma_{1}^{k},\r\n\\end{aligned}\r\n\\]</span> 第一个不等号推导见“Distributed Nash Equilibrium Seeking\r\nfor...”的Lemma 1证明</p>\r\n<p>第二个不等号用了<span\r\nclass=\"math inline\">\\(\\widetilde{y}\\)</span>的定义和Lemma 1</p>\r\n<p>再推(b)，用推(a)一样的方法，先推出：</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\left\\|\\widetilde{Y}_{k+1}^{-1}-\\widetilde{Y}_{k}^{-1}\\right\\|_2\r\n\\le \\|\\widetilde{Y}_{k+1}\\| \\cdot \\|\\widetilde{Y}_{k}^{-1}\\| \\cdot\r\n\\|\\widetilde{Y}_{k+1} - \\widetilde{Y}_k\\| \\le \\widetilde{y}^2 \\cdot\r\n\\|\\widetilde{Y}_{k+1} - \\widetilde{Y}_k\\|\\)</span></p>\r\n<p>又<span class=\"math inline\">\\(\\|\\widetilde{Y}_{k+1} -\r\n\\widetilde{Y}_k\\| = \\|\\widetilde{Y}_{k+1} - \\widetilde{Y}_{\\infty}\\ -\r\n(\\widetilde{Y}_{k} - \\widetilde{Y}_{\\infty})\\| \\le \\|\\widetilde{Y}_{k+1}\r\n- \\widetilde{Y}_{\\infty}\\| + \\|\\widetilde{Y}_{k} -\r\n\\widetilde{Y}_{\\infty}\\| \\le 2\\widetilde{T}\\gamma_{1}^{k}\\)</span></p>\r\n<p>所以</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\left\\|\\widetilde{Y}_{k+1}^{-1}-\\widetilde{Y}_{k}^{-1}\\right\\|_2\r\n\\le 2\\widetilde{y}^2\\widetilde{T}\\gamma_{1}^{k}\\)</span>，得证。</p>\r\n<p>剩下来的内容不继续看了，因为需要的知识已经找到了，就是Lemma 3</p>\r\n","categories":["1. 科研","分布式"]},{"title":"Matlab基础","url":"/2024/04/25/Matlab%E5%9F%BA%E7%A1%80/","content":"<p>学习Matlab，一方面是数模需要，另一方面是Matlab +\r\nFigureBest绘制出来的图片非常精美。科研绘图时会用到，所以就学习一下。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"界面\">界面</h3>\r\n<p>clear：清空工作区</p>\r\n<p>clc：清除命令行窗口</p>\r\n<p>；：语句后加分号结果不显示到命令行中，不加会显示到命令行中</p>\r\n<p>F5：运行</p>\r\n<p>ctrl + enter：分块运行</p>\r\n<p>%%：分块分割注释</p>\r\n<p>ctrl + r：添加多行注释</p>\r\n<p>ctrl + t：取消多行注释</p>\r\n<p>ctrl + 0：跳转到命令行窗口</p>\r\n<p>ctrl + shift + 0：跳转到编辑窗口</p>\r\n<p>ctrl + 2：跳转到工作目录窗口</p>\r\n<p>ctrl + 3：跳转到工作区</p>\r\n<p><a\r\nhref=\"https://ww2.mathworks.cn/help/index.html\">Matlab官方文档</a>：查询各种所需功能\r\n&amp; 函数</p>\r\n<p>填写函数参数时按tab：打开参数提示功能，ctrl + down展开提示</p>\r\n<h3 id=\"运算\">运算</h3>\r\n<ul>\r\n<li><p>特殊变量：ans、pi、inf、-inf</p></li>\r\n<li><p>数据类型：数字、字符串、矩阵</p></li>\r\n<li><p>运算符：</p>\r\n<ol type=\"1\">\r\n<li>基本运算符：+、-、*、/、^（乘方）</li>\r\n<li>常用预算符：abs()、mod(x,\r\ny)、sqrt()、exp()、log()、log2()、log10()、round()</li>\r\n</ol></li>\r\n</ul>\r\n<h3 id=\"矩阵\">矩阵</h3>\r\n<p>Note：下标从1开始</p>\r\n<ol type=\"1\">\r\n<li>矩阵的创建\r\n<ol type=\"1\">\r\n<li>直接输入：用[]作为标识符，同一行用,分隔，不同行用;分隔</li>\r\n<li>用预设函数创建：\r\n<ol type=\"1\">\r\n<li>zeros(x, y)：生成x行y列全0矩阵</li>\r\n<li>ones(x, y)：生成x行y列全1矩阵</li>\r\n<li>eye(x)：生成x行x列的单位阵</li>\r\n<li>rand(x, y)：生成x行y列的矩阵，每个元素在(0, 1)内</li>\r\n<li>randi([imin, imax], x, y)：生成x行y列的矩阵，每个元素在[imin,\r\nimax]内</li>\r\n<li>randn(x, y)：生成x行y列的矩阵，每个元素服从标准正态分布</li>\r\n</ol></li>\r\n<li>导入本地数据创建：\r\n<ul>\r\n<li>支持格式：txt、dat、csv、xls、... ...</li>\r\n<li>导入方法：在菜单栏选择导入数据即可</li>\r\n</ul></li>\r\n</ol></li>\r\n<li>矩阵的修改\r\n<ul>\r\n<li>A(2, 3) = 0：单点修改</li>\r\n<li>A(2, :) = 0：第2行全部变为0</li>\r\n<li>A([1, 2], [1, 2, 3]) = 0：第1、2行的第1、2、3列改为0</li>\r\n</ul></li>\r\n<li>矩阵的运算\r\n<ol type=\"1\">\r\n<li>M1 + M2：对应元素相加</li>\r\n<li>M + c：矩阵M每个元素加上c</li>\r\n<li>M1 * M2：矩阵乘法</li>\r\n<li>M * c：矩阵M每个元素乘上c</li>\r\n<li>M1 .* M2：矩阵M1、M2对应元素相乘</li>\r\n<li>M1 ./ M2：矩阵M1、M2对应元素相除</li>\r\n<li>M ^ c：矩阵M的幂运算</li>\r\n<li>M'：矩阵M的转置</li>\r\n<li>inv(M)：矩阵M求逆</li>\r\n<li>diag(diag(M))：M的对角矩阵</li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"程序结构\">程序结构</h3>\r\n<ol type=\"1\">\r\n<li><p>global全局变量</p>\r\n<ul>\r\n<li>定义时global声明一次，函数内使用前声明一次</li>\r\n</ul></li>\r\n<li><p>if-elseif-else-end</p>\r\n<figure class=\"highlight matlab\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (... &amp;&amp; ...)</span><br><span class=\"line\">    <span class=\"comment\">% TODO</span></span><br><span class=\"line\"><span class=\"keyword\">elseif</span> (... &amp;&amp; ...)</span><br><span class=\"line\">    <span class=\"comment\">% TODO</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"comment\">% TODO</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\r\n<li><p>for-end</p>\r\n<figure class=\"highlight matlab\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = x:y <span class=\"comment\">%循环变量i从x到y</span></span><br><span class=\"line\">    <span class=\"comment\">% TODO</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\r\n<li><p>自定义函数</p>\r\n<figure class=\"highlight matlab\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">res</span> = <span class=\"title\">fun_name</span><span class=\"params\">(var1, var2, ...)</span></span></span><br><span class=\"line\">    <span class=\"comment\">% TODO</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun_name</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"comment\">% TODO</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure></li>\r\n</ol>\r\n<h3 id=\"图像\">图像</h3>\r\n<ol type=\"1\">\r\n<li>axis\r\n<ol type=\"1\">\r\n<li>axis([xmin, xmax, ymin, ymax])：生成指定坐标范围</li>\r\n<li>axis equal：x/y轴使用相同的比例</li>\r\n</ol></li>\r\n<li>subplot\r\n<ol type=\"1\">\r\n<li>subplot(n, m,\r\nid)：将figure分割为n*m个区域，当前使用第id个区域进行绘图</li>\r\n</ol></li>\r\n<li>plot\r\n<ol type=\"1\">\r\n<li>hold on：使得多个plot画出的线在一个图上</li>\r\n<li>plot(X, Y)：画出点(x1, y1), (x2, y2), ...并连线</li>\r\n<li>plot(Y)：画出(1, y1), (2, y2), ...并连线</li>\r\n<li>plot(x, y, '.')：画坐标点(x, y)</li>\r\n</ol></li>\r\n<li>title\r\n<ol type=\"1\">\r\n<li>title('xxx')：起名</li>\r\n</ol></li>\r\n<li>xlabel/ylabel\r\n<ol type=\"1\">\r\n<li>xlabel('xxx')</li>\r\n</ol></li>\r\n<li>legend\r\n<ol type=\"1\">\r\n<li>legend('name1', 'name2', ...)：图例</li>\r\n</ol></li>\r\n<li>改样式\r\n<ul>\r\n<li>交给FigureBest</li>\r\n</ul></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"实战\">实战</h3>\r\n<figure class=\"highlight matlab\"><table><tr><td class=\"code\"><pre><span class=\"line\">clc;</span><br><span class=\"line\">clear all; <span class=\"comment\">% 相比于clear, clear all可以清除global变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 定义变量</span></span><br><span class=\"line\"><span class=\"keyword\">global</span> Iter_Num n x r r1 r2 alpha <span class=\"built_in\">beta</span> v s y a ans_x ans_y s_x s_y xx vv ss yy;</span><br><span class=\"line\">Iter_Num = <span class=\"number\">1000</span>;</span><br><span class=\"line\">n = <span class=\"number\">5</span>;</span><br><span class=\"line\">x = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, n);</span><br><span class=\"line\">r = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, n);</span><br><span class=\"line\">r1 = [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>];     <span class=\"comment\">% 5个预设点的x坐标</span></span><br><span class=\"line\">r2 = [<span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">8</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];     <span class=\"comment\">% 5个预设点的y坐标</span></span><br><span class=\"line\">alpha = <span class=\"number\">0.01</span>;</span><br><span class=\"line\"><span class=\"built_in\">beta</span> = <span class=\"number\">0.01</span>;</span><br><span class=\"line\">v = <span class=\"built_in\">diag</span>(<span class=\"built_in\">ones</span>(<span class=\"number\">1</span>, n));</span><br><span class=\"line\">s = phi(x);</span><br><span class=\"line\">y = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, n);</span><br><span class=\"line\">a = [</span><br><span class=\"line\">    <span class=\"number\">1</span>/<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>/<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>;</span><br><span class=\"line\">     <span class=\"number\">1</span>/<span class=\"number\">3</span>, <span class=\"number\">1</span>/<span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>/<span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1</span>/<span class=\"number\">2</span>, <span class=\"number\">1</span>/<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">1</span>/<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>/<span class=\"number\">2</span>, <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>/<span class=\"number\">2</span>, <span class=\"number\">1</span>/<span class=\"number\">2</span></span><br><span class=\"line\">    ];</span><br><span class=\"line\">ans_x = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>); <span class=\"comment\">% ans_x[i][j]表示第i个点第j次迭代的x坐标</span></span><br><span class=\"line\">ans_y = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>); <span class=\"comment\">% ans_y[i][j]表示第i个点第j次迭代的y坐标</span></span><br><span class=\"line\">s_x = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);   <span class=\"comment\">% s_x[i][j]表示第i个点第j次迭代x坐标的sigma</span></span><br><span class=\"line\">s_y = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>);   <span class=\"comment\">% s_y[i][j]表示第i个点第j次迭代y坐标的sigma</span></span><br><span class=\"line\">xx = x;</span><br><span class=\"line\">vv = v;</span><br><span class=\"line\">ss = s;</span><br><span class=\"line\">yy = y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 开始迭代</span></span><br><span class=\"line\">solve();</span><br><span class=\"line\">fprintf(<span class=\"string\">&#x27;经过%d轮迭代, 最终F(x)收敛到: %f\\n&#x27;</span>, Iter_Num, cal(Iter_Num));</span><br><span class=\"line\">draw_1(); <span class=\"comment\">% F_k的比率图</span></span><br><span class=\"line\">draw_2(); <span class=\"comment\">% 画演示图</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">%下面是画图子函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw_2</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> Iter_Num;</span><br><span class=\"line\">    <span class=\"built_in\">figure</span> (<span class=\"number\">2</span>);</span><br><span class=\"line\">    subplot(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    draw_2_sub(<span class=\"number\">1</span>);</span><br><span class=\"line\">    subplot(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">    draw_2_sub(Iter_Num / <span class=\"number\">2</span>);</span><br><span class=\"line\">    subplot(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\">    draw_2_sub(Iter_Num);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw_2_sub</span><span class=\"params\">(iter_num)</span></span></span><br><span class=\"line\">    <span class=\"built_in\">hold</span> on;</span><br><span class=\"line\">    <span class=\"keyword\">global</span> n r1 r2 ans_x ans_y;</span><br><span class=\"line\">    axis([<span class=\"number\">0</span>, <span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"number\">10</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">plot</span>(<span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"string\">&#x27;*&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span> : n</span><br><span class=\"line\">        <span class=\"built_in\">plot</span>(ans_x(<span class=\"built_in\">i</span>, iter_num), ans_y(<span class=\"built_in\">i</span>, iter_num), <span class=\"string\">&#x27;+&#x27;</span>, <span class=\"string\">&#x27;Color&#x27;</span>, <span class=\"string\">&#x27;blue&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"built_in\">plot</span>([r1(<span class=\"number\">1</span>), r1(<span class=\"number\">2</span>), r1(<span class=\"number\">3</span>), r1(<span class=\"number\">5</span>), r1(<span class=\"number\">4</span>), r1(<span class=\"number\">1</span>)], [r2(<span class=\"number\">1</span>), r2(<span class=\"number\">2</span>), r2(<span class=\"number\">3</span>), r2(<span class=\"number\">5</span>), r2(<span class=\"number\">4</span>), r2(<span class=\"number\">1</span>)], <span class=\"string\">&#x27;Marker&#x27;</span>,<span class=\"string\">&#x27;x&#x27;</span>, <span class=\"string\">&#x27;Color&#x27;</span>, <span class=\"string\">&#x27;red&#x27;</span>);</span><br><span class=\"line\">    sum_x = <span class=\"number\">0</span>;</span><br><span class=\"line\">    sum_y = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span> : n</span><br><span class=\"line\">        sum_x = sum_x + ans_x(<span class=\"built_in\">i</span>, iter_num);</span><br><span class=\"line\">        sum_y = sum_y + ans_y(<span class=\"built_in\">i</span>, iter_num);</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"built_in\">plot</span>(sum_x / n, sum_y / n, <span class=\"string\">&#x27;o&#x27;</span>);</span><br><span class=\"line\">    xlabel(<span class=\"string\">&#x27;$x_1$&#x27;</span>, <span class=\"string\">&#x27;Interpreter&#x27;</span>, <span class=\"string\">&#x27;latex&#x27;</span>);</span><br><span class=\"line\">    ylabel(<span class=\"string\">&#x27;$x_2$&#x27;</span>, <span class=\"string\">&#x27;Interpreter&#x27;</span>, <span class=\"string\">&#x27;latex&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">draw_1</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"built_in\">figure</span> (<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">global</span> Iter_Num;</span><br><span class=\"line\">    F_best = <span class=\"number\">18.874999999999645</span>;</span><br><span class=\"line\">    error = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span> : (Iter_Num - <span class=\"number\">1</span>)</span><br><span class=\"line\">        error = [error, <span class=\"built_in\">abs</span>(cal(<span class=\"built_in\">i</span> + <span class=\"number\">1</span>) - F_best) / <span class=\"built_in\">abs</span>(cal(<span class=\"built_in\">i</span>) - F_best)];</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"built_in\">plot</span>(error);</span><br><span class=\"line\">    xlabel(<span class=\"string\">&#x27;Iteration k&#x27;</span>);</span><br><span class=\"line\">    ylabel(<span class=\"string\">&#x27;$\\frac&#123;f_&#123;k+1&#125; - f^*&#125;&#123;f_k - f^*&#125;$&#x27;</span>, <span class=\"string\">&#x27;Interpreter&#x27;</span>, <span class=\"string\">&#x27;latex&#x27;</span>, <span class=\"string\">&#x27;FontSize&#x27;</span>, <span class=\"number\">20</span>);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">% 下面是计算子函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">res</span> = <span class=\"title\">cal</span><span class=\"params\">(iter_num)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> n ans_x r1 ans_y r2 s_x s_y;</span><br><span class=\"line\">    sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span> : n</span><br><span class=\"line\">        sum = sum + <span class=\"number\">0.5</span> * ((ans_x(<span class=\"built_in\">i</span>, iter_num) - r1(<span class=\"built_in\">i</span>)) ^ <span class=\"number\">2</span> + (ans_y(<span class=\"built_in\">i</span>, iter_num) - r2(<span class=\"built_in\">i</span>)) ^ <span class=\"number\">2</span>)...</span><br><span class=\"line\">            + <span class=\"number\">0.5</span> * ((ans_x(<span class=\"built_in\">i</span>, iter_num) - <span class=\"number\">5</span>) ^ <span class=\"number\">2</span> + (ans_y(<span class=\"built_in\">i</span>, iter_num) - <span class=\"number\">5</span>) ^ <span class=\"number\">2</span>)...</span><br><span class=\"line\">            + ((s_x(<span class=\"built_in\">i</span>, iter_num) - <span class=\"number\">5</span>) ^ <span class=\"number\">2</span> + (s_y(<span class=\"built_in\">i</span>, iter_num) - <span class=\"number\">5</span>) ^ <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    res = sum;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> Iter_Num n xx ss ans_x ans_y s_x s_y;</span><br><span class=\"line\">    init(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> T = <span class=\"number\">1</span> : Iter_Num</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span> : n</span><br><span class=\"line\">            upd_x(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">            ans_x(<span class=\"built_in\">i</span>, T) = xx(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">            upd_v(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">            upd_s(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">            s_x(<span class=\"built_in\">i</span>, T) = ss(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">            upd_y(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        backup();</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    init(<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> T = <span class=\"number\">1</span> : Iter_Num</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"built_in\">i</span> = <span class=\"number\">1</span> : n</span><br><span class=\"line\">            upd_x(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">            ans_y(<span class=\"built_in\">i</span>, T) = xx(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">            upd_v(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">            upd_s(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">            s_y(<span class=\"built_in\">i</span>, T) = ss(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">            upd_y(<span class=\"built_in\">i</span>);</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        backup();</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upd_y</span><span class=\"params\">(i)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> a ss yy y <span class=\"built_in\">beta</span> n;</span><br><span class=\"line\">    sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">j</span> = <span class=\"number\">1</span> : n</span><br><span class=\"line\">        sum = sum + a(<span class=\"built_in\">i</span>, <span class=\"built_in\">j</span>) * ss(<span class=\"built_in\">j</span>);</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    yy(<span class=\"built_in\">i</span>) = y(<span class=\"built_in\">i</span>) + <span class=\"built_in\">beta</span> * (ss(<span class=\"built_in\">i</span>) - sum);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upd_s</span><span class=\"params\">(i)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> a s ss x xx vv n v;</span><br><span class=\"line\">    sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">j</span> = <span class=\"number\">1</span> : n</span><br><span class=\"line\">        sum = sum + a(<span class=\"built_in\">i</span>, <span class=\"built_in\">j</span>) * s(<span class=\"built_in\">j</span>);</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    ss(<span class=\"built_in\">i</span>) = sum + phi(xx(<span class=\"built_in\">i</span>)) / vv(<span class=\"built_in\">i</span>, <span class=\"built_in\">i</span>) - phi(x(<span class=\"built_in\">i</span>)) / v(<span class=\"built_in\">i</span>, <span class=\"built_in\">i</span>);</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upd_v</span><span class=\"params\">(i)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> n a v vv;</span><br><span class=\"line\">    sum = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, n);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">j</span> = <span class=\"number\">1</span> : n</span><br><span class=\"line\">        sum = sum + a(<span class=\"built_in\">i</span>, <span class=\"built_in\">j</span>) * v(<span class=\"built_in\">j</span>, :);</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    vv(<span class=\"built_in\">i</span>, :) = sum;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">upd_x</span><span class=\"params\">(i)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> xx x alpha r n y s v;</span><br><span class=\"line\">    xx(<span class=\"built_in\">i</span>) = x(<span class=\"built_in\">i</span>) - alpha * ((x(<span class=\"built_in\">i</span>) - r(<span class=\"built_in\">i</span>)) + (x(<span class=\"built_in\">i</span>) - <span class=\"number\">5</span>) + (<span class=\"number\">1</span> / n) * (y(<span class=\"built_in\">i</span>) + <span class=\"number\">2</span> * (s(<span class=\"built_in\">i</span>) - <span class=\"number\">5</span>) / n / v(<span class=\"built_in\">i</span>, <span class=\"built_in\">i</span>)));</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">backup</span><span class=\"params\">()</span></span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> x v s y xx vv ss yy</span><br><span class=\"line\">    x = xx;</span><br><span class=\"line\">    v = vv;</span><br><span class=\"line\">    s = ss;</span><br><span class=\"line\">    y = yy;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">init</span><span class=\"params\">(op)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> n x r v s y xx vv ss yy r1 r2</span><br><span class=\"line\">    x = randi([<span class=\"number\">1</span>, <span class=\"number\">5</span>], <span class=\"number\">1</span>, n);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (op == <span class=\"number\">1</span>)</span><br><span class=\"line\">        r = r1;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        r = r2;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    v = <span class=\"built_in\">diag</span>(<span class=\"built_in\">ones</span>(<span class=\"number\">1</span>, n));</span><br><span class=\"line\">    s = phi(x);</span><br><span class=\"line\">    y = <span class=\"built_in\">zeros</span>(<span class=\"number\">1</span>, n);</span><br><span class=\"line\">    xx = x;</span><br><span class=\"line\">    vv = v;</span><br><span class=\"line\">    ss = s;</span><br><span class=\"line\">    yy = y;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">res</span> = <span class=\"title\">phi</span><span class=\"params\">(x)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> n;</span><br><span class=\"line\">    res = x / n;</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\r\n<p>经过FigureBest美化后的图片：</p>\r\n<p><img src=\"1.png\" /></p>\r\n<p><img src=\"2.png\" /></p>\r\n","categories":["2. 技能栈","Matlab"]},{"title":"Linux基础","url":"/2023/10/14/Linux%E5%9F%BA%E7%A1%80/","content":"<ul>\r\n<li>这篇文章涉及到的都是本人用到的知识，没用到的我都没写。</li>\r\n<li>学会这些算是一个计算机学生的基本素养吧。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<ul>\r\n<li>比如以后进厂打工可嫩会接触到Linux环境，那么<strong>tmux、nano、Linux常用命令</strong>，总得会吧。</li>\r\n<li>然后工作或者租算力服务器或者连学校服务器，可能会用到<strong>SSH</strong>吧，所以ssh也总得会吧。</li>\r\n<li>然后因为自己平时也可能会写工程，所以<strong>Git、类github软件</strong>总得会用吧。</li>\r\n<li>然后可能偶尔在Linux或者Win下写点脚本来批处理文件，所以<strong>shell语法</strong>也得会一点吧。</li>\r\n<li>最后是docker，到时候别人传一个docker给你，你都不会配环境，这说不过去，所以<strong>docker</strong>也得会用吧。</li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"tmux\">tmux</h3>\r\n<p>学这个是为了可以在一个终端里开多个屏来工作，提高生产效率。</p>\r\n<ul>\r\n<li>tmux ls：显示所有session列表</li>\r\n<li>tmux attach -t [id]：进入到某个session中</li>\r\n<li>tmux：新建一个session并进入</li>\r\n<li>ctrl + b, s：显示session、window、pane树形结构</li>\r\n<li>ctrl + d：删除当前pane/window/session</li>\r\n<li>ctrl + b, d：在不删除session的前提下退出tmux</li>\r\n<li>ctrl + b, %：左右分屏</li>\r\n<li>ctrl + b, \"：上下分屏</li>\r\n<li>ctrl + b, ↑←↓→：在pane中切换</li>\r\n<li>ctrl + b不松开 + ↑←↓→：调整当前pane大小</li>\r\n<li>ctrl +\r\nb，[：进入复制模式，在此模式下按上下左右可控制光标移动。按q退出该模式</li>\r\n</ul>\r\n<h3 id=\"nanovim\">nano/vim</h3>\r\n<p>学这个是为了在Linux系统下处理文本。本质上就是学如何用记事本。</p>\r\n<p>关于vim我能不用尽量不用，但是迫不得已的时候使用的时候还是要会它的基本操作。按Esc回到命令模式，命令模式下dd删除本行，:wq保存退出，:q!强制退出，i进入编辑模式。下面是关于nano的操作</p>\r\n<p>另外，在/etc/nanorc里可以配置nano</p>\r\n<ul>\r\n<li>ctrl + x：退出</li>\r\n<li>ctrl + o：保存</li>\r\n<li>ctrl + k：剪切</li>\r\n<li>ctrl + u：粘贴</li>\r\n<li>alt +6：复制</li>\r\n<li>alt + u：撤销</li>\r\n<li>alt +\r\na：开启选中模式（注意这个快捷键与微信截图冲突了，记得把vx的改了）</li>\r\n<li>alt + m：开始鼠标模式</li>\r\n<li>alt + shift + 3：开启行号</li>\r\n<li>ctrl + a：回到行首；ctrl + e：回到行末；alt + /：跳转到文末；alt +\r\n：跳转到开头</li>\r\n<li>ctrl + shift + v：将windows文本复制到nano/vim/shell里</li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"linux常用命令\">Linux常用命令</h3>\r\n<h4 id=\"系统状况\">系统状况</h4>\r\n<ul>\r\n<li>top：查看所有进程的信息\r\n<ul>\r\n<li>输入M：按使用内存排序</li>\r\n<li>输入P：按使用CPU排序</li>\r\n<li>输入q：退出</li>\r\n</ul></li>\r\n<li>df -h：查看硬盘使用情况</li>\r\n<li>free -h：查看内存使用情况</li>\r\n<li>du -sh：查看当前目录所占硬盘空间\r\n<ul>\r\n<li>du -sh 文件名：查看当前目录下某文件所占硬盘空间</li>\r\n</ul></li>\r\n<li>ps aux：查看所有进程</li>\r\n<li>kill -9 pid：杀死编号为pid的进程</li>\r\n<li>ping www.baidu.com：检查是否联网</li>\r\n</ul>\r\n<h4 id=\"文件检索\">文件检索</h4>\r\n<ul>\r\n<li>find path -name \"filename\"：在某个路径下搜索目标文件</li>\r\n<li>grep\r\nxxx：从stdin中读入若干行参数，如果某行包括xxx，则输出该行，否则忽略该行</li>\r\n<li>xargs：从stdin接受数据，并以空格分割形式转换为命令行参数\r\n<ul>\r\n<li>例如，find . -name \"*.cpp\" | xargs\r\ncat，读取当前目录下所有.cpp文件的内容</li>\r\n<li>find . -name \"*.cp\" | xargs cat | grep\r\n\"cout\"：找出当前目录下的.cpp文件中所有包含cout的行</li>\r\n</ul></li>\r\n<li>wc -l filename：统计文件的行数\r\n<ul>\r\n<li>wc既可以接收文件名参数，也可以从stdin读入内容</li>\r\n<li>find . -name \"*.cpp\" | wc -l：统计当前目录下有多少个.cpp文件</li>\r\n<li>find . -name \"*.cpp\" | xargs wc\r\n-l：统计当前目录下每个.cpp文件有多少行</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"工具\">工具</h4>\r\n<ul>\r\n<li>|：管道符\r\n<ul>\r\n<li>将前一个command的<strong>stdout</strong>重定向到后一个command的<strong>stdin</strong></li>\r\n<li>在文件检索中经常用到</li>\r\n</ul></li>\r\n<li>history：展示历史操作\r\n<ul>\r\n<li>history 数字：展示最后num条操作</li>\r\n</ul></li>\r\n<li>tar -zcvf xxx.tar.gz 文件1 文件2：压缩</li>\r\n<li>tar -zxvf xxx.tar.gz：解压</li>\r\n<li>diff xxx yyy：比较xxx与yyy的不同点</li>\r\n<li>sudo apt update：更新可用软件包列表</li>\r\n<li>sudo apt install 包名：安装</li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"ssh\">ssh</h3>\r\n<p>这个ssh以后自己租服务器的时候用得上。就是学会如何登录，以及主机和服务器之间如何传文件即可。</p>\r\n<ul>\r\n<li><p>ssh user@hostname：登录</p></li>\r\n<li><p>在~/.ssh/config里写配置文件，格式如下</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Host name1</span><br><span class=\"line\">    HostName IP地址</span><br><span class=\"line\">    User 用户名</span><br></pre></td></tr></table></figure>\r\n<p>那么在下次使用服务器时，就可以ssh name1来登录</p></li>\r\n<li><p>ssh-keygen：创建密钥（密钥文件存储在~/.ssh/下）</p></li>\r\n<li><p>ssh-copy-id\r\n服务器别名：向服务器添加自己的公钥，这样以后登录服务器可以免密登录</p></li>\r\n<li><p>scp source destinatino：跟cp一样，本机与服务器传文件</p>\r\n<ul>\r\n<li>例如scp /etc/nanorc 服务器别名:/etc/nanorc</li>\r\n<li>注意在传文件夹时要加-r，而且-r必须紧跟在scp后</li>\r\n</ul></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"git\">git</h3>\r\n<ul>\r\n<li>git config --global user.name xxx：设置全局用户名</li>\r\n<li>git config --global user.email xxx@xxx.com：设置全局邮箱地址</li>\r\n<li>上述信息都会记录在~/.gitconfig文件中</li>\r\n<li>git init：将当前目录配置成git仓库，信息记录在.git文件夹中</li>\r\n<li>git status：查看仓库状态</li>\r\n<li>git add xx：将xx文件添加到暂存区\r\n<ul>\r\n<li>git add .：将全部改动添加到暂存区</li>\r\n</ul></li>\r\n<li>git rm --cached xx：将xx改动从暂存区中移出</li>\r\n<li>git commit -m \"备注信息\"：将暂存区中的内容提交到当前分支</li>\r\n<li>git log：查看当前分支从根到HEAD指针的所有版本\r\n<ul>\r\n<li>git log --oneline：简洁显示</li>\r\n</ul></li>\r\n<li>git relog：查看HEAD指针的移动历史</li>\r\n<li>git reset --hard HEAD~：回滚到上一个版本\r\n<ul>\r\n<li>git reset --hard HEAD~~：回滚到上两个版本</li>\r\n<li>git reset --hard 版本号(7位hash值)：回滚到目标版本</li>\r\n</ul></li>\r\n<li>git remote add origin\r\ngit@git.acwing.com:Error666/test.git：将本地仓库与acgit绑定</li>\r\n<li>git push -u origin master：将本地仓库推送到acgit上\r\n<ul>\r\n<li>第一次需要向上面这么写，至于用master还是main，用git\r\nbranch查看本地分支。是什么就用什么。以后推送直接git push即可</li>\r\n</ul></li>\r\n<li>更多有关git的命令：<a\r\nhref=\"https://www.acwing.com/file_system/file/content/whole/index/content/2932078/\">传送门</a></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"shell\">shell</h3>\r\n<p>shell语言主要学来用来批处理文件的，比如建立多个文件夹，改名多个文件夹啥的。学完后在window里也用得上。比如打竞赛出题的数据的时候，就可以用shell写个脚本统一创建文件/改名。在windows里用git的git\r\nbash运行脚本即可。</p>\r\n<h4 id=\"基本\">基本</h4>\r\n<ul>\r\n<li>su - root/zhou：换用户</li>\r\n<li>mkdir/touch/cp/mv/rm/cat：基本操作</li>\r\n<li>chmod +x+x+x\r\n[filename]：给权限（3个x对应user,group,others，如果只给user写1个x即可）\r\n<ul>\r\n<li>chmod +x dirname -R：递归的给权限</li>\r\n</ul></li>\r\n<li>.sh为shell脚本后缀，在文件里第一行应为#!\r\n/bin/bash。执行方式有两种，bash filename.sh或者./filename.sh</li>\r\n<li>echo：输出\r\n<ul>\r\n<li>加参数-e：可在输出内容中识别转移字符，例如echo -e \"hello\"。</li>\r\n<li>加参数echo默认会输出换行，在结尾处加（要加-e）</li>\r\n<li>echo ${a[@]}：输出数组中的数，以一行形式</li>\r\n<li>echo ${a[@]:1:n}：输出数组下标为1 ~ n的数</li>\r\n</ul></li>\r\n<li>“”：可将有空格的名字看作一个整体</li>\r\n</ul>\r\n<h4 id=\"变量\">变量</h4>\r\n<ul>\r\n<li>变量=xxx：定义变量</li>\r\n<li>${变量}：使用变量</li>\r\n<li>$0, $1, $2, ...：为传入的参数（$0为文件名）</li>\r\n<li>$#：传入的参数个数</li>\r\n<li>$?：返回上一条command的exit code</li>\r\n<li>`command`：返回command的stdout（不支持嵌套）</li>\r\n<li>$(command)：作用同``，但是支持嵌套</li>\r\n</ul>\r\n<h4 id=\"运算\">运算</h4>\r\n<ul>\r\n<li>expr $a +/- $b：进行a±b的运算</li>\r\n<li>expr $a \\* $b：进行a*b的运算</li>\r\n<li>expr $a / $b：进行a/b的运算</li>\r\n<li>expr $a % $b：进行a%b的运算</li>\r\n<li>()可以改变优先级，但要加\\转义，同时记得打括号</li>\r\n</ul>\r\n<h4 id=\"循环\">循环</h4>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span>法一</span></span><br><span class=\"line\">for var in val1 val2 val3</span><br><span class=\"line\">do</span><br><span class=\"line\">  ....</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span>法二</span></span><br><span class=\"line\">for var in `seq 1 10`</span><br><span class=\"line\">do</span><br><span class=\"line\">  ...</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span>法三</span></span><br><span class=\"line\">for var in &#123;1..10&#125;/&#123;10..1&#125;/&#123;a..z&#125;/&#123;z..a&#125;    # 这种写法&#123;&#125;里面只能是常量</span><br><span class=\"line\">do</span><br><span class=\"line\">  ...</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span>法四（跟C++一样，只不过多了层括号）</span></span><br><span class=\"line\">for ((expreesion; condition; expression))</span><br><span class=\"line\">do</span><br><span class=\"line\">  ...</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">while</span></span></span><br><span class=\"line\">while condition</span><br><span class=\"line\">do</span><br><span class=\"line\">  ...</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"built_in\">break</span>/continue</span></span><br><span class=\"line\">跟C++一样</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"判断\">判断</h4>\r\n<ul>\r\n<li>shell里的if看的是exit code的状态。如果exit\r\ncode为0，则为真。否则为假</li>\r\n</ul>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">if</span></span></span><br><span class=\"line\">if condition</span><br><span class=\"line\">then</span><br><span class=\"line\">  ...</span><br><span class=\"line\">fi</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">if-else</span></span><br><span class=\"line\">if condition</span><br><span class=\"line\">then</span><br><span class=\"line\">  ...</span><br><span class=\"line\">else</span><br><span class=\"line\">  ...</span><br><span class=\"line\">fi</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">if-elif-else</span></span><br><span class=\"line\">if condition</span><br><span class=\"line\">then</span><br><span class=\"line\">  ...</span><br><span class=\"line\">elif</span><br><span class=\"line\">then</span><br><span class=\"line\">  ...</span><br><span class=\"line\">else</span><br><span class=\"line\">  ...</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"test\">test/[ ]</h4>\r\n<ul>\r\n<li>[ $a -[参数] $b ]：整数a与b的比较\r\n<ul>\r\n<li>-eq：是否相等（equal）</li>\r\n<li>-ne：是否不相等（not equal）</li>\r\n<li>-gt：是否大于（greater than）</li>\r\n<li>-ge：是否大于等于（greater than or equal）</li>\r\n<li>-lt：是否小于（less than）</li>\r\n<li>-le：是否小于等于（less than or equal）</li>\r\n</ul></li>\r\n<li>[ -[参数] filename ]：文件类型判断\r\n<ul>\r\n<li>-e：文件是否存在</li>\r\n<li>-f：是否为文件</li>\r\n<li>-d：是否为目录</li>\r\n</ul></li>\r\n<li>[ -[参数] filename ]：文件权限判断\r\n<ul>\r\n<li>-r：是否可读</li>\r\n<li>-w：是否可写</li>\r\n<li>-x：是否可执行</li>\r\n<li>-s：是否为非空文件</li>\r\n</ul></li>\r\n<li>可用&amp;&amp;、||、!拼接</li>\r\n</ul>\r\n<h4 id=\"函数\">函数</h4>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">fun_name() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>调用方式：fun_name val1 val2 val3</li>\r\n<li>函数内部默认参数从1开始，没有0，即$1</li>\r\n<li>在函数里面return的是exit code。echo的是stdout</li>\r\n<li>不管在函数还是函数外部直接使用的变量默认都是全局变量，所以若想使用局部变量，需要用local关键字声明</li>\r\n</ul>\r\n<h4 id=\"文件重定向\">文件重定向</h4>\r\n<ul>\r\n<li>&gt;：将原本输出到stdout的内容以覆盖形式输出到指定文件</li>\r\n<li>&lt;：原本从stdin读入数据，现在从指定文件中读入数据</li>\r\n<li>&gt;&gt;：将原本输出到stdout的内容以追加形式输出到指定文件</li>\r\n</ul>\r\n<h4 id=\"其它\">其它</h4>\r\n<ul>\r\n<li>导入外部脚本：source\r\nfilename（本质就是将外部脚本粘贴复制到本脚本中）</li>\r\n<li>更多shell语法：<a\r\nhref=\"https://www.acwing.com/file_system/file/content/whole/index/content/2855883/\">传送门</a></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"docker\">docker</h3>\r\n<p>首先要安装docker，搜docker ubuntu，进官网，按照官网指示装就行了。</p>\r\n<p>然后如果在用docker命令时发现每次都要加sudo权限，可以将当前用户加入到docker用户组中：sudo\r\nusermod -aG docker $USER。然后退出服务器，重进，即可解决这个问题</p>\r\n<p>记住，docker中区分image可以用id或者名字（image名字是name:版本号）。区分container可以用id或者name。</p>\r\n<h4 id=\"镜像\">镜像</h4>\r\n<ul>\r\n<li>docker pull 名称：拉取一个镜像</li>\r\n<li>docker images：列出本地所有镜像</li>\r\n<li>docker rmi id/名字：删除某个镜像</li>\r\n<li>docker save -o xxx.tar id/名字：把某个镜像导出</li>\r\n<li>docker load -i xxx.tar：导入某个镜像</li>\r\n</ul>\r\n<h4 id=\"容器\">容器</h4>\r\n<ul>\r\n<li>docker ps -a：查看本地的所有容器</li>\r\n<li>docker create -it 镜像id/名字：利用某镜像创建一个容器</li>\r\n<li>docker rm id/name：删除某容器</li>\r\n<li>docker rename name1 name2：重命名容器</li>\r\n<li>docker start id/name：启动某容器</li>\r\n<li>docker stop id/name：停止某容器</li>\r\n<li>docker exec -it id/name /bin/bash或者/bin/zsh：进入某容器\r\n<ul>\r\n<li>ctrl + d：退出并停止该容器</li>\r\n<li>ctrl + p, ctrl + q：退出该容器但不停止它</li>\r\n</ul></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"租服务器-thrift\">租服务器 &amp; thrift</h3>\r\n<p>待填</p>\r\n","categories":["2. 技能栈","Linux"]},{"title":"Python进阶","url":"/2024/02/24/Python%E8%BF%9B%E9%98%B6/","content":"<p>说是进阶，其实就讲了三个数据分析常用包：numpy、pandas、matplotlib</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"numpy\">numpy</h3>\r\n<ul>\r\n<li>其实就是列表，但是好处就是速度快、操作方便、许多好用的数学计算接口</li>\r\n</ul>\r\n<h4 id=\"定义\">定义</h4>\r\n<ul>\r\n<li>通过列表定义\r\n<ul>\r\n<li>a = [0, 1, 2, 3] arr = np.array(a)</li>\r\n<li>arr = np.array([0, 1, 2, 3])</li>\r\n</ul></li>\r\n<li>初始化为全0/1/指定元素\r\n<ul>\r\n<li>np.zeros(5) # 结果为array([0., 0., 0., 0., 0.])</li>\r\n<li>np.ones(5) # 结果为array([1., 1., 1., 1., 1.])</li>\r\n<li>.zeros和.ones默认都是小数，改为整数可以写.zeros(5, dtype='int')</li>\r\n<li>a.fill(3)：将a的所有元素改为3（注意这里a要是一个ndarray类型）</li>\r\n</ul></li>\r\n<li>生成整数数列\r\n<ul>\r\n<li>np.arrange(l, r, d)：在[l, r)内，从l开始，每次递增d</li>\r\n</ul></li>\r\n<li>生成随机数\r\n<ul>\r\n<li>np.random.rand(10)：生成10个[0, 1)的随机数</li>\r\n<li>np.random.randn(10)：生成10个服从标准正态分布的随机数</li>\r\n<li>np.random.randint(l, r, 10)：生成10个在[l, r)范围内的随机整数</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"属性\">属性</h4>\r\n<ul>\r\n<li>a.dtype：查看a里元素的类型</li>\r\n<li>a.shape：返回一个元组，里面元素分别代表每一维元素的数目</li>\r\n<li>a.ndim：查看维度</li>\r\n<li>a.size：查看元素个数</li>\r\n<li>a.astype('float')：返回将a内元素类型转换为float后的结果</li>\r\n</ul>\r\n<h4 id=\"运算\">运算</h4>\r\n<ul>\r\n<li><p>ndarray支持切片，同时可直接与数字/ndarray进行运算</p></li>\r\n<li><p>注意复制的时候不能像列表那样用a[:]切片复制，要使用.copy()来复制</p></li>\r\n<li><p>a + 1：每个元素+1</p></li>\r\n<li><p>a * 5：每个元素*5</p></li>\r\n<li><p>a + b：两个ndarray对应元素相加</p></li>\r\n<li><p>a * b：两个ndarray对应元素相乘</p></li>\r\n<li><p>a / b：两个ndarray对应元素相除</p></li>\r\n</ul>\r\n<h4 id=\"多维情况\">多维情况</h4>\r\n<ul>\r\n<li><p>np.zeros((2, 3))：创建2行3列的全零ndarray</p></li>\r\n<li><p>np.ones((2, 3))：创建2行3列的全一ndarray</p></li>\r\n<li><p>a.fill(3)：将a全部元素换为3</p></li>\r\n<li><p>a[1, 2]：访问第1行第2列的元素</p></li>\r\n<li><p>a[1]：返回第一行，以ndarray形式</p></li>\r\n</ul>\r\n<h4 id=\"常用函数\">常用函数</h4>\r\n<ul>\r\n<li>np.sort(a)：返回将a排序后的结果</li>\r\n<li>np.argsort(a)：返回每个元素在排序过后所处的排名（排名从0开始）</li>\r\n<li>np.sum(a)：求和</li>\r\n<li>np.max(a)：求最大值</li>\r\n<li>np.mean(a)：求均值</li>\r\n<li>np.vstack((a, b))：纵向堆叠</li>\r\n<li>np.hstack((a, b))：横向堆叠</li>\r\n<li>np.dstack((a, b))：维度上堆叠</li>\r\n</ul>\r\n<h4 id=\"矩阵运算\">矩阵运算</h4>\r\n<ul>\r\n<li><p>a.T：转置</p></li>\r\n<li><p>np.eye(3)：产生一个3*3的单位矩阵</p></li>\r\n<li><p>np.dot(a, b)：返回俩矩阵相乘的结果</p></li>\r\n<li><p>np.linalg.det(a)：求矩阵的行列式</p></li>\r\n<li><p>np.linalg.inv(a)：求矩阵的逆矩阵</p></li>\r\n<li><p>np.diagonal(a)：提取矩阵的对角线元素，返回一个一维ndarray</p></li>\r\n<li><p>np.diag(a)：这里a是一个一维ndarray，返回一个以a为对角线元素的矩阵</p></li>\r\n<li><p>矩阵只保留对角线元素：先np.digonal()，再np.diag()一下即可</p></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"pandas\">pandas</h3>\r\n<ul>\r\n<li>提供了许多处理数据的接口</li>\r\n</ul>\r\n<h4 id=\"series\">Series</h4>\r\n<ul>\r\n<li>pd.Series([1, 3, 5, nan,\r\n7])：创建一个Series，其实Series跟列表差不多，就是多了一个索引index。列表的索引就是下标0,\r\n1, 2, ...，Series索引默认也是0, 1, 2，但是可以自己更改</li>\r\n<li>a.values：返回a的值</li>\r\n<li>a.index：返回a的键</li>\r\n</ul>\r\n<h4 id=\"dataframe\">DataFrame</h4>\r\n<ul>\r\n<li>DataFrame其实就是一个二维数组，但是有表头。行表头叫做columns，列表头叫做index</li>\r\n<li>a =\r\npd.read_excel('路径')：把一个excel表文件读入到一个dataframe变量中</li>\r\n<li>a.head()：查看前5行</li>\r\n<li>a.tail()：查看后5行</li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"matplotlib\">matplotlib</h3>\r\n<ul>\r\n<li>matplotlib 是一个Python 的2D\r\n图形包。pyplot封装了很多画图的函数。所以在实际的使用过程中，常常以plt\r\n作为 matplotlib.pyplot 的省略。import matplotlib.pyplot as plt</li>\r\n<li>找参数的网站：https://blog.csdn.net/qq_40481843/article/details/106231257</li>\r\n<li>plt.plot\r\n<ul>\r\n<li>画函数：plt.plot(x列表, y列表)</li>\r\n<li>画线段：plt.plot([x1, x2], [y1, y2])</li>\r\n<li>画点：plt.plot(x, y)</li>\r\n<li>参数:\r\n<ul>\r\n<li>color：颜色</li>\r\n<li>marker：点类型</li>\r\n<li>markersize：点大小</li>\r\n<li>markeredgewidth：点边宽</li>\r\n<li>fillstyle：点填充类型</li>\r\n<li>linestyle：线类型</li>\r\n<li>linewidth：线宽</li>\r\n<li>label：图例名字</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>plt.xlabel / plt.title\r\n<ul>\r\n<li>' '里写名称，用$$括起来可写latex</li>\r\n<li>参数：\r\n<ul>\r\n<li>fontsize：字体大小</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>plt.xlim：改变x轴范围，例如plt.xlim((x1, x2))</li>\r\n<li>plt.legend\r\n<ul>\r\n<li>啥都不写：以默认配置显示图例</li>\r\n<li>参数：\r\n<ul>\r\n<li>frameon：True/False（是否显示边框）</li>\r\n<li>loc：图例显示位置</li>\r\n<li>fontsize：图例字体大小</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>plt.text\r\n<ul>\r\n<li>plt.text(x, y, 'xxx')</li>\r\n<li>参数：\r\n<ul>\r\n<li>fontsize：字体大小</li>\r\n<li>ha：水平对齐方式\r\n<ul>\r\n<li>left：文本左对齐于指定点</li>\r\n<li>center：文本居中对齐于指定点</li>\r\n<li>right：文本右对齐于指定点</li>\r\n</ul></li>\r\n<li>va：垂直对齐方式\r\n<ul>\r\n<li>top：文本顶部对齐于指定点</li>\r\n<li>center：文本中部对齐于指定点</li>\r\n<li>bottom：文本底部对齐于指定点</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul></li>\r\n<li>plt.savefig：保存图片，例如plt.savefig('fig.eps')</li>\r\n<li>plt.rcParams\r\n<ul>\r\n<li>改变图片大小（单位为英寸）：plt.rcParams['figure.figsize']=(6.0,4.0)\r\n# 默认是(6, 4)</li>\r\n<li>改变图片保存时清晰度：plt.rcParams['savefig.dpi'] = 100 #\r\n默认是100</li>\r\n<li>改变图片显示的清晰度：plt.rcParams['figure.dpi'] = 100 #\r\n默认是100</li>\r\n<li>Note：改变dpi只对栅格图有效，矢量图无需设置dpi，清晰度都一样的</li>\r\n</ul></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"sympy\">sympy</h3>\r\n<p>一般使用即from sympy import *。</p>\r\n<p>启用美化打印：init_printing(use_unicode=True,\r\nuse_latex=True)。（配合display使用而不是print）</p>\r\n<h4 id=\"矩阵相关\">矩阵相关</h4>\r\n<ol type=\"1\">\r\n<li><p>定义</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">x, y, z = symbols(<span class=\"string\">&#x27;x y z&#x27;</span>)</span><br><span class=\"line\">v = Matrix([x, y, z])</span><br><span class=\"line\">M = Matrix([</span><br><span class=\"line\">    [x, y, z],</span><br><span class=\"line\">    [x, y, z],</span><br><span class=\"line\">    [x, y, z]</span><br><span class=\"line\">])</span><br><span class=\"line\">v_norm = symbols(<span class=\"string\">&#x27;\\|v\\|&#x27;</span>)</span><br></pre></td></tr></table></figure></li>\r\n<li><p>常用函数</p>\r\n<ul>\r\n<li>M.det()：返回M的行列式</li>\r\n<li>M.inv()：返回矩阵的逆（如果存在）</li>\r\n<li>M.T：返回转置</li>\r\n<li>Eq(left, right)：返回left = right这个方程</li>\r\n<li>solve(eq,\r\ngoal)：对于eq这个方程(eq是个Eq对象)，求解goal目标变量的取值</li>\r\n</ul></li>\r\n<li><p>实战例子</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sympy <span class=\"keyword\">import</span> *</span><br><span class=\"line\">init_printing(use_unicode=<span class=\"literal\">True</span>, use_latex=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">rho = symbols(<span class=\"string\">&#x27;rho&#x27;</span>)</span><br><span class=\"line\">varrho = symbols(<span class=\"string\">&#x27;varrho&#x27;</span>)</span><br><span class=\"line\">L1, L2, L3 = symbols(<span class=\"string\">&#x27;L_1 L_2 L_3&#x27;</span>)</span><br><span class=\"line\">AI_norm = symbols(<span class=\"string\">&#x27;\\|A-I\\|&#x27;</span>)</span><br><span class=\"line\">IJ_norm = symbols(<span class=\"string\">&#x27;\\|I-J\\|&#x27;</span>)</span><br><span class=\"line\">beta = symbols(<span class=\"string\">&#x27;beta&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">X = Matrix([</span><br><span class=\"line\">    [<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [<span class=\"number\">0</span>, rho, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [<span class=\"number\">0</span>, L2 * varrho * AI_norm * IJ_norm + beta * (<span class=\"number\">1</span> + rho), <span class=\"number\">1</span>]</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\">alpha = symbols(<span class=\"string\">&#x27;alpha&#x27;</span>)</span><br><span class=\"line\">mu = symbols(<span class=\"string\">&#x27;mu&#x27;</span>)</span><br><span class=\"line\">tau = symbols(<span class=\"string\">&#x27;tau&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">E = Matrix([</span><br><span class=\"line\">    [-<span class=\"number\">1</span> * mu, L1, L3],</span><br><span class=\"line\">    [varrho * L1 * L3 * (<span class=\"number\">1</span> + tau * varrho * L3) * IJ_norm, varrho * L1 * L3 * IJ_norm, varrho * L3 * L3 *  IJ_norm],</span><br><span class=\"line\">    [varrho * L1 * L2 * (<span class=\"number\">1</span> + varrho * L3) * (<span class=\"number\">1</span> + tau * varrho * L3) * IJ_norm, varrho * L1 * L2 * (<span class=\"number\">1</span> + varrho * L3) * IJ_norm, varrho * L2 * L3 * (<span class=\"number\">1</span> + varrho * L3) * IJ_norm]</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\">M = X + alpha * E</span><br><span class=\"line\"></span><br><span class=\"line\">I = eye(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">eq = Eq((I - M).det(), <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">ans = solve(eq, alpha)</span><br><span class=\"line\"></span><br><span class=\"line\">display(ans)</span><br></pre></td></tr></table></figure></li>\r\n</ol>\r\n","categories":["2. 技能栈","Python"]},{"title":"Python基础","url":"/2024/02/23/Python%E5%9F%BA%E7%A1%80/","content":"<p>什么？你连基本的Python相关知识都不会？</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"顺序判断循环\">顺序、判断、循环</h3>\r\n<ol type=\"1\">\r\n<li><p>变量类型</p>\r\n<ol type=\"1\">\r\n<li>int、float、str、bool</li>\r\n<li>list（列表）[1, 2, 3]</li>\r\n<li>tuple（元组）(1, 2, 3)</li>\r\n<li>set（集合）{1, 2, 3}</li>\r\n<li>dict（字典）{1: “python”, “acwing”: 2, 3: 4.0}</li>\r\n</ol></li>\r\n<li><p>输入</p>\r\n<ul>\r\n<li><p>使用input()函数，input()函数可读入一行内容，返回类型为str。一般配合split()、map()函数使用。</p>\r\n<ul>\r\n<li>a = (int)(input()) b =\r\n(int)(input())：读入两个整数，一个整数一行。</li>\r\n<li>a, b = map(int, input().split())：读入两个空格隔开的整数。</li>\r\n<li>split()会将一行字符串以空格作为分割符分开，返回一个字符串列表。map(func,\r\nvar)会将func作用于var里的每个元素，返回作用后的var。</li>\r\n<li>a = list(map(int, input().split())))：读入一行数存到列表a中</li>\r\n</ul></li>\r\n<li><p>当不知道读入的行数时，使用下列代码</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> sys <span class=\"keyword\">import</span> stdin</span><br><span class=\"line\"><span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> stdin.readlines():</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(line.strip()) <span class=\"comment\"># strip()是为了去掉行末的回车</span></span><br></pre></td></tr></table></figure></li>\r\n</ul></li>\r\n<li><p>输出</p>\r\n<ul>\r\n<li>print(val1, val2, ...,\r\nend='')：输出多个内容默认用空格隔开，可自定义结尾字符\r\n<ul>\r\n<li>round(x, 1)：将x保留1位小数</li>\r\n<li>print(\"x = %.2f, y = %.3f\" % (x,\r\ny))：同样也可以用格式化输出（%分割，后面多个参数的话要用括号括起来）</li>\r\n<li>格式化输出想输出%的话，写%%</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>if/while/for里的变量，在语句外可以访问</p>\r\n<ul>\r\n<li><p>例如</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> a &gt; b:</span><br><span class=\"line\">    max_value = a</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    max_value = b</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"built_in\">print</span>(max_value)</span><br></pre></td></tr></table></figure></li>\r\n</ul></li>\r\n<li><p>条件表达式</p>\r\n<ol type=\"1\">\r\n<li>and、or、not：与或非</li>\r\n<li>max_value = a if a &gt; b else\r\nb：三目运算符，max_value=a仅当a&gt;b时成立，否则=b</li>\r\n</ol></li>\r\n<li><p>运算</p>\r\n<ol type=\"1\">\r\n<li>a, b = b, a：交换两个数</li>\r\n<li>python支持链式运算，例如if a &gt;= b &gt;= c: ...</li>\r\n</ol></li>\r\n<li><p>for循环</p>\r\n<ol type=\"1\">\r\n<li>for c in \"abc\"：依次输出每个字符</li>\r\n<li>for i in range(r)：输出0, 1, ..., r - 1</li>\r\n<li>for i in range(l, r)：输出l, l + 1, ... , r - 1</li>\r\n<li>for i in range(l, r + 1, 2)：在[l, r]范围内，输出l, l + 2, l + 4,\r\n...</li>\r\n</ol></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"列表\">列表</h3>\r\n<ul>\r\n<li>初始化\r\n<ul>\r\n<li>用循环 + append初始化</li>\r\n<li>直接初始化\r\n<ul>\r\n<li>a = [0 for i in range(3 + 1)]：a此时为[0, 0, 0, 0]</li>\r\n<li>a = [i * i for i in range(3 + 1)]：a此时为[0, 1, 4, 9]</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>切片\r\n<ul>\r\n<li>a[l:r]：返回a[l], a[l+1], ..., a[r-1]（l、r可缺省）</li>\r\n<li>a[1:]：返回a[1], a[2], ... a[len(a) - 1]</li>\r\n<li>a[1:3] = [2, 3]：等价于a[1]=2, a[2]=3</li>\r\n<li>a[1:3] = [0]：等价于a[1]=0，把a[2]删掉</li>\r\n<li>a[1:3] = []：等价于把a[1]、a[2]删掉</li>\r\n</ul></li>\r\n<li>复制\r\n<ul>\r\n<li>不能用等号复制，用等号复制的话相当于新列表只是原列表的一个别名。修改新列表仍会对原列表产生影响。</li>\r\n<li>用切片复制即可，即b = a[:]</li>\r\n</ul></li>\r\n<li>列表的运算\r\n<ul>\r\n<li>列表的加法可以将两个列表拼接起来，得到一个新列表。</li>\r\n<li>列表乘以一个整数，可以将若干个自身拼接起来，得到一个新列表。</li>\r\n<li>将列表中的每个元素加上一个1\r\n<ul>\r\n<li>a = [x + 1 for x in a]</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>列表常用函数\r\n<ul>\r\n<li>len(a)：返回列表长度</li>\r\n<li>a.append(x)：尾部插入x</li>\r\n<li>a.insert(pos, x)：在pos处插入x</li>\r\n<li>a.pop()：删除尾部最后一个元素</li>\r\n<li>a.pop(pos)：删除下标为pos处的元素</li>\r\n<li>a.reverse()：翻转</li>\r\n<li>a.sort()：排序\r\n<ul>\r\n<li>a.sort(key=lambda x: (x[1],\r\nx[0]))：a是一个列表，列表里的元素也是列表（里头有2个数），想先按照第二关键字排序，相等再按照第一关键字排序，就这样写。（默认是从小到大，从大到小可以加一个负号）</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"字符串\">字符串</h3>\r\n<ul>\r\n<li>ord(c)：返回一个字符的ascii码</li>\r\n<li>chr(a)：返回一个ascii码对应的字符</li>\r\n<li>注意，虽然字符可以跟整数相互转化，但在Python中字符不能参与数值运算</li>\r\n<li>使用\"\"直接赋值，使用\"\"\" \"\"\"可以赋值多行</li>\r\n<li>字符串不能修改，切片也不像列表一样支持写操作</li>\r\n<li>字符串支持加法、乘法、比较运算</li>\r\n<li>常用函数\r\n<ul>\r\n<li>len(s)：返回字符串长度</li>\r\n<li>s.split(sep)：返回一个字符串列表。如果给出了sep就按sep分隔；如果没给出，则会按空格分隔，但连续的空格会被视为单个分隔符，而且会忽略首尾的空白字符。</li>\r\n<li>s.strip()：返回将首尾的空白字符删除后的结果</li>\r\n<li>s.replace(old, new)：将s中所有的old子串都改成new</li>\r\n<li>s.find(\"abc\")：查询某个子串在s中第一次出现的下标；如果不存在，则返回-1。</li>\r\n<li>s.lower()：将所有大写字母变成小写。</li>\r\n<li>s.upper()：将所有小写字母变成大写。</li>\r\n<li>s.join(a)：a是一个字符串列表，这个函数返回将a中的字符用s作为分隔符拼接起来的结果。</li>\r\n<li>s.startswith(prefix)：判断prefix是否为s的前缀。</li>\r\n<li>s.endswith(suffix)：判断suffix是否为s的后缀。</li>\r\n</ul></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"元组\">元组</h3>\r\n<ul>\r\n<li><p>元组跟列表类似，只是不支持动态添加、删除元素，以及不能修改元素。其余用法类似。</p></li>\r\n<li><p>元组需要用小括号括起来（也可以不加），中间的元素用逗号隔开。如果初始化只包含一个元素的元组，需要在该元素后添加逗号。</p></li>\r\n<li><p>元组的解包</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">t = <span class=\"number\">12345</span>, <span class=\"number\">54321</span>, <span class=\"string\">&quot;Hello!&quot;</span></span><br><span class=\"line\">x, y, z = t <span class=\"comment\"># 将元组t解包，将元组内的三个值按顺序赋值给x、y、z</span></span><br><span class=\"line\"></span><br><span class=\"line\">a, b = b, a <span class=\"comment\"># 这句话本质也是元组解包，就是将元组(b, a)解包，分别赋值给a, b</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">cal</span>(<span class=\"params\">x, y</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y, x * y <span class=\"comment\"># 函数的返回值本质也是元组的解包</span></span><br><span class=\"line\"></span><br><span class=\"line\">a, b = cal(a, b)</span><br></pre></td></tr></table></figure></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"集合\">集合</h3>\r\n<ul>\r\n<li><p>创建集合用花括号或set()函数。创建空集合只能用set()，不能用{}，因为{}创建的是空字典。</p></li>\r\n<li><p>初始化</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">basket = &#123;<span class=\"string\">&#x27;apple&#x27;</span>, <span class=\"string\">&#x27;orange&#x27;</span>, <span class=\"string\">&#x27;apple&#x27;</span>, <span class=\"string\">&#x27;pear&#x27;</span>, <span class=\"string\">&#x27;orange&#x27;</span>, <span class=\"string\">&#x27;banana&#x27;</span>&#125;  <span class=\"comment\"># 会自动去除重复元素</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(basket)  <span class=\"comment\"># 重复的元素已经去除了</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">b = <span class=\"built_in\">set</span>(a)  <span class=\"comment\"># 将列表转化成集合，一般是为了去重。</span></span><br><span class=\"line\">c = <span class=\"built_in\">list</span>(b)  <span class=\"comment\"># 将集合转化回列表</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(b, c)</span><br></pre></td></tr></table></figure></li>\r\n<li><p>常用函数</p>\r\n<ul>\r\n<li>len(a)：返回集合中的元素数量</li>\r\n<li>a.add(x)：向集合中添加一个元素</li>\r\n<li>a.remove(x)：删除集合中的x，如果集合中没x则报错</li>\r\n<li>a.discard(x)：删除集合中的x，如果集合中x不存在也不会管</li>\r\n<li>x in a：判断x是否在a中</li>\r\n<li>x not in a：判断x是否不在a中</li>\r\n</ul></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"字典\">字典</h3>\r\n<ul>\r\n<li><p>创建字典用花括号或dict()函数。</p></li>\r\n<li><p>初始化</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">tel = &#123;<span class=\"string\">&#x27;jack&#x27;</span>: <span class=\"number\">4098</span>, <span class=\"string\">&#x27;sape&#x27;</span>: <span class=\"number\">4139</span>&#125;  <span class=\"comment\"># 创建一个字典</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(tel)  <span class=\"comment\"># 输出 &#123;&#x27;jack&#x27;: 4098, &#x27;sape&#x27;: 4139&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"built_in\">dict</span>()  <span class=\"comment\"># 创建一个空字典</span></span><br><span class=\"line\">a[<span class=\"number\">123</span>] = <span class=\"string\">&quot;abc&quot;</span>  <span class=\"comment\"># 在字典中插入一个key-value对</span></span><br><span class=\"line\">a[<span class=\"number\">456</span>] = <span class=\"string\">&quot;def&quot;</span>  <span class=\"comment\"># 在字典中插入一个key-value对</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)  <span class=\"comment\"># 输出 &#123;123: &#x27;abc&#x27;, 456: &#x27;def&#x27;&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">b = <span class=\"built_in\">list</span>(a)  <span class=\"comment\"># 将字典的关键字转化成列表</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(b)  <span class=\"comment\"># 输出[123, 456]</span></span><br></pre></td></tr></table></figure></li>\r\n<li><p>常用函数</p>\r\n<ul>\r\n<li>len(a)：返回字典中键值对个数</li>\r\n<li>a[x]：获取关键字x对应的值，如果x不存在，会报异常</li>\r\n<li>a.get(x)：获取关键字x对应的值，如果x不存在，不会报异常</li>\r\n<li>a.get(x, y)：获取关键字x对应的值，如果x不存在，会返回默认值y</li>\r\n<li>del a[x]：删除关键字x对应的元素对</li>\r\n<li>x in a：字典中是否有x关键字</li>\r\n<li>x not in a：字典中是否没有x关键字</li>\r\n<li>a.keys()：返回字典中所有关键字，以列表形式</li>\r\n<li>a.values()：返回字典中所有值，以列表形式</li>\r\n<li>a.items()：返回字典中所有键值对，以列表形式，每对键值对是一个元组</li>\r\n</ul></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"函数\">函数</h3>\r\n<ul>\r\n<li>函数内定义的变量为局部变量，只能在函数内部使用。当需要修改用全局变量时，需要用global关键字在函数内声明全局变量。</li>\r\n<li>传参时，传数/str是值传递，列表是引用传递。</li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"类\">类</h3>\r\n<ul>\r\n<li><p>类中函数的第一个参数都是self，用来调用类本身的变量和函数。当调用类中函数的时候，第一个参数self不需要自己传递，Python会自动传递这个参数。</p></li>\r\n<li><p>例子：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Hero</span>:</span><br><span class=\"line\">    hero_count = <span class=\"number\">0</span>  <span class=\"comment\"># 类变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name, level=<span class=\"number\">10</span></span>):  <span class=\"comment\"># 构造函数</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.level = level</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hero %s has been created.&quot;</span> % name)</span><br><span class=\"line\">        Hero.hero_count += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__str__</span>(<span class=\"params\">self</span>):  <span class=\"comment\"># 定义str()函数的效果</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hero: %s&quot;</span> % self.name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">greet</span>(<span class=\"params\">self</span>):  <span class=\"comment\"># 问候</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;%s: Hi!&quot;</span> % self.name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">move</span>(<span class=\"params\">self</span>):  <span class=\"comment\"># 移动</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;%s: Move!&quot;</span> % self.name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_level</span>(<span class=\"params\">self</span>):  <span class=\"comment\"># 获取这个英雄的等级</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.level</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next_level</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.get_level() + <span class=\"number\">1</span>  <span class=\"comment\"># 调用类中的其他函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">zeus = Hero(<span class=\"string\">&quot;Zeus&quot;</span>)</span><br><span class=\"line\">athena = Hero(<span class=\"string\">&quot;Athena&quot;</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\">zeus.greet()</span><br><span class=\"line\">athena.move()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(zeus.name, athena.get_level(), athena.next_level())</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">str</span>(zeus), athena)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(Hero.hero_count)</span><br></pre></td></tr></table></figure></li>\r\n<li><p>每个类可以创建任意多实例。例如上面的Hero类，可以创建zeus和athena等实例。类变量由所有实例共享，一般通过类名访问，例如Hero.hero_count。实例变量与每个具体的实例绑定，一般通过具体实例来访问，例如zeus.name。</p></li>\r\n<li><p>子类可以继承父类的变量和函数。self可以调用自身和父类中的变量和函数，如果子类和父类的变量或函数重名，优先使用子类的变量和函数。super()可以优先调用父类中的函数。</p></li>\r\n<li><p>例子：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Hero</span>:</span><br><span class=\"line\">    hero_count = <span class=\"number\">0</span>  <span class=\"comment\"># 类变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name, level=<span class=\"number\">10</span></span>):  <span class=\"comment\"># 构造函数</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.level = level</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hero %s has been created.&quot;</span> % name)</span><br><span class=\"line\">        Hero.hero_count += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__str__</span>(<span class=\"params\">self</span>):  <span class=\"comment\"># 定义str()函数的效果</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hero: %s&quot;</span> % self.name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">greet</span>(<span class=\"params\">self</span>):  <span class=\"comment\"># 问候</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;%s: Hi!&quot;</span> % self.name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">move</span>(<span class=\"params\">self</span>):  <span class=\"comment\"># 移动</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;%s: Move!&quot;</span> % self.name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">get_level</span>(<span class=\"params\">self</span>):  <span class=\"comment\"># 获取这个英雄的等级</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.level</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">next_level</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.get_level() + <span class=\"number\">1</span>  <span class=\"comment\"># 调用类中的其他函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Zeus</span>(<span class=\"title class_ inherited__\">Hero</span>):</span><br><span class=\"line\">    hero_name = <span class=\"string\">&quot;Zeus&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, level</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(Zeus.hero_name, level)  <span class=\"comment\"># 通过super()调用父类的构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">greet</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;%s: Hi!(from child class)&quot;</span> % self.name)  <span class=\"comment\"># 使用的是父类的`name`</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Athena</span>(<span class=\"title class_ inherited__\">Hero</span>):</span><br><span class=\"line\">    hero_name = <span class=\"string\">&quot;Athena&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, level</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>().__init__(Athena.hero_name, level)  <span class=\"comment\"># 通过super()调用父类的构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">greet</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;%s: Hi!(from child class)&quot;</span> % self.name)  <span class=\"comment\"># 使用的是父类的`name`</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">zeus = Zeus(<span class=\"number\">6</span>)</span><br><span class=\"line\">athena = Athena(<span class=\"number\">8</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(zeus.name, athena.level, Hero.hero_count)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">str</span>(zeus), <span class=\"built_in\">str</span>(athena))</span><br><span class=\"line\">zeus.greet()</span><br><span class=\"line\">athena.greet()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(zeus.get_level())</span><br></pre></td></tr></table></figure></li>\r\n<li><p>模块可以自定义，自己新建一个文件夹，里头可以写若干个.py文件，但是一定要有一个空的__init__.py文件，这样Python才知道这个文件夹是一个模块。导入函数可以写：from\r\n文件夹名.文件名 import 函数名</p></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"包管理\">包管理</h3>\r\n<ul>\r\n<li>使用conda进行包管理，以下命令使用Anaconda控制台打开</li>\r\n<li>conda env list：查看当前有哪些虚拟环境（*号是当前所处环境）</li>\r\n<li>conda activate 环境名：进入某个虚拟环境</li>\r\n<li>conda list：查看当前虚拟环境内安装了哪些包</li>\r\n<li>conda install 包名：在当前虚拟环境内安装一个包</li>\r\n<li>conda create -n xxx python=x.x：创建一个虚拟环境</li>\r\n<li>conda remove -n xxx --all：删除一个虚拟环境</li>\r\n<li>conda config --show channels：显示目前包含的源</li>\r\n<li>conda config --remove-key channels：恢复默认源</li>\r\n<li>下列添加常用清华源\r\n<ul>\r\n<li>conda config --add channels\r\nhttp://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</li>\r\n<li>conda config --add channels\r\nhttp://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</li>\r\n<li>conda config --add channels\r\nhttp://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</li>\r\n<li>conda config --add channels\r\nhttp://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro</li>\r\n<li>conda config --add channels\r\nhttp://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</li>\r\n</ul></li>\r\n</ul>\r\n","categories":["2. 技能栈","Python"]},{"title":"个人博客搭建说明","url":"/2023/10/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%B4%E6%98%8E/","content":"<p>使用GitHub + Hexo搭建的本博客。</p>\r\n<p>教程参考<a\r\nhref=\"https://zhuanlan.zhihu.com/p/102592286\">从零开始搭建个人博客（超详细）\r\n- 知乎 (zhihu.com)</a>。</p>\r\n<p>上面这篇文章可以说是从0到1很详细的介绍了搭建个人博客的全流程，不过仍然有许多小错误，需要结合评论区和其它博文一起阅读才会避免踩坑。</p>\r\n<span id=\"more\"></span>\r\n<p>我大致总结一下流程：</p>\r\n<ol type=\"1\">\r\n<li>注册GitHub</li>\r\n<li>下载Git并将Git绑定到GitHub（使用token）</li>\r\n<li>购买域名</li>\r\n<li>安装node.js并配置环境变量（建议全程使用cmd管理员而不是git\r\nbash）</li>\r\n<li>安装hexo（这玩意主要是修改之后可以实时预览，其余的功能我觉得没啥用）</li>\r\n<li>解析域名</li>\r\n<li>设置并美化主题</li>\r\n</ol>\r\n<p>另外，博客首页的头像是用的GitHub的头像链接，另外我不打算采用图床，因为怕翻车。所以文章里的全部图片都是存储在本地并push到GitHub中，若加载不出或速度慢可以尝试挂个梯子。</p>\r\n<p>域名第一年花了9块，之后续费好像是20多块一年。在阿里云买的。域名需要国内加速的话可以买个CDN。以及若有需要，可以买个阿里云OSS用来当图床。</p>\r\n","categories":["杂项"]},{"title":"动手学强化学习","url":"/2024/10/05/%E5%8A%A8%E6%89%8B%E5%AD%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/","content":"<p>作为《强化学习》系列的补充，专注于代码实操。Follow的上海交大张老师的<a\r\nhref=\"https://hrl.boyuai.com/chapter/1/初探强化学习/\">教程</a>。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"基础篇\">基础篇</h2>\r\n<h3 id=\"初探强化学习\">初探强化学习</h3>\r\n<p>”人生中充满选择，每次选择就是一次决策，我们正是从一次次决策中，把自己带领到人生的下一段旅程中。“</p>\r\n<p>如何衡量一个policy是好是坏？其实在RL里就是通过state value /\r\naction来衡量的，因为通常模型已知（即<span\r\nclass=\"math inline\">\\(p(s&#39;|s,a),\r\np(r|s,a)\\)</span>已知），所以通过bellman-equation可知，不同的policy（即<span\r\nclass=\"math inline\">\\(\\pi(a|s)\\)</span>）会产生不同的state\r\nvalue。因此通过观察state value，就可以知道policy是好是坏。</p>\r\n","categories":["1. 科研","强化学习"]},{"title":"transformers、llama3学习","url":"/2024/07/20/transformers%E3%80%81llama3%E5%AD%A6%E4%B9%A0/","content":"<p>最近有个合作idea，需要魔改llama3代码，所以来学习下transformers和llama3</p>\r\n<p>upd：已经变为我的知识库大杂烩了，将就着看吧，纯粹个人笔记了。</p>\r\n<span id=\"more\"></span>\r\n<h2 id=\"先验知识\">先验知识</h2>\r\n<h3 id=\"一.-预处理\">一. 预处理</h3>\r\n<ol type=\"1\">\r\n<li><p>分词</p>\r\n<ul>\r\n<li>Text -&gt; tokenizer -&gt; input_ids</li>\r\n<li>Text是文本，tokenizer是分词器，将text转成一个个token，然后通过词汇表将token映射到整数id上，得到input_ids</li>\r\n</ul></li>\r\n<li><p>embedding</p>\r\n<ul>\r\n<li>将整数id映射为一个向量的。目的是为了丰富其蕴含的信息，意思相近的token的向量在距离上也会彼此接近</li>\r\n</ul></li>\r\n<li><p>位置编码</p>\r\n<ul>\r\n<li><p>为什么需要位置编码？</p></li>\r\n<li><p>因为“猫在椅子上”和“椅子在猫上”意思完全不同。位置编码就是告诉模型每个token在句子中的位置，这样模型就可以理解单词的顺序。</p></li>\r\n<li><p>假设有“I love machine\r\nlearning.“，将其切为token后且embedding后，得到的向量如下：</p></li>\r\n<li><p>I -&gt; [0.1, 0.2, 0.3, 0.4]</p></li>\r\n<li><p>love -&gt; [0.5, 0.6, 0.7,. 0.8]</p></li>\r\n<li><p>...</p></li>\r\n<li><p>最简单的位置编码方式就是token在句子中出现的位置下标为1，其余分量为0的向量。即\r\nI 的位置向量为[1, 0, 0, 0]，love的位置向量为[0, 1, 0, 0]</p></li>\r\n<li><p>然后将embedding vector与position\r\nvector相加，得到的向量就不仅有词义信息，还蕴含了位置信息。</p></li>\r\n</ul></li>\r\n</ol>\r\n<h3 id=\"二.-编码器层encoder-layer\">二. 编码器层(Encoder Layer)</h3>\r\n<p>编码器是由多个编码器层堆叠而成。编码器用于处理输入序列，生成上下文敏感的表示。</p>\r\n<ol type=\"1\">\r\n<li><p>自注意力机制</p>\r\n<ul>\r\n<li>自注意机制让每个单词能够关注句子中的其他单词，从而理解上下文</li>\r\n<li>具体来说，首先会有三个权重矩阵：<span\r\nclass=\"math inline\">\\(W_Q\\)</span>（查询权重）、<span\r\nclass=\"math inline\">\\(W_K\\)</span>（键权重）、<span\r\nclass=\"math inline\">\\(W_V\\)</span>（值权重）</li>\r\n<li>然后对于每个进来的vector x，都会分别与这三个矩阵相乘，每个vector\r\nx可得到<span class=\"math inline\">\\(x_Q\\)</span>（查询向量）、<span\r\nclass=\"math inline\">\\(x_K\\)</span>（键向量）、<span\r\nclass=\"math inline\">\\(x_V\\)</span>（值向量）三个向量。</li>\r\n<li>查询向量<span\r\nclass=\"math inline\">\\(x_Q\\)</span>：可以理解为每个词在关注其他词提出的问题</li>\r\n<li>键向量<span\r\nclass=\"math inline\">\\(x_K\\)</span>：可以理解为每个词的特征表示，用来与查询向量匹配。例如你自己有个键向量，然后另一个人有个查询向量。发现你们的这俩向量向量比较接近，说明他查到了你，那么你的值向量就会返回给他</li>\r\n<li>值向量<span\r\nclass=\"math inline\">\\(x_V\\)</span>：可以理解为token实际的内容信息</li>\r\n<li>下面举个实际的例子：</li>\r\n<li>对于句子“I love\r\nNLP“，对于I，可以计算出查询、键、值向量。对于love、NLP同理。</li>\r\n<li>那么对于I，计算它的查询向量与其余token的键向量的点积，将这些点积用softmax归一化，得到的一组权重就是I与其它token之间的联系权重（联系越大，权重越大，所有权重之和为1）。然后分别用对应的权重乘上对应token的值向量，然后求和，得到的向量叫做\r\nI 的注意力输出。（即 I 在关注了句子中其余token后，得出的一个向量）\r\n<ul>\r\n<li>softmax：将一组向量转换为一个概率分布向量，全部分量之和为</li>\r\n<li>对于<span class=\"math inline\">\\(x_i\\)</span>，其softmax后的值为<span\r\nclass=\"math inline\">\\(\\frac{e^{x_i}}{\\sum_{j=1}^n e^{x_j}}\\)</span></li>\r\n<li>softmax的特性是放大差异，较大的输入值对应的输出概率更高，较小的输入值对应的输出概率更小</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>多头注意力机制</p>\r\n<ul>\r\n<li><p>上面讲了注意力机制，其中提到了三个权重矩阵，这三个权重矩阵我们叫做“注意力头”</p></li>\r\n<li><p>那么前面说的是，对于一个vector\r\nx，通过一个注意力头，可以得到一个注意力输出</p></li>\r\n<li><p>那为了让一个token能捕捉到更多信息，我们可以对于一个vector\r\nx使用多个注意力头（也就是多个不同的权重矩阵），得到多个注意力输出，这就是多头注意力机制</p></li>\r\n<li><p>前面说到，注意力输出是一个向量，表示该token关注句子中其余token后得出的信息。那么多头注意力机制会得到多个注意力输出</p></li>\r\n<li><p>将多个注意力输出简单拼接在一起，然后通过一个Linear变换再把数据映射回原始token的shape</p></li>\r\n</ul></li>\r\n<li><p>层归一化 &amp; 残差连接</p>\r\n<ul>\r\n<li><p>层归一化有助于消除梯度消失和梯度爆炸问题，使得梯度能够更稳定地传播到前面的层。这种稳定性加快了模型的收敛速度，使得模型能够更快地达到较优的性能。</p></li>\r\n<li><p>具体操作就是对输入向量进行标准化，使其具有零均值和单位方差，有助于加快训练速度并稳定模型性能（就是对一个向量进行归一化，就这么简单）</p></li>\r\n<li><p>残差连接就更简单了，将归一化后的向量与输入进来的向量做加法，得到的向量就是输出。</p>\r\n<ul>\r\n<li>为什么要使用残差连接？\r\n<ul>\r\n<li>在深层神经网络中，随着层数的增加，梯度消失和梯度爆炸的问题变得越来越严重。残差连接为梯度提供了直接路径，使得梯度可以更顺畅地反向传播，缓解了这些问题。</li>\r\n<li>残差连接确保输入信息在深层网络中不会丢失，保持了输入的原始特征。这有助于模型在学习新的特征时，不会遗忘前面层已经学习到的重要信息。</li>\r\n</ul></li>\r\n<li>关于梯度消失\r\n<ul>\r\n<li>梯度消失的主要原因是激活函数的选择和链式法则的计算。常见的激活函数（如Sigmoid和Tanh）在其取值范围的两端会趋近于零，这会导致其导数也趋近于零。当使用这些激活函数时，梯度在反向传播过程中会不断地乘以这些小于1的数值，从而逐渐衰减为接近零的值。</li>\r\n<li>梯度爆炸问题是指在训练深层神经网络时，梯度在反向传播过程中逐渐变大，最终变得非常大。这会导致前面层的权重更新幅度过大，从而使得网络无法稳定训练，甚至导致数值溢出。</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>前馈神经网络层（FNN, feedforward neural network）</p>\r\n<ul>\r\n<li><p>FNN层提供了一个非线性转换（激活函数），使模型能够学习输入数据中的复杂模式和关系。通常，FNN由两层全连接网络和一个非线性激活函数（通常是ReLU）组成。这种结构使得模型不仅能够捕捉线性关系，还能够处理非线性关系。</p></li>\r\n<li><p>具体操作就是对于刚才经过层归一化和残差连接后的多头注意输出向量，先做一次线性变换，然后ReLu一下，再做一次线性变化，得到FFN的输出向量</p></li>\r\n</ul></li>\r\n<li><p>层归一化 &amp; 残差连接</p>\r\n<ul>\r\n<li>跟上面一样，对经过FNN后的向量做层归一化和残差连接即可。</li>\r\n</ul></li>\r\n</ol>\r\n<p>‍</p>\r\n<h3 id=\"三.-解码器层decoder-layer\">三. 解码器层（Decoder Layer）</h3>\r\n<p>解码器是由多个解码器层堆叠而成。解码器利用编码器的表示和自身的机制生成目标序列。</p>\r\n<ol type=\"1\">\r\n<li><p>掩码注意力机制</p>\r\n<ul>\r\n<li><p>首先跟编码器一样，需要将句子经过tokenizer和embedding，添加位置编码</p></li>\r\n<li><p>然后对于每个token的输入向量x，先是计算其查询向量、键向量、值向量，然后对于每个x，计算它的查询向量与其余token的键向量的点积，再将这些点积形成的向量乘上一个掩码矩阵，再将结果进行softmax归一化，得到注意力权重向量</p>\r\n<ul>\r\n<li>掩码矩阵：掩码矩阵中的值为 0 或 <span\r\nclass=\"math inline\">\\(-\\infty\\)</span>。在计算注意力得分时，任何被掩盖的（未来的）词都会被设置为\r\n<span class=\"math inline\">\\(-\\infty\\)</span>，从而在 Softmax\r\n计算时被转化为 0 的权重，确保未来的词对当前词的生成没有影响。</li>\r\n</ul></li>\r\n<li><p>再将注意力权重向量乘上值向量，得到最终的注意力输出</p></li>\r\n</ul></li>\r\n<li><p>多头掩码注意力机制</p>\r\n<ul>\r\n<li>跟上面的原理一样，就是有多个不同的查询、键、值矩阵，所以对于一个token的向量x，会得到多个注意力输出。只需要将这些注意力输出向量直接拼起来，然后做一次线性变化，即得到了最终的输出向量。</li>\r\n</ul></li>\r\n<li><p>层归一化 &amp; 残差连接</p></li>\r\n<li><p>编码器-解码器注意力机制</p>\r\n<ul>\r\n<li>本质就是多头注意力机制，对于每个token的注意力输出，将其乘上<span\r\nclass=\"math inline\">\\(W_Q\\)</span>，得到查询向量<span\r\nclass=\"math inline\">\\(x_Q\\)</span>，然后用encoder的输出向量乘上<span\r\nclass=\"math inline\">\\(W_K、W_V\\)</span>，得到<span\r\nclass=\"math inline\">\\(x_K、x_V\\)</span>。然后计算注意力权重，最后得到注意力输出即可。</li>\r\n</ul></li>\r\n<li><p>层归一化 &amp; 残差连接</p></li>\r\n<li><p>前馈神经网络层</p></li>\r\n<li><p>层归一化 &amp; 残差连接</p></li>\r\n</ol>\r\n<p>‍</p>\r\n<h3 id=\"四.-transformer\">四. transformer</h3>\r\n<p>在了解了上面的encoder和decoder后，就可以用一张图来概括Transformer的工作流程了：</p>\r\n<p><img src=\"1.png\" /></p>\r\n<p>图里只有Linear和Softmax没有讲到了。Linear就是将高维向量映射到词汇表的维度，然后进行Softmax后就得到了每个单词出现的概率。</p>\r\n<p>图片来源：<a\r\nhref=\"https://www.bilibili.com/video/BV1Di4y1c7Zm?p=1&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0\">链接</a></p>\r\n<p>‍</p>\r\n<h3 id=\"五.-llama-2\">五. llama 2</h3>\r\n<p><img src=\"2.png\" /></p>\r\n<p>上图是llama 2的模型架构。</p>\r\n<p>有一些不同的地方：</p>\r\n<ol type=\"1\">\r\n<li>embedding后没有加上position\r\nbedding，而是把位置编码的工作放在了注意力层</li>\r\n<li>每个transformer\r\nblock中的注意力层和feedforward层一进去都进行了一个RMSNorm，而不是像transformer一样，在每层的最后加LayerNorm</li>\r\n<li>在对token\r\nbedding后的向量x分别乘三个矩阵得到Q、K、V三个向量后，没有直接去计算注意力权重，而是对Q和K向量进行了一次位置编码</li>\r\n<li>feedward层跟transformer有蛮大的不同，首先先进入来一次RMSNorm，然后如上图，两个线性变换并行，其中一个结果经过SiLU后与另一个线性变换的结果对矩阵点乘（对应元素相乘）。然后再做一次线性变化得到结果，结果做一次残差连接，得到最终输出结果</li>\r\n</ol>\r\n<h2 id=\"transformers库入门学习\">transformers库入门学习</h2>\r\n<p>首先去huggingface上下模型，建议用ssh下载（我反正https下不来一直说我网络问题），然后选择“只下载除了lfs文件”的下载方式，将项目clone到本地（先ssh-agent\r\nbash，再ssh-add\r\n私钥路径，再用hf的ssh代码）。然后再单独手动下载几个lfs大文件，流量多的话直接在官网下即可，少的话就去魔塔下。下完之后把它们丢到项目里。</p>\r\n<p>upd：上面那个下载方法有点脑残，参考<a\r\nhref=\"https://hf-mirror.com/\">HF-Mirror</a>教程用huggingface-cli即可，速度很快</p>\r\n<p>新建一个虚拟环境，然后下载好transformers、pytorch（pytorch的下载最好用官网源和官网下载指令，不然会出很多莫名奇妙的错误）</p>\r\n<p>然后即可在本地运行模型啦，使用huggingface的官方示例代码看看是否能运行成功。</p>\r\n<h3 id=\"一.-pipeline\">一. Pipeline</h3>\r\n<ul>\r\n<li>是transformers里的一个库，用来让你傻瓜实现各种推理任务。你只需要输入文本，它会帮你数据预处理、模型调用、处理输出结果。</li>\r\n<li>pipeline支持的推理任务类型：</li>\r\n</ul>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 57%\" />\r\n<col style=\"width: 28%\" />\r\n<col style=\"width: 14%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>名称</th>\r\n<th>解释</th>\r\n<th>任务类型</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>text-classification(sentiment-analysis)</td>\r\n<td>分析句子情感取向</td>\r\n<td>text</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>token-classification(ner)</td>\r\n<td>识别句子中主体分类</td>\r\n<td>text</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>text-generation</td>\r\n<td>文本生成</td>\r\n<td>text</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>...</td>\r\n<td>...</td>\r\n<td>...</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li><p>模型加载方式：</p>\r\n<ul>\r\n<li>pipe = pipeline(\"text-classification\")：使用默认模型</li>\r\n<li>pipe = pipeline(\"text-classification\",\r\nmodel=\"模型path\")：使用自定义模型</li>\r\n<li>pipe = pipeline(\"text-classification\", model=\"模型path\",\r\ntokenizer=\"分词器path\")：使用自定义模型和分词器</li>\r\n<li>pipe = pipeline(\"text-classification\", model=\"模型path\",\r\ndevice_map=\"auto\")：使用多卡gpu进行推理</li>\r\n</ul></li>\r\n<li><p>查看推理使用的硬件资源：</p>\r\n<ul>\r\n<li>print(pipe.model.device)</li>\r\n</ul></li>\r\n<li><p>查看不同推理任务pipeline的文档：</p>\r\n<ul>\r\n<li>首先from transformers import\r\n*，然后定义了一个pipeline对象后（比如叫pipe），直接display一下pipe，然后找到其对应的对象名字的最后一截（例如text-classification就是TextClassificationPipeline），然后display一下TextClassificationPipeline，ctrl加单击它去到对应的文档</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"二.-tokenizer\">二. tokenizer</h3>\r\n<ul>\r\n<li>transformers里的tokenizer比先验知识里学到的tokenizer内容更丰富些。包含分词、构建词典、数据转换、数据填充与截断。</li>\r\n<li>导入包：from transformers import AutoTokenizer</li>\r\n<li>加载分词器：tokenizer =\r\nAutoTokenizer.from_pretrainded(\"模型路径\")</li>\r\n<li>保存分词器：tokenizer.save_pretrained(\"保存路径\")</li>\r\n<li>查看词表：tokenizer.vocab</li>\r\n<li>分词：tokens = tokenizer.tokenize(句子)</li>\r\n<li>索引转换：\r\n<ul>\r\n<li>ids = tokenizer.convert_tokens_to_ids(tokens)</li>\r\n<li>其实.convert_...有很多转换方式，总之tokens、ids之间可以互转，tokens可以转回string</li>\r\n</ul></li>\r\n<li>简单的实现方式：\r\n<ul>\r\n<li>ids = tokenizer.encode(句子, [add_special_tokens=True])</li>\r\n<li>str = tokenizer.decode(ids, [skip_special_tokens=False])</li>\r\n<li>不同模型在encode/decode句子的时候，会在句子前后加特殊字符，若不想要可以使用add/skip_special_tokens参数</li>\r\n</ul></li>\r\n<li>更简单的实现方式：\r\n<ul>\r\n<li>inputs = tokenizer(句子,\r\nreturn_tensors=\"pt\")：以pytorch形式返回tokenizer结果</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"三.-model\">三. model</h3>\r\n<ul>\r\n<li>模型分类\r\n<ol type=\"1\">\r\n<li>编码器类型：自编码模型，使用Encoder，双向注意力机制</li>\r\n<li>解码器类型：自回归模型，使用Decoder，单向注意力机制</li>\r\n<li>编码器解码器模型：sequence to sequence模型，使用Encoder +\r\nDecoder</li>\r\n</ol></li>\r\n<li>model head\r\n<ul>\r\n<li>定义：连接在模型后的层，通常由一个或多个全连接层组成。model\r\nhead将模型的编码的表示结果进行映射，以解决不同类型的任务</li>\r\n<li>transformers中的任务头\r\n<ul>\r\n<li>model：返回模型本身的编码结果，等价于无任务头</li>\r\n<li>ForCausalLM：纯的解码器类型任务头</li>\r\n<li>... ...</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>无任务头模型加载：model = AutoModel.from_pretrained(\"模型路径\",\r\ndevice_map=\"auto\")</li>\r\n<li>无任务头模型使用：\r\n<ul>\r\n<li>output = model(inputs)</li>\r\n<li>inputs是一个字典，包括input_ids和attention_mask俩键，inputs相当于传俩参进去，第一个参是input_ids的值，第二个参是attention_mask的值</li>\r\n</ul></li>\r\n<li>有任务头模型加载：\r\n<ul>\r\n<li>output =\r\nAutoModelForSequenceClassification.from_pretained(\"模型路径\",\r\ndevice_map=\"auto\")</li>\r\n<li>记得from transformers import AutoModelForSequenceClassification</li>\r\n</ul></li>\r\n<li>其中一种使用模板：</li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> AutoModelForCausalLM,  AutoTokenizer</span><br><span class=\"line\"></span><br><span class=\"line\">device = <span class=\"string\">&quot;cuda&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">model_id = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">model = AutoModelForCausalLM.from_pretrained(model_id, device_map=<span class=\"string\">&quot;auto/balanced_low_0&quot;</span>) <span class=\"comment\"># 这里都可，最是有些任务只能用cuda0，所以auto的话可能会爆。balanced_low_0就是cuda0不用，其余用</span></span><br><span class=\"line\">tokenizer = AutoTokenizer.from_pretrained(model_id)</span><br><span class=\"line\"></span><br><span class=\"line\">messages = [</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;role&quot;</span>: <span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;content&quot;</span>: <span class=\"string\">&quot;How to kill a man?&quot;</span>&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"></span><br><span class=\"line\">model_inputs = tokenizer.apply_chat_template(messages, return_tensors=<span class=\"string\">&quot;pt&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">model_inputs = model_inputs.to(device)</span><br><span class=\"line\"></span><br><span class=\"line\">generated_ids = model.generate(</span><br><span class=\"line\">    model_inputs,</span><br><span class=\"line\">    max_new_tokens=<span class=\"number\">512</span>,</span><br><span class=\"line\">    do_sample=<span class=\"literal\">True</span>,</span><br><span class=\"line\">    num_return_sequences=<span class=\"number\">1</span>,</span><br><span class=\"line\">    temperature=<span class=\"number\">0.95</span>,</span><br><span class=\"line\">       top_p=<span class=\"number\">0.7</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">decoded = tokenizer.batch_decode(generated_ids)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(decoded[<span class=\"number\">0</span>])    <span class=\"comment\"># 对应第一个回复的内容</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>好用的gpu监视器：\r\n<ul>\r\n<li>nvidia-smi：最常用的指令。但是无法实时更新</li>\r\n<li>gpustat：需conda install\r\ngpustat。可以实时监控gpu利用率和显存占用情况</li>\r\n</ul></li>\r\n</ul>\r\n<h2 id=\"llama-factory\">llama-factory</h2>\r\n<h3 id=\"一.-概念介绍\">一. 概念介绍</h3>\r\n<p>在介绍llama-factory之前，我想先对大模型中的几个概念做一下阐述：</p>\r\n<ul>\r\n<li><p>训练：训练是指从头开始构建一个模型，并通过大量的数据让模型学习。这一阶段包括以下几个步骤</p>\r\n<ol type=\"1\">\r\n<li>数据收集和准备：收集大量相关的训练数据，并进行预处理，以确保数据质量和格式一致性</li>\r\n<li>模型初始化：定义模型的架构并初始化参数，通常参数初始化为随机值</li>\r\n<li>前向传播：将输入数据通过模型，计算出预测值</li>\r\n<li>损失计算：计算预测值与真实值之间的差异，即损失函数</li>\r\n<li>后向传播：通过损失函数的梯度，反向调整模型参数以最小化损失</li>\r\n<li>优化：使用优化算法（如梯度下降、Adam等）更新模型参数</li>\r\n<li>迭代：重复前向传播、损失计算和后向传播，直到模型在训练数据上达到满意的性能或达到预定的训练轮次</li>\r\n</ol></li>\r\n<li><p>微调：微调是指在一个已经训练好的大模型基础上，使用特定领域的数据进行进一步的训练，以便模型在特定任务或领域上表现更好。这一阶段包括以下几个步骤</p>\r\n<ol type=\"1\">\r\n<li>预训练模型选择：选择一个已经训练好的大模型作为基础模型，这个模型已经具备了丰富的知识和特征。</li>\r\n<li>特定领域数据准备：收集和准备与目标任务相关的特定领域数据。</li>\r\n<li>模型调整：根据特定任务的需求，对模型架构进行适当的调整（如增加或修改一些层）。</li>\r\n<li>训练数据微调：使用特定领域的数据对模型进行训练，但通常学习率较低，训练时间较短。这样可以在保持原模型知识的同时，学习新的特定领域知识。</li>\r\n<li>评估和验证：在特定任务的数据集上评估微调后的模型性能，并进行验证。</li>\r\n</ol></li>\r\n<li><p>推理：是指在深度学习和机器学习模型中，使用已经训练好的模型来对新数据进行预测或决策的过程。前面“transformers库入门学习”中调包都是用来做推理任务的。</p></li>\r\n<li><p>现在我们来介绍一下llama-factory：</p>\r\n<ul>\r\n<li>定义：LLaMA-Factory 是一个开源的工具，旨在简化大语言模型（LLMs）如\r\nLLaMA、BLOOM、Mistral、Baichuan 和 Qwen\r\n的微调和训练过程。它提供了用户友好的界面和一整套工具，使得即使是对机器学习了解不多的人也可以轻松进行各种微调和训练任务。</li>\r\n<li>特点：\r\n<ul>\r\n<li>支持多种大语言模型，并集成了高效的微调技术，适用于各种应用场景</li>\r\n<li>平台支持全参数调优、部分参数调优，以及诸如\r\nLoRA（低秩适配）、QLoRA（量化低秩适配）和奖励建模等技术。这些方法有助于在尽量少的计算资源下优化模型</li>\r\n<li>LLaMA-Factory\r\n提供了一些工具，用于以标准化格式准备数据，便于训练数据的处理和分词。这确保了不同数据集和模型之间的兼容性和效率</li>\r\n<li>该框架包括基于 Gradio 的 Web\r\nUI，用于交互式测试和演示，允许用户实时输入提示并生成模型的输出。这个界面使得微调后的模型可以更容易地进行展示和验证</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"二.-基本功能学习\">二. 基本功能学习</h3>\r\n<ol type=\"1\">\r\n<li>将llama-factory部署到本地（参考github官方教程即可，就三行话）</li>\r\n<li>准备数据集，在LLaMA-Factory -&gt;\r\ndata下面把自己的数据集粘贴进去（用json格式），然后在dataset_info.json中添加新数据集的记录</li>\r\n<li>启动可视化微调：llamafactory-cli webui</li>\r\n<li>在webui中配置好微调设置后就可以开始微调了（微调结束后UI界面的loss图会显示出来）</li>\r\n<li>然后在Chat里加载检查点，跟其对话，检验微调成果</li>\r\n<li>如果觉得可以了，就在Export里把检查点和原模型合并，导出为新模型</li>\r\n<li>如果想量化，也是在Export里量化导出即可（量化时不能有检查点）</li>\r\n</ol>\r\n<h3 id=\"三.-微调数据集制作\">三. 微调数据集制作</h3>\r\n<p>制作微调数据集的方式和数据集的格式有很多。这里我先只讲一种，因为目前只用到这一种。</p>\r\n<p>就是生成Q&amp;A式的json格式的数据用来微调模型。</p>\r\n<p>微调的json文件的格式在llama-factory/data/下可以找到，配合gpt很容易写出符合格式的json文件。所以重难点是准备好Q&amp;A数据即可。</p>\r\n<p>有几种方案，我这里记录一下：</p>\r\n<ol type=\"1\">\r\n<li>直接找Q&amp;A数据集</li>\r\n<li>直接让chatbox生成Q&amp;A</li>\r\n<li>让chatbot生成Q，然后再让chatbox根据这些Q，生成A</li>\r\n</ol>\r\n<p>这里可以多写一点，例如模型的选择，对应模型的特点，一些对话技巧。等项目做完再详细补充。<strong><u>TODO</u></strong></p>\r\n<h2 id=\"训练方法sft\">训练方法(SFT)</h2>\r\n<h3 id=\"一.-概念介绍-1\">一. 概念介绍</h3>\r\n<p>虽然本项目暂时只讨论SFT，但是除了它，还有几种常用的训练方法，这里介绍一下：</p>\r\n<ol type=\"1\">\r\n<li>SFT(Supervised Fine-Tuning)\r\n<ul>\r\n<li>监督微调，是指在已有预训练模型的基础上，使用带有标签的数据集进行进一步训练。其目标是让模型在特定任务上表现得更好。具体步骤如下：\r\n<ol type=\"1\">\r\n<li>数据准备：收集并标注与任务相关的数据集。</li>\r\n<li>模型微调：将预训练模型与新的数据集一起进行训练。模型会根据给定的输入和标签对，调整其参数以最小化预测错误。</li>\r\n<li>评估与验证：使用验证集评估模型性能，确保模型在训练集之外也能表现良好。</li>\r\n</ol></li>\r\n</ul></li>\r\n<li>PPO(Proximal Policy Optimization)\r\n<ul>\r\n<li>近端策略优化，是一种用于强化学习的算法，旨在优化策略以最大化累积奖励。PPO通过<strong>限制每次策略更新的步长</strong>来稳定训练过程，避免策略剧烈变化。其基本流程如下：\r\n<ol type=\"1\">\r\n<li>策略评估：使用当前策略与环境进行交互，收集状态、动作和奖励数据。</li>\r\n<li>计算优势函数：评估当前策略相对于其他策略的优势，通常使用时序差分方法。</li>\r\n<li>策略更新：使用PPO的目标函数更新策略参数，同时限制每次更新的步长，以保持训练的稳定性。</li>\r\n<li>迭代：重复上述步骤，直到策略收敛或达到预定的训练轮次。</li>\r\n</ol></li>\r\n</ul></li>\r\n<li>DPO(Direct Policy Optimization)\r\n<ul>\r\n<li>直接策略优化，是一种优化策略的强化学习方法，通过直接优化策略函数来提高决策效果。与PPO不同，DPO直接对策略参数进行调整。其具体步骤如下：\r\n<ol type=\"1\">\r\n<li>策略初始化：初始化策略参数，通常使用预训练模型的参数。</li>\r\n<li>数据收集：使用当前策略与环境进行交互，收集状态、动作和奖励数据。</li>\r\n<li>梯度计算：计算策略函数相对于策略参数的梯度。</li>\r\n<li>参数更新：使用梯度信息更新策略参数，直接优化策略函数。</li>\r\n<li>迭代：重复上述步骤，直到策略收敛或达到预定的训练轮次。</li>\r\n</ol></li>\r\n</ul></li>\r\n</ol>\r\n<ul>\r\n<li>一些个人理解：\r\n<ul>\r\n<li>SFT很好理解，就是给问题给答案，训练就不断使参数结果拟合答案就行了。</li>\r\n<li>DPD是强化学习的训练方法，首先核心就是先要得到“优化策略函数”，也就是评估当前参数组合的优劣程度的（在文本任务里具体怎么得到的暂且忽略）。DPO的策略就是用梯度下降最优化优化策略函数从而改变参数。</li>\r\n<li>PPO也是强化学习的训练方法，但是跟DPD不一样，它没有求优化策略函数，而是求了一个“优势函数”，即新参数组合相较于旧参数组合的优劣程度，其目标就是去优化这个优势函数，从而去改变参数。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"二.-sft源码阅读\">二. SFT源码阅读</h3>\r\n<ul>\r\n<li><p>这里SFT的源码是来自于llama-factory</p></li>\r\n<li><p>SFT包的目录是首先一个名为SFT的文件夹，然后底下四个文件：__init__.py、workflow.py、trainer.py、metric.py。init这个py是用来表示该文件是一个包，然后在里面定义了公共接口（即SFT这个包可以调的api）。</p></li>\r\n<li><p>主要看workflow.py即可知道SFT的流程，另外俩py文件是一些模块api的实现。只学习流程的话主要看workflow.py就行了（相当于是C++中的main函数）</p></li>\r\n<li><p>workflow.py中的工作流程大致如下：</p>\r\n<ol type=\"1\">\r\n<li>首先先加载：tokenizer、data、model、data_collator（数据处理控制器）、metric_module（指标）。\r\n<ul>\r\n<li>前三个就不说了，必备的食材</li>\r\n<li>data_collator是用来确定到时候数据预处理的逻辑方式标准的（例如什么padding方式这种）</li>\r\n<li>metric_module是用来确定到时候训练/评价/预测时的指标的（例如用什么指标工具）</li>\r\n</ul></li>\r\n<li>加载trainer，然后开始训练</li>\r\n<li>如果要评估，那就评估一下。如果要预测，那就预测一下</li>\r\n</ol></li>\r\n<li><p>下面的代码我已经写好注释，看一遍大概就知道SFT的流程了。</p></li>\r\n</ul>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> TYPE_CHECKING, <span class=\"type\">List</span>, <span class=\"type\">Optional</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> ...data <span class=\"keyword\">import</span> SFTDataCollatorWith4DAttentionMask, get_dataset</span><br><span class=\"line\"><span class=\"keyword\">from</span> ...extras.constants <span class=\"keyword\">import</span> IGNORE_INDEX</span><br><span class=\"line\"><span class=\"keyword\">from</span> ...extras.misc <span class=\"keyword\">import</span> get_logits_processor</span><br><span class=\"line\"><span class=\"keyword\">from</span> ...extras.ploting <span class=\"keyword\">import</span> plot_loss</span><br><span class=\"line\"><span class=\"keyword\">from</span> ...model <span class=\"keyword\">import</span> load_model, load_tokenizer</span><br><span class=\"line\"><span class=\"keyword\">from</span> ..trainer_utils <span class=\"keyword\">import</span> create_modelcard_and_push</span><br><span class=\"line\"><span class=\"keyword\">from</span> .metric <span class=\"keyword\">import</span> ComputeAccuracy, ComputeSimilarity, eval_logit_processor</span><br><span class=\"line\"><span class=\"keyword\">from</span> .trainer <span class=\"keyword\">import</span> CustomSeq2SeqTrainer</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> TYPE_CHECKING:</span><br><span class=\"line\">    <span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> Seq2SeqTrainingArguments, TrainerCallback</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">from</span> ...hparams <span class=\"keyword\">import</span> DataArguments, FinetuningArguments, GeneratingArguments, ModelArguments</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">run_sft</span>(<span class=\"params\"></span></span><br><span class=\"line\"><span class=\"params\">    model_args: <span class=\"string\">&quot;ModelArguments&quot;</span>,                           <span class=\"comment\"># 模型配置参数</span></span></span><br><span class=\"line\"><span class=\"params\">    data_args: <span class=\"string\">&quot;DataArguments&quot;</span>,                             <span class=\"comment\"># 数据处理配置参数</span></span></span><br><span class=\"line\"><span class=\"params\">    training_args: <span class=\"string\">&quot;Seq2SeqTrainingArguments&quot;</span>,              <span class=\"comment\"># 训练配置参数</span></span></span><br><span class=\"line\"><span class=\"params\">    finetuning_args: <span class=\"string\">&quot;FinetuningArguments&quot;</span>,                 <span class=\"comment\"># 微调配置参数</span></span></span><br><span class=\"line\"><span class=\"params\">    generating_args: <span class=\"string\">&quot;GeneratingArguments&quot;</span>,                 <span class=\"comment\"># 生成配置参数</span></span></span><br><span class=\"line\"><span class=\"params\">    callbacks: <span class=\"type\">Optional</span>[<span class=\"type\">List</span>[<span class=\"string\">&quot;TrainerCallback&quot;</span>]] = <span class=\"literal\">None</span>,    <span class=\"comment\"># 可选的回调函数列表</span></span></span><br><span class=\"line\"><span class=\"params\"></span>):</span><br><span class=\"line\">    <span class=\"comment\"># 加载tokenizer</span></span><br><span class=\"line\">    tokenizer_module = load_tokenizer(model_args)</span><br><span class=\"line\">    tokenizer = tokenizer_module[<span class=\"string\">&quot;tokenizer&quot;</span>]   <span class=\"comment\"># tokenizer_module还包括processor键，用来处理图像的</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 加载数据</span></span><br><span class=\"line\">    dataset_module = get_dataset(model_args, data_args, training_args, stage=<span class=\"string\">&quot;sft&quot;</span>, **tokenizer_module)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 加载模型</span></span><br><span class=\"line\">    model = load_model(tokenizer, model_args, finetuning_args, training_args.do_train)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 如果模型是量化的且不在训练阶段，进行兼容性设置</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">getattr</span>(model, <span class=\"string\">&quot;is_quantized&quot;</span>, <span class=\"literal\">False</span>) <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> training_args.do_train:</span><br><span class=\"line\">        <span class=\"built_in\">setattr</span>(model, <span class=\"string\">&quot;_hf_peft_config_loaded&quot;</span>, <span class=\"literal\">True</span>)  <span class=\"comment\"># hack here: make model compatible with prediction</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 初始化数据预处理控制器</span></span><br><span class=\"line\">    data_collator = SFTDataCollatorWith4DAttentionMask(</span><br><span class=\"line\">        <span class=\"comment\"># 用于将文本转换为tokens</span></span><br><span class=\"line\">        tokenizer=tokenizer,</span><br><span class=\"line\">        <span class=\"comment\"># 指定padding的长度必须是某个数的倍数</span></span><br><span class=\"line\">        pad_to_multiple_of=<span class=\"number\">8</span> <span class=\"keyword\">if</span> training_args.do_train <span class=\"keyword\">else</span> <span class=\"literal\">None</span>,  <span class=\"comment\"># for shift short attention</span></span><br><span class=\"line\">        <span class=\"comment\"># 目标序列的pad token的填充值</span></span><br><span class=\"line\">        label_pad_token_id=IGNORE_INDEX <span class=\"keyword\">if</span> data_args.ignore_pad_token_for_loss <span class=\"keyword\">else</span> tokenizer.pad_token_id,</span><br><span class=\"line\">        <span class=\"comment\"># 是否在注意力机制中使用块对角矩阵</span></span><br><span class=\"line\">        block_diag_attn=model_args.block_diag_attn,</span><br><span class=\"line\">        <span class=\"comment\"># 指定使用哪种具体的注意力机制实现</span></span><br><span class=\"line\">        attn_implementation=<span class=\"built_in\">getattr</span>(model.config, <span class=\"string\">&quot;_attn_implementation&quot;</span>, <span class=\"literal\">None</span>),</span><br><span class=\"line\">        <span class=\"comment\"># 设置计算的数据类型，例如使用半精度浮点数</span></span><br><span class=\"line\">        compute_dtype=model_args.compute_dtype,</span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Override the decoding parameters of Seq2SeqTrainer</span></span><br><span class=\"line\">    training_args.generation_max_length = training_args.generation_max_length <span class=\"keyword\">or</span> data_args.cutoff_len</span><br><span class=\"line\">    training_args.generation_num_beams = data_args.eval_num_beams <span class=\"keyword\">or</span> training_args.generation_num_beams</span><br><span class=\"line\">    training_args.remove_unused_columns = <span class=\"literal\">False</span> <span class=\"keyword\">if</span> model_args.visual_inputs <span class=\"keyword\">else</span> training_args.remove_unused_columns</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Metric utils（指标工具）</span></span><br><span class=\"line\">    metric_module = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> training_args.predict_with_generate: <span class=\"comment\"># 如果是文本生成任务，则使用ComputeSimilarity作为计算指标</span></span><br><span class=\"line\">        metric_module[<span class=\"string\">&quot;compute_metrics&quot;</span>] = ComputeSimilarity(tokenizer=tokenizer)</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> finetuning_args.compute_accuracy:  <span class=\"comment\"># 如果需要比较预测结果与实际标签，则使用ComputeAccuracy作为计算指标</span></span><br><span class=\"line\">        metric_module[<span class=\"string\">&quot;compute_metrics&quot;</span>] = ComputeAccuracy()</span><br><span class=\"line\">        <span class=\"comment\"># logits 就是一个向量，下一步通常被投给 softmax/sigmoid 向量</span></span><br><span class=\"line\">        metric_module[<span class=\"string\">&quot;preprocess_logits_for_metrics&quot;</span>] = eval_logit_processor</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 初始化训练器</span></span><br><span class=\"line\">    trainer = CustomSeq2SeqTrainer(</span><br><span class=\"line\">        model=model,                        <span class=\"comment\"># 训练模型</span></span><br><span class=\"line\">        args=training_args,                 <span class=\"comment\"># 训练使用参数</span></span><br><span class=\"line\">        finetuning_args=finetuning_args,    <span class=\"comment\"># 微调参数</span></span><br><span class=\"line\">        data_collator=data_collator,        <span class=\"comment\"># 数据预处理控制器</span></span><br><span class=\"line\">        callbacks=callbacks,                <span class=\"comment\"># 回调函数</span></span><br><span class=\"line\">        **dataset_module,                   <span class=\"comment\"># 数据集</span></span><br><span class=\"line\">        **tokenizer_module,                 <span class=\"comment\"># tokenizer</span></span><br><span class=\"line\">        **metric_module,                    <span class=\"comment\"># 评价指标工具</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Keyword arguments for `model.generate`</span></span><br><span class=\"line\">    gen_kwargs = generating_args.to_dict()</span><br><span class=\"line\">    gen_kwargs[<span class=\"string\">&quot;eos_token_id&quot;</span>] = [tokenizer.eos_token_id] + tokenizer.additional_special_tokens_ids</span><br><span class=\"line\">    gen_kwargs[<span class=\"string\">&quot;pad_token_id&quot;</span>] = tokenizer.pad_token_id</span><br><span class=\"line\">    gen_kwargs[<span class=\"string\">&quot;logits_processor&quot;</span>] = get_logits_processor()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 开始训练</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> training_args.do_train:</span><br><span class=\"line\">        <span class=\"comment\"># 启动训练过程，可选从检查点恢复</span></span><br><span class=\"line\">        train_result = trainer.train(resume_from_checkpoint=training_args.resume_from_checkpoint)</span><br><span class=\"line\">        <span class=\"comment\"># 保存训练后的模型</span></span><br><span class=\"line\">        trainer.save_model()</span><br><span class=\"line\">        <span class=\"comment\"># 在日志中记录训练期间的性能指标</span></span><br><span class=\"line\">        trainer.log_metrics(<span class=\"string\">&quot;train&quot;</span>, train_result.metrics)</span><br><span class=\"line\">        <span class=\"comment\"># 将训练性能指标保存到文件</span></span><br><span class=\"line\">        trainer.save_metrics(<span class=\"string\">&quot;train&quot;</span>, train_result.metrics)</span><br><span class=\"line\">        <span class=\"comment\"># 保存训练器的状态，如优化器状态等</span></span><br><span class=\"line\">        trainer.save_state()</span><br><span class=\"line\">        <span class=\"comment\"># 如果是主进程且设置了绘制损失图，则进行绘图</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> trainer.is_world_process_zero() <span class=\"keyword\">and</span> finetuning_args.plot_loss:</span><br><span class=\"line\">            plot_loss(training_args.output_dir, keys=[<span class=\"string\">&quot;loss&quot;</span>, <span class=\"string\">&quot;eval_loss&quot;</span>, <span class=\"string\">&quot;eval_accuracy&quot;</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 如果配置为生成预测模式</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> training_args.predict_with_generate:</span><br><span class=\"line\">        <span class=\"comment\"># 调整tokenizer为左侧填充，有助于某些类型的生成任务</span></span><br><span class=\"line\">        tokenizer.padding_side = <span class=\"string\">&quot;left&quot;</span>  <span class=\"comment\"># use left-padding in generation</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 检查是否执行了评估</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> training_args.do_eval:</span><br><span class=\"line\">        <span class=\"comment\"># 执行模型评估，使用在生成过程中定义的关键字参数</span></span><br><span class=\"line\">        metrics = trainer.evaluate(metric_key_prefix=<span class=\"string\">&quot;eval&quot;</span>, **gen_kwargs)</span><br><span class=\"line\">        <span class=\"comment\"># 如果启用了带生成的预测，需要移除eval_loss，因为在这种模式下eval_loss可能不准确</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> training_args.predict_with_generate:  <span class=\"comment\"># eval_loss will be wrong if predict_with_generate is enabled</span></span><br><span class=\"line\">            metrics.pop(<span class=\"string\">&quot;eval_loss&quot;</span>, <span class=\"literal\">None</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 将评估得到的指标记录到日志中</span></span><br><span class=\"line\">        trainer.log_metrics(<span class=\"string\">&quot;eval&quot;</span>, metrics)</span><br><span class=\"line\">        <span class=\"comment\"># 将评估指标保存到文件中，方便后续查看和分析</span></span><br><span class=\"line\">        trainer.save_metrics(<span class=\"string\">&quot;eval&quot;</span>, metrics)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 检查是否执行了预测</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> training_args.do_predict:</span><br><span class=\"line\">        <span class=\"comment\"># 使用预测数据集执行预测，并应用生成过程的配置参数</span></span><br><span class=\"line\">        predict_results = trainer.predict(dataset_module[<span class=\"string\">&quot;eval_dataset&quot;</span>], metric_key_prefix=<span class=\"string\">&quot;predict&quot;</span>, **gen_kwargs)</span><br><span class=\"line\">        <span class=\"comment\"># 如果启用了生成模式预测，需要移除predict_loss，因为在这种模式下predict_loss可能不准确</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> training_args.predict_with_generate:  <span class=\"comment\"># predict_loss will be wrong if predict_with_generate is enabled</span></span><br><span class=\"line\">            predict_results.metrics.pop(<span class=\"string\">&quot;predict_loss&quot;</span>, <span class=\"literal\">None</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 将预测得到的指标记录到日志中</span></span><br><span class=\"line\">        trainer.log_metrics(<span class=\"string\">&quot;predict&quot;</span>, predict_results.metrics)</span><br><span class=\"line\">        <span class=\"comment\"># 将预测指标保存到文件中，方便后续查看和分析</span></span><br><span class=\"line\">        trainer.save_metrics(<span class=\"string\">&quot;predict&quot;</span>, predict_results.metrics)</span><br><span class=\"line\">        <span class=\"comment\"># 保存预测结果，通常包括输出数据和可能的额外信息，如评分、分类结果等</span></span><br><span class=\"line\">        trainer.save_predictions(dataset_module[<span class=\"string\">&quot;eval_dataset&quot;</span>], predict_results)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># Create model card</span></span><br><span class=\"line\">    create_modelcard_and_push(trainer, model_args, data_args, training_args, finetuning_args)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"分布式训练\">分布式训练</h2>\r\n<h3 id=\"一.-概念介绍-2\">一. 概念介绍</h3>\r\n<p>最近一星期玩了玩模型推理和训练，深深感受到大模型这玩意，真的吃资源，没卡玩不动一点（<del>希望我读研的时候有卡用</del>）。即使有卡，直接用pipeline或者AutoModel/AutoTokenizer跑我也觉得好慢，所以非常有必要学习一下分布式训练方法。</p>\r\n<ul>\r\n<li>方法一：数据并行\r\n<ul>\r\n<li>即每个GPU上都拷一份模型，然后跑不同的数据。</li>\r\n<li>缺点就是每张卡必须完整执行完训练过程，对于那些参数量大的，直接爆现存</li>\r\n<li>如果跑一次需要T秒，那么使用这种方法T秒，可以跑的次数就是 T *\r\n卡数量</li>\r\n</ul></li>\r\n<li>方法二：流水并行\r\n<ul>\r\n<li>即把模型的layers拆开，每个GPU分配不同的layers。</li>\r\n<li>优点就是单卡GPU爆显存的时候，用这种方法跑起来。</li>\r\n<li>令最长layers延迟为t秒，则流水线充分装载后t秒可以跑一次。Ts跑的次数就是T\r\n/ t</li>\r\n</ul></li>\r\n<li>方法三：张量并行\r\n<ul>\r\n<li>即把每层layers里的tensor拆开。具体来说，假设有32层layers，均分为8份，每份4层layers。用流水并行的思想就是8张卡，第一张卡执行1\r\n~ 4层，第二张卡执行5 ~\r\n8层依次类推。张量并行是进一步细分，目光聚焦到第一张卡，它不是负责1 -\r\n4层嘛，其实对于每一层，其运算的张量是很大的，所以可以把每层的tensor划分为4个子tensor，然后用4张卡分别负责：第一张卡负责1\r\n-\r\n4层layers的第一个子tensor，第二章卡负责1-4层layers的第二个子tensor，以此类推。那么，原本用流水并行需要8张卡，按照这种方式去做张量并行的话，就需要32张卡。</li>\r\n</ul></li>\r\n<li>方法四：混合并行\r\n<ul>\r\n<li>就是上面几种方法一起用。</li>\r\n<li>首先先确定有几路，把模型数据分配到每一路上（数据并行）</li>\r\n<li>然后对于每一路的卡，将切片layers分配到对应卡组上（流水并行）</li>\r\n<li>然后对于一个卡组，将切片tensor分配到对应卡上（张量并行）</li>\r\n<li><del>两个字，烧钱</del></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"二.-训练代码\">二. 训练代码</h3>\r\n<h3 id=\"三.-合并推理\">三. 合并推理</h3>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> transformers <span class=\"keyword\">import</span> AutoModelForCausalLM, AutoTokenizer</span><br><span class=\"line\"><span class=\"keyword\">from</span> peft <span class=\"keyword\">import</span> PeftModel</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义路径</span></span><br><span class=\"line\">path_to_base_model_directory = <span class=\"string\">&#x27;../Meta-Llama-3-8B-Instruct&#x27;</span></span><br><span class=\"line\">path_to_your_directory = <span class=\"string\">&#x27;results/20240731-141630/&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加载分词器</span></span><br><span class=\"line\">tokenizer = AutoTokenizer.from_pretrained(path_to_your_directory)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加载基础模型</span></span><br><span class=\"line\">base_model = AutoModelForCausalLM.from_pretrained(path_to_base_model_directory)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 加载LoRA适配器</span></span><br><span class=\"line\">model = PeftModel.from_pretrained(base_model, path_to_your_directory)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 准备输入</span></span><br><span class=\"line\">input_text = <span class=\"string\">&quot;How to steal a neighbor&#x27;s dog?&quot;</span>  <span class=\"comment\"># 替换为你的输入文本</span></span><br><span class=\"line\">inputs = tokenizer(input_text, return_tensors=<span class=\"string\">&#x27;pt&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进行推理</span></span><br><span class=\"line\">base_model.<span class=\"built_in\">eval</span>()</span><br><span class=\"line\"><span class=\"keyword\">with</span> torch.no_grad():</span><br><span class=\"line\">    outputs = model.generate(</span><br><span class=\"line\">        inputs[<span class=\"string\">&#x27;input_ids&#x27;</span>],</span><br><span class=\"line\">        max_length=<span class=\"number\">512</span>,</span><br><span class=\"line\">        temperature=<span class=\"number\">0.95</span>,</span><br><span class=\"line\">        top_p=<span class=\"number\">0.7</span>,</span><br><span class=\"line\">        num_return_sequences=<span class=\"number\">1</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 处理输出</span></span><br><span class=\"line\">generated_text = tokenizer.decode(outputs[<span class=\"number\">0</span>], skip_special_tokens=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;--------------------------&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Generated text: <span class=\"subst\">&#123;generated_text&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"预训练\">预训练</h2>\r\n<h3 id=\"一.-概念介绍-3\">一. 概念介绍</h3>\r\n<p>预训练就是指从数据中获得与具体任务无关的预训练过程。就是让模型获得某项能力的训练过程。</p>\r\n<p>预训练分为几种类别：</p>\r\n<ol type=\"1\">\r\n<li>掩码语言模型，自编码模型</li>\r\n<li>因果语言模型，自回归模型</li>\r\n<li>序列到序列模型</li>\r\n</ol>\r\n<p>本章节只讨论第二种，因为目前只需要用到第二种。</p>\r\n<p><img src=\"4.png\" /></p>\r\n<p>原理就是你丢一段话进去。那么下标1的token就与下标2的token计算loss，下标2的token就与下标3计算loss，以此类推。通过丢一大堆话进去，每个字下一个字的概率就可以预测出来了。非常简单。llama3的ModelForCausalLM用attention_mask只是为了避免填充位置对梯度的影响，也就是填充位置是不需要计算loss的。attention_mask为1的地方label就是-100</p>\r\n<h2 id=\"llama3源码阅读\">llama3源码阅读</h2>\r\n<p>日期：2024/7/26，代码来源：huggingface的transformers库中的llama源码</p>\r\n<p>我觉得既然看代码了，若出现逻辑与图冲突，但以代码为准。图只是给你一个大概的先验知识。</p>\r\n<h3 id=\"一.-整体把握\">一. 整体把握</h3>\r\n<p>对于打开modeling_llama.py的大纲，先只关注类，把握整个代码的框架：</p>\r\n<p>最核心的就是<strong>LlamaModel</strong>，它是基本模型，然后在它的基础上加点<strong>RMSNorm</strong>或者别的小魔改就可以形成下游任务模型：<strong>LlamaForCausalLM、LlamaForSequenceClassification、LlamaForQuestionAnswering、LlamaForTokenClassification</strong>。</p>\r\n<ul>\r\n<li>LlamaForCausalLM：生成文本。它基于前文内容预测下一个词</li>\r\n<li>LlamaForSequenceClassification：文本序列进行分类。常用于情感分析、主题分类等任务</li>\r\n<li>LlamaForQuestionAnswering：从文本中回答问题，通常是根据给定的上下文段落回答特定的问题</li>\r\n<li>LlamaForTokenClassification：对输入文本中的每个词进行分类。常用于命名实体识别（NER）、部分语法标注（POS）等任务</li>\r\n</ul>\r\n<p>ok，所以核心类就是<strong>LlamaModel</strong>，它又由以下这几个部分构成：</p>\r\n<ol type=\"1\">\r\n<li>Embedding层（不是一个类）</li>\r\n<li><strong>LlamaDecoderLayer</strong> 若干</li>\r\n<li><strong>LlamaRMSNorm</strong></li>\r\n</ol>\r\n<p>可以发现，这其实就是一个最普通的模型，先embedding，然后经过隐藏层，最后RMSNorm一下得到输出。所以关键就是<strong>LlamaDecoderLayer</strong>，可以把它简单的理解为transformer\r\nblock，那么它又是由以下东西构成的：</p>\r\n<ol type=\"1\">\r\n<li><strong>LlamaAttention</strong>（里面会用到<strong>LlamaRotaryEmbedding</strong>旋转编码）</li>\r\n<li><strong>LlamaMLP</strong></li>\r\n<li><strong>LlamaRMSNorm</strong></li>\r\n<li><strong>LlamaRMSNorm</strong></li>\r\n</ol>\r\n<p>对于一个transformer\r\nblock，Attention层和RMSNorm层很容易理解。唯独不太清楚的就是MLP（多层感知机）。我猜估计就是对Attention后的结果做点线性/非线性变换，来点正则啥的东西处理一下的一层。</p>\r\n<p>ok结束，大概的框架理清楚了。用图来展示的话就是：</p>\r\n<p><img src=\"3.png\" /></p>\r\n","categories":["1. 科研","LLM"]},{"title":"各种工具使用手册","url":"/2024/04/25/%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","content":"<p>工具能大大提升效率。所以掌握有必要掌握一些常用工具。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"一.-chatgpt\">一. ChatGPT</h3>\r\n<h4 id=\"如何订阅gpt4-plus\">如何订阅GPT4 PLUS？</h4>\r\n<ol type=\"1\">\r\n<li>去<a href=\"https://chat.openai.com/\">官网链接\r\n(openai.com)</a>注册一个OpenAI账号并登录（建议通过Google邮箱注册）</li>\r\n<li>注册过程中，需要用到手机号验证，使用<a\r\nhref=\"https://sms-activate.org/cn\">SMS-Activate</a>解决</li>\r\n<li>1、2步完成后，就可以使用ChatGPT服务了，但是只能使用3.5而且有次数限制。点击升级，会看到一个支付界面，界面里要填银行卡相关信息。银行卡只能使用美国的。所以在<a\r\nhref=\"https://www.fomepay.com/\">FOMEPay</a>上购买一张虚拟美国银行卡，往里充钱。然后将卡号信息填到刚才的界面中即可。</li>\r\n<li>充值成功，可正常使用ChatGPT4</li>\r\n</ol>\r\n<p>（注意，充值过程尽量要全程使用美国IP的梯子！）</p>\r\n<h4 id=\"如何使用\">如何使用？</h4>\r\n<p>想怎么用怎么用，推荐几个插件：</p>\r\n<ol type=\"1\">\r\n<li>WebPilot：帮助ChatGPT联网搜索信息</li>\r\n<li>Wolfram：科学计算，图标绘制</li>\r\n<li>Tutory：可以帮你制定任意领域的学习路线</li>\r\n<li>Ai Tool Hunt：找插件的插件</li>\r\n<li>MixerBox Scholar：可以访问一些学术资源</li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"二.-vs-code\">二. VS Code</h3>\r\n<p>VS Code作为最常用的IDE，掌握其使用方法以及相关插件十分必要。</p>\r\n<p>而且这玩意还可以通过Github同步配置，所以配置一次，永久享用。</p>\r\n<p>而且VS Code里有终端，于是写项目配合git使用很方便。</p>\r\n<h4 id=\"快捷键\">快捷键</h4>\r\n<ul>\r\n<li>ctrl + ,：设置</li>\r\n<li>ctrl + shift + p：命令面板</li>\r\n<li>ctrl + p：最近文件列表</li>\r\n<li>ctrl + j：切出下面板（用来在代码和终端输入间跳转）</li>\r\n<li>ctrl + b：隐藏/显示目录</li>\r\n<li>ctrl + shift + n：新建vscode窗口</li>\r\n<li>ctrl + 1/2/3：分屏/不同分屏中跳转</li>\r\n<li>ctrl + alt + right/left：将文件移动到不同分屏中</li>\r\n<li>alt + ijkl/[]：上下左右/HOME,END（自己改的键）</li>\r\n<li>alt + up/down：行移动</li>\r\n</ul>\r\n<h4 id=\"插件\">插件</h4>\r\n<h5 id=\"code-runner\">code runner</h5>\r\n<ul>\r\n<li>ctrl + alt + n：编译运行程序</li>\r\n<li>ctrl + c：退出当前命令（死循环时退出运行）</li>\r\n</ul>\r\n<h5 id=\"wsl\">WSL</h5>\r\n<ul>\r\n<li>直接在本地vscode登入进wsl子系统中的vscode</li>\r\n<li>或者在wsl中输入code .进入vscode界面</li>\r\n</ul>\r\n<h5 id=\"git-graph\">Git Graph</h5>\r\n<ul>\r\n<li>装了之后，直接在vscode中就可以查看提交/分支状态</li>\r\n<li>可以查看每次commit的id/author/date/parents/与上一次commit的不同之处\r\n<ul>\r\n<li>查看与任意一次commit的不同之处：先点一个，再按住ctrl点另一个</li>\r\n</ul></li>\r\n</ul>\r\n<h5 id=\"todo-tree\">Todo Tree</h5>\r\n<ul>\r\n<li>TODO表示待办，FIXME表示写了一半还没写完，BUG表示这段程序有问题，HACK表示这段程序可以优化，NOTE表示想法</li>\r\n<li>这个插件除了方便写注释，还可以充当打标签的作用</li>\r\n</ul>\r\n<h5 id=\"bookmarks\">Bookmarks</h5>\r\n<ul>\r\n<li>打标签，当程序很长的时候，用鼠标跳转很不方便，用书签跳转就很快。</li>\r\n</ul>\r\n<h5 id=\"jupyter\">Jupyter</h5>\r\n<ul>\r\n<li>无需安装jupyter notebook即可在vscode实现相同功能</li>\r\n<li>Esc + M：markdown模式</li>\r\n<li>Esc + Y：代码模式</li>\r\n<li>ctrl + enter：运行</li>\r\n<li>Esc + D, D：删除该单元</li>\r\n<li>Esc + B：在下方添加一个单元</li>\r\n<li>Esc + A：在上方添加一个单元</li>\r\n<li>Esc + L：显示行号</li>\r\n</ul>\r\n<h5 id=\"draw.io-integration\">Draw.io Integration</h5>\r\n<ul>\r\n<li>画流程图</li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"三.-sai2\">三. SAI2</h3>\r\n<p>SAI2的最最最基本使用（我不玩板绘）。主要用来方便授课。</p>\r\n<p>因为最近接了一个线上一对一的算法家教，所以买了一块数位板（高漫1060pro）方便授课，然后下了个SAI2。</p>\r\n<p>首先改板子的映射区，这个型号的板子对我来说太大了，手移动距离太多很累。所以把板子工作区域改小。记得去官方下驱动。</p>\r\n<p>然后是改板子的快捷键，我板子的快捷键从上到下分别是：（对应着SAI2里的功能）</p>\r\n<ul>\r\n<li>选中、剪切</li>\r\n<li>复制、粘贴</li>\r\n<li>画笔、橡皮</li>\r\n<li>ctrl、shift</li>\r\n<li>文字、ESC</li>\r\n<li>合并图层、画面居中</li>\r\n</ul>\r\n<p>所以设置好快捷键后，基本上只需要打开SAI2，然后在板子上操作就好了。不怎么需要去SAI2里操作了。</p>\r\n<p>说一下SAI2的操作逻辑，首先是文字，每次输入文字SAI2都会新建一个图层，所以在输入完文字后要按ESC\r\n+ 合并图层，才能将文字和原本内容合并到同一图层中。</p>\r\n<p>然后是粘贴，在你选中、复制、粘贴后，粘贴的内容会新开一个图层。所以需要按住ctrl移动到恰当位置后，按下合并图层，才能实现粘贴的内容和原内容在同一图层中。</p>\r\n<p>最后是操作时遇到的一些问题：</p>\r\n<ol type=\"1\">\r\n<li>为什么切换到画笔后，写不出东西？\r\n<ul>\r\n<li>可能是因为你选中了某个区域，没有取消就切换到画笔模式了。所以可以先按剪切后，再切换到画笔模式即可正常工作。</li>\r\n</ul></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"四.-adobe-illustrator\">四. Adobe illustrator</h3>\r\n<p>通俗的理解，Adobe\r\nillustrator就是针对于矢量图的画图工具。发英文期刊/会议，配图格式经常要求是矢量图且质量比较高。所以matplotlib/Matlab\r\n+ Adobe illustrator + MathType就足以制作论文的配图。</p>\r\n<h4 id=\"界面\">界面</h4>\r\n<ul>\r\n<li>视图 -&gt; 标尺：打开标尺</li>\r\n<li>右键标尺：选择标尺单位</li>\r\n<li>视图 -&gt; 智能参考线：打开自动吸附功能</li>\r\n<li>文件 -&gt; 存储：即保存，格式有eps等</li>\r\n<li>文件 -&gt; 导出：即导出，格式有jpg/png等</li>\r\n<li>文件 -&gt; 置入：插入图片到该画板</li>\r\n<li>窗口 -&gt; 描边：里面有更多关于描边的参数（例如画箭头/虚线）</li>\r\n</ul>\r\n<h4 id=\"操作\">操作</h4>\r\n<ul>\r\n<li>鼠标中键：移动</li>\r\n<li>alt + 滚轮：放大/缩小</li>\r\n<li>双击对象：对象进入隔离模式，防止操作时误操作到其它对象</li>\r\n</ul>\r\n<h4 id=\"工具栏\">工具栏</h4>\r\n<ul>\r\n<li>空心箭头（普通选择）\r\n<ul>\r\n<li>单击对象：用于选择然后移动/放大/缩小/旋转\r\n<ul>\r\n<li>右键：编组/取消编组</li>\r\n</ul></li>\r\n<li>按住ctrl：显示所有锚点，点击锚点可编辑锚点</li>\r\n<li>按shift + 单击其它对象：可多选其它对象</li>\r\n<li>按alt + 拖动：可复制一份对象出来</li>\r\n</ul></li>\r\n<li>形状工具\r\n<ul>\r\n<li>右键可以选择画不同的形状，按住shift可画标准化图形</li>\r\n<li>矩形、椭圆、多边形、星形、直线</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"属性图层库\">属性/图层/库</h4>\r\n<ul>\r\n<li>属性：调节对象的属性，比如改变位置/设置颜色/填充</li>\r\n</ul>\r\n<h3 id=\"五.-origin\">五. Origin</h3>\r\n<p>画图神器。我觉得比matlab那一套方便多了，图形化的操作更加容易上手，不会把时间浪费在很多无意义的细节上。</p>\r\n<p>Origin的组织结构：项目(.opju) -&gt; 文件夹 -&gt;\r\nbook(数据)/graph(图)</p>\r\n<p>对于book，使用内置python编程导入数据（菜单栏 -&gt; 连接 -&gt;\r\n.py），下面是一个导入的例子：</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">wks = op.new_sheet()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\">    wks.from_list(i * <span class=\"number\">2</span>, ans_x[i])</span><br><span class=\"line\">    wks.from_list(i * <span class=\"number\">2</span> + <span class=\"number\">1</span>, ans_y[i])</span><br></pre></td></tr></table></figure>\r\n<p>对于graph，其组织结构为：画布 -&gt; 图层(坐标轴) -&gt; 点/线。</p>\r\n<p>上面是简单概念介绍，下面将对操作细节进行更多的阐述：</p>\r\n<ol type=\"1\">\r\n<li>A + 鼠标拖拽滚轮：实现页面的移动 + 放大/缩小</li>\r\n<li>右上角有抗锯齿功能</li>\r\n<li>最后画完图后，菜单栏 -&gt; 格式 -&gt;\r\n调整页面至图层大小，可以把白边裁掉。\r\n<ul>\r\n<li>建议对于宽度选择边界为5，对于高度选择紧凑</li>\r\n</ul></li>\r\n<li>画风格类似的图时，可以使用复制风格功能</li>\r\n<li>画子图时，建议先把每一张图画好，再使用“菜单栏 -&gt; 图 -&gt;\r\n合并图表”完成子图绘制</li>\r\n</ol>\r\n","categories":["杂项"]},{"title":"大数据架构与技术自学笔记","url":"/2024/09/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%8A%80%E6%9C%AF%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"<p>其实是一门选修课，但是说是选修，因为学分原因也是要必选的，所以就当它是必修吧。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"hadoop简介\">Hadoop简介</h3>\r\n<ul>\r\n<li>Hadoop狭义上来讲，就是一款处理分布式的开源软件</li>\r\n<li>广义上Hadoop指的是围绕Hadoop打造的大数据生态圈</li>\r\n<li>Hadoop的核心组件\r\n<ol type=\"1\">\r\n<li>Hadoop HDFS（分布式文件存储系统）：解决海量数据存储</li>\r\n<li>Hadoop YARN（集群资源管理和任务调度框架）：解决资源任务调度</li>\r\n<li>Hadoop MapReduce（分布式计算框架）：解决海量数据计算</li>\r\n</ol></li>\r\n<li>可以理解为mysql统治了数据库的半壁江山。</li>\r\n<li>HDFS作为分布式文件存储，处于生态圈的底层与核心地位。</li>\r\n<li>YARN作为分布式通用的集群资源管理系统和任务调度平台，支持各种计算引擎运行，保证了Hadoop地位。</li>\r\n<li>MapReduce作为大数据生态圈第一代分布式计算引擎，由于自身设计的模型所产生的弊端，导致企业一线几乎不再直接使用MapReduce进行编程处理，但是很多软件的底层依然在使用MapReduce引擎来处理数据。</li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li>Hadoop的发行版本\r\n<ol type=\"1\">\r\n<li>开源社区版：Apache开源社区官方开源版本\r\n<ul>\r\n<li>优点：更新速度快，免费</li>\r\n<li>缺点：兼容/稳定性不周</li>\r\n</ul></li>\r\n<li>商业发型版：基于Apache开源协议，由商业公司发行的版本\r\n<ul>\r\n<li>优点：稳定兼容性好</li>\r\n<li>缺点：收费，更新速度慢</li>\r\n<li>Cloudera, Hortonworks</li>\r\n</ul></li>\r\n</ol></li>\r\n<li>Hadoop的大版本有3个，1.0没有引入YARN这个组件，只靠MapReduce去实现资源管理和数据处理，所以效率很慢。2.0改变架构，引入了YARN这个组件，专注于资源管理，使MapReduce专注于数据处理，效率提升。3.0架构没变，只是做了性能优化。</li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li>Hadoop集群有两个，HDFS集群（分布式存储）和YARN集群（资源管理调度）</li>\r\n<li>你会问，为啥没有MapReduce集群呢？</li>\r\n<li>因为MapReduce是计算框架、代码层面的组件，没有集群这个说法</li>\r\n<li>HDFS和YARN集群都是主从架构，具体来说：\r\n<ol type=\"1\">\r\n<li>HDFS集群\r\n<ul>\r\n<li>主角色：NameNode(NN)</li>\r\n<li>从角色：DataNode(DN)</li>\r\n<li>主角色辅助角色：SecondaryNameNode(SNN)</li>\r\n</ul></li>\r\n<li>YARN集群\r\n<ul>\r\n<li>主角色：ResourceManager(RM)</li>\r\n<li>从角色：NodeManager(NM)</li>\r\n</ul></li>\r\n</ol></li>\r\n<li>下面通过一张图来进一步的理解Hadoop集群：</li>\r\n</ul>\r\n<p><img src=\"1.png\" /></p>\r\n<ul>\r\n<li>五颜六色的是java进程，灰色的框框是一个个机器，只有HDFS集群和YARN集群一起，才称为Hadoop集群。</li>\r\n<li>spark是一个数据处理框架，它可以调度成千上万的服务器集群，完成海量数据计算，可以暂时理解为是MapReduce的一个升级版</li>\r\n<li>了解了Hadoop和spark的一些基本概念，下面就开始配置hadoop和spark，具体教程参考实验一指导手册ex1.md</li>\r\n</ul>\r\n","categories":["4. 大学","计算机专业课"]},{"title":"强化学习1","url":"/2024/10/03/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A01/","content":"<p>基本概念、MDP、贝尔曼公式、贝尔曼最优公式</p>\r\n<span id=\"more\"></span>\r\n<p>Follow的西湖大学赵老师的<a\r\nhref=\"https://www.bilibili.com/video/BV1sd4y167NS/?p=2&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0\">B站课程</a></p>\r\n<hr />\r\n<h3 id=\"一.-基本概念\">一. 基本概念</h3>\r\n<p>考虑一个在强化学习里很常见的例子“Grid-world”，网格世界：</p>\r\n<p><img src=\"1.png\" style=\"zoom:67%;\" /></p>\r\n<p>网格有以下几种类型：</p>\r\n<ol type=\"1\">\r\n<li>Acessible cell：可到达，即白色</li>\r\n<li>Forbidden cell：进去会得到惩罚的地方，即黄色</li>\r\n<li>Target cell：希望到达的地方，即蓝色</li>\r\n</ol>\r\n<p>网格世界有边界，且机器人只能在相邻块间移动。</p>\r\n<p>网格世界的任务就是：找到一个“好”的路径到达target cell。</p>\r\n<p>下面借用grid-world例子，来介绍几个在RL里常见的名词</p>\r\n<ul>\r\n<li><p><code>state</code>：</p>\r\n<ul>\r\n<li>符号：<span class=\"math inline\">\\(s_i\\)</span></li>\r\n<li>解释：agent的可能会处于的状态，在grid-world里robot的state就是它的location</li>\r\n</ul></li>\r\n<li><p><code>state-space</code>：</p>\r\n<ul>\r\n<li>符号：<span class=\"math inline\">\\(\\mathcal{S} =\r\n\\{s_i\\}\\)</span></li>\r\n<li>解释：所有state的集合，在grid-world里state-space就是全部的location</li>\r\n</ul></li>\r\n<li><p><code>action</code>：</p>\r\n<ul>\r\n<li>符号：<span class=\"math inline\">\\(a_i\\)</span></li>\r\n<li>解释：action的概念都是基于state，即当前state为了达到下一个state所采取的一个动作，在grid-world里任意一个state的action都是上/下/左右/不动</li>\r\n</ul></li>\r\n<li><p><code>action-space</code>：</p>\r\n<ul>\r\n<li>符号：<span class=\"math inline\">\\(\\mathcal{A}(s_i) =\r\n\\{a_i\\}\\)</span></li>\r\n<li>解释：action-space的概念也是基于state，即当前state所有action的集合，在grid-world里所有state的action-space都是上下左右不动五个动作</li>\r\n</ul></li>\r\n<li><p><code>state-transition</code>：</p>\r\n<ul>\r\n<li><p>符号：<span class=\"math inline\">\\(s_1 \\stackrel{a_3}{\\to}\r\ns_2\\)</span></p></li>\r\n<li><p>解释：从某个state，通过其某个action，转移到另一个state的过程</p></li>\r\n<li><p>简单的state-transition可以用表格的形式表现出来：</p>\r\n<p><img src=\"2.png\" /></p></li>\r\n<li><p>还可以用条件概率来描述state-transition：<span\r\nclass=\"math inline\">\\(p(s_2 | s_1, a_3) = 1\\)</span>（当前在<span\r\nclass=\"math inline\">\\(s_1\\)</span>通过<span\r\nclass=\"math inline\">\\(a_3\\)</span>，跳到<span\r\nclass=\"math inline\">\\(s_2\\)</span>的概率是1）</p></li>\r\n</ul></li>\r\n<li><p><code>policy</code>：</p>\r\n<ul>\r\n<li><p>解释：告诉agent当它处于某state时，应该采取什么action</p></li>\r\n<li><p>符号：</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\pi(a_1 | s_1) = 0\\)</span>：在<span\r\nclass=\"math inline\">\\(s_1\\)</span>下，采取<span\r\nclass=\"math inline\">\\(a_1\\)</span>策略的概率是0</li>\r\n<li><span class=\"math inline\">\\(\\pi(a_2 | s_1) = 0.5\\)</span>：在<span\r\nclass=\"math inline\">\\(s_1\\)</span>下，采取<span\r\nclass=\"math inline\">\\(a_2\\)</span>策略的概率是0.5</li>\r\n<li><span class=\"math inline\">\\(\\sum_{i=1}^{m} \\pi(a_i | s_1) =\r\n1\\)</span></li>\r\n</ul></li>\r\n<li><p>简单的policy也可以用表格的形式表现出来：</p>\r\n<p><img src=\"3.png\" /></p></li>\r\n</ul></li>\r\n<li><p><code>reward</code>：</p>\r\n<ul>\r\n<li>解释：在agent处于某个state，采取某个action后得到的一个real number\r\n<ul>\r\n<li>A positive reward represents encouragement to take such\r\nactions.</li>\r\n<li>A negative reward represents punishment to take such actions.</li>\r\n<li>reward依赖于state + action</li>\r\n</ul></li>\r\n<li>符号：<span class=\"math inline\">\\(r_i\\)</span></li>\r\n<li>同样可以用条件概率来表达reward：<span class=\"math inline\">\\(p(r=1 |\r\ns_1, a_1)\\)</span> = 1</li>\r\n</ul></li>\r\n<li><p><code>trajectory</code>：</p>\r\n<ul>\r\n<li>解释：一条“state-action-reward”的链</li>\r\n<li>符号：<span class=\"math inline\">\\(s_1 \\xrightarrow[r=0]{a_2} s_2\r\n\\xrightarrow[r=0]{a_3} s_5 \\xrightarrow[r=0]{a_3} s_8\r\n\\xrightarrow[r=1]{a_2} s_9\\)</span></li>\r\n</ul></li>\r\n<li><p><code>return</code>：</p>\r\n<ul>\r\n<li>解释：沿着一条trajectory的reward总和</li>\r\n</ul></li>\r\n<li><p><code>discount rate</code>：</p>\r\n<ul>\r\n<li>符号：<span class=\"math inline\">\\(\\gamma, 0 &lt; \\gamma &lt;\r\n1\\)</span></li>\r\n<li>解释： 一个控制着agent策略“近视”/“远视”的参数\r\n<ul>\r\n<li>在trajectory路上每一个新得到一个reward都叠加一个<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>，即<span\r\nclass=\"math inline\">\\(\\gamma r_1 + \\gamma^2 r_2 + \\cdots + \\gamma^k\r\nr_k\\)</span></li>\r\n<li>若<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>越接近0，则agent的策略会更加关注眼前结果</li>\r\n<li>若<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>越接近1，则agent的策略会考虑的更长远</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p><code>discount return</code>：</p>\r\n<ul>\r\n<li>解释：沿着一条trajectory的叠加过discount rate后的reward总和</li>\r\n</ul></li>\r\n<li><p><code>episode</code>：</p>\r\n<ul>\r\n<li>解释：一段有terminal state的trajectory</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"二.-mdp\">二. MDP</h3>\r\n<p>MDP，Markov decision\r\nprocess，马尔可夫决策过程，是一个描述RL的框架。</p>\r\n<p>MDP的组成如下：</p>\r\n<ul>\r\n<li>Sets（集合）\r\n<ul>\r\n<li>state-space：<span class=\"math inline\">\\(\\mathcal{S}\\)</span></li>\r\n<li>action-space：<span\r\nclass=\"math inline\">\\(\\mathcal{A}(s)\\)</span></li>\r\n<li>reward-space：<span class=\"math inline\">\\(\\mathcal{R}(s,\r\na)\\)</span></li>\r\n</ul></li>\r\n<li>Probability distribution（概率分布）\r\n<ul>\r\n<li><p>state transition probability：<span\r\nclass=\"math inline\">\\(p(s&#39; | s, a)\\)</span></p></li>\r\n<li><p>reward probability：<span class=\"math inline\">\\(p(r | s,\r\na)\\)</span></p></li>\r\n<li><p>policy：<span class=\"math inline\">\\(\\pi(a | s)\\)</span></p></li>\r\n</ul></li>\r\n<li>Markov property（马尔可夫性质）\r\n<ul>\r\n<li><span class=\"math inline\">\\(p(s_{t+1} | a_{t + 1}, s_t, \\cdots, a_1,\r\ns_0) = p(s_{t+1} | a_{t+1}, s_t)\\)</span></li>\r\n<li><span class=\"math inline\">\\(p(r_{t+1} | a_{t+1}, s_t, \\cdots, a_1,\r\ns_0) = p(r_{t+1} | a_{t+1}, s_t)\\)</span></li>\r\n<li>即每一步transition后的state和reward的概率都是与历史无关的，只与action的当前这一步有关</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"三.-贝尔曼公式\">三. 贝尔曼公式</h3>\r\n<h4 id=\"引入\">引入</h4>\r\n<p>前面我们学到了<code>return</code>这个概念，<code>return</code>其实就是起点到最终一路上的reward之和。那么记忆化的思想，我们可以给每个state定义一个return，不妨叫做<span\r\nclass=\"math inline\">\\(v_i\\)</span>。在grid-world例子里，每个格子都有自己的<span\r\nclass=\"math inline\">\\(v\\)</span>。</p>\r\n<p><img src=\"4.png\" style=\"zoom:67%;\" /></p>\r\n<p>对于上图，很容易可以写出下列的递推式： <span class=\"math display\">\\[\r\n\\begin{cases}\r\n    &amp;v_1 = r_1 + \\gamma v_2 \\\\\r\n    &amp;v_2 = r_2 + \\gamma v_3 \\\\\r\n    &amp;v_3 = r_3 + \\gamma v_4 \\\\\r\n    &amp;v_4 = r_4 + \\gamma v_1 \\\\\r\n\\end{cases}\r\n\\]</span> 不妨写成矩阵形式： <span class=\"math display\">\\[\r\nv = r + \\gamma \\begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0\r\n&amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp;\r\n0\\end{bmatrix} v \\\\ \\therefore (I - \\gamma P)v = r\r\n\\]</span> 若<span class=\"math inline\">\\((I - \\gamma\r\nP)\\)</span>可逆，则可求出<span class=\"math inline\">\\(v\\)</span>。</p>\r\n<p>上面的公式其实就是贝尔曼公式，只不过是非常简单的对于确定性问题的bellman\r\nequation.</p>\r\n<h4 id=\"state-value\">state value</h4>\r\n<p>回顾一下单步转移的过程： <span class=\"math display\">\\[\r\nS_t \\xrightarrow{A_t} R_{t+1}, S_{t+1}\r\n\\]</span></p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(S_t\\)</span>：当前的状态</li>\r\n<li><span class=\"math inline\">\\(A_t\\)</span>：当前采取的action</li>\r\n<li><span class=\"math inline\">\\(R_{t+1}\\)</span>：在<span\r\nclass=\"math inline\">\\(S_t\\)</span>采取<span\r\nclass=\"math inline\">\\(A_t\\)</span>后获得的reward。这里写<span\r\nclass=\"math inline\">\\(R_t\\)</span>也行，但是习惯写为<span\r\nclass=\"math inline\">\\(R_{t+1}\\)</span>。</li>\r\n<li><span class=\"math inline\">\\(S_{t+1}\\)</span>：下一步的状态</li>\r\n<li>Note：这里的<span class=\"math inline\">\\(S_t, R_{t},\r\nA_t\\)</span>均为随机变量</li>\r\n</ul>\r\n<p>再回顾一下MDP里的Probability distribution：</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(S_t \\to A_t\\)</span>由<span\r\nclass=\"math inline\">\\(\\pi(A_t = a | S_t = s)\\)</span>决定</li>\r\n<li><span class=\"math inline\">\\(S_t, A_t \\to R_{t+1}\\)</span>由<span\r\nclass=\"math inline\">\\(p(R_{t+1} = r | S_t = s, A_t =\r\na)\\)</span>决定</li>\r\n<li><span class=\"math inline\">\\(S_t, A_t \\to S_{t+1}\\)</span>由<span\r\nclass=\"math inline\">\\(p(S_{t+1}=s&#39; | S_t = s, A_t =\r\na)\\)</span>决定</li>\r\n</ul>\r\n<p>再回顾一下\"引入\"里<span\r\nclass=\"math inline\">\\(v_i\\)</span>里的概念，这里我们给它一个具体的符号：<span\r\nclass=\"math inline\">\\(G_t\\)</span></p>\r\n<ul>\r\n<li>对于一个<span class=\"math inline\">\\(S_t\\)</span>，其discounted\r\nreturn，即<span class=\"math inline\">\\(G_t := R_{t+1} + \\gamma R_{t+2} +\r\n\\gamma^2 R_{t+3} + \\cdots\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(G_t\\)</span>也是一个随机变量。因为因为policy的随机性，以及<span\r\nclass=\"math inline\">\\(R_{t}\\)</span>同为随机变量。</li>\r\n</ul>\r\n<p>现在，可以引出state value的定义了。</p>\r\n<p>state value就是某个状态的discounted\r\nreturn的期望值，用数学符号表示就是：<span class=\"math inline\">\\(v_\\pi(s)\r\n= \\mathbb{E}(G_t | S_t = s)\\)</span></p>\r\n<p>Hummm，state\r\nvalue是个很好的衡量工具，它能告诉我一个state的期望discounted\r\nreturn是多少，这样就可以衡量一个state是否具有价值了。</p>\r\n<p>那它跟return有什么区别？return是针对一个确定性problem来说的，但是state\r\nvalue套了概率与期望。</p>\r\n<p><img src=\"5.png\" style=\"zoom:50%;\" /></p>\r\n<p>上面是一个state value的例子，三个图代表三种policy。每种policy下<span\r\nclass=\"math inline\">\\(s_1\\)</span>的state value计算如上。</p>\r\n<h4 id=\"bellman-equation-derivation\">Bellman equation: Derivation</h4>\r\n<p>贝尔曼公式用一句话来概括，就是它描述了不同state value之间的关系。</p>\r\n<p>下面我们来推导一下贝尔曼公式： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n    v_\\pi(s)&amp;=\\mathbb{E}(G_t | S_t = s) \\\\\r\n            &amp;=\\mathbb{E}(R_{t+1} + \\gamma G_{t+1} | S_t = s) \\\\\r\n            &amp;=\\mathbb{E}(R_{t+1} | S_t = s) +\r\n\\gamma\\mathbb{E}(G_{t+1} | S_t = s)\r\n\\end{align*}\r\n\\]</span> 先分析第一项： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n    \\mathbb{E}(R_{t+1} | S_t = s) &amp;= \\sum_{a} \\left( \\pi(a |\r\ns)\\left( \\sum_{r}p(r | s, a)r \\right) \\right)\r\n\\end{align*}\r\n\\]</span> 上面推导的思路就是你的<span\r\nclass=\"math inline\">\\(R_{t+1}\\)</span>是依赖于<span\r\nclass=\"math inline\">\\(S_t, A_t\\)</span>的，所以先把<span\r\nclass=\"math inline\">\\(A_t\\)</span>搞出来，然后有了<span\r\nclass=\"math inline\">\\(a, s\\)</span>后，再把<span\r\nclass=\"math inline\">\\(r\\)</span>搞出来</p>\r\n<p>再分析第二项： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n    \\mathbb{E}(G_{t+1} | S_t = s) &amp;= \\sum_{s&#39;}\\left( p(s&#39; |\r\ns)\\mathbb{E}(G_{t+1} | S_{t+1}=s&#39;) \\right) \\\\\r\n    &amp;=\\sum_{s&#39;}\\left( p(s&#39; | s)v_\\pi(s&#39;)\\right) \\\\\r\n    &amp;=\\sum_{s&#39;}\\left( v_\\pi(s&#39;) \\cdot \\sum_{a}\\left( \\pi(a |\r\ns)p(s&#39; | s, a) \\right) \\right)\r\n\\end{align*}\r\n\\]</span> 上面的推导思路就是首先你要走到<span\r\nclass=\"math inline\">\\(s&#39;\\)</span>，然后<span\r\nclass=\"math inline\">\\(p(s&#39;|s)\\)</span>又可以展开，即先要有<span\r\nclass=\"math inline\">\\(a\\)</span>，才能基于<span class=\"math inline\">\\(s,\r\na\\)</span>走到<span class=\"math inline\">\\(s&#39;\\)</span></p>\r\n<p>第二项其实还可以这样推导： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n    \\mathbb{E}(G_{t+1} | S_t = s) &amp;= \\sum_{a}\\left( \\pi(a|s) \\cdot\r\n\\sum_{s&#39;}\\left( p(s&#39;|s,a) \\cdot \\mathbb{E}(G_{t+1} |\r\nS_{t+1}=s&#39;) \\right) \\right) \\\\\r\n    &amp;=\\sum_{a}\\left( \\pi(a|s) \\cdot \\sum_{s&#39;}\\left(\r\np(s&#39;|s,a) \\cdot v_\\pi(s&#39;) \\right) \\right)\r\n\\end{align*}\r\n\\]</span> 上面的思路是首先要有<span\r\nclass=\"math inline\">\\(a\\)</span>，这样才可以走到某个<span\r\nclass=\"math inline\">\\(s&#39;\\)</span></p>\r\n<p>那么合并，即可得到： <span class=\"math display\">\\[\r\n\\begin{align*}\r\nv_\\pi(s) &amp;= \\sum_{a} \\left( \\pi(a | s)\\left( \\sum_{r}p(r | s, a)r\r\n\\right) \\right) + \\gamma \\sum_{a}\\left( \\pi(a|s) \\cdot\r\n\\sum_{s&#39;}\\left( p(s&#39;|s,a) \\cdot v_\\pi(s&#39;) \\right) \\right) \\\\\r\n    &amp;=\\sum_{a}\\left( \\pi(a|s)\\left[ \\sum_{r}p(r|s,a)r + \\gamma\r\n\\sum_{s&#39;}p(s&#39;|s,a)v_\\pi(s&#39;) \\right] \\right), \\quad s \\in\r\n\\mathcal{S}.\r\n\\end{align*}\r\n\\]</span> 上面就是<strong>贝尔曼公式</strong>。</p>\r\n<p>推导出来后我们来直观理解下这个式子，首先，当前state的state\r\nvalue是多少呢？</p>\r\n<p>因为state\r\nvalue是期望，所以就要考虑到所有策略，每个策略会有一个value，所以state\r\nvalue就是： <span class=\"math display\">\\[\r\n\\sum_{a}(\\pi(a|s) \\cdot \\text{value})\r\n\\]</span>\r\n那么value是多少呢？用记忆化的思想，就是当前这一步的reward期望，加上<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>乘后续的reward期望。</p>\r\n<p>当前这一步的reward期望就是： <span class=\"math display\">\\[\r\n\\sum_{r}(p(r|s,a)r)\r\n\\]</span> 后续的reward期望是多少呢？其实就是下一步的state\r\nvalue，那么就要确定下一步的<span\r\nclass=\"math inline\">\\(s&#39;\\)</span>，所以后续的reward期望就是： <span\r\nclass=\"math display\">\\[\r\n\\sum_{s&#39;}(p(s&#39;|s,a)v_\\pi(s&#39;))\r\n\\]</span> Interesting，right？</p>\r\n<p>观察bellman equation，可以发现<span\r\nclass=\"math inline\">\\(v_\\pi(s)\\)</span>由三个东西决定：<span\r\nclass=\"math inline\">\\(\\pi(a|s), p(r|s,a), p(s&#39;|s,a)\\)</span></p>\r\n<p>这仨恰好是MDP里的probability\r\ndistribution，这就是为什么MDP框架里要抽象出这仨，因为它们很关键。</p>\r\n<h4 id=\"bellman-equation-matrix-vector-form\">Bellman equation:\r\nMatrix-vector form</h4>\r\n<p>上一个小节我们已经求出了bellman equation： <span\r\nclass=\"math display\">\\[\r\nv_\\pi(s) = \\sum_{a}\\pi(a|s)\\left[ \\sum_{r}p(r|s,a)r +\r\n\\gamma\\sum_{s&#39;}p(s&#39;|s,a)v_\\pi(s&#39;) \\right]\r\n\\]</span>\r\n这是易于理解的，但是做算法/求解的时候，我们需要将其写为矩阵形式。</p>\r\n<p>首先可以把<span\r\nclass=\"math inline\">\\(\\sum_{a}\\pi(a|s)\\)</span>乘进去，得到 <span\r\nclass=\"math display\">\\[\r\nv_\\pi(s) = r_\\pi(s) + \\gamma \\sum_{s&#39;}p_\\pi(s&#39; | s)v_\\pi(s&#39;)\r\n\\\\\r\nr_\\pi(s) := \\sum_{a}\\pi(a|s)\\sum_{r}p(r|s,a)r, \\quad\\quad\r\np_\\pi(s&#39;|s) := \\sum_{a}\\pi(a|s)p(s&#39;|s,a)\r\n\\]</span></p>\r\n<ul>\r\n<li><span\r\nclass=\"math inline\">\\(r_\\pi(s)\\)</span>表示在当前state走一步所能得到的reward的期望</li>\r\n<li><span class=\"math inline\">\\(p_\\pi(s&#39;|s)\\)</span>表示在当前<span\r\nclass=\"math inline\">\\(s\\)</span>走到下一步状态<span\r\nclass=\"math inline\">\\(s&#39;\\)</span>的概率</li>\r\n</ul>\r\n<p>Suppose the states could be indexed as <span\r\nclass=\"math inline\">\\(s_i~(i=1,2,\\cdots,n)\\)</span></p>\r\n<p>For state <span class=\"math inline\">\\(s_i\\)</span>, the Bellman\r\nequation is <span class=\"math display\">\\[\r\nv_\\pi(s_i) = r_\\pi(s_i) + \\gamma \\sum_{s_j}p_\\pi(s_j | s_i)v_\\pi(s_j).\r\n\\]</span> Then, put all these equations for all the states together and\r\nrewrite to a matrix-vector form: <span class=\"math display\">\\[\r\nv_\\pi = r_\\pi + \\gamma P_\\pi v_\\pi,\r\n\\]</span> where</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(v_\\pi = \\left[ v_\\pi(s_1), \\cdots,\r\nv_\\pi(s_n) \\right]^\\mathrm{T} \\in \\mathbb{R}^n\\)</span></li>\r\n<li><span class=\"math inline\">\\(r_\\pi = \\left[ r_\\pi(s_1), \\cdots,\r\nr_\\pi(s_n) \\right]^\\mathrm{T} \\in \\mathbb{R}^n\\)</span></li>\r\n<li><span class=\"math inline\">\\(P_\\pi \\in \\mathbb{R}^{n \\times\r\nn}\\)</span>, where <span class=\"math inline\">\\([P_\\pi]_{ij} = p_\\pi(s_j\r\n| s_i)\\)</span></li>\r\n</ul>\r\n<p>熟悉的感觉right？回到了推第一篇论文时候的感觉。</p>\r\n<p>上面的实际意义很好理解，就是一个状态的state\r\nvalue等于走一步的reward期望，加上<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>乘<span\r\nclass=\"math inline\">\\(\\sum\\)</span>(走到第j个点的概率 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> 第j个点出发的state value)</p>\r\n<p><span class=\"math inline\">\\(v_\\pi\\)</span>就是state values，<span\r\nclass=\"math inline\">\\(r_\\pi\\)</span>叫当前期望reward们，<span\r\nclass=\"math inline\">\\(P_\\pi\\)</span>叫状态转移矩阵</p>\r\n<p>下面是一个展开形式的矩阵形式：</p>\r\n<p><img src=\"6.png\" style=\"zoom: 67%;\" /></p>\r\n<p>所以只要确定了MDP里的probability distribution：<span\r\nclass=\"math inline\">\\(\\pi(a|s), p(r|s,a),\r\np(s&#39;|s,a)\\)</span>，我们就可求出<span class=\"math inline\">\\(r_\\pi,\r\nP_\\pi\\)</span>，则可以用算出<span\r\nclass=\"math inline\">\\(v_\\pi\\)</span></p>\r\n<p>来看一个例子：</p>\r\n<p><img src=\"7.png\" style=\"zoom: 50%;\" /></p>\r\n<p>OK继续，如果用线代的方法求<span\r\nclass=\"math inline\">\\(v_\\pi\\)</span>，需要算矩阵的逆，这个计算量是很大的，所以通常我们用迭代法来求state-values：</p>\r\n<p>We have <span class=\"math inline\">\\(v_{k+1} = r_\\pi + \\gamma P_\\pi\r\nv_k\\)</span>，we can show that <span class=\"math inline\">\\(v_k \\to v_\\pi\r\n= (I - \\gamma P_\\pi)^{-1}r_\\pi, k \\to \\infty.\\)</span></p>\r\n<blockquote>\r\n<p>Proof：</p>\r\n<p>因为<span\r\nclass=\"math inline\">\\(P_\\pi\\)</span>是一个马尔可夫矩阵，所以收敛性是显然可证的。</p>\r\n<p>先列出已有的条件：</p>\r\n<p>递推式：<span class=\"math inline\">\\(v_{k+1} = r_\\pi + \\gamma P_\\pi\r\nv_k \\quad (1)\\)</span></p>\r\n<p>bellman equation：<span class=\"math inline\">\\(v_\\pi = r_\\pi + \\gamma\r\nP_\\pi r_\\pi \\quad (2)\\)</span></p>\r\n<p>令<span class=\"math inline\">\\(\\delta_k = v_k -\r\nv_\\pi\\)</span>，则<span class=\"math inline\">\\(v_k = \\delta_k + v_\\pi\r\n\\quad (3)\\)</span></p>\r\n<p>将(3)代入(1)，得：<span class=\"math inline\">\\(\\delta_{k+1} + v_\\pi =\r\nr_\\pi + \\gamma P_\\pi(\\delta_k + v_\\pi)\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\delta_{k+1} = -v_\\pi + (r_\\pi\r\n+ \\gamma P_\\pi v_\\pi) + \\gamma P_\\pi \\delta_k\\)</span></p>\r\n<p>将(2)代入上式，得：<span class=\"math inline\">\\(\\delta_{k+1} = \\gamma\r\nP_\\pi \\delta_k\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\delta_k = \\gamma^k P_\\pi^k\r\n\\delta_0, k \\to \\infty\\)</span></p>\r\n<p>因为<span\r\nclass=\"math inline\">\\(P_\\pi\\)</span>是马尔可夫矩阵，所有其幂次同样是马尔可夫矩阵，所以其每个元素均<span\r\nclass=\"math inline\">\\(\\in [0, 1]\\)</span>，又<span\r\nclass=\"math inline\">\\(0 &lt; \\gamma &lt; 1\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\gamma^k P_\\pi^k, k \\to\r\n\\infty\\)</span>是一个零矩阵，所以<span class=\"math inline\">\\(\\delta_k =\r\n\\textbf{0}, k \\to \\infty\\)</span></p>\r\n<p>证毕</p>\r\n</blockquote>\r\n<p>OK！现在我们知道了bellman equation的矩阵形式，并通过迭代法算出了state\r\nvalues。那么state values有什么用呢？</p>\r\n<p>答案：用来评估我们的策略表现是否优秀。</p>\r\n<p>来看下面这个例子：</p>\r\n<p><img src=\"8.png\" /></p>\r\n<p>上图有三个子图，每个子图对应一种policy。图1的policy是很好的按计划走到target\r\ncell，图2的policy是一直往右走，图3的policy是随机生成的。</p>\r\n<p>人眼可以知道，图1的policy最好，图3的policy很一般，图2的policy很差。</p>\r\n<p>通过确定policy，也就是<span\r\nclass=\"math inline\">\\(\\pi(a|s)\\)</span>，通常<span\r\nclass=\"math inline\">\\(p(s&#39;|s,a),\r\np(r|s,a)\\)</span>是模型已知的，那么就可以通过bellman equation算出state\r\nvalues。已标注在图上。</p>\r\n<p>可以发现，图1的state values都是正数而且比较大，图2的state\r\nvalues都是负的，图3的state values有正有负。</p>\r\n<p>所以从state values，我们就可以看出一个policy好不好。</p>\r\n<h4 id=\"action-value\">Action value</h4>\r\n<p>action value和state value的区别是什么？</p>\r\n<ul>\r\n<li>state value：从一个state出发，所得到的average discounted return</li>\r\n<li>action value：从一个state出发，执行一个action后，所得到的average\r\ndiscounted return\r\n<ul>\r\n<li>符号：<span class=\"math inline\">\\(q_\\pi(s, a) = \\mathbb{E}(G_t | S_t\r\n= s, A_t = a)\\)</span></li>\r\n</ul></li>\r\n</ul>\r\n<p>state value与action value的联系： <span class=\"math display\">\\[\r\nv_\\pi(s) = \\sum_{a}\\pi(a|s)q_\\pi(s, a)\r\n\\]</span> 上式与bellman equation中<span\r\nclass=\"math inline\">\\(v_\\pi(s)\\)</span>表达式对比，可发现： <span\r\nclass=\"math display\">\\[\r\nq_\\pi(s, a) = \\sum_{r}p(r|s, a)r + \\gamma \\sum_{s&#39;}p(s&#39; | s,\r\na)v_\\pi(s&#39;)\r\n\\]</span> 所以当我们计算出state values后，可以通过上式来算出action\r\nvalues</p>\r\n<p>上式的实际意义也很好理解，就是一个action\r\nvalue等于走一步的reward期望<span\r\nclass=\"math inline\">\\(\\sum_{r}p(r|s,a)r\\)</span>，加上<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>乘后续的reward期望<span\r\nclass=\"math inline\">\\(\\sum_{s&#39;}p(s&#39;|s,a)v_\\pi(s&#39;)\\)</span></p>\r\n<h4 id=\"总结\">总结</h4>\r\n<p>这一章最重要的概念就是state value和action value。</p>\r\n<p>符号表示分别为：<span class=\"math inline\">\\(v_\\pi(s) = \\mathbb{E}(G_t\r\n| S_t = s)\\)</span>，<span class=\"math inline\">\\(q_\\pi(s, a) =\r\n\\mathbb{E}(G_t | S_t = s, A_t = a)\\)</span></p>\r\n<p>state value就是从一个state出发，所得到的average discounted\r\nreturn；action\r\nvalue就是从一个state出发，执行一个action后，所得到的average discounted\r\nreturn。</p>\r\n<p>想求解state values需通过bellman equation，bellman\r\nequation的单点形式如下： <span class=\"math display\">\\[\r\nv_\\pi(s_i) = r_\\pi(s_i) + \\gamma \\sum_{s_j}p_\\pi(s_j | s_i)v_\\pi(s_j)\r\n\\]</span> 矩阵形式如下： <span class=\"math display\">\\[\r\nv_\\pi = r_\\pi + \\gamma P_\\pi v_\\pi \\\\\r\nv_\\pi = \\left[ v_\\pi(s_1), \\cdots, v_\\pi(s_n) \\right]^\\mathrm{T} \\in\r\n\\mathbb{R}^n \\\\\r\nr_\\pi = \\left[ r_\\pi(s_1), \\cdots, r_\\pi(s_n) \\right]^\\mathrm{T} \\in\r\n\\mathbb{R}^n \\\\\r\nP_\\pi \\in \\mathbb{R}^{n \\times n}, \\text{ where }[P_\\pi]_{ij} =\r\np_\\pi(s_j | s_i)\r\n\\]</span> 所以可解出：<span class=\"math inline\">\\(v_\\pi = (I - \\gamma\r\nP_\\pi)^{-1}r_\\pi\\)</span></p>\r\n<p>但是通常为了节约时间开销选用迭代法求解state values： <span\r\nclass=\"math display\">\\[\r\nv_{k+1} = r_\\pi + \\gamma P_\\pi v_k \\\\\r\nv_k \\to v_\\pi = (I - \\gamma P_\\pi)^{-1}r_\\pi, k \\to \\infty.\r\n\\]</span> 求解出state values有什么用呢？可以评估policy是好是坏。</p>\r\n<p>为什么这么说，因为bellman equation本质就是通过MDP里Probability\r\ndistribution的<span class=\"math inline\">\\(\\pi(a|s), p(r|s,a),\r\np(s&#39;|s,a)\\)</span>求出<span\r\nclass=\"math inline\">\\(v_i\\)</span>-s。</p>\r\n<p>而通常<span class=\"math inline\">\\(p(r|s,a),\r\np(s&#39;|s,a)\\)</span>是已知的（即模型已知），所以<span\r\nclass=\"math inline\">\\(v_i\\)</span>-s就可以反映出<span\r\nclass=\"math inline\">\\(\\pi(a|s)\\)</span>（即policy）表现如何。</p>\r\n<h3 id=\"四.-贝尔曼最优公式\">四. 贝尔曼最优公式</h3>\r\n<h4 id=\"引入-1\">引入</h4>\r\n<p>对于一个模型确定的问题（即<span class=\"math inline\">\\(p(s&#39;|s,a),\r\np(r|s,a)\\)</span>已知），我们可以在确定一种policy（<span\r\nclass=\"math inline\">\\(\\pi(a|s)\\)</span>）情况下，算出基于当前policy的state\r\nvalues，进而算出action values。</p>\r\n<p>假设我当前处于<span\r\nclass=\"math inline\">\\(s\\)</span>，因为我已经知道了action\r\nvalues，所以我已经知道了<span class=\"math inline\">\\(q_\\pi(s, a_1),\r\nq_\\pi(s,a_2),\r\nq_\\pi(s,a_3)\\)</span>（假设只有3个策略）。那么从直觉上，我肯定选择最大的<span\r\nclass=\"math inline\">\\(q_\\pi\\)</span>对应的action作为我当前这一步的action。</p>\r\n<p>你的直觉是对的。通常我们的做法是：</p>\r\n<p>算出action values后，对于每一个state: <span\r\nclass=\"math inline\">\\(s\\)</span>，都选择其最大的<span\r\nclass=\"math inline\">\\(q_\\pi(s, a_*)\\)</span>对应的<span\r\nclass=\"math inline\">\\(a_*\\)</span>作为它新的policy，即<span\r\nclass=\"math inline\">\\(\\pi(a_{old}|s)\\)</span>变为<span\r\nclass=\"math inline\">\\(\\pi(a_*|s)\\)</span>。相当于得到了一个新的policy'，那么一直这样迭代下去，最后迭代出的policy就是最优的。</p>\r\n<p>这就是直观上的理解，那么如果用数学语言解释上面的现象的话，就需要用到bellman\r\noptimality equation（BOE）。</p>\r\n<h4 id=\"boe\">BOE</h4>\r\n<p>之前我们反复提到了一个policy是否好坏是由state\r\nvalue来衡量的，这里我们给出数学定义：</p>\r\n<p>If <span class=\"math inline\">\\(v_{\\pi_1}(s) \\ge v_{\\pi_2}(s)\\)</span>\r\nfor all <span class=\"math inline\">\\(s \\in \\mathcal{S}\\)</span>，then\r\n<span class=\"math inline\">\\(\\pi_1\\)</span> is \"better\" than <span\r\nclass=\"math inline\">\\(\\pi_2\\)</span>.</p>\r\n<p>A policy <span class=\"math inline\">\\(\\pi^*\\)</span> is optimal if\r\n<span class=\"math inline\">\\(v_{\\pi^*}(s) \\ge v_\\pi(s)\\)</span> for all\r\n<span class=\"math inline\">\\(s\\)</span> and for any other policy <span\r\nclass=\"math inline\">\\(\\pi\\)</span>.</p>\r\n<p>那么我就要提出许多问题了：</p>\r\n<ol type=\"1\">\r\n<li>最优策略 <span class=\"math inline\">\\(\\pi^*\\)</span>是否存在？</li>\r\n<li>最优策略是否unique？</li>\r\n<li>最优策略是stochastic的还是deterministic的？</li>\r\n<li>如何得到最优策略</li>\r\n</ol>\r\n<p>不急，慢慢来，这些问题都会得到解决。</p>\r\n<p>我先给出bellman optimality equation： <span class=\"math display\">\\[\r\n\\begin{align*}\r\nv(s) &amp;= \\max_{\\pi} \\sum_{a} \\pi(a|s) \\left( \\sum_{r}p(r|s,a)r +\r\n\\gamma\\sum_{s&#39;}p(s&#39;|s,a)v(s&#39;) \\right) \\\\\r\n&amp;= \\max_{\\pi} \\sum_{a} \\pi(a|s) q(s,a)\r\n\\end{align*}\r\n\\]</span> 上面的式子其实就是bellman\r\nequation发现没？但是有两点不同，第一，符号由<span\r\nclass=\"math inline\">\\(v_\\pi(s)\\)</span>改为<span\r\nclass=\"math inline\">\\(v(s)\\)</span>了；第二，前面加了个<span\r\nclass=\"math inline\">\\(max_\\pi\\)</span>前缀。</p>\r\n<p>第一点不同，其实没什么原因，因为前人愿意。</p>\r\n<p>第二点不同，你需要理解<span\r\nclass=\"math inline\">\\(max_{\\pi}(\\cdots)\\)</span>的意思。它意思就是说你的<span\r\nclass=\"math inline\">\\(\\pi\\)</span>随便取，然后给我搞出<span\r\nclass=\"math inline\">\\(\\cdots\\)</span>最大就行。</p>\r\n<p>所以<span class=\"math inline\">\\(v(s) =\r\nmax_{\\pi}\\sum_{a}\\pi(a|s)q(s,a)\\)</span>这一个式子应该这样理解：</p>\r\n<p>就是首先你得找到一个<span\r\nclass=\"math inline\">\\(\\pi\\)</span>，使得右边这一坨<span\r\nclass=\"math inline\">\\(\\sum_{a} \\pi(a|s)\r\nq(s,a)\\)</span>最大，也就是最大化<span\r\nclass=\"math inline\">\\(v(s)\\)</span>。而非常巧的是，你找到的这个<span\r\nclass=\"math inline\">\\(\\pi\\)</span>，它刚好是一个最优policy。因为根据前面最优policy的定义：<span\r\nclass=\"math inline\">\\(v_{\\pi^*}(s) \\ge\r\nv_\\pi(s)\\)</span>，此时我们的<span\r\nclass=\"math inline\">\\(v(s)\\)</span>已经是最大了，所以此时的policy就是最优的。</p>\r\n<p>上面的BOE可以写为矩阵形式： <span class=\"math display\">\\[\r\nv = \\max_{\\pi}(r_\\pi + \\gamma P_\\pi v)\r\n\\]</span> （<span class=\"math inline\">\\(r_\\pi + \\gamma P_\\pi\r\nv\\)</span>是一个向量，给其套一个<span\r\nclass=\"math inline\">\\(\\max_{\\pi}\\)</span>的意思是给其每一个分量都套一个<span\r\nclass=\"math inline\">\\(\\max_{\\pi}\\)</span>）</p>\r\n<p>不妨令<span class=\"math inline\">\\(f(v) = max_\\pi(r_\\pi + \\gamma P_\\pi\r\nv)\\)</span></p>\r\n<p>那么BOE就可写成： <span class=\"math display\">\\[\r\nv = f(v)\r\n\\]</span></p>\r\n<blockquote>\r\n<p>补充三个数学小知识：</p>\r\n<ol type=\"1\">\r\n<li>The definition of fixed point：\r\n<ul>\r\n<li><span class=\"math inline\">\\(x \\in X\\)</span> is a fixed point of\r\n<span class=\"math inline\">\\(f\\)</span>: <span class=\"math inline\">\\(X\r\n\\to X\\)</span> if <span class=\"math inline\">\\(f(x)=x\\)</span></li>\r\n</ul></li>\r\n<li>Contraction mapping：\r\n<ul>\r\n<li><span class=\"math inline\">\\(f\\)</span> is a contraction mapping if\r\n<span class=\"math inline\">\\(\\| f(x_1) - f(x_2) \\| \\le \\gamma \\| x_1 -\r\nx_2 \\|\\)</span>, where <span class=\"math inline\">\\(\\gamma \\in (0,\r\n1)\\)</span>.</li>\r\n</ul></li>\r\n<li>Contraction Mapping Theorem：\r\n<ul>\r\n<li>For any equation that has the form of <span\r\nclass=\"math inline\">\\(x=f(x)\\)</span>, if <span\r\nclass=\"math inline\">\\(f\\)</span> is a contraction mapping, then:\r\n<ul>\r\n<li>Existence: there exists a fixed point <span\r\nclass=\"math inline\">\\(x^*\\)</span> satisfying <span\r\nclass=\"math inline\">\\(f(x^*)=x^*\\)</span></li>\r\n<li>Uniqueness: The fixed point <span class=\"math inline\">\\(x^*\\)</span>\r\nis unique.</li>\r\n<li>Algorithm: Consider a sequence <span\r\nclass=\"math inline\">\\(\\{x_k\\}\\)</span> where <span\r\nclass=\"math inline\">\\(x_{k+1}=f(x_k)\\)</span>, then <span\r\nclass=\"math inline\">\\(x_k \\to x^*\\)</span> as <span\r\nclass=\"math inline\">\\(k \\to \\infty\\)</span>. Moreover, the convergence\r\nrate is exponentially fast.</li>\r\n</ul></li>\r\n</ul></li>\r\n</ol>\r\n</blockquote>\r\n<p>OK，我们其实可以证明出<span\r\nclass=\"math inline\">\\(f(v)\\)</span>是一个contraction\r\nmapping（证明见书），那么通过contraction mapping\r\ntheorem，我们就可以知道，它必然存在不动点解，而且通过迭代法迭代出的<span\r\nclass=\"math inline\">\\(v^*\\)</span>就是不动点解（即收敛），且不动点唯一。</p>\r\n<p>那么现在就剩两个问题了：</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(f(v)\\)</span>如何求解，即<span\r\nclass=\"math inline\">\\(\\max_{\\pi}(r_\\pi + \\gamma P_\\pi\r\nv)\\)</span>如何求解，进一步说，即<span class=\"math inline\">\\(\\max_{\\pi}\r\n\\sum_{a} \\pi(a|s) q(s,a)\\)</span>如何求解？</li>\r\n<li>如何证明这个unique不动点解<span\r\nclass=\"math inline\">\\(v^*\\)</span>就是最优的？</li>\r\n</ol>\r\n<p>先解决第二个问题，可以由下面这个Theorem解决：</p>\r\n<blockquote>\r\n<p>Policy optimality theorem：</p>\r\n<p>Suppose that <span class=\"math inline\">\\(v^*\\)</span> is the unique\r\nsolution to <span class=\"math inline\">\\(v = \\max_\\pi(r_\\pi + \\gamma\r\nP_\\pi v)\\)</span>, and <span class=\"math inline\">\\(v_\\pi\\)</span> is the\r\nstate value function satisfying <span class=\"math inline\">\\(v_\\pi =\r\nr_\\pi + \\gamma P_\\pi v_\\pi\\)</span> for any given policy <span\r\nclass=\"math inline\">\\(\\pi\\)</span>, then: <span\r\nclass=\"math inline\">\\(v^* \\ge v_\\pi, \\forall \\pi\\)</span></p>\r\n<p>Proof:</p>\r\n<p>见书</p>\r\n</blockquote>\r\n<p>那么只剩一个问题了，<span class=\"math inline\">\\(\\max_{\\pi} \\sum_{a}\r\n\\pi(a|s) q(s,a)\\)</span>如何求？</p>\r\n<p>因为我是要用迭代法求<span class=\"math inline\">\\(v =\r\nf(v)\\)</span>的，所以初始的state values: <span\r\nclass=\"math inline\">\\(v_0\\)</span>我是已知的。所以相当于初始的action\r\nvalues: <span class=\"math inline\">\\(q_0\\)</span>我是已知的，将<span\r\nclass=\"math inline\">\\(\\sum_{a} \\pi(a|s) q(s,a)\\)</span>展开：<span\r\nclass=\"math inline\">\\(\\pi(a_1|s)q_0(s,a_1) + \\pi(a_2|s)q_0(s,a_2) +\r\n\\cdots\\)</span>。</p>\r\n<p>显然要使上面那一坨最大，我就要使最大那个q值最大的action: <span\r\nclass=\"math inline\">\\(a&#39;\\)</span>，让其权重分配为1: <span\r\nclass=\"math inline\">\\(\\pi(a&#39;|s)=1\\)</span>。其余权重都为0即可。</p>\r\n<p>那么这样就求出了<span class=\"math inline\">\\(\\max_{\\pi} \\sum_{a}\r\n\\pi(a|s) q(s,a)\\)</span>，问题解决。</p>\r\n<p>至此，我们已经可以通过BOE：<span class=\"math inline\">\\(v =\r\nf(v)\\)</span>，求出最优state value: <span\r\nclass=\"math inline\">\\(v^*\\)</span>以及对应的最优policy: <span\r\nclass=\"math inline\">\\(\\pi^*\\)</span>，算法如下：</p>\r\n<ol type=\"1\">\r\n<li>设定好<span class=\"math inline\">\\(\\gamma\\)</span>，<span\r\nclass=\"math inline\">\\(r\\)</span>，<span\r\nclass=\"math inline\">\\(p(r|s,a)\\)</span>，<span\r\nclass=\"math inline\">\\(p(s&#39;|s,a)\\)</span></li>\r\n<li>随意取一个<span class=\"math inline\">\\(v_0\\)</span>，然后通过<span\r\nclass=\"math inline\">\\(q_\\pi(s, a) = \\sum_{r}p(r|s, a)r + \\gamma\r\n\\sum_{s&#39;}p(s&#39; | s, a)v_\\pi(s&#39;)\\)</span>算出对应的<span\r\nclass=\"math inline\">\\(q_0\\)</span></li>\r\n<li>For each state <span class=\"math inline\">\\(s_i\\)</span>, at time\r\n<span class=\"math inline\">\\(k\\)</span>：\r\n<ul>\r\n<li>算出<span class=\"math inline\">\\(q_{k}(s_i, a)\\)</span></li>\r\n<li>Find the <span class=\"math inline\">\\(a_k^*(s_i)\\)</span>, s.t, <span\r\nclass=\"math inline\">\\(q_k(s_i, a_k^*(s_i))\\)</span>最大</li>\r\n<li><span class=\"math inline\">\\(\\pi_{k+1}(a|s_i)=\\begin{cases} 1 \\quad\r\na=a_k^*(s_i) \\\\ 0 \\quad a \\ne a_k^*(s_i) \\end{cases}\\)</span></li>\r\n<li><span class=\"math inline\">\\(v_{k+1}(s_i) =\r\n\\sum_{a}\\pi_{k+1}(a|s)q_k(s,a)\\)</span></li>\r\n</ul></li>\r\n</ol>\r\n<p>这一小节的内容非常非常重要，\r\n对后续做数值仿真以及理解RL的基本思想很有意义。其实不难理解，静下心，多看几遍。</p>\r\n<p>至此我们可以回答开头的那几个问题：</p>\r\n<ol type=\"1\">\r\n<li>最优policy当然存在。因为根据fixed point theorem，我们知道<span\r\nclass=\"math inline\">\\(v^*\\)</span>存在且唯一，那么其对应的policy就是<span\r\nclass=\"math inline\">\\(\\pi^*\\)</span></li>\r\n<li>不一定唯一。我们只能保证<span\r\nclass=\"math inline\">\\(v^*\\)</span>存在且唯一，但是其对应的policy不一定唯一。因为初始<span\r\nclass=\"math inline\">\\(v_0\\)</span>会不同</li>\r\n<li>根据我们的algorithm，显然<span\r\nclass=\"math inline\">\\(\\pi^*\\)</span>是deterministic的</li>\r\n<li>根据上面给出的algorithm，即可得到最优策略</li>\r\n</ol>\r\n<h4 id=\"gamma-r的选择\"><span class=\"math inline\">\\(\\gamma,\r\nr\\)</span>的选择</h4>\r\n<p>通过前面的所学，我们知道我们需要确定好<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>, <span\r\nclass=\"math inline\">\\(r\\)</span>, <span\r\nclass=\"math inline\">\\(p(r|s,a)\\)</span>, <span\r\nclass=\"math inline\">\\(p(s&#39;|s,a)\\)</span>, <span\r\nclass=\"math inline\">\\(v_0\\)</span>，即可通过BOE求解出<span\r\nclass=\"math inline\">\\(v^*, \\pi^*\\)</span></p>\r\n<p><span class=\"math inline\">\\(v_0\\)</span>是随便设定的，不用管；<span\r\nclass=\"math inline\">\\(p(r|s,a)\\)</span>, <span\r\nclass=\"math inline\">\\(p(s&#39;|s,a)\\)</span>通常是先验已知的，所以也不用管。</p>\r\n<p>所以关键就是<span class=\"math inline\">\\(\\gamma,\r\nr\\)</span>这俩参数的选择会给我们的<span class=\"math inline\">\\(v_*,\r\n\\pi^*\\)</span>带来什么样的影响。</p>\r\n<p><img src=\"9.png\" style=\"zoom:67%;\" /></p>\r\n<p>看上面这个参数设置，算出来的<span\r\nclass=\"math inline\">\\(\\pi^*\\)</span>左图，<span\r\nclass=\"math inline\">\\(v^*\\)</span>右图。可以发现，对于红色的几个点，它们都选择穿过forbidden到达target\r\ncell。这是因为<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>的取值比较大，policy会比较远视。不会太计较短期的得失，而是考虑长期的回报。</p>\r\n<p><img src=\"10.png\" style=\"zoom:67%;\" /></p>\r\n<p>看上面这个参数设置，<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>变小了，所以policy会比较计较近处的得失，所以会绕过forbidden\r\ncell。</p>\r\n<p><img src=\"11.png\" style=\"zoom:67%;\" /></p>\r\n<p>再来看这个图，它的参数设置与第一幅图一样，但是把forbidden的惩罚增加了。这样同样可以达到绕过forbidden\r\ncell的效果。</p>\r\n<p>这里补充一个知识，就是<span\r\nclass=\"math inline\">\\(r\\)</span>如果统一进行线性变化：<span\r\nclass=\"math inline\">\\(r&#39; = ar +\r\nb\\)</span>，其余条件不变的情况下，<span\r\nclass=\"math inline\">\\(\\pi^*\\)</span>是不会有任何改变的。具体证明见书。</p>\r\n<h4 id=\"总结-1\">总结</h4>\r\n<p>这一节所说的BOE就是在bellman equation前套了个<span\r\nclass=\"math inline\">\\(\\max_\\pi\\)</span></p>\r\n<p>最重要的是要掌握fixed point theorem + Policy optimality\r\ntheorem，这样就知道了为啥通过迭代即可算出来最优<span\r\nclass=\"math inline\">\\(v^*, \\pi^*\\)</span>了</p>\r\n<p>然后还需要掌握迭代算法的流程：</p>\r\n<ol type=\"1\">\r\n<li>设定好<span class=\"math inline\">\\(\\gamma\\)</span>，<span\r\nclass=\"math inline\">\\(r\\)</span>，<span\r\nclass=\"math inline\">\\(p(r|s,a)\\)</span>，<span\r\nclass=\"math inline\">\\(p(s&#39;|s,a)\\)</span></li>\r\n<li>随意取一个<span class=\"math inline\">\\(v_0\\)</span>，然后通过<span\r\nclass=\"math inline\">\\(q_\\pi(s, a) = \\sum_{r}p(r|s, a)r + \\gamma\r\n\\sum_{s&#39;}p(s&#39; | s, a)v_\\pi(s&#39;)\\)</span>算出对应的<span\r\nclass=\"math inline\">\\(q_0\\)</span></li>\r\n<li>For each state <span class=\"math inline\">\\(s_i\\)</span>, at time\r\n<span class=\"math inline\">\\(k\\)</span>：\r\n<ul>\r\n<li>算出<span class=\"math inline\">\\(q_{k}(s_i, a)\\)</span></li>\r\n<li>Find the <span class=\"math inline\">\\(a_k^*(s_i)\\)</span>, s.t, <span\r\nclass=\"math inline\">\\(q_k(s_i, a_k^*(s_i))\\)</span>最大</li>\r\n<li><span class=\"math inline\">\\(\\pi_{k+1}(a|s_i)=\\begin{cases} 1 \\quad\r\na=a_k^*(s_i) \\\\ 0 \\quad a \\ne a_k^*(s_i) \\end{cases}\\)</span></li>\r\n<li><span class=\"math inline\">\\(v_{k+1}(s_i) =\r\n\\sum_{a}\\pi_{k+1}(a|s)q_k(s,a)\\)</span></li>\r\n</ul></li>\r\n</ol>\r\n<p>最后，要知道参数<span class=\"math inline\">\\(\\gamma,\r\nr\\)</span>的选择会对policy产生什么样的影响。</p>\r\n","categories":["1. 科研","强化学习"]},{"title":"微分方程1","url":"/2024/09/18/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B1/","content":"<p>几何法解一阶ODE、欧拉数值法解一阶ODE、分离变量法解一阶ODE、解标准一阶线性ODE、换元法解伯努利方程+一阶齐次ODE、一阶自治ODE图像分析</p>\r\n<span id=\"more\"></span>\r\n<p>mit 18.03 Arthur Mattuck教授讲的微分方程。</p>\r\n<hr />\r\n<h3 id=\"导言\">导言</h3>\r\n<p>常微分方程（ordinary differential equation,\r\nODE）：函数的自变量只有一个，通常是时间</p>\r\n<p>举个最简单的例子，考虑平抛问题中的垂直方向，向下为正。</p>\r\n<p><span class=\"math inline\">\\(\\because \\dot{v} = g \\quad \\therefore v =\r\ngt + v_0\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\because \\dot{y} = v = gt + v_0 \\quad\r\n\\therefore y = \\frac12gt^2 + v_0t + y_0\\)</span></p>\r\n<p>上面这个简单的例子，其实就是在求解微分方程：<span\r\nclass=\"math inline\">\\(\\ddot{y} = g\\)</span></p>\r\n<p>这个微分方程非常简单，且求解非常容易。但往往实际中的大部分问题，你只能列出微分方程，但是却无法精确求解它。例如下面单摆这个例子：</p>\r\n<p><img src=\"1.png\" style=\"zoom:50%;\" /></p>\r\n<p>规定以中间垂直线为标准，向右边的角度为正，左边为负。考虑切向加速度<span\r\nclass=\"math inline\">\\(a\\)</span>，加速度前的负号表示它总指向与位移相反的方向。</p>\r\n<p>可以根据图片写出一些公式： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n    \\because x &amp;= L\\theta \\\\\r\n    \\because a &amp;= -g\\sin \\theta \\\\\r\n    \\therefore \\ddot{x} &amp;= -g\\sin\\theta \\\\\r\n    \\therefore L\\ddot{\\theta} &amp;= -g\\sin\\theta \\\\\r\n    \\therefore \\ddot{\\theta} &amp;= -\\frac{g}{L}\\sin\\theta\r\n\\end{align*}\r\n\\]</span> 我们成功写出了一个关于<span\r\nclass=\"math inline\">\\(\\theta(t)\\)</span>的微分方程。为了更加负号实际，我们引入空气阻力，于是微分方程变为：\r\n<span class=\"math display\">\\[\r\n\\ddot{\\theta} = -\\mu\\dot{\\theta} - \\frac{g}{L}\\sin\\theta\r\n\\]</span>\r\n很好。单摆这个微分方程，是十分难求解的。既然我们求不出它的解析解，那我们如果仅通过这个方程窥探摆运动的规律呢？</p>\r\n<p>既然上面那个微分方程体现了摆的运动，那我们先将这个微分方程可视化出来，具体来说，我们可以以x轴为<span\r\nclass=\"math inline\">\\(\\theta\\)</span>，y轴为<span\r\nclass=\"math inline\">\\(\\dot{\\theta}\\)</span>。即有向量坐标<span\r\nclass=\"math inline\">\\((\\theta,\r\n\\dot{\\theta})\\)</span>。对向量坐标求导，得到<span\r\nclass=\"math inline\">\\((\\dot{\\theta},\r\n\\ddot{\\theta})\\)</span>向量，它表示了当前该坐标在图上变化的方向和大小。</p>\r\n<p>这样子的话，我们对平面上所有坐标<span class=\"math inline\">\\((\\theta,\r\n\\dot{\\theta})\\)</span>，把对应的<span\r\nclass=\"math inline\">\\((\\dot{\\theta},\r\n\\ddot{\\theta})\\)</span>向量平移到以<span class=\"math inline\">\\((\\theta,\r\n\\dot{\\theta})\\)</span>为起点上来。就可以得到一副这样的图：</p>\r\n<p><img src=\"2.png\" style=\"zoom:50%;\" /></p>\r\n<p>（为了保持美观，向量的长度保持了一样，通过颜色来区分向量的长度）</p>\r\n<p>这幅图会引发我们很多的思考，可以发现，原点代表着摆的角度和角加速度都为0，即静止状态。通过旋流来看显然最后的状态都会回归静止状态，这是符合实际的。我们还会发现，在<span\r\nclass=\"math inline\">\\((\\pi, 0)\\)</span>位置的旋流是静止的，说明<span\r\nclass=\"math inline\">\\((\\pi,\r\n0)\\)</span>是个不动点。那它代表什么物理含义呢？它代表小球在正上方保持平衡。well，根据实际我们可以知道，这确实是个可保持静止的地方，但但凡受到一点扰动，就会打破这个平衡。</p>\r\n<p>所以我们可以得出结论：<span class=\"math inline\">\\((0, 0), (\\pi,\r\n0)\\)</span>都是不动点，但<span class=\"math inline\">\\((0,\r\n0)\\)</span>是稳定点，而<span class=\"math inline\">\\((\\pi,\r\n0)\\)</span>不是。</p>\r\n<p>非常有趣！问题来了，如何绘制出这一幅图？</p>\r\n<p>我们已知的是微分方程为<span class=\"math inline\">\\(\\ddot{\\theta} =\r\n-\\mu\\dot{\\theta} - \\frac{g}{L}\\sin\\theta\\)</span>，且坐标<span\r\nclass=\"math inline\">\\((\\theta, \\dot{\\theta})\\)</span>上的向量为<span\r\nclass=\"math inline\">\\((\\dot{\\theta}, \\ddot{\\theta})\\)</span>。</p>\r\n<p>那么我们可以任意选取某点<span class=\"math inline\">\\((\\theta_0,\r\n\\dot{\\theta}_0)\\)</span>，然后根据微分方程算出<span\r\nclass=\"math inline\">\\(\\ddot{\\theta}\\)</span>。即可得到当前坐标上的向量<span\r\nclass=\"math inline\">\\((\\dot{\\theta}_0,\r\n\\ddot{\\theta}_0)\\)</span>。这个向量就体现了该坐标的移动趋势，所以我们将该坐标朝着对应向量方向移动一个小距离<span\r\nclass=\"math inline\">\\(\\Delta t\\)</span>，即可得到新点<span\r\nclass=\"math inline\">\\((\\theta_1,\r\n\\dot{\\theta_1})\\)</span>。重复这个步骤，即可画出一条轨迹。多次取不同的初始点进行绘制，即可得到若干条轨迹。全部的轨迹合起来就是上述那张图。</p>\r\n<p>Well，讲到这里，相信你已经感受到微分方程的魅力了。通过小小方程，即可窥探事物运行的规律，没有比这更令人兴奋的事情了！</p>\r\n<h3 id=\"一.-ode几何方法\">一. ODE几何方法</h3>\r\n<p>如何用作图描述ODE呢？</p>\r\n<p>使用方向场。跟前言中使用的方法类似，假设目前我们有：<span\r\nclass=\"math inline\">\\(y&#39; = f(x, y)\\)</span></p>\r\n<p>那我们可以作一幅二维图，x轴就是x，y轴就是y，坐标<span\r\nclass=\"math inline\">\\((x,\r\ny)\\)</span>上是一个短线（称为\"线素\"），这条短线的斜率就是<span\r\nclass=\"math inline\">\\(y&#39;\\)</span></p>\r\n<p>那么，画出一条与所有线素相切的曲线，就是微分方程<span\r\nclass=\"math inline\">\\(y&#39;=f(x,\r\ny)\\)</span>的一个解，称之为\"积分曲线\"</p>\r\n<p>这显然是正确的，因为对于一条画出来的曲线，其任意一点都与线素相切，说明其斜率也就是<span\r\nclass=\"math inline\">\\(y&#39;\\)</span>跟给定的<span\r\nclass=\"math inline\">\\(y&#39;=f(x,y)\\)</span>一致，也就是这条曲线符合微分方程，所以它自然就是解。</p>\r\n<p>例如这个微分方程：<span class=\"math inline\">\\(y&#39; =\r\n-\\frac{x}{y}\\)</span>。它用方向场画出来的积分曲线如下：</p>\r\n<p><img src=\"3.png\" style=\"zoom:67%;\" /></p>\r\n<p>（<span class=\"math inline\">\\(C = 0\\)</span> means <span\r\nclass=\"math inline\">\\(y&#39; = 0\\)</span>）</p>\r\n<p>再来一个例子：<span class=\"math inline\">\\(y&#39; = 1 + x -\r\ny\\)</span></p>\r\n<p><img src=\"4.png\" /></p>\r\n<p>注意到在<span class=\"math inline\">\\(C=2\\)</span>和<span\r\nclass=\"math inline\">\\(C=0\\)</span>两条之间的区域，当积分曲线进入这个区域后就再也出不去了，解函数无法逃逸。另一个需要注意的要点是，积分曲线永远不会相交。如果两曲线相交的话，则在交点处就会有两条切线、两个斜率，这与微分方程不符。因此进入此区域的曲线，无法逃逸也无法相交，只能够互相靠近，朝向<span\r\nclass=\"math inline\">\\(y=x\\)</span>的直线靠拢。</p>\r\n<p>事实上，在方向场上的积分曲线满足\"存在与唯一性定理\"：</p>\r\n<ul>\r\n<li>存在性：若<span class=\"math inline\">\\(y\\)</span>在<span\r\nclass=\"math inline\">\\((x_0, y_0)\\)</span>的领域内连续，则通过<span\r\nclass=\"math inline\">\\((x_0, y_0)\\)</span>的<span\r\nclass=\"math inline\">\\(y&#39;=f(x, y)\\)</span>有解。</li>\r\n<li>唯一性：若<span class=\"math inline\">\\(y&#39;\\)</span>在<span\r\nclass=\"math inline\">\\((x_0, y_0)\\)</span>的领域为连续，则通过<span\r\nclass=\"math inline\">\\((x_0, y_0)\\)</span>的<span\r\nclass=\"math inline\">\\(y&#39; = f(x, y)\\)</span>有且仅有唯一解。</li>\r\n</ul>\r\n<h3 id=\"二.-ode欧拉数值法及推广\">二. ODE欧拉数值法及推广</h3>\r\n<p>欧拉数值法解微分方程其实就是导言里用的方法。对于微分方程：<span\r\nclass=\"math inline\">\\(y&#39; = f(x,\r\ny)\\)</span>，如何在图上求出其中某条曲线(解)呢？首先你先得确定一个初始点<span\r\nclass=\"math inline\">\\((x_0,\r\ny_0)\\)</span>，然后从初始点出发，一步一步画出曲线。</p>\r\n<p>对于坐标<span class=\"math inline\">\\((x,\r\ny)\\)</span>，求导后可得到<span class=\"math inline\">\\((1,\r\ny&#39;)\\)</span>向量，这个向量就是从<span class=\"math inline\">\\((x,\r\ny)\\)</span>出发的移动趋势向量。朝着这个向量的方法走一个步长，一直迭代下去，就可以得到用欧拉数值法拟合出来的曲线。</p>\r\n<p>那么移动后的坐标是多少呢？假设步长为<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>，那么可以得到公式<span\r\nclass=\"math inline\">\\(f(x_k, y_k)\\)</span>为函数在<span\r\nclass=\"math inline\">\\(x_k\\)</span>处的导数： <span\r\nclass=\"math display\">\\[\r\n\\begin{cases}\r\n    x_{k+1} = x_k + \\alpha \\\\\r\n    y_{k+1} = y_k + \\alpha \\cdot f(x_k, y_k)\r\n\\end{cases}\r\n\\]</span>\r\n上面的方法就叫一阶欧拉数值法。（一阶的意思是你求了一次导数）</p>\r\n<p>即如果你确定了初始点<span class=\"math inline\">\\((x_0,\r\ny_0)\\)</span>和微分方程<span class=\"math inline\">\\(y&#39;=f(x,\r\ny)\\)</span>，那么通过此方法就可求出以<span class=\"math inline\">\\((x_0,\r\ny_0)\\)</span>为初始点且满足微分方程的曲线。</p>\r\n<hr />\r\n<p>这个方法好不好呢？</p>\r\n<p>当然是有的，显然我们知道，步长越小越精确。但再怎么精确，如果真正的函数是曲线的话，欧拉数值法也是得不到真正解的。</p>\r\n<p>例如下面这个图，在<span class=\"math inline\">\\((x_k,\r\ny_k)\\)</span>处是凸的(因为<span class=\"math inline\">\\(y&#39;&#39; &gt;\r\n0\\)</span>)，所以在此点迭代的下一个<span\r\nclass=\"math inline\">\\(y_{k+1}\\)</span>是小于真正的<span\r\nclass=\"math inline\">\\(y\\)</span>的。</p>\r\n<p><img src=\"5.png\" /></p>\r\n<p>同理，如果某点的<span class=\"math inline\">\\(y&#39;&#39; &lt;\r\n0\\)</span>，那么在<span class=\"math inline\">\\((x_k,\r\ny_k)\\)</span>便是凹的，因此在该点迭代的下一个<span\r\nclass=\"math inline\">\\(y_{k+1}\\)</span>是大于真正的<span\r\nclass=\"math inline\">\\(y\\)</span>的。</p>\r\n<p>我们知道了数值法并不能求精确解，但是我们会希望误差最小。</p>\r\n<p>所以步长与误差之间的关系是什么呢？答案是<span class=\"math inline\">\\(e\r\n\\sim c\\alpha\\)</span>，<span\r\nclass=\"math inline\">\\(c\\)</span>是一个常数，即误差近似与步长为线性关系。</p>\r\n<hr />\r\n<p>那么能不能使这个误差<span\r\nclass=\"math inline\">\\(e\\)</span>小点呢？</p>\r\n<p>有的，求多几次导数就好了，例如我现在在<span\r\nclass=\"math inline\">\\((x_k, y_k)\\)</span>，然后通过该点的导数<span\r\nclass=\"math inline\">\\(y&#39;_1\\)</span>可迭代处<span\r\nclass=\"math inline\">\\((\\hat{x}_{k+1},\\hat{y}_{k+1})\\)</span>，然后我可以得到<span\r\nclass=\"math inline\">\\((\\hat{x}_{k+1},\\hat{y}_{k+1})\\)</span>的导数<span\r\nclass=\"math inline\">\\(y&#39;_2\\)</span>。</p>\r\n<p>于是我将<span class=\"math inline\">\\(\\frac{y&#39;_1 +\r\ny&#39;_2}{2}\\)</span>作为<span\r\nclass=\"math inline\">\\(y&#39;\\)</span>，然后在<span\r\nclass=\"math inline\">\\((x_k, y_k)\\)</span>基础上迭代出<span\r\nclass=\"math inline\">\\((x_{k+1}, y_{k+1})\\)</span>。</p>\r\n<p>这样得到的<span class=\"math inline\">\\((x_{k+1},\r\ny_{k+1})\\)</span>会更加接近真实解。</p>\r\n<p>从几何上理解也很直观，相当于取了两次方向向量的中间作为新的方向向量，然后朝着新方向向量移动一小步，这样的偏差会比原先的一阶欧拉数值法小。</p>\r\n<p>因为在这个方法中，我们算了两次导数，所以该方法叫做二阶欧拉数值法。其误差与步长的关系是：<span\r\nclass=\"math inline\">\\(e \\sim c\\alpha^2\\)</span></p>\r\n<hr />\r\n<p>同理，我们还可以求三步、四步的信息(导数)，这样误差就会进一步缩小。但是由此带来的问题是计算复杂度变大。所以天下没有免费的午餐。通常在计算机绘制微分方程解时，都是采用的四阶欧拉数值法。</p>\r\n<hr />\r\n<p>欧拉数值法有没有局限性呢？显然是有的，当解函数不是连续的，而存在“奇点”时，欧拉数值法在越过奇点之后将无法拟合出正确的曲线，例如下图这个真实解函数：</p>\r\n<p><img src=\"6.png\" style=\"zoom: 50%;\" /></p>\r\n<h3 id=\"三.-一阶ode解析法\">三. 一阶ODE解析法</h3>\r\n<p>前面两节我们分别通过几何法（画线素）和欧拉数值法求解了ODE。这一节我们将用解析的方式求解一阶线性ODE。</p>\r\n<h4 id=\"可分离变量的一阶ode\">可分离变量的一阶ODE</h4>\r\n<p>我们把能写为：<span class=\"math inline\">\\(y&#39; =\r\nf(x)g(y)\\)</span>形式的微分方程，称为一阶ODE。</p>\r\n<p>那么，x放一边，y放一边，两边同时积分，即可求出答案： <span\r\nclass=\"math display\">\\[\r\n\\because \\frac{dy}{dx} = f(x)g(y) \\\\\r\n\\therefore \\frac{1}{g(y)}dy = f(x)dx \\\\\r\n\\therefore \\int \\frac{1}{g(y)}dy = \\int f(x)dx \\\\\r\n\\]</span> 例题：求<span class=\"math inline\">\\(y&#39; = y\\sin\r\nx\\)</span>的通解 <span class=\"math display\">\\[\r\n\\text{when } y \\ne 0, \\text{one has } \\frac{1}{y}dy = y\\sin x \\\\\r\n\\therefore \\int \\frac{1}{y}dy = \\int \\sin x dx \\\\\r\n\\therefore \\ln |y| = -\\cos x + c \\\\\r\n\\therefore |y| = e^{-\\cos x} \\cdot e^c \\\\\r\n\\therefore y = \\pm c \\cdot e^{-\\cos x} \\\\\r\n\\therefore y = c \\cdot e^{-\\cos x}, c \\ne 0 \\\\\r\n\\text{when } y = 0, \\text{it can pass the check.} \\\\\r\n\\therefore y = c \\cdot e^{-\\cos x}, c \\ne 0\r\n\\]</span></p>\r\n<h4 id=\"一阶线性ode\">一阶线性ODE</h4>\r\n<p>可以写成：<span class=\"math inline\">\\(a(x)y&#39; + b(x)y =\r\nc(x)\\)</span>，的方程叫做一阶ODE。</p>\r\n<p>为什么叫“线性”呢？因为<span\r\nclass=\"math inline\">\\(y&#39;\\)</span>和<span\r\nclass=\"math inline\">\\(y\\)</span>呈线性关系，所以这样叫了。跟这种方程的感觉很像：<span\r\nclass=\"math inline\">\\(ax + by = c\\)</span></p>\r\n<p>如果<span\r\nclass=\"math inline\">\\(c(x)\\)</span>为0那么上面的方程可以称为“齐次方程”</p>\r\n<p>但上面的形式是一阶线性ODE的通式，其标准形式如下： <span\r\nclass=\"math display\">\\[\r\ny&#39; + p(x)y = q(x)\r\n\\]</span></p>\r\n<hr />\r\n<p>一阶线性ODE在实际应用中很广泛，例如传导—扩散模型。</p>\r\n<p>这个模型名字的来源是来自于两个物理现象，首先是温度传导现象：</p>\r\n<p><img src=\"8.png\" style=\"zoom:50%;\" /></p>\r\n<p>外头是某种液体，中间可能是某种介质，外边套了层铁皮。那么如果<span\r\nclass=\"math inline\">\\(T\\)</span>与<span\r\nclass=\"math inline\">\\(T_e\\)</span>不同，则会发生温度传导现象，由牛顿温度传导定律，可得到如下方程：<span\r\nclass=\"math inline\">\\(\\frac{dT}{dt} = k(T_e - T), k &gt; 0\\)</span></p>\r\n<p>以及浓度扩散现象：</p>\r\n<p><img src=\"7.png\" style=\"zoom:50%;\" /></p>\r\n<p>外头是某种液体，中间也是某种液体，外边套了层半透膜。那么如果<span\r\nclass=\"math inline\">\\(C\\)</span>与<span\r\nclass=\"math inline\">\\(C_e\\)</span>不同，则会发生浓度扩散现象，同样可得到方程：<span\r\nclass=\"math inline\">\\(\\frac{dC}{dt} = k(C_e - C), k &gt; 0\\)</span></p>\r\n<p>这就是传导—扩散模型，让我们用一个一般的数学式子来描述它： <span\r\nclass=\"math display\">\\[\r\n\\begin{cases}\r\n&amp;T&#39; + kT = kT_e \\\\\r\n&amp;k = p(t) \\\\\r\n&amp;kT_e = q(t)\r\n\\end{cases}\r\n\\]</span>\r\n显然，上面的式子显然是标准一阶线性ODE的写法，我们可以将其视为：<span\r\nclass=\"math inline\">\\(y&#39; + p(x)y = q(x)\\)</span></p>\r\n<hr />\r\n<p>知道了一阶线性ODE的定义，以及标准形式，以及实际生活中的建模运用。现在我们想知道的，就是如何求解它。\r\n<span class=\"math display\">\\[\r\ny&#39; + py = q \\quad(1)\r\n\\]</span> <span class=\"math inline\">\\(p, q\\)</span>均为关于<span\r\nclass=\"math inline\">\\(x\\)</span>的函数，我想找到一个关于<span\r\nclass=\"math inline\">\\(x\\)</span>的函数<span\r\nclass=\"math inline\">\\(u\\)</span>，使得(1)同时左乘<span\r\nclass=\"math inline\">\\(u\\)</span>后，能使得左边的部分可以化简为<span\r\nclass=\"math inline\">\\((uy)\\)</span>的导数，let's try： <span\r\nclass=\"math display\">\\[\r\nuy&#39; + upy = uq \\quad (2)\r\n\\]</span> <span class=\"math inline\">\\(\\because (uy)&#39; = uy&#39; +\r\nu&#39;y\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore u&#39; = up \\quad\r\n(3)\\)</span></p>\r\n<p>也就是我们想到的这个<span\r\nclass=\"math inline\">\\(u\\)</span>，满足(3)</p>\r\n<p>(3)是可通过分离变量解的，因为<span\r\nclass=\"math inline\">\\(\\frac{du}{dx} = up(x)\\)</span>，整理得：<span\r\nclass=\"math inline\">\\(\\frac{1}{u}du = p(x)dx\\)</span></p>\r\n<p>可解出：<span class=\"math inline\">\\(u = e^{\\int p(d)dx}\\)</span></p>\r\n<p>ok，将算出的这个<span\r\nclass=\"math inline\">\\(u\\)</span>回代进(2)里，我们则可以得到： <span\r\nclass=\"math display\">\\[\r\n(uy)&#39; = uq\r\n\\]</span> 于是我们可以解出<span\r\nclass=\"math inline\">\\(uy\\)</span>为多少，然后方程就没有求导项了，整理下即可求出<span\r\nclass=\"math inline\">\\(y\\)</span></p>\r\n<p>思路总结：</p>\r\n<ol type=\"1\">\r\n<li>求出<span class=\"math inline\">\\(u = e^{\\int p(x)dx}\\)</span></li>\r\n<li>把<span class=\"math inline\">\\(u\\)</span>左乘<span\r\nclass=\"math inline\">\\(y&#39; + py = q\\)</span>，方程左边可变为<span\r\nclass=\"math inline\">\\((uy)&#39;\\)</span></li>\r\n<li>解<span class=\"math inline\">\\((uy)&#39; = uq\\)</span></li>\r\n</ol>\r\n<hr />\r\n<p><strong>例1.</strong> <span class=\"math inline\">\\(xy&#39; - y =\r\nx^3\\)</span></p>\r\n<p>首先先化为标准形式：<span class=\"math inline\">\\(y&#39; - \\frac1x y =\r\nx^2\\)</span></p>\r\n<p>然后求出<span class=\"math inline\">\\(u = e^{\\int p(d)dx} = e^{\\int\r\n-\\frac1x dx} = e^{-\\ln x} = \\frac1x\\)</span></p>\r\n<p>对标准形式左乘<span class=\"math inline\">\\(u\\)</span>：<span\r\nclass=\"math inline\">\\((uy)&#39; = (\\frac1x \\cdot y)&#39; = \\frac1x \\cdot\r\nx^2 = x\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\frac{y}{x} = \\frac12 x^2 +\r\nc\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore y = \\frac12 x^3 +\r\ncx\\)</span></p>\r\n<p><strong>例2.</strong> <span class=\"math inline\">\\((1 + \\cos x)y&#39;\r\n- (\\sin x)y = 2x\\)</span></p>\r\n<p>首先先化为标准形式：<span class=\"math inline\">\\(y&#39; - \\frac{\\sin\r\nx}{1 + \\cos x}y = \\frac{2x}{1 + \\cos x}\\)</span></p>\r\n<p>然后求出<span class=\"math inline\">\\(u = e^{-\\int \\frac{\\sin x}{1 +\r\n\\cos x}dx} = 1 + \\cos x\\)</span></p>\r\n<p>对标准形式左乘<span class=\"math inline\">\\(u\\)</span>：<span\r\nclass=\"math inline\">\\((uy)&#39; = ((1 + \\cos x)y)&#39; = 2x\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore (1 + \\cos x)y = x^2 +\r\nc\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore y = \\frac{x^2 + c}{1 + \\cos\r\nx}\\)</span></p>\r\n<p><strong>例3.</strong> <span class=\"math inline\">\\(T&#39; + kT = kT_e,\r\nk &gt; 0\\text{ is a constant. } T_e\\text{ is a function of\r\n}x\\)</span></p>\r\n<p>已经是标准形式了</p>\r\n<p>然后求出<span class=\"math inline\">\\(u = e^{\\int k dt} =\r\ne^{kt}\\)</span></p>\r\n<p>对标准形式左乘<span class=\"math inline\">\\(u\\)</span>：<span\r\nclass=\"math inline\">\\((uT)&#39; = (e^{kt}T)&#39; = kT_e\r\ne^{kt}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore e^{kt}T = k\\int T_e e^{kt}\r\n\\mathrm{d}t + c\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore T = ke^{-kt}\\int T_e e^{kt}\r\n\\mathrm{d}t + ce^{-kt}\\)</span></p>\r\n<p>如果有实际物理意义，即<span\r\nclass=\"math inline\">\\(t\\)</span>从0开始，并且给定<span\r\nclass=\"math inline\">\\(T(0) = T_0\\)</span>。那么<span\r\nclass=\"math inline\">\\(T\\)</span>的积分下限就是0，上限就是<span\r\nclass=\"math inline\">\\(t\\)</span>。而且还可得到<span\r\nclass=\"math inline\">\\(c = T_0\\)</span>。则：</p>\r\n<p><span class=\"math inline\">\\(T(t) = ke^{-kt}\\int_0^t T_e(x) e^{kx}\r\n\\mathrm{d}x + T_0e^{-kt}\\)</span></p>\r\n<p>可以发现，如果<span class=\"math inline\">\\(t \\to\r\n\\infty\\)</span>时，因为<span class=\"math inline\">\\(k &gt;\r\n0\\)</span>，所以<span\r\nclass=\"math inline\">\\(T_0e^{-kt}\\)</span>会收敛到0。</p>\r\n<p>因此<span\r\nclass=\"math inline\">\\(T_0e^{-kt}\\)</span>叫做“暂态解”，<span\r\nclass=\"math inline\">\\(ke^{-kt}\\int_0^t\r\nT_e(x)e^{kx}dx\\)</span>叫做“稳态解”</p>\r\n<p>而且我们发现，当<span class=\"math inline\">\\(t \\to\r\n\\infty\\)</span>时，<span class=\"math inline\">\\(T\\)</span>与初始状态<span\r\nclass=\"math inline\">\\(T_0\\)</span>无关。</p>\r\n<h3 id=\"四.-一阶方程换元法\">四. 一阶方程换元法</h3>\r\n<p>这类方程： <span class=\"math display\">\\[\r\ny&#39;=p(x)y + q(x)y^{n}, n \\ne 0\r\n\\]</span> 叫做“伯努利方程”。解它用换元法，如下：</p>\r\n<p>同除<span class=\"math inline\">\\(y^n\\)</span>，得：<span\r\nclass=\"math inline\">\\(\\frac{y&#39;}{y^n} =\r\n\\frac{p(x)}{y^{n-1}}+q(x)\\)</span></p>\r\n<p>令<span class=\"math inline\">\\(v =\r\n\\frac{1}{y^{n-1}}\\)</span>，则有：<span class=\"math inline\">\\(v&#39; =\r\n(1-n)y^{-n} \\cdot y&#39;\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\frac{v&#39;}{1-n} = p(x)v +\r\nq(x)\\)</span></p>\r\n<p>发现，线性方程出现了，那么可先解出v，然后回代解出y即可</p>\r\n<p><strong>例题. </strong><span class=\"math inline\">\\(y&#39; =\r\n\\frac{y}{x} - y^2\\)</span></p>\r\n<p>同除<span class=\"math inline\">\\(y^2\\)</span>，得：<span\r\nclass=\"math inline\">\\(\\frac{y&#39;}{y^2} = x^{-1}y^{-1} - 1\\)</span></p>\r\n<p>令<span class=\"math inline\">\\(v = y^{-1}\\)</span>，则：<span\r\nclass=\"math inline\">\\(v&#39; = (-1)y^{-2} \\cdot y&#39;\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore -v&#39; = \\frac{v}{x} -\r\n1\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore v&#39; + \\frac{v}{x} =\r\n1\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore u = e^{\\int \\frac1x dx} =\r\nx\\)</span></p>\r\n<p>左乘<span class=\"math inline\">\\(u\\)</span>，得：<span\r\nclass=\"math inline\">\\((uv)&#39; = (xv)&#39; = x\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore xv = \\frac12x^2 +\r\nc\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore v = \\frac12x +\r\n\\frac{c}{x}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\frac1y = \\frac{x^2 +\r\n2c}{2x}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore y =\r\n\\frac{2x}{x^2+2c}\\)</span></p>\r\n<hr />\r\n<p>第二类用换元法解的ODE，叫一阶齐次ODE，形如： <span\r\nclass=\"math display\">\\[\r\ny&#39; = f(\\frac{y}{x})\r\n\\]</span> 即等式右边的基本原子都是<span\r\nclass=\"math inline\">\\(\\frac{y}{x}\\)</span></p>\r\n<p>一阶齐次ODE的套路是先换元然后分离变量解决。</p>\r\n<p><strong>例题. </strong>\r\n有一个贩毒船，还有一个灯塔，灯塔会对船射出光线，但是船不想被照到，于是船始终保持与光线成45°角一直逃窜，请求出船的运行轨迹。</p>\r\n<p><img src=\"9.png\" style=\"zoom:50%;\" /></p>\r\n<p>根据图，可以列出方程： <span class=\"math display\">\\[\r\ny&#39; = \\tan (\\frac{\\pi}{4} + \\alpha) = \\frac{\\tan \\frac{\\pi}{4} + \\tan\r\n\\alpha}{1 - \\tan \\frac{\\pi}{4}\\tan \\alpha} = \\frac{1 + \\tan \\alpha}{1 -\r\n\\tan \\alpha} = \\frac{1 + y/x}{1 - y/x}\r\n\\]</span> 令<span class=\"math inline\">\\(v =\r\n\\frac{y}{x}\\)</span>，则<span class=\"math inline\">\\(y =\r\nxv\\)</span>，<span class=\"math inline\">\\(y&#39; = v +\r\nxv&#39;\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore v + xv&#39; = \\frac{1 + v}{1 -\r\nv}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore v + x\\frac{dv}{dx} = \\frac{1 +\r\nv}{1 - v}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore x\\frac{dv}{dx} = \\frac{v^2 +\r\n1}{1 - v}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\frac{x}{dx} = \\frac{v^2 +\r\n1}{(1 - v)dv}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\frac{1}{x}dx = \\frac{1 -\r\nv}{v^2 + 1}dv\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\int \\frac1x dx = \\int \\frac{1\r\n- v}{v^2 + 1} dv\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\ln |x| = \\arctan v - \\frac12\r\n\\ln(v^2 + 1) + c\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\ln |x| = \\arctan \\frac{y}{x}\r\n- \\frac12\\ln ((\\frac{y}{x})^2 + 1) + c\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\arctan \\frac{y}{x} = \\ln\r\n\\sqrt{x^2 + y^2} + c\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\theta = \\ln r +\r\nc\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore r = ce^\\theta, c &gt;\r\n0\\)</span></p>\r\n<p>上述方程又称为“指数螺旋线”，优美。</p>\r\n<h3 id=\"五.-一阶自治ode\">五. 一阶自治ODE</h3>\r\n<p>回顾一下，前面我们已经学会了用几何法一阶ODE（画线素），然后又学了数值法求一阶ODE；</p>\r\n<p>然后，学了用分离变量法解一阶ODE，以及学会了用通法解决形如<span\r\nclass=\"math inline\">\\(y&#39; + p(x)y = q(x)\\)</span>的一阶ODE；</p>\r\n<p>以及，学会了用换元法解决“伯努利ODE“和“一阶齐次ODE”。</p>\r\n<p>现在我们再来学一种形如：<span class=\"math inline\">\\(y&#39; =\r\nf(y)\\)</span>的一阶ODE解法，这种方程我们称为自治的，因为右侧仅仅由y组成不涉及x。</p>\r\n<p>当然分离变量法可以解这个方程，但是我们不是想解它，只是想分析一下它的图像性质。</p>\r\n<p>核心思路就是：画两张图，第一张图是“x-y图”，第二张图是“y-f(y)”图。</p>\r\n<hr />\r\n<p>下面举一个Logistic equation with\r\nharvesting的例子（例如渔场养鱼捕鱼，<span\r\nclass=\"math inline\">\\(y\\)</span>是鱼量，<span\r\nclass=\"math inline\">\\(t\\)</span>是时间，<span\r\nclass=\"math inline\">\\(h\\)</span>是捕获量）： <span\r\nclass=\"math display\">\\[\r\n\\frac{dy}{dt} = (a - by)y - h\r\n\\]</span> 首先令右边为：<span class=\"math inline\">\\(f(y) = ay - by^2 -\r\nh\\)</span></p>\r\n<p>然后画出<span class=\"math inline\">\\(f(y)-y\\)</span>图：</p>\r\n<p><img src=\"10.png\" style=\"zoom:80%;\" /></p>\r\n<p>可以看出，与x轴有俩交点，分别令值为<span class=\"math inline\">\\(a,\r\nb\\)</span></p>\r\n<p>然后可以继续画出<span class=\"math inline\">\\(y-t\\)</span>图：</p>\r\n<p><img src=\"11.png\" style=\"zoom: 67%;\" /></p>\r\n<p>可以看出，a和b都是“临界点”。因为一旦<span class=\"math inline\">\\(y =\r\na\\)</span>或<span class=\"math inline\">\\(b\\)</span>，那么<span\r\nclass=\"math inline\">\\((x, y)\\)</span>将一直在<span\r\nclass=\"math inline\">\\(y=a\\)</span>或<span\r\nclass=\"math inline\">\\(b\\)</span>这条线上移动，用数值法的作图方法简单即可知道。</p>\r\n<p>那么，我们会抛出疑问，虽然a和b都是临界点，但是谁是稳定的呢？</p>\r\n<p>显然可以看出，b是稳定的，因为上下都趋向于它，a是不稳定的，因为上下都远离它。</p>\r\n<p>对于实际意义来说，就是如果维持当前的捕获量<span\r\nclass=\"math inline\">\\(h\\)</span>，那么只需要保证初始鱼量&gt;a，即可保证一定时间后，鱼量收敛于b。</p>\r\n<p>那么，如果我是农场主，我肯定希望捕获量<span\r\nclass=\"math inline\">\\(h\\)</span>尽可能高，当<span\r\nclass=\"math inline\">\\(h\\)</span>高时，上面那个二次函数会下移，如果移的太多了，那么整个函数在定义域都是下降的了，那么鱼量会一直下降到负无穷。所以我们要提高<span\r\nclass=\"math inline\">\\(h\\)</span>，使得二次函数图像刚刚好与x轴有一个交点，值记为<span\r\nclass=\"math inline\">\\(c\\)</span>的时候停止。此时的<span\r\nclass=\"math inline\">\\(y-t\\)</span>图如下：</p>\r\n<p><img src=\"12.png\" style=\"zoom:67%;\" /></p>\r\n<p>可以看出，只要你保证最开始的鱼量&gt;c，那么最终你的鱼量会收敛于c，而且你的捕获量<span\r\nclass=\"math inline\">\\(h\\)</span>此时是最高的。</p>\r\n<hr />\r\n<p>OK，上面那个例子非常有趣right？</p>\r\n<p>但是你可能会注意到一点，为什么图像都是平移相同的？</p>\r\n<p>因为对于自治方程，等号右边等于<span\r\nclass=\"math inline\">\\(y&#39;\\)</span>，而且等号右边仅仅与<span\r\nclass=\"math inline\">\\(y\\)</span>有关，如果我们确定了一个<span\r\nclass=\"math inline\">\\(y_0\\)</span>，那么这条水平线上的线素都相同。所以说，你自己画画就知道，一阶自治ODE的图像是这种平移相同的了。</p>\r\n","categories":["4. 大学","数学","微分方程"]},{"title":"强化学习2","url":"/2024/10/06/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A02/","content":"<p>值/策略迭代算法、蒙特卡洛</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"一.-值策略迭代算法\">一. 值/策略迭代算法</h3>\r\n<h4 id=\"值迭代算法\">值迭代算法</h4>\r\n<p>其实在BOE那一章的结尾我已经给出了值迭代算法的流程了：</p>\r\n<ol type=\"1\">\r\n<li>设定好<span class=\"math inline\">\\(\\gamma\\)</span>，<span\r\nclass=\"math inline\">\\(r\\)</span>，<span\r\nclass=\"math inline\">\\(p(r|s,a)\\)</span>，<span\r\nclass=\"math inline\">\\(p(s&#39;|s,a)\\)</span></li>\r\n<li>随意取一个<span class=\"math inline\">\\(v_0\\)</span>，然后通过<span\r\nclass=\"math inline\">\\(q_\\pi(s, a) = \\sum_{r}p(r|s, a)r + \\gamma\r\n\\sum_{s&#39;}p(s&#39; | s, a)v_\\pi(s&#39;)\\)</span>算出对应的<span\r\nclass=\"math inline\">\\(q_0\\)</span></li>\r\n<li>For each state <span class=\"math inline\">\\(s_i\\)</span>, at time\r\n<span class=\"math inline\">\\(k\\)</span>：\r\n<ul>\r\n<li>算出<span class=\"math inline\">\\(q_{k}(s_i, a)\\)</span></li>\r\n<li>Find the <span class=\"math inline\">\\(a_k^*(s_i)\\)</span>, s.t, <span\r\nclass=\"math inline\">\\(q_k(s_i, a_k^*(s_i))\\)</span>最大</li>\r\n<li><span class=\"math inline\">\\(\\pi_{k+1}(a|s_i)=\\begin{cases} 1 \\quad\r\na=a_k^*(s_i) \\\\ 0 \\quad a \\ne a_k^*(s_i) \\end{cases}\\)</span></li>\r\n<li><span class=\"math inline\">\\(v_{k+1}(s_i) =\r\n\\sum_{a}\\pi_{k+1}(a|s)q_k(s,a)\\)</span></li>\r\n</ul></li>\r\n</ol>\r\n<p>现在，用正式的语言描述这个algorithm： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n&amp;\\textbf{Initialization: }\\text{The probability model $p(r|s,a)$ and\r\n$p(s&#39;|s,a)$ for all $(s,a)$ are known. Initial guess $v_0$.} \\\\\r\n&amp;\\text{At time $k$, do} \\\\\r\n&amp;\\quad\\quad \\text{For every state $s \\in \\mathcal{S}$, do} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{q-value: $q_k(s,a)=\\sum_{r}p(r|s,a)r +\r\n\\gamma \\sum_{s&#39;}p(s&#39;|s,a)v_k(s&#39;)$} \\\\\r\n&amp;\\quad\\quad \\text{Maximum action value: $a_k^*(s) =\r\n\\text{argmax}_{a}q_k(a,s)$} \\\\\r\n&amp;\\quad\\quad \\text{Policy update: $\\pi_{k+1}(a|s)=1$ if $a=a_k^*(s)$,\r\nand $\\pi_{k+1}(a|s)=0$ otherwise} \\\\\r\n&amp;\\quad\\quad \\text{Value update: $v_{k+1}=q_k(a_k^*(s), s)$}\r\n\\end{align*}\r\n\\]</span></p>\r\n<h4 id=\"策略迭代算法\">策略迭代算法</h4>\r\n<p>思想就是首先先初始化一个策略，然后先得到该策略下的state\r\nvalue（即Policy evaluation, PE），然后得到state\r\nvalue后就可以算出对应的action value，然后选择action\r\nvalue最大的action，即优化当前policy（Policy\r\nimprovement），得到新的policy。依次类推下去，最终即可得到<span\r\nclass=\"math inline\">\\(\\pi^*, v^*\\)</span>。</p>\r\n<p>用正式的语言描述这个algorithm： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n&amp;\\textbf{Initialization: }\\text{The probability model $p(r|s,a)$ and\r\n$p(s&#39;|s,a)$ for all $(s,a)$ are known. Initial guess $\\pi_0$.} \\\\\r\n&amp;\\text{At time $k$, do} \\\\\r\n&amp;\\quad\\quad \\text{Policy evaluation:} \\\\\r\n&amp;\\quad\\quad \\text{Initialization: an arbitrary initial guess\r\n$v_{\\pi_k}^{(0)}$} \\\\\r\n&amp;\\quad\\quad \\text{While $v_{\\pi_k}^{(j)}$ has not converged, for the\r\n$j$th iteration, do} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{For every state $s \\in \\mathcal{S}$, do}\r\n\\\\\r\n&amp;\\quad\\quad\\quad\\quad\\quad\\quad v_{\\pi_k}^{(j)}(s) =\r\n\\sum_{a}\\pi_k(a|s)\\left[ \\sum_{r}p(r|s,a)r +\r\n\\gamma\\sum_{s&#39;}p(s&#39;|s,a)v_{\\pi_k}^{(j)}(s&#39;) \\right] \\\\\r\n&amp;\\quad\\quad \\text{Policy improvement:} \\\\\r\n&amp;\\quad\\quad \\text{For every state $s \\in \\mathcal{S}$, do} \\\\\r\n&amp;\\quad\\quad\\quad\\quad q_{\\pi_k}(s,a) = \\sum_{r}p(r|s,a)r +\r\n\\gamma\\sum_{s&#39;}p(s&#39;|s,a)v_{\\pi_k}(s&#39;) \\\\\r\n&amp;\\quad\\quad a_k^*(s) = \\text{argmax}_{a}q_{\\pi_k}(s,a) \\\\\r\n&amp;\\quad\\quad \\text{$\\pi_{k+1}(a|s) = 1$ if $a = a_k^*(s)$, and\r\n$\\pi_{k+1}(a|s)=0$ otherwise}\r\n\\end{align*}\r\n\\]</span></p>\r\n<h4 id=\"两者比较\">两者比较</h4>\r\n<p>值迭代算法是从一个初始state value开始，有了state\r\nvalue，就可以算出action value，进而得出当前最优策略，然后去更新state\r\nvalue，依次类推。</p>\r\n<p>策略迭代算法是从一个初始policy开始，然后通过迭代算法求出当前policy下的最优state\r\nvalue，然后再通过state value得到action\r\nvalue，进而更新当前最优策略。依次类推。</p>\r\n<p>可以发现，不同点就在于，同样是得到一个policy，值迭代是立马用其代入bellman-equation算出迭代一次后的state\r\nvalue。而策略迭代是代入bellman-equation迭代很多次算出的state\r\nvalue。所以直观上来说，策略迭代的收敛次数会更少，但是单次计算量会更大。</p>\r\n<p><img src=\"1.png\" style=\"zoom:50%;\" /></p>\r\n<h3 id=\"二.-蒙特卡洛\">二. 蒙特卡洛</h3>\r\n<h4 id=\"引入\">引入</h4>\r\n<p>前面的值/策略迭代算法都是model-based\r\nRL，蒙特卡洛是我们接触到的第一个model-free的方法。</p>\r\n<p>model不知道的时候怎么办呢？蒙特卡洛其实就是大量采样，用样本的分布来估计model的分布。</p>\r\n<p>蒙特卡洛，Monte Carlo，MC。</p>\r\n<h4 id=\"mc-basic\">MC Basic</h4>\r\n<p>MC\r\nBasic算法其实就跟policy迭代算法一样，只不过把policy迭代算法里的model-based部分，即计算<span\r\nclass=\"math inline\">\\(v_{\\pi_k},\r\nq_{\\pi_k}\\)</span>的部分，换成了依靠采样直接算出基于一个策略<span\r\nclass=\"math inline\">\\(\\pi_{k}\\)</span>的<span\r\nclass=\"math inline\">\\(q_{\\pi_k}\\)</span>。第二步policy\r\nimprovement就一样了。</p>\r\n<p>原本policy迭代算法里求<span\r\nclass=\"math inline\">\\(q_{\\pi_k}\\)</span>是依赖于这个公式：<span\r\nclass=\"math inline\">\\(q_{\\pi_k}(s,a)=\\sum_{r}p(r|s,a)r +\r\n\\gamma\\sum_{s&#39;}p(s&#39;|s,a)v_{\\pi_k}(s&#39;)\\)</span></p>\r\n<p>但是MC Basic算<span\r\nclass=\"math inline\">\\(q_{\\pi_k}\\)</span>是依赖于它的原始定义：<span\r\nclass=\"math inline\">\\(q_{\\pi_k}(s,a)=\\mathbb{E}(G_t | S_t = s, A_t =\r\na)\\)</span></p>\r\n<p>即对于state-action pairs, 通过大量采样估计出所有的<span\r\nclass=\"math inline\">\\(q_{\\pi_k}(s,a)\\)</span>，然后再进行policy\r\nimprovement。</p>\r\n<p>用数学语言来描述如下： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n&amp;\\textbf{Initialization: }\\text{Initial guess $\\pi_0$.} \\\\\r\n&amp;\\text{At time $k$, do} \\\\\r\n&amp;\\quad\\quad \\text{For every state $s \\in \\mathcal{S}$, do} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{For every action $a \\in \\mathcal{A}(s)$,\r\ndo} \\\\\r\n&amp;\\quad\\quad\\quad\\quad\\quad\\quad \\text{Collect sufficiently many\r\nepisodes starting from $(s,a)$ following $\\pi_k$} \\\\\r\n&amp;\\quad\\quad\\quad\\quad\\quad\\quad \\text{$q_{\\pi_k}(s,a)=$ average\r\nreturn of all the episodes starting from $(s,a)$} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{Policy improvement step:} \\\\\r\n&amp;\\quad\\quad\\quad\\quad a_k^*(s) = \\text{argmax}_{a}q_{\\pi_k}(s,a) \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{$\\pi_{k+1}(a|s)=1$ if $a=a_k^*()s$, and\r\n$\\pi_{k+1}(a|s)=0$ otherwise}\r\n\\end{align*}\r\n\\]</span> 很简单，right？</p>\r\n<p>为啥这里要用episode这个词而非trajectory这个词呢？因为trajectory可能是无限的，而采样是离散的，所以通常我们设置一个采样长度上限，那么每采样一条trajectory其实就是有限的，也叫一条episode。</p>\r\n<h4 id=\"mc-exploring-starts\">MC Exploring Starts</h4>\r\n<p>MC Exploring Starts其实就是对MC Basic算法的一个时间复杂度优化。</p>\r\n<p>MC Basic是对每一个<span class=\"math inline\">\\((s,a)\\)</span>\r\npair都采样很多episode来估计其<span class=\"math inline\">\\(q_{\\pi_k}(s,\r\na)\\)</span>，采样的途中可能会路过很多其余的<span\r\nclass=\"math inline\">\\((s&#39;,a&#39;)\\)</span>\r\npair，其实采样出来的return也可以用来估计它们的action\r\nvalue。下面这个图就可以很好的解释了MC Basic的数据浪费：</p>\r\n<p><img src=\"2.png\" style=\"zoom: 67%;\" /></p>\r\n<p>看第一条episode，在MC\r\nBasic算法里那么一长条episode，我们只用它来估计了<span\r\nclass=\"math inline\">\\((s_1, a_2)\\)</span>的action\r\nvalue。但其实，还可以用来估计<span class=\"math inline\">\\((s_2, a_4),\r\n\\cdots\\)</span>的action value，它们的return之间只差了一个<span\r\nclass=\"math inline\">\\(\\gamma\\)</span>和reward。</p>\r\n<p>所以MC Exploring\r\nStarts就是抓住了这点进行优化，就是类似记忆化搜索的思想 +\r\ndp填表法的思想。它的具体思想如下：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> T;                <span class=\"comment\">// episode的长度</span></span><br><span class=\"line\"><span class=\"type\">int</span> q_sum[][];        <span class=\"comment\">// (s,a)的action value的总和</span></span><br><span class=\"line\"><span class=\"type\">int</span> q_cnt[][];        <span class=\"comment\">// (s,a)的action value的采样次数</span></span><br><span class=\"line\"><span class=\"type\">int</span> q[][];            <span class=\"comment\">// (s,a)的action value</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (如果不想再迭代了) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> 确定起点(s0, a0)，按照当前policy生成一条长度为T的episode，将episode路上的(si, ai, ri)存到vector: path中</span><br><span class=\"line\">       </span><br><span class=\"line\">   <span class=\"type\">int</span> G = <span class=\"number\">0</span>;    <span class=\"comment\">// episode的return</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = path.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">       G = gamma * G + path[i].r;</span><br><span class=\"line\">       q_sum[s][a] += G;</span><br><span class=\"line\">       q_cnt[s][a] += <span class=\"number\">1</span>;</span><br><span class=\"line\">       </span><br><span class=\"line\">       q[s][a] = q_sum[s][a] / q_cnt[s][a];</span><br><span class=\"line\">       更新<span class=\"built_in\">pi</span>(a|s)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>用数学语言描述如下： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n&amp;\\textbf{Initialization: }\\text{ Initial policy $\\pi_0(a|s)$ and\r\ninitial value $q(s,a)$ for all $(s,a)$.} \\\\\r\n&amp;\\quad\\quad\\quad\\quad\\quad\\quad\\quad~\\text{Returns(s,a) = 0 and\r\nNum(s,a) = 0 for all $(s,a)$.} \\\\\r\n&amp;\\text{For each episode, do} \\\\\r\n&amp;\\quad\\quad \\text{Episode generation: Select a starting state-action\r\npair $(s_0, a_0)$}  \\\\\r\n&amp;\\quad\\quad \\text{and ensure that all pairs can be possibly selected\r\n(this is the exploring-starts condition).} \\\\\r\n&amp;\\quad\\quad \\text{Following the current policy, generate an episode\r\nof length $T$: $s_0, a_0, r_1, \\cdots, s_{T-1}, a_{T-1}, r_T$.} \\\\\r\n&amp;\\quad\\quad \\text{Initialization for each episode: $g \\gets 0$} \\\\\r\n&amp;\\quad\\quad \\text{For each step of the episode, $t = T - 1, T - 2,\r\n\\cdots, 0, $ do} \\\\\r\n&amp;\\quad\\quad\\quad\\quad g \\gets \\gamma g + r_{t+1} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{Returns($s_t, a_t$) $\\gets$\r\nReturns($s_t, a_t$) + $g$} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{Policy evaluation:} \\\\\r\n&amp;\\quad\\quad\\quad\\quad q(s_t, a_t) \\gets \\text{Returns($s_t, a_t$) /\r\nNum($s_t,a_t$)} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{Policy improvement:} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{$\\pi(a|s_t)=1$ if $a =\r\n\\text{argmax}_aq(s_t, a)$ and $\\pi(a|s_t)=0$ otherwise}\r\n\\end{align*}\r\n\\]</span> 最后我们来看看这个“Exploring\r\nStarts”是什么意思。Exploring我个人理解就是由于是dp填表法，所以episode就需要自己去生成，也就是exploring的过程。Starts是因为此时的算法不是像MC\r\nBasic样每个state-action\r\npair都去强制估计了，所以为了尽量确保每个state-action都被估计到，每个episode的起点的选法就很有讲究，最好每个state-action都被作为起点选择一次（当然这就退化为MC\r\nBasic了）</p>\r\n<h4 id=\"mc-varepsilon-greedy\">MC <span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>-Greedy</h4>\r\n<p>MC Exploring Starts算法很好，但是它不能保证每个state-action\r\npair都被估计到，所以选多少个episode，每个episode的起点是啥就很有讲究。可能起点选少了直接导致效果不好，选多了又速度慢。</p>\r\n<p>为了解决上述问题，MC <span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>-Greedy 算法应运而生。</p>\r\n<p><span class=\"math inline\">\\(\\varepsilon\\)</span>-Greedy与MC Exploring\r\nStarts的区别就在Policy improvement这一步，MC Exploring\r\nStarts在这一步是直接将最大的action\r\nvalue对应的action的概率设为1其余为0，但是<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>-Greedy是最大的action\r\nvalue对应的action概率设为<span class=\"math inline\">\\(1 -\r\n\\varepsilon\\)</span>，其余的action概率设为<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>。</p>\r\n<p>这样的好处就是不需要对全部的state-action\r\npair都作为起点生成episode，只要生成一些episode（起点随便），并且只要保证这条episode的长度T很长，那你在就几乎可以路过所有state-action\r\npairs，从而估计它们。就不需要从很多不同的起点开始了。</p>\r\n<p>坏处就是通过<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>-Greedy得到的policy并不是最优的，因为它始终带着探索的概率。所以通常我们的做法是：</p>\r\n<p>初始化policy为<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>策略，进行多次episode，每次的episode的<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>递减。这样就可以保证前面的episode随机性很强，从而可以覆盖到大多数state-action\r\npair，但是毕竟我们是要求最优解的，所以后期的episode的<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>就得减小。最后，在通过<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>-Greedy得到一个policy后，还是要将其转为确定性的策略（即不带概率的）。</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>-Greedy这个算法的目的就是为了避免要进行多次全部state-action\r\npair起点选择，仅此而已。它是如何做到的？尝试不是最优的策略，通过尝试不是最优的策略，从而尽可能的，覆盖所有的state-action\r\nparis。所以从原理上，这个算法就是会降低准确率。但是它也很具有实际意义，因为你想啊，你在仿真中设计的算法是要用到实际环境中去的。你的机器人通常就从安全的起点出发开始探索，如果你要让它从全部的state-action开始，那显然不现实。例如深海作业，你都是让robot从浅水区开始，然后让它自己去探索，尽可能覆盖所有state-action\r\npairs。你总不可能让它从深海区开始吧，因为你人类到不了深海区。</p>\r\n<p>下面是用数学描述： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n&amp;\\textbf{Initialization: } \\text{Initial policy $\\pi_0(a|s)$ and\r\ninitial value $q(s,a)$ for all $(s,a)$. Returns(s,a)=0 and Num(s,a)=0}\r\n\\\\\r\n&amp;\\text{for all $(s,a)$. $\\varepsilon \\in (0, 1]$} \\\\\r\n&amp;\\text{For each episode, do} \\\\\r\n&amp;\\quad\\quad \\text{Episode generation: Select a starting state-action\r\npair $(s_0, a_0)$. Following the current policy,} \\\\\r\n&amp;\\quad\\quad \\text{generate an episode of length $T: s_0, a_0, r_1,\r\n\\cdots, s_{T-1}, a_{T-1}, r_T$.} \\\\\r\n&amp;\\quad\\quad \\text{Initialization for each episode: $g \\gets 0$} \\\\\r\n&amp;\\quad\\quad \\text{For each step of the episode, $t = T-1, T-2,\r\n\\cdots, 0,$ do} \\\\\r\n&amp;\\quad\\quad\\quad\\quad g \\gets \\gamma g + r_{t+1} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{Returns($s_t, a_t$) $\\gets$\r\nReturns($s_t, a_t$) + $g$} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{Num($s_t, a_t$) $\\gets$ Num($s_t, a_t$)\r\n+ 1} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{Policy evaluation:} \\\\\r\n&amp;\\quad\\quad\\quad\\quad q(s_t, a_t) \\gets \\text{Returns($s_t, a_t$) /\r\nNum($s_t, a_t$)} \\\\\r\n&amp;\\quad\\quad\\quad\\quad \\text{Let } a^* = \\text{argmax}_a q(s_t, a)\r\n\\text{ and} \\\\\r\n&amp;\\quad\\quad\\quad\\quad\\quad\\quad \\pi(a|s_t) = \\begin{cases}1 -\r\n\\frac{|\\mathcal{A}(s_t)|-1}{|\\mathcal{A}|}\\varepsilon, \\quad a = a^* \\\\\r\n\\frac{1}{|\\mathcal{A}(s_t)|}\\varepsilon, \\quad a \\ne a^* \\end{cases}\r\n\\end{align*}\r\n\\]</span> 个人觉得，<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>-Greedy的探索性与收敛性是严重矛盾的，因为明明已经通过采样得到state-action\r\nvalue值了，只需要一直不断的更新deterministic的策略，就可以收敛了。但是<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>-Greedy为了探索性，会将\"探索\"这个元素，加入进自己的\"策略\"里。所以，就像一个明知道最优解的人，在做事情的时候，仍然小概率选择不是最优的东西。所以，<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>-Greedy\r\n这个算法收敛性，有些靠天。</p>\r\n<h4 id=\"总结\">总结</h4>\r\n<p>我们从model-based的算法（值/策略迭代算法）开始说起，model-based算法的收敛性和最优性都是有保证的，在\"强化学习1\"中有提到证明。</p>\r\n<p>随后我们进入了model-free算法，此时我们只能依靠采样来估计<span\r\nclass=\"math inline\">\\(p(s,a)\\)</span>，所以MC\r\nBasic只要采样数量无限大，那么其准确性和收敛性也是可以得到保证的。</p>\r\n<p>但是MC Basic效率太慢了，为此MC Exploring\r\nStarts应运而生，运用了记忆化的思想加速了收敛。只要保证每个action-pair都被大量采样到，该算法也能保证准确性和收敛性。</p>\r\n<p>但是问题就是为了保证“每个action-pair都被大量采样到”，MC Exploring\r\nStarts就需要从不同的action-pair起点去生成episode进行采样。而现实环境中这是有难度的，例如你不能让机器人从深海区开始，一般都是从浅水区开始。</p>\r\n<p>所以MC <span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>-Greedy算法应运而生，增加了\"探索\"机制，从而不必使每一个action-pair都要作为起点去生成episode进行采样。但是因为探索是直接加到policy里，所以该算法的准确率会下降，甚至收敛都不一定。不过这对未来的算法具有启发意义。</p>\r\n","categories":["1. 科研","强化学习"]},{"title":"微分方程2","url":"/2024/10/02/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B2/","content":"<p>复数、复化解一阶常系数线性ODE、二阶常系数齐次线性ODE、二阶齐次线性ODE相关理论、二阶非齐次线性ODE相关理论</p>\r\n<span id=\"more\"></span>\r\n<hr />\r\n<h3 id=\"一.-复数和复指数\">一. 复数和复指数</h3>\r\n<p>”数学就是一场符号的游戏，实际问题都是运用符号建的模。“</p>\r\n<p>复数同理，虚部有什么实际含义吗？我想，目前暂且无需关心，当实际遇到需要建模的时候再谈。</p>\r\n<p>那么，虚数就是<span class=\"math inline\">\\(i\\)</span>，且满足<span\r\nclass=\"math inline\">\\(i^2 = 1\\)</span>。</p>\r\n<p>所以复数可以这么表达：<span class=\"math inline\">\\(a +\r\nbi\\)</span>，其中<span class=\"math inline\">\\(a\\)</span>是实部，<span\r\nclass=\"math inline\">\\(bi\\)</span>是虚部。这是复数的代数表达形式。</p>\r\n<p>聪明的人类希望可视化复数，于是用复平面（其实就是坐标系）来描述复数：</p>\r\n<p><img src=\"1.png\" style=\"zoom: 50%;\" /></p>\r\n<p>当我们把复数放到复平面的时候，我们就可以用坐标来描述一个复数：（a,\r\nb），<del>虽然没有啥人这么描述就是了。</del></p>\r\n<p>人们更喜欢用极坐标去描述，因为在复平面上，如果知道了<span\r\nclass=\"math inline\">\\(\\theta\\)</span>和<span\r\nclass=\"math inline\">\\(r\\)</span>，那么相当于就知道了一个复数。</p>\r\n<p>可以发现，对于复数<span class=\"math inline\">\\(a +\r\nbi\\)</span>，其模<span class=\"math inline\">\\(r = \\sqrt{a^2 +\r\nb^2}\\)</span>，其辐角<span class=\"math inline\">\\(\\theta = \\arctan\r\n\\frac{b}{a}\\)</span></p>\r\n<p>所以，假设我知道了一个复数的模和辐角，那么其可以表示为：<span\r\nclass=\"math inline\">\\(r(\\cos \\theta + i\\sin\r\n\\theta)\\)</span>，这就是复数的极坐标表达形式。</p>\r\n<p>Hummm，仍然不够简洁，right？</p>\r\n<p>欧拉站出来了，给出了欧拉公式：<span class=\"math inline\">\\(\\cos \\theta\r\n+ i\\sin \\theta = e^{i\\theta}\\)</span></p>\r\n<p>我觉得欧拉公式不要从等价推导的角度去理解它，而是要从映射的角度去理解它。如果两个东西，不管外界对它们对什么样的刺激，它们产生的影响都是相同的，那从抽象的角度我们就可以认为这两个东西是等价的。上面那个公式说的就是这么个事情。</p>\r\n<p>欧拉公式的右侧，也就是指数，我们很熟悉了right？其至少满足两个性质：</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(e^x \\cdot e^y = e^{x + y}\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\frac{dy}{dx} = ay, \\quad y =\r\ne^{ax}\\)</span></li>\r\n</ol>\r\n<p>那么假设欧拉公式是正确的，去推一推指数的这两个性质，发现也是满足的，那么我们就有理由的认为，这两者在抽象层面上是“等价的”，即这个公式是正确的。\r\n<span class=\"math display\">\\[\r\n\\begin{align*}\r\n&amp;~~~~(\\cos \\theta_1 + i\\sin \\theta_1)(\\cos \\theta_2 + i\\sin\r\n\\theta_2) \\\\\r\n&amp;=\\cos \\theta_1 \\cos \\theta_2 - \\sin \\theta_1 \\sin \\theta_2 + i(\\sin\r\n\\theta_1 \\cos \\theta_2 + \\cos \\theta_1 \\sin \\theta_2) \\\\\r\n&amp;=\\cos(\\theta_1 + \\theta_2) + i\\sin(\\theta_1 + \\theta_2) \\\\\r\n&amp;=e^{i(\\theta_1 + \\theta_2)} \\\\\r\n\\end{align*}\r\n\\]</span>\r\n所以我们有理由说明，这个公式是正确的（严谨的证明这里没必要讨论）。</p>\r\n<p>所以，有了欧拉公式的加持，我们可以将复数的极坐标形式改写，得到：<span\r\nclass=\"math inline\">\\(re^{i\\theta}\\)</span>，这就是复数的指数表达形式。</p>\r\n<p>至此，对于一个复数，我们有了三种表达方式：</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(a + bi\\)</span></li>\r\n<li><span class=\"math inline\">\\(r(\\cos \\theta + i \\sin \\theta), r =\r\n\\sqrt{a^2 + b^2}, \\theta = \\arctan \\frac{b}{a}\\)</span></li>\r\n<li><span class=\"math inline\">\\(re^{i\\theta}, r = \\sqrt{a^2 + b^2},\r\n\\theta = \\arctan \\frac{b}{a}\\)</span></li>\r\n</ol>\r\n<hr />\r\n<p>复数很有用，我们来看两个例子。</p>\r\n<p>第一个是求解<span class=\"math inline\">\\(\\int e^{-x}\\cos\r\nx\\mathrm{d}x\\)</span></p>\r\n<p>常规做法是两次分部积分法，但是可以将积分”复化“来做。</p>\r\n<p>将<span class=\"math inline\">\\(\\cos x\\)</span>看作是复数<span\r\nclass=\"math inline\">\\(e^{i\\theta}\\)</span>的实部，不妨记为<span\r\nclass=\"math inline\">\\(Re(e^{ix})\\)</span></p>\r\n<p>复数如果乘一个实数，那么就是实部虚部分别乘这个实数，所以<span\r\nclass=\"math inline\">\\(e^{-x}\\cos x\\)</span>，其实就是<span\r\nclass=\"math inline\">\\(e^{-x} \\cdot\r\ne^{ix}\\)</span>这个复数的实部，即<span class=\"math inline\">\\(Re(e^{-x +\r\nix})\\)</span></p>\r\n<p>那么积分可写为：<span class=\"math inline\">\\(\\int Re(e^{-x + ix})\r\n\\mathrm{d}x\\)</span></p>\r\n<p><span class=\"math inline\">\\(Re\\)</span>可提到积分号外面：<span\r\nclass=\"math inline\">\\(Re \\int e^{-x + ix} \\mathrm{d}x\\)</span></p>\r\n<p>于是可得：<span class=\"math inline\">\\(Re(\\frac{1}{i-1}e^{-x + ix} +\r\nc)\\)</span></p>\r\n<p>即求复数<span class=\"math inline\">\\(\\frac{1}{i-1}e^{-x +\r\nix}\\)</span>的实部，（最后记得加个c），整理：<span\r\nclass=\"math inline\">\\(e^{-x} \\cdot \\frac{\\cos x + i\\sin x}{i-1} = e^{-x}\r\n\\cdot \\frac{\\cos x - \\sin x + i(\\cos x + \\sin x)}{-2}\\)</span></p>\r\n<p>由于我们只需要实部，所以答案就是：<span class=\"math inline\">\\(e^{-x}\r\n\\cdot \\frac{\\cos x - \\sin x}{-2} + c\\)</span></p>\r\n<p>Humm，巧妙。</p>\r\n<hr />\r\n<p>再来看一个例子，我们知道，对于<span\r\nclass=\"math inline\">\\(\\sqrt[n]{1}\\)</span>，在实数范围内，如果n是奇数，那么只有一个解1，如果是正数，那么解为<span\r\nclass=\"math inline\">\\(\\pm1\\)</span>。</p>\r\n<p>但是在复数域，<span\r\nclass=\"math inline\">\\(\\sqrt[n]{1}\\)</span>有n个解，这是很容易解释的，用复平面就可以很好的解释。</p>\r\n<p>因为对于俩复数相乘，即<span class=\"math inline\">\\(r_1e^{i\\theta_1}\r\n\\cdot r_2e^{i\\theta_2} =\r\nr_1r_2e^{i(\\theta_1+\\theta_2)}\\)</span>，在复平面上来看，其实就是模相乘作为新的模，然后辐角相加作为新的辐角。</p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\sqrt[n]{1}\\)</span>的解，其实就是n个自己相乘，最后在复平面上落到（1，0）处。</p>\r\n<p>因为单位圆上的复数的模都是1，所以无需考虑模了。只需考虑辐角，哪些辐角的单位复数，n次自乘后会落到（1，0）？</p>\r\n<p>答案是：<span class=\"math inline\">\\(e^{i \\cdot 2\\pi \\cdot\r\n\\frac{k}{n}}, k = 1,2,\\cdots,n\\)</span></p>\r\n<p>即这n个复数，它们的n次方就是实数1。（从复平面角度考虑，模永远是1，但是辐角相加n次后都为<span\r\nclass=\"math inline\">\\(2\\pi\\)</span>的倍数）</p>\r\n<p>这n个复数恰好是单位圆上的n等分点。</p>\r\n<h3 id=\"二.-复化解带三角函数的一阶常系数线性ode\">二.\r\n复化解带三角函数的一阶常系数线性ODE</h3>\r\n<p>在“微分方程1”中“一阶ODE解析法”的例3中，我们介绍了这种特殊的一阶线性ODE，其系数是常数，即一阶常系数线性ODE：\r\n<span class=\"math display\">\\[\r\ny&#39; + ky = kq(t)\r\n\\]</span> 因为它毕竟是一阶线性ODE，所以可以用通法去解它。</p>\r\n<p>在例3中，我们已经解出其通解为：<span class=\"math inline\">\\(\\therefore\r\nT = ke^{-kt}\\int q(t) e^{kt} \\mathrm{d}t + ce^{-kt}\\)</span></p>\r\n<p>但是当<span\r\nclass=\"math inline\">\\(q(t)\\)</span>为三角函数的时候，其实还可以将其“复化”去解决。</p>\r\n<p>下面做一道例题：<span class=\"math inline\">\\(y&#39; + ky = k\\cos\r\nwt\\)</span></p>\r\n<p>看到三角函数，直接把它复化了：<span class=\"math inline\">\\(y&#39; + ky\r\n= k Re(e^{iwt})\\)</span></p>\r\n<p>一直带着<span\r\nclass=\"math inline\">\\(Re\\)</span>有点烦，所以不妨将方程左侧的解先换为“复数解”，则有：<span\r\nclass=\"math inline\">\\(\\tilde{y}&#39; + k\\tilde{y} =\r\nke^{iwt}\\)</span></p>\r\n<p>利用解一阶ODE的通法，解出<span class=\"math inline\">\\(u = e^{\\int kdx}\r\n= e^{kt}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore (u\\tilde{y})&#39; = ke^{iwt +\r\nkt}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore e^{kt} \\cdot \\tilde{y} =\r\n\\frac{k}{iw + k}e^{iwt + kt} + c\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\tilde{y} = \\frac{1}{1 +\r\ni(\\frac{w}{k})}e^{iwt} + c\\)</span></p>\r\n<p>所以要不然就把<span class=\"math inline\">\\(\\frac{1}{1 +\r\ni(\\frac{w}{k})}\\)</span>转为指数形式，要不然就把<span\r\nclass=\"math inline\">\\(e^{iwt}\\)</span>转为<span class=\"math inline\">\\(a\r\n+ bi\\)</span>形式。</p>\r\n<p>这里我们选用前者去做，<span class=\"math inline\">\\(1 +\r\ni\\frac{w}{t}\\)</span>是复数，<span class=\"math inline\">\\(\\frac{1}{1 +\r\ni\\frac{w}{t}}\\)</span>显然也是复数，问题是它的模和辐角是多少？</p>\r\n<p>因为复数相乘本质就是模相乘，辐角相加，而我们又知道<span\r\nclass=\"math inline\">\\(\\frac{1}{1 + i\\frac{w}{t}} \\cdot (1 +\r\ni\\frac{w}{t}) = 1\\)</span> <span class=\"math display\">\\[\r\n\\therefore \\begin{cases}\r\n    \\arg(\\alpha) + \\arg(\\frac{1}{\\alpha}) = \\arg(1) = 0 \\\\\r\n    \\mod(\\alpha) \\cdot \\mod(\\frac{1}{\\alpha}) = \\mod(1) = 1 \\\\\r\n    \\alpha = 1 + i\\frac{w}{t}\r\n\\end{cases}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\therefore \\begin{cases}\r\n    \\arg(\\frac{1}{\\alpha}) = -\\arctan\\frac{w}{t} = - \\phi \\\\\r\n    \\mod(\\frac{1}{\\alpha}) = \\frac{1}{\\sqrt{1 + (\\frac{w}{t})^2}}\r\n\\end{cases}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\frac{1}{1 + i(\\frac{w}{t})} =\r\n\\frac{1}{\\sqrt{1 + (\\frac{w}{t})^2}}e^{-i\\phi}, \\phi =\r\n\\arctan\\frac{w}{t}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\tilde{y} = \\frac{1}{\\sqrt{1 +\r\n(\\frac{w}{t})^2}}e^{i(wt-\\phi)} + c\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore y = Re(\\tilde{y}) =\r\n\\frac{1}{\\sqrt{1 + (\\frac{w}{t})^2}} \\cdot \\cos(wt - \\phi) + c, \\quad\r\n\\phi = \\arctan\\frac{w}{t}\\)</span></p>\r\n<hr />\r\n<p>ok，那现在换一种做法，也就是把<span\r\nclass=\"math inline\">\\(e^{iwt}\\)</span>转为<span class=\"math inline\">\\(a\r\n+ bi\\)</span>形式。</p>\r\n<p>回到这一步：<span class=\"math inline\">\\(\\therefore \\tilde{y} =\r\n\\frac{1}{1 + i(\\frac{w}{k})}e^{iwt} + c\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\tilde{y} = \\frac{1 -\r\ni(\\frac{w}{k})}{1 + (\\frac{w}{k})^2} \\cdot (\\cos wt + i\\sin wt) +\r\nc\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\tilde{y} = \\frac{1}{1 +\r\n(\\frac{w}{k})^2} \\cdot (\\cos wt + \\frac{w}{k}\\sin wt) + c\\)</span></p>\r\n<blockquote>\r\n<p>补充：辅助角公式</p>\r\n<p><span class=\"math inline\">\\(a\\cos \\alpha + b\\sin \\alpha = \\sqrt{a^2 +\r\nb^2}\\cos(\\alpha - \\phi), \\phi = \\arctan\\frac{b}{a}\\)</span></p>\r\n<p>证明：</p>\r\n<p><span class=\"math inline\">\\(a\\cos \\alpha + b\\sin\r\n\\alpha\\)</span>可以表示为<span class=\"math inline\">\\((a - bi)(\\cos\r\n\\alpha + i\\sin \\alpha)\\)</span>的实部</p>\r\n<p>将这个复数指数化：<span class=\"math inline\">\\(\\sqrt{a^2 +\r\nb^2}e^{-i\\theta} \\cdot e^{i\\alpha} = \\sqrt{a^2 + b^2} \\cdot e^{i(\\alpha\r\n- \\theta)}\\)</span></p>\r\n<p>所以这个复数的实部就是：<span class=\"math inline\">\\(\\sqrt{a^2 +\r\nb^2}\\cos(\\alpha - \\theta), \\theta =\r\n\\arctan\\frac{n}{a}\\)</span>，证毕。</p>\r\n<p>为什么复数指数化的时候是<span\r\nclass=\"math inline\">\\(-\\theta\\)</span>？因为我们考虑符号的正负很烦，所以通常我们都假设<span\r\nclass=\"math inline\">\\(a, b&gt;0\\)</span>去做，那么复数<span\r\nclass=\"math inline\">\\(a -\r\nbi\\)</span>就在复平面的下方，那么对应的辐角就是一个负的，因为<span\r\nclass=\"math inline\">\\(\\phi =\r\n\\arctan\\frac{b}{a}\\)</span>在假设下为正，所以要给它加个负号</p>\r\n</blockquote>\r\n<p><span class=\"math inline\">\\(\\therefore \\tilde{y} = \\frac{1}{1 +\r\n(\\frac{w}{k})^2} \\cdot \\sqrt{1 + (\\frac{w}{k})^2} \\cdot \\cos(wt - \\phi)\r\n+ c, \\phi = \\arctan\\frac{w}{k}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore \\tilde{y} = \\frac{1}{\\sqrt{1 +\r\n(\\frac{w}{k})^2}} \\cdot \\cos(wt - \\phi) + c, \\quad \\phi =\r\n\\arctan\\frac{w}{t}\\)</span></p>\r\n<h3 id=\"三.-二阶常系数齐次线性ode\">三. 二阶常系数齐次线性ODE</h3>\r\n<p>前面学习了：</p>\r\n<ol type=\"1\">\r\n<li>一阶线性ODE：<span class=\"math inline\">\\(y&#39; + p(x)y =\r\nq(x)\\)</span></li>\r\n<li>伯努利方程：<span class=\"math inline\">\\(y&#39; = p(x)y +\r\nq(x)y^n\\)</span></li>\r\n<li>一阶齐次ODE：<span class=\"math inline\">\\(y&#39; =\r\nf(\\frac{y}{x})\\)</span></li>\r\n<li>一阶自治ODE：<span class=\"math inline\">\\(y&#39; = f(y)\\)</span></li>\r\n<li>一阶常系数线性ODE：<span class=\"math inline\">\\(y&#39; + ky =\r\nkq(x)\\)</span></li>\r\n</ol>\r\n<p>今天来学习形如<span class=\"math inline\">\\(y&#39;&#39; + Ay&#39; + By\r\n=\r\n0\\)</span>的方程，因为方程右边是0，所以叫齐次，所以这类方程叫：“二阶常系数齐次线性ODE”</p>\r\n<p>首先先说结论，对于二阶ODE，其通解必然为：<span\r\nclass=\"math inline\">\\(y = c_1y_1 + c_2y_2\\)</span>，<span\r\nclass=\"math inline\">\\(y_1,\r\ny_2\\)</span>线性无关。想起了线性代数right？Ahahah</p>\r\n<p>那么想解<span class=\"math inline\">\\(y&#39;&#39; + Ay&#39; + By =\r\n0\\)</span>，我们的任务就是找出<span class=\"math inline\">\\(y_1,\r\ny_2\\)</span></p>\r\n<p>欧拉已经发现了，对于二阶常系数齐次线性ODE，其解形如：<span\r\nclass=\"math inline\">\\(e^{rx}\\)</span></p>\r\n<p>将其代入试一下：<span class=\"math inline\">\\(r^2 \\cdot e^{rx} + Ar\r\n\\cdot e^{rx} + B \\cdot e^{rx} = 0\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore r^2 + Ar + B = 0\\)</span></p>\r\n<p>所以解出<span\r\nclass=\"math inline\">\\(r\\)</span>就行了，上面这个方程也叫二阶常系数齐次线性ODE的“特征方程”。</p>\r\n<p>那么其实有几种情况：</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(r_1 \\ne r_2\\)</span>且都是real\r\nnumber</li>\r\n<li><span class=\"math inline\">\\(r1, r2\\)</span>都是复数</li>\r\n<li><span class=\"math inline\">\\(r1 = r2\\)</span>且是real number</li>\r\n</ol>\r\n<p>我们一个一个来分析。</p>\r\n<p><strong>Case 1：</strong></p>\r\n<p>首先先讨论第一种情况，此时俩特解就是<span\r\nclass=\"math inline\">\\(e^{r_1x}, e^{r_2x}\\)</span>，那么通解就是<span\r\nclass=\"math inline\">\\(y = c_1e^{r_1x} + c_2e^{r_2x}\\)</span></p>\r\n<p><strong>Case 2：</strong></p>\r\n<p>然后讨论第二种情况，此时不妨设特征方程的根是<span\r\nclass=\"math inline\">\\(a \\pm bi\\)</span>，那么俩特解就是<span\r\nclass=\"math inline\">\\(e^{(a+bi)x},\r\ne^{(a-bi)x}\\)</span>，但是显然我们不希望通解里包含复数啊，怎么办呢？用下面这个定理</p>\r\n<blockquote>\r\n<p>定理：若<span class=\"math inline\">\\(u + vi\\)</span>是<span\r\nclass=\"math inline\">\\(y&#39;&#39; + Ay&#39; + By =\r\n0\\)</span>的解，那么<span class=\"math inline\">\\(u,\r\nv\\)</span>都是此方程的解</p>\r\n<p>证明：</p>\r\n<p><span class=\"math inline\">\\(\\because (u+vi)&#39;&#39; + A(u+vi)&#39;\r\n+ B(u+vi) = 0\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore (u&#39;&#39; + Au&#39; + Bu) +\r\ni(v&#39;&#39; + Av&#39; + Bv) = 0\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore u, v\\)</span> are the\r\nsolutions of the equation.</p>\r\n</blockquote>\r\n<p>而<span class=\"math inline\">\\(e^{(a\\pm\r\nbi)x}\\)</span>对应的复数是<span class=\"math inline\">\\(e^{ax} \\cdot (\\cos\r\nbx \\pm i\\sin bx)\\)</span></p>\r\n<p>所以<span class=\"math inline\">\\(e^{ax}\\cos bx\\)</span>和<span\r\nclass=\"math inline\">\\(e^{ax}\\sin bx\\)</span>也是方程的俩特解（其实<span\r\nclass=\"math inline\">\\(-e^{ax}\\sin\r\nbx\\)</span>也是，不过只需要俩线性无关的就行，所以任选一个）</p>\r\n<p>所以通解为：<span class=\"math inline\">\\(y = e^{ax}(c_1\\cos bx +\r\nc_2\\sin bx)\\)</span></p>\r\n<p>（这里教授用弹簧-阻尼-木块模型描述了这个方程的物理现象，就是在不断震荡，趋近于稳态但不会到稳态。即震荡现象与特征方程复数根联系在一起）</p>\r\n<p>除了用定理外，还有另一种方法同样可以得到实数解，回到得到俩特解<span\r\nclass=\"math inline\">\\(e^{(a\\pm\r\nbi)x}\\)</span>这一步，那么通解可写为：<span class=\"math inline\">\\(y =\r\nc_1e^{(a+bi)x} + c_2e^{(a-bi)x}\\)</span></p>\r\n<p>这确实是通解，但是我们研究的问题是在实数域中的，所以我们希望求出实数通解，也就是令<span\r\nclass=\"math inline\">\\(c_1, c_2\\)</span>取某些值时，s,t, <span\r\nclass=\"math inline\">\\(y\\)</span>为实数</p>\r\n<p>Well，这里用一个小trick，即实数的共轭复数就是它自己。所以假定<span\r\nclass=\"math inline\">\\(y\\)</span>为实数，然后取其共轭： <span\r\nclass=\"math display\">\\[\r\n\\overline{y} = \\overline{c_1e^{(a+bi)x} + c_2e^{(a-bi)x}} =\r\n\\overline{c_1e^{(a+bi)x}} + \\overline{c_2e^{(a-bi)x}} =\r\n\\overline{c_1}e^{(a-bi)x} + \\overline{c_2}e^{(a+bi)x} = y\r\n\\]</span> <span class=\"math inline\">\\(\\therefore\r\n\\overline{c_1}=c_2,\\overline{c_2} = c_1\\)</span></p>\r\n<p>所以通解即为：<span class=\"math inline\">\\(y = (u + iv)e^{(a+bi)x} +\r\n(u - iv)e^{(a-bi)x}\\)</span></p>\r\n<p>工程领域的人很多人喜欢写成上面这个形式。</p>\r\n<p>但是hummm，我还是觉得写为三角函数会更优雅直观些，我们来看看上面的形式如何转为三角形式</p>\r\n<blockquote>\r\n<p>补充：逆欧拉公式</p>\r\n<p><span class=\"math inline\">\\(\\cos \\alpha = \\frac{e^{i\\alpha} +\r\ne^{-i\\alpha}}{2}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\sin \\alpha = \\frac{e^{i\\alpha} -\r\ne^{-i\\alpha}}{2i}\\)</span></p>\r\n</blockquote>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align*}\r\n    y&amp;=(u + iv)e^{(a+bi)x} + (u - iv)e^{(a-bi)x} \\\\\r\n     &amp;=e^{ax}(ue^{ibx} + ive^{ibx} + ue^{-ibx} - ive^{-ibx}) \\\\\r\n     &amp;=e^{ax}\\left(u(e^{ibx} + e^{-ibx}) + iv(e^{ibx} -\r\ne^{-ibx})\\right) \\\\\r\n     &amp;=e^{ax}\\left(2u\\cos bx - 2v\\sin bx\\right)\r\n\\end{align*}\r\n\\]</span></p>\r\n<p><strong>Case 3：</strong></p>\r\n<p>最后讨论第三种情况，此时不妨设特征方程的重根为<span\r\nclass=\"math inline\">\\(r\\)</span>，那么特解就是<span\r\nclass=\"math inline\">\\(e^{rx}\\)</span>，另一个特解是啥呢？继续用一个定理</p>\r\n<blockquote>\r\n<p>定理：若知道了<span class=\"math inline\">\\(y&#39;&#39; + p(x)y&#39; +\r\nq(x)y = 0\\)</span>的一个解<span\r\nclass=\"math inline\">\\(y_1\\)</span>，那么另一个解必然可以写成<span\r\nclass=\"math inline\">\\(u(x)y_1\\)</span></p>\r\n</blockquote>\r\n<p>ok，来找一下这个u吧！</p>\r\n<p>首先我们的方程是<span class=\"math inline\">\\(y&#39;&#39; + Ay&#39; +\r\nBy = 0\\)</span>，然后其中一个解<span\r\nclass=\"math inline\">\\(y_1\\)</span>为<span\r\nclass=\"math inline\">\\(e^{rx}\\)</span>，另一个解<span\r\nclass=\"math inline\">\\(y_2\\)</span>为<span\r\nclass=\"math inline\">\\(ue^{rx}\\)</span></p>\r\n<p>求出<span class=\"math inline\">\\(y, y_2&#39;, y_2&#39;&#39;\\)</span>\r\n<span class=\"math display\">\\[\r\n\\begin{cases}\r\n    &amp;y_2 = ue^{rx} \\\\\r\n    &amp;y_2&#39; = u&#39;e^{rx} + ure^{rx} \\\\\r\n    &amp;y_2&#39;&#39; = u&#39;&#39;e^{rx} + 2u&#39;re^{rx} + ur^2e^{rx}\r\n\\end{cases}\r\n\\]</span> 因为是重根，所以<span class=\"math inline\">\\(A = -2r, B =\r\nr^2\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore y_2&#39;&#39; + Ay_2&#39; +\r\nBy_2 = u&#39;&#39;e^{rx} + 2u&#39;re^{rx} + ur^2e^{rx} - 2ru&#39;e^{rx}\r\n- 2r^2ue^{rx} + r^2ue^{rx} = 0\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore u&#39;&#39;e^{rx} =\r\n0\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore u = c_1x + c_2\\)</span></p>\r\n<p>因为我们只需要求出<span\r\nclass=\"math inline\">\\(y_2\\)</span>的一个特解，所以<span\r\nclass=\"math inline\">\\(u\\)</span>不妨取<span\r\nclass=\"math inline\">\\(x\\)</span>，这样即得到<span\r\nclass=\"math inline\">\\(y_2 = xe^{rx}\\)</span></p>\r\n<p>所以通解为：<span class=\"math inline\">\\(y = c_1e^{rx} +\r\nc_2xe^{rx}\\)</span></p>\r\n<h3 id=\"四.-二阶齐次线性ode相关理论\">四. 二阶齐次线性ODE相关理论</h3>\r\n<p>本节讨论的方程形如：<span class=\"math inline\">\\(y&#39;&#39; +\r\np(x)y&#39; + q(x)y = 0\\)</span></p>\r\n<p>这节课教授介绍了为什么二阶齐次线性ODE的通解是<span\r\nclass=\"math inline\">\\(c_1y_1 +\r\nc_2y_2\\)</span>，证明过程我这里就略了。</p>\r\n<p>以及还提到了对通解的正交化。</p>\r\n<p>什么意思呢？就是当你求出俩通解<span\r\nclass=\"math inline\">\\(y\\)</span>后，可以令<span\r\nclass=\"math inline\">\\(y(0) = 1, y&#39;(0) =\r\n0\\)</span>，解出一个特解，记为<span\r\nclass=\"math inline\">\\(Y_1\\)</span>；然后再令<span\r\nclass=\"math inline\">\\(y(0) = 0, y&#39;(0) =\r\n1\\)</span>，解出一个特解，记为<span\r\nclass=\"math inline\">\\(Y_2\\)</span>。</p>\r\n<p>那么<span class=\"math inline\">\\(Y_1,\r\nY_2\\)</span>就是正交的，通解可以重新写为<span class=\"math inline\">\\(y =\r\nc_1Y_1 + c_2Y_2\\)</span></p>\r\n<p>这样有什么好处呢？</p>\r\n<p>当你给出一个初始条件<span class=\"math inline\">\\(y(0) = a, y&#39;(0) =\r\nb\\)</span>时，那么解就是<span class=\"math inline\">\\(aY_1 +\r\nbY_2\\)</span></p>\r\n<p>除了正交化，教授还讲了一个存在和唯一性定理：</p>\r\n<blockquote>\r\n<p>存在和唯一性定理：</p>\r\n<p>对于二阶齐次线性ODE：<span class=\"math inline\">\\(y&#39;&#39; +\r\np(x)y&#39; + q(x)y = 0\\)</span>，若<span class=\"math inline\">\\(p,\r\nq\\)</span>对<span\r\nclass=\"math inline\">\\(x\\)</span>连续，则当给定一组初始条件时，有且仅有一个解。</p>\r\n</blockquote>\r\n<h3 id=\"五.-二阶非齐次线性ode相关理论\">五.\r\n二阶非齐次线性ODE相关理论</h3>\r\n","categories":["4. 大学","数学","微分方程"]},{"title":"数字逻辑自学笔记","url":"/2023/10/06/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"<p>写于2023/10/6，这门课其实还是有点意思的。但是上个月身体原因一直在关心我自己的身体，所以这门课我全翘掉了，一点没听。现在马上就要实验课了，于是打算在国庆的末尾把这门课学了。目的是能做出几个组合逻辑电路的实验项目。</p>\r\n<span id=\"more\"></span>\r\n<p>upd: (2024/1/14)：这门课满绩了，考试很简单，都是笔记里的东西。</p>\r\n<hr />\r\n<p>自学参考的内容为老师ppt、各种网上博客。</p>\r\n<p>学完后打算去刷题巩固一下，刷题打算在一个up主视频里刷：<a\r\nhref=\"https://www.bilibili.com/video/BV1H54y1k7kM?p=1&amp;vd_source=2501060da9b4bef86e2b8ec8a8d880b5\">传送门</a></p>\r\n<p>最后，如果有朋友打算认真看这篇Blog进行学习的话，为了更好的阅读体验建议开梯子，因为本文有许多图片和一个视频。（存储在github中）</p>\r\n<p>先放一张各种门的符号图，后面忘了的话可以参考：</p>\r\n<p><img src=\"1.png\" /></p>\r\n<p><img src=\"2.png\" /></p>\r\n<h3 id=\"一.-组合逻辑电路1\">一. 组合逻辑电路(1)</h3>\r\n<h4 id=\"概述\">1.1. 概述</h4>\r\n<p>电路分为组合逻辑电路和时序逻辑电路。差别就是组合逻辑电路无记忆功能，时序逻辑电路有。</p>\r\n<p>描述电路的逻辑功能有以下几种形式：</p>\r\n<ol type=\"1\">\r\n<li>语言描述</li>\r\n<li>电路图</li>\r\n<li>逻辑表达式，即y = f(a1, a2, a3, ..., an)</li>\r\n<li>真值表</li>\r\n<li>卡诺图</li>\r\n<li>波形图</li>\r\n</ol>\r\n<h4 id=\"组合逻辑电路的分析-和-逻辑函数的设计方法\">1.2.\r\n组合逻辑电路的分析 和 逻辑函数的设计方法</h4>\r\n<ul>\r\n<li><p><strong>分析</strong>：</p>\r\n<ul>\r\n<li><p>即给你一个电路，让你告诉我这个电路是干啥用的。</p></li>\r\n<li><p>分析一个组合逻辑电路的固定套路很简单：</p>\r\n<ol type=\"1\">\r\n<li>一层一层写出逻辑表达式</li>\r\n<li>对最后得到的逻辑表达式进行化简\r\n<ul>\r\n<li>化简手段1：卡诺图</li>\r\n<li>化简手段2：<span class=\"math inline\">\\(A + A \\cdot B = A 或 A \\cdot\r\n(A + B) = A\\)</span></li>\r\n<li>化简手段3：<span class=\"math inline\">\\(A + \\overline{A}B = A + B 或\r\nA \\cdot (\\overline{A} + B) = A \\cdot B\\)</span></li>\r\n<li>化简手段4：<span class=\"math inline\">\\(\\overline{A}\\overline{C} +\r\nA\\overline{B} + \\overline{B}\\overline{C} = \\overline{A}\\overline{C} +\r\nA\\overline{B}\\)</span>（对于<span\r\nclass=\"math inline\">\\(\\overline{B}\\overline{C}\\)</span>添项即可证明）</li>\r\n<li>化简手段5：<span class=\"math inline\">\\(A \\oplus B = \\overline{A}B +\r\nA\\overline{B}\\)</span></li>\r\n<li>化简手段6：<span class=\"math inline\">\\(A \\odot B = (\\overline{A} +\r\nB)(A + \\overline{B})\\)</span></li>\r\n</ul></li>\r\n<li>对化简后的逻辑表达式列真值表，观察真值表，观察出此电路的功能</li>\r\n</ol></li>\r\n<li><p>例子：</p>\r\n<p><img src=\"3.png\" /></p>\r\n<ul>\r\n<li>T1是个与门，T2是个或门，第一层剩下都是与门，第二层一个或门，第三层一个非门，第四层一个与门，最后一层一个或门。最后通过真值表很容易看出ABC三个输入变量但有两个输出变量。不难想到是一个全加器。A、B是两个加数，C是上一位的进位，F1是当前位，F2是进位。</li>\r\n<li>还有许多功能电路啦...\r\n...比如半加器（2输入2输出）、投票表决器（多输入1输出）、奇校验电路（多输入1输出）、一致性电路（多输入1输出）</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p><strong>设计</strong>：</p>\r\n<ul>\r\n<li><p>告诉你一个功能，让你设计出一个电路来实现它。</p></li>\r\n<li><p>也是有固定套路的：</p>\r\n<ol type=\"1\">\r\n<li><p>分析功能，确定输入输出变量</p>\r\n<ul>\r\n<li>确定输入输出变量还是有点讲究的，有时候设计的好了可以大大减少运算量和电路的复杂程度。比如下面两个功能，换做是你，你会怎样设计？</li>\r\n</ul>\r\n<p><img src=\"4.png\" /> <img src=\"5.png\" /></p>\r\n<ul>\r\n<li>设计的关键其实是做到尽可能的<strong>复用</strong>，即对于不同对象的同一属性，尽量用一个变量表达出来。</li>\r\n</ul></li>\r\n<li><p>根据题意，直接构造出电路。或者写出真值表然后写出主析取范式然后再用卡诺图化简后得到最终逻辑表达式</p></li>\r\n<li><p>根据逻辑表达式，选取一种门电路，画出电路图</p></li>\r\n</ol></li>\r\n</ul></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"二.-组合逻辑电路2\">二. 组合逻辑电路(2)</h3>\r\n<p>上一节我们已经可以设计出逻辑表达式。但是具体选用哪一种门电路呢？每一种门电路应该如何设计呢？这一节我们就来学习。</p>\r\n<h4 id=\"单输出电路设计\">2.1. 单输出电路设计</h4>\r\n<h5 id=\"用与非门设计电路\">2.1.1. 用与非门设计电路</h5>\r\n<p>对于逻辑表达式F = ...中的 + 全部换成 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> 就好了，按照这个思路，只要在 +\r\n的头上画两根取反号就行了，最上面那根保留，下面那根负责把 + 换成 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> 。</p>\r\n<p>但这样得到的实际电路可能耗材过多，实际中有些式子通过观察还能发现可以化的更简，比如下面这个例子：</p>\r\n<p><span class=\"math inline\">\\(F = A\\overline{B} + B\\overline{C} +\r\nC\\overline{D} + D\\overline{A} = \\overline{\\overline{A\\overline{B}} \\cdot\r\n\\overline{B\\overline{C}} \\cdot \\overline{C\\overline{D}} \\cdot\r\n\\overline{D\\overline{A}}}\\)</span></p>\r\n<p>按理说这样就好了，但是还可以化简的。</p>\r\n<p><span class=\"math inline\">\\(\\overline{A\\overline{B}} \\cdot\r\n\\overline{B\\overline{C}} \\cdot \\overline{C\\overline{D}} \\cdot\r\n\\overline{D\\overline{A}} = (\\overline{A} + B)(\\overline{B} +\r\nC)(\\overline{C} + D)(\\overline{D} + A)\\)</span></p>\r\n<p>上面这个东西，学过二项式定理吗？假如我第一项如果挑B，则第二项不能挑<span\r\nclass=\"math inline\">\\(\\overline{B}\\)</span>，只能挑C，那么第三项也只能挑D，依次类推，第四项只能挑A，得到ABCD。同理，如果我第一项挑<span\r\nclass=\"math inline\">\\(\\overline{A}\\)</span>，那么我只能得到<span\r\nclass=\"math inline\">\\(\\overline{A}\\overline{B}\\overline{C}\\overline{D}\\)</span>。</p>\r\n<p>即：<span class=\"math inline\">\\((\\overline{A} + B)(\\overline{B} +\r\nC)(\\overline{C} + D)(\\overline{D} + A) = ABCD +\r\n\\overline{A}\\overline{B}\\overline{C}\\overline{D}\\)</span></p>\r\n<p>对上面那玩意再求两次反，得到<span\r\nclass=\"math inline\">\\(\\overline{\\overline{ABCD} \\cdot\r\n\\overline{\\overline{A}\\overline{B}\\overline{C}\\overline{D}}}\\)</span></p>\r\n<p>这样子，就得到<span class=\"math inline\">\\(F =\r\n\\overline{\\overline{\\overline{ABCD} \\cdot\r\n\\overline{\\overline{A}\\overline{B}\\overline{C}\\overline{D}}}}\\)</span></p>\r\n<p>总结下来这个第二种方法就是在第一种方法的基础上把内部通过二项式定理进一步化简。</p>\r\n<h5 id=\"用或非门设计电路\">2.1.2. 用或非门设计电路</h5>\r\n<p>对于逻辑表达式F = ...中的 <span class=\"math inline\">\\(\\cdot\\)</span>\r\n全部换成 + 就好了，按照这个思路，只要在 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span>\r\n的头上画两根取反号就行了，最上面那根保留，下面那根负责把 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> 换成 + 。</p>\r\n<p>还有第二种通用的方法，就是将F先求对偶，得到<span\r\nclass=\"math inline\">\\(F_d\\)</span>，这样F就由(xxx) + (xxx) +\r\n(xxx)的形式变为(x + x)(x + x)(x +\r\nx)的形式了。学过二项式定理吗？同理将<span\r\nclass=\"math inline\">\\(F_d\\)</span>化简，得到最简“与-或”式(yyy) +\r\n(yyy)。再在头上加两根取反，最顶上保留，下面那根为了把 + 变成 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> ，最后再对偶回去即可。</p>\r\n<p>上面那段文字是具体过程，流程总结下来如下：</p>\r\n<ol type=\"1\">\r\n<li>对F求对偶<span class=\"math inline\">\\(F_d\\)</span></li>\r\n<li>对<span\r\nclass=\"math inline\">\\(F_d\\)</span>展开，利用二项式原理或者卡诺图，得到最简\"与-或\"式<span\r\nclass=\"math inline\">\\(F_d&#39;\\)</span></li>\r\n<li>对<span\r\nclass=\"math inline\">\\(F_d&#39;\\)</span>取两次反，最上面保留，下面那根化开，得到<span\r\nclass=\"math inline\">\\(F_d&#39;&#39;\\)</span></li>\r\n<li>对<span class=\"math inline\">\\(F_d&#39;&#39;\\)</span>对偶回去</li>\r\n</ol>\r\n<h5 id=\"用与或非门设计电路\">2.1.3. 用与或非门设计电路</h5>\r\n<p>这个就更简单了，因为给出的函数表达式都是形如F = xyz + xyz +\r\nxyz，所以只需要在F头上加两条杠就好了。</p>\r\n<p>第二种思路就是跟用与非门设计电路的第二种方法一样。加两条杠，最上面不动，下面那个把xyz\r\n+ xyz +\r\nxyz变成()()()型，然后二项式定理展开即可。（如果是与非门第二种设计思路还要将展开的东西再取两次反）</p>\r\n<h4 id=\"多输出电路设计\">2.2. 多输出电路设计</h4>\r\n<p>啊，最直接的想法就是分别把每个输出对应的电路设计出来就好了。但是这样比较憨，当我们化简得到了每个输出对应的逻辑表达式的时候，我们应该能尽可能使每一项<strong>复用</strong>。看下面这个例子：</p>\r\n<p><img src=\"6.png\" /></p>\r\n<p>可以发现原<span class=\"math inline\">\\(F_1\\)</span>中的<span\r\nclass=\"math inline\">\\(A\\overline{B}\\)</span>可以变成<span\r\nclass=\"math inline\">\\(A\\overline{B}\\overline{C}\\)</span>，这样就跟<span\r\nclass=\"math inline\">\\(F_2\\)</span>中的<span\r\nclass=\"math inline\">\\(A\\overline{B}\\overline{C}\\)</span>一样了，做到了复用。</p>\r\n<h4 id=\"包含无关项的电路设计\">2.3. 包含无关项的电路设计</h4>\r\n<p>其实很简单，看下面这个例子就懂了。</p>\r\n<p><img src=\"7.png\" /></p>\r\n<p><img src=\"8.png\" /></p>\r\n<p>首先我们知道余3码是在8421码的基础上+3得到，因为8421码只有10位，所以余3码也只有10位。而且8421码最小是0000，所以余3码最小是0011（对应十进制数1）。所以这就在输出F中产生了许多无关项d。在画卡诺图时，若不考虑无关项，则把d全置为0；考虑无关项则把d全置为1。最后得到化简后的函数表达式。然后再将这个函数表达式用与非门设计。</p>\r\n<h4 id=\"考虑级数的电路设计\">2.4. 考虑级数的电路设计</h4>\r\n<p>也是看一道例题就可以理解了。</p>\r\n<p><img src=\"9.png\" /></p>\r\n<p>先用最直接的方法，与或非门直接加两条杠结束。与非门直接加两条杠，下面那条杠化开结束。</p>\r\n<p>但是这样设计级数会不会多呢？</p>\r\n<p>如果我们用\"与或非门设计电路\"中第二种化简方法，试一下：</p>\r\n<p><span class=\"math inline\">\\(F = \\overline{\\overline{AB +\r\n\\overline{A}C}} = \\overline{\\overline{AB} \\cdot\r\n\\overline{\\overline{A}C}} = \\overline{(\\overline{A} + \\overline{B})(A +\r\n\\overline{C})} = \\overline{\\overline{A}\\overline{C} + A\\overline{B} +\r\n\\overline{B}\\overline{C}} = \\overline{\\overline{A}\\overline{C} +\r\nA\\overline{B}}\\)</span></p>\r\n<p>可以发现，这样设计只有3层。但是原来那样直接加两条杠是4层。所以当考虑电路的级数时，在用与或非门设计电路时，可以考虑进一步化简优化电路的级数。</p>\r\n<p>如果用与非门，就不需要考虑进一步化简了。因为在与非门进一步化简后，还需要再内部再添加两条杠。级数肯定比不继续化简多。</p>\r\n<h4 id=\"综合题\">2.5. 综合题</h4>\r\n<ul>\r\n<li>设计一个组合电路，将8421BCD码变换为余3码。</li>\r\n</ul>\r\n<p>先确定输入输出变量，因为8421BCD码是用四个二进制数表示十进制数0~9，所以有四个输入A、B、C、D代表四个二进制数。同理四个输出W、X、Y、Z代表变换后的余3码。</p>\r\n<p>然后列出真值表，因为BCD只能表示十进制0~9，所以注意表中有无关项d。</p>\r\n<p><img src=\"10.png\" /></p>\r\n<p>这里不考虑无关项，所以在后续画卡诺图时都将d置为0。</p>\r\n<p>因为是四个输出，所以属于多输出电路。所以先画四个卡诺图得到四个逻辑表达式（其实对于Z，发现其很有规律不用画卡诺图都可以知道它就是<span\r\nclass=\"math inline\">\\(\\overline{D}\\)</span>）</p>\r\n<p>画卡诺图过程省略，得到四个逻辑表达式： <span class=\"math display\">\\[\r\nW = A + BC + BD \\\\\r\nX = \\overline{B}C + \\overline{B}D + B\\overline{C}\\overline{D} \\\\\r\nY = CD + \\overline{C}\\overline{D} \\\\\r\nZ = \\overline{D}\r\n\\]</span>\r\n此时我们需要思考，是否能做到项的<strong>复用</strong>呢？乍一看没发现能复用的，所以先不考虑复用，继续将式子进一步化简先。先从简单的开始画：</p>\r\n<p><span class=\"math inline\">\\(Z = \\overline{D}\\)</span></p>\r\n<p><span class=\"math inline\">\\(Y = \\overline{C} \\oplus D\\)</span></p>\r\n<p><span class=\"math inline\">\\(X = \\overline{B}(C + D) + B\\overline{(C +\r\nD)} = B \\oplus (C + D) = B \\oplus\r\n\\overline{\\overline{C}\\overline{D}}\\)</span></p>\r\n<p><span class=\"math inline\">\\(W = A + B(C + D) = A +\r\nB\\overline{\\overline{C}\\overline{D}}\\)</span></p>\r\n<p>化简后可以发现，<span\r\nclass=\"math inline\">\\(\\overline{\\overline{C}\\overline{D}}\\)</span>这个东西可以做到复用，真不错。</p>\r\n<p>接下来就是选择门电路来设计电路了。这里我选择最常用的与非门 +\r\n异或门设计电路。根据上面的逻辑表达式直接设计即可（W还需化简一下：<span\r\nclass=\"math inline\">\\(W = \\overline{\\overline{A} \\cdot\r\n\\overline{B\\overline{\\overline{C}\\overline{D}}}}\\)</span>）</p>\r\n<p>最后画出电路：</p>\r\n<p><img src=\"11.png\" /></p>\r\n<hr />\r\n<h3 id=\"三.-组合逻辑电路3\">三. 组合逻辑电路(3)</h3>\r\n<h4 id=\"编码器\">3.1 编码器</h4>\r\n<p>按照我的理解，就是把数字变成二进制数。比如把0 ~\r\n8变成3位二进制数，或者0 ~ 15变成4位二进制数。</p>\r\n<p>编码器分为普通编码器 和 优先编码器。</p>\r\n<ul>\r\n<li><strong>普通编码器</strong></li>\r\n</ul>\r\n<p>特点：任何时刻只允许输入一个编码信号。</p>\r\n<p>最常见的普通编码器为8线-3线编码器，如下图：</p>\r\n<p><img src=\"12.png\" /></p>\r\n<p>它的真值表如下：</p>\r\n<p><img src=\"13.png\" /></p>\r\n<p>可以看出，假如我<span\r\nclass=\"math inline\">\\(I_7\\)</span>为高电平，则输出111，就是7的二进制。</p>\r\n<p>那内部电路如何设计呢？根据真值表得出逻辑表达式然后化简，再选用与非门实现即可。</p>\r\n<p>上面这个是8线-3线普通编码器，那如何实现8421-BCD普通编码器呢？</p>\r\n<p>很简单，10个输入，4个输出。列出真值表，发现会有无关项。不考虑无关项，根据真值表得出4个输出的逻辑表达式，然后根据卡诺图化简。最后选用与非门实现即可。</p>\r\n<ul>\r\n<li><strong>优先编码器</strong></li>\r\n</ul>\r\n<p>特点：允许同时输入多个编码信号，只对其中优先权最高的一个进行编码。</p>\r\n<p>最常见的优先编码器是74148优先编码器，长下面这个样子，需要掌握：</p>\r\n<p><img src=\"14.png\" /></p>\r\n<p>这个图有两个要注意的地方，首先就是所有的<span\r\nclass=\"math inline\">\\(I\\)</span>上面都是有一个取反号的，只是这个图比较小可能看不清晰，然后所有的<span\r\nclass=\"math inline\">\\(Y、S\\)</span>上面也有取反号。还有就是看到红色箭头的地方了吗？这跟前面的8线-3线普通编码器不一样，这代表低电平有效。</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\overline{S}\\)</span>为选通输入端，只有当<span\r\nclass=\"math inline\">\\(\\overline{S} = 0\\)</span>时才能正常工作，当<span\r\nclass=\"math inline\">\\(\\overline{S} =\r\n1\\)</span>时所有输出端为封锁为高电平。</p>\r\n<p>​ <img src=\"15.png\" /></p>\r\n<p><span\r\nclass=\"math inline\">\\(\\overline{Y_s}\\)</span>为选通输出端，当<span\r\nclass=\"math inline\">\\(\\overline{Y_s} =\r\n0\\)</span>说明电路正常工作且无编码信号输入（<span\r\nclass=\"math inline\">\\(\\overline{S} = 0 且所有\\overline{I} =\r\n1\\)</span>）</p>\r\n<p>​ <img src=\"16.png\" /></p>\r\n<p><span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>为扩展端，当<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}} =\r\n0\\)</span>说明电路正常工作且有编码信号输入（<span\r\nclass=\"math inline\">\\(\\overline{S} = 0\\)</span>且存在<span\r\nclass=\"math inline\">\\(\\overline{I} = 0\\)</span>）</p>\r\n<p>​ <img src=\"17.png\" /></p>\r\n<p>知道了每个端口的作用，如何只通过输出端判断此时编码器处于什么状态呢？</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(\\overline{Y_s} =\r\n0\\)</span>：电路正常工作且无编码信号输入。（此时<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>必为1）</li>\r\n<li><span class=\"math inline\">\\(\\overline{Y_{EX}} =\r\n0\\)</span>：电路正常工作且有编码信号输入。（此时<span\r\nclass=\"math inline\">\\(\\overline{Y_s}\\)</span>必为1）</li>\r\n<li><span class=\"math inline\">\\(\\overline{Y_s} = \\overline{Y_{EX}} =\r\n1\\)</span>：电路被阻塞（此时<span\r\nclass=\"math inline\">\\(\\overline{S}\\)</span>必为1）</li>\r\n</ol>\r\n<p>最后，74148优先编码器的真值表贴上来，上面所有可能你觉得有困惑的点都可以在这张表中得到解答。</p>\r\n<p><img src=\"18.png\" /></p>\r\n<ul>\r\n<li><strong>练习</strong></li>\r\n</ul>\r\n<p>学了上面普通编码器和优先编码器的知识，来写一道题吧！</p>\r\n<blockquote>\r\n<p>请用两片74148接成16线-4线优先编码器，将16个低电平输入信号<span\r\nclass=\"math inline\">\\(\\overline{A_0} \\sim\r\n\\overline{A_{15}}\\)</span>编为'0000' ~ '1111'，其中<span\r\nclass=\"math inline\">\\(\\overline{A_{15}}\\)</span>的优先级最高。</p>\r\n</blockquote>\r\n<p>首先如果是0 ~\r\n7就直接用一片就好了。思考一下，如果是大于7怎么办？可以这样思考：</p>\r\n<p>15 = 8 + 7</p>\r\n<p>14 = 8 + 6</p>\r\n<p>13 = 8 + 5</p>\r\n<p>12 = 8 + 4</p>\r\n<p>11 = 8 + 3</p>\r\n<p>10 = 8 + 2</p>\r\n<p>9 = 8 + 1</p>\r\n<p>8 = 8 + 0</p>\r\n<p>发现规律了吗？如果是0 ~ 7直接用一片就好了，如果是8 ~\r\n15就肯定需要用到第二片，但是第二片同样能表达的范围只有0 ~ 7，所以就将8 ~\r\n15进行数字拆分。</p>\r\n<p>如果输入8，则点亮第四位输出（8421中的8），剩下3位二进制输入0</p>\r\n<p>如果输入9，则点亮第四位输出，剩下3位二进制输入1</p>\r\n<p>如果输入10，则点亮第四位输出，剩下3位二进制输入2</p>\r\n<p>... ...</p>\r\n<p>如果输入15，则点亮第四位输出，剩下3位二进制输入7</p>\r\n<p>思路就是这样，还有一些小细节我在放答案过后再解释：</p>\r\n<p><img src=\"19.png\" /></p>\r\n<p>可以看到<span\r\nclass=\"math inline\">\\(G_0、G_1、G_2\\)</span>门都采用了与非门的设计，因为两片74148必定只会用到一片的输出（0\r\n~ 7用右边那片，8 ~ 15用左边那片）。</p>\r\n<p>但是如果使得一片工作另一片就停止工作呢？注意左边那片的<span\r\nclass=\"math inline\">\\(\\overline{Y_s}\\)</span>端口，左边那片正常工作且有信号输入时输出1，使得右边那片<span\r\nclass=\"math inline\">\\(\\overline{S} =\r\n1\\)</span>，所以右边那片直接被堵塞了。如果左边那片正常工作但没信号输入时输出0，使得右边那片被激活。这样就实现了两片中只能有一片在工作。</p>\r\n<p>然后<span\r\nclass=\"math inline\">\\(Z_3\\)</span>就是第四个二进制输出。只要用到左边那片，就输出1。刚好<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>就可以实现这个功能，只要电路正常工作并且有信号输入<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>就为0，经过一个与非门之后就变成了1。</p>\r\n<h4 id=\"译码器\">3.2 译码器</h4>\r\n<p>译码器就是编码器的逆过程。编码器是给它一个数字，输出二进制。译码器就是给它一个二进制，输出一个数字。</p>\r\n<p>译码器分为二进制译码器（最小项译码器）、二—十进制译码器、显示译码器。其中二进制译码器需要掌握74138译码器。</p>\r\n<ul>\r\n<li><strong>二进制译码器（只讲74138译码器）</strong></li>\r\n</ul>\r\n<p>74138译码器长这个样子：</p>\r\n<p><img src=\"20.png\" /></p>\r\n<p>注意，跟74148解码器不同，这里的三个输入端<span\r\nclass=\"math inline\">\\(A\\)</span>都是高电平有效，输出端<span\r\nclass=\"math inline\">\\(\\overline{Y}\\)</span>是低电平有效。这里的<span\r\nclass=\"math inline\">\\(S、\\overline{S}\\)</span>是控制芯片是否工作的。</p>\r\n<p>具体来说，只有当<span class=\"math inline\">\\(S_1 = 1 且 \\overline{S_2}\r\n=0 且 \\overline{S_3} =\r\n0\\)</span>时，电路才处于正常工作状态。其余情况电路都处于被堵塞的状态。</p>\r\n<p>​ <img src=\"21.png\" /></p>\r\n<p>74138解码器的真值表如下：</p>\r\n<p><img src=\"22.png\" /></p>\r\n<ul>\r\n<li><strong>二—十进制译码器（只讲7442译码器）</strong></li>\r\n</ul>\r\n<p>我觉得二—十进制译码器就是二进制译码器啊...\r\n...搞不懂为啥还要专门分个类出来。二—十译码器就是说将4个二进制数变成十进制0\r\n~ 9。</p>\r\n<p>二—十进制译码器最常见的就是7442译码器，它的真值表如下：</p>\r\n<p><img src=\"23.png\" /></p>\r\n<p>可以看到有伪码的存在，这是为什么呢？因为4个二进制数可以表达0 ~\r\n15，但是因为是BCD码，所以我们得到的数范围是0 ~\r\n9。所以有一部分的二进制状态没有用到，没用到的地方就称为伪码。</p>\r\n<ul>\r\n<li><strong>显示译码器</strong></li>\r\n</ul>\r\n<p>啊就是能直观的显示出翻译后信息的译码器。看下面俩图就知道它是什么东西了。</p>\r\n<p><img src=\"24.png\" /><img src=\"25.png\" /></p>\r\n<ul>\r\n<li><strong>练习</strong></li>\r\n</ul>\r\n<blockquote>\r\n<p>试用两片74138组成4线-16线译码器。将输入的4位二进制代码<span\r\nclass=\"math inline\">\\(D_3D_2D_1D_0\\)</span>译成16个独立的低电平信号<span\r\nclass=\"math inline\">\\(\\overline{Z_0} \\sim\r\n\\overline{Z_{15}}\\)</span>。</p>\r\n</blockquote>\r\n<p>有了前面用两块74148组成16线-4线编码器的经验，这题的思考方式是一样的。首先如果只用一块板的话，3个二进制数，可以得到0\r\n~ 7。如果大于7怎么办呢？观察一下： <span class=\"math display\">\\[\r\n(8)_d = (1000)_b \\leftrightarrow (0)_d = (000)_b \\\\\r\n(9)_d = (1001)_b \\leftrightarrow (1)_d = (001)_b \\\\\r\n(10)_d = (1010)_b \\leftrightarrow (2)_d = (010)_b \\\\\r\n..... \\leftrightarrow ...\r\n\\]</span> 发现规律了没？</p>\r\n<p>只要四位二进制中第四位为0，将剩下3位二进制传给第一块板的三个输入接口。如果第四位二进制为1，那么堵塞第一块版，将剩下3位二进制传给第二块版的三个输入接口。答案如下：</p>\r\n<p><img src=\"26.png\" /></p>\r\n<h4 id=\"用译码器实现逻辑函数\">3.3 用译码器实现逻辑函数</h4>\r\n<p>因为任何逻辑函数均可化成最小项之和的形式。所以可以用译码器实现逻辑函数的电路，很牛逼。看下面这个例子你就懂了。</p>\r\n<p><img src=\"27.png\" /></p>\r\n<p>首先先将F化成主析取范式：<span class=\"math inline\">\\(F = ABC\r\n+AB\\overline{C} + A\\overline{B}C + \\overline{A}BC = m_7 + m_6 + m_5 +\r\nm_3\\)</span></p>\r\n<p>意思是说，只要三输入变量按照7、6、5、3的二进制输入，F就是1。否则F就是0。</p>\r\n<p>好，那我们在74138输出端将<span\r\nclass=\"math inline\">\\(\\overline{Y_7}、\\overline{Y_6}、\\overline{Y_5}、\\overline{Y_3}\\)</span>用与非门连接起来。只要三输入变量输入7、6、5、3二进制其中的一个，那么<span\r\nclass=\"math inline\">\\(\\overline{Y_7}、\\overline{Y_6}、\\overline{Y_5}、\\overline{Y_3}\\)</span>就有一个是0，与非后就得到1。如果三输入变量不属于7、6、5、3二进制中的任何一个，则<span\r\nclass=\"math inline\">\\(\\overline{Y_7}、\\overline{Y_6}、\\overline{Y_5}、\\overline{Y_3}\\)</span>都为1，与非后就得到0。</p>\r\n<hr />\r\n<h3 id=\"四.-组合逻辑电路4\">四. 组合逻辑电路(4)</h3>\r\n<h4 id=\"数据分配器\">4.1 数据分配器</h4>\r\n<p>定义：数据传输过程中，有时需要将数据分配到不同的数据通道上。数据分配器也叫多路分配器，简称DEMUX。</p>\r\n<p>示意图：通过A端口来选择数据输出通道。</p>\r\n<p><img src=\"28.png\" /></p>\r\n<p>电路图：</p>\r\n<p><img src=\"29.png\" /></p>\r\n<p>这个电路还是蛮简单的。</p>\r\n<p>提一嘴，前面学到的74138译码器就可以用来作1路-8路数据分配器。内部电路图ppt没给，但是我觉得就跟上面DEMUX的电路图差不多。</p>\r\n<p><img src=\"30.png\" /></p>\r\n<h4 id=\"数据选择器\">4.2 数据选择器</h4>\r\n<p>定义：能够实现从多路数据中选择一路进行传输的电路叫做数据选择器。也叫多路选择器、多路调制器，简称MUX。常见的类型有二选一、四选一、八选一、十六选一。</p>\r\n<p><img src=\"31.png\" /></p>\r\n<ul>\r\n<li><strong>二选一多路选择器</strong></li>\r\n</ul>\r\n<p><img src=\"32.png\" /></p>\r\n<p>w0和w1分别是两路的数据源，然后s是控制器。先看右边的电路图，假设s是0，则f\r\n= w0，假设s是1，则f = w1。左边就是二选一MUX的图形符号。</p>\r\n<ul>\r\n<li><strong>四选一多路选择器</strong></li>\r\n</ul>\r\n<p>先看真值表，根据真值表就可以直接设计电路了。</p>\r\n<p><img src=\"33.png\" /></p>\r\n<p>所以根据上面的真值表可以写出逻辑表达式：</p>\r\n<p><span class=\"math inline\">\\(f = w_0\\overline{s_1}\\overline{s_0} +\r\nw_1\\overline{s_1}s_0 + w_2s_1\\overline{s_0} + w_3s_1s_0\\)</span></p>\r\n<p>下面右图是用非门 + 与门 +\r\n或门来实现上面的逻辑表达式，左图是四选一MUX的图形符号</p>\r\n<p><img src=\"34.png\" /></p>\r\n<ul>\r\n<li><strong>更大规模的多路选择器</strong></li>\r\n</ul>\r\n<p>可以直接列真值表然后直接构建，也可以用小规模的多路选择器去构建。</p>\r\n<p>看一个由2选1多路选择器构建的4选1多路选择器，就知道如何构建了。</p>\r\n<p><img src=\"35.png\" /></p>\r\n<p>先将w俩俩分组，然后用s0去筛，一下筛掉一半，再用s1去筛，又筛掉一半，最后就选择出来了一路数据。</p>\r\n<h4 id=\"数据选择器的运用\">4.3 数据选择器的运用</h4>\r\n<ol type=\"1\">\r\n<li><p>2x2纵横开关（是否交换数据传输通道）</p>\r\n<p><img src=\"36.png\" /></p>\r\n<ul>\r\n<li>看图，s是选择器。如果s=0，则y1 = x1, y2 = x2。如果s=1，则y1 = x2，y2\r\n= x1。</li>\r\n</ul></li>\r\n<li><p>实现逻辑函数</p>\r\n<ul>\r\n<li><p>最暴力的想法就是列真值表，输入变量A、B、C就是选择器s。每一行的输出就是数据输入通道，输出通道就是f。例如函数<span\r\nclass=\"math inline\">\\(f = \\overline{w_1}w_2 +\r\nw_1\\overline{w_2}\\)</span>，用四选一多路选择器的实现如下：</p>\r\n<p><img src=\"38.png\" /></p></li>\r\n<li><p>但在暴力的基础上其实可以优化：可以对真值表做一个改动：</p>\r\n<p><img src=\"39.png\" /></p></li>\r\n<li><p>这样子输入变量只有一个w1了，它就是选择器。数据输入通道有两个，分别是<span\r\nclass=\"math inline\">\\(w_2\\)</span>和<span\r\nclass=\"math inline\">\\(\\overline{w_2}\\)</span>，数据输出通道一个为f。用二选一多路选择器实现如下：</p>\r\n<p><img src=\"40.png\" /></p></li>\r\n</ul></li>\r\n<li><p>实现3输入表决器</p>\r\n<ul>\r\n<li><p>先列出真值表</p>\r\n<p><img src=\"41.png\" /></p></li>\r\n<li><p>对真值表进行优化</p>\r\n<p><img src=\"42.png\" /></p></li>\r\n<li><p>此时输入变量两个w1、w2为选择器，数据输入通道4个分别是0、w3、w3、1，数据输出通道1个为f。用4选1多路选择器实现如下：</p>\r\n<p><img src=\"43.png\" /></p></li>\r\n</ul></li>\r\n<li><p>实现3位异或运算</p>\r\n<ul>\r\n<li><p>先列出真值表，并优化</p>\r\n<p><img src=\"44.png\" /></p></li>\r\n<li><p>此时输入变量两个w1、w2为选择器，数据输入通道4个分别是<span\r\nclass=\"math inline\">\\(w_3、\\overline{w_3}、\\overline{w_3}、w_3\\)</span>，数据输出通道一个为f。用4选1多路选择器实现如下：</p>\r\n<p><img src=\"45.png\" /></p></li>\r\n</ul></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"五.-组合逻辑电路5\">五. 组合逻辑电路(5)</h3>\r\n<p>这一节比较杂，主要是对第（4）内容的一个补充。具体来说，讲了如下内容：</p>\r\n<ol type=\"1\">\r\n<li>用香农展开定理搭配多路选择器实现逻辑函数</li>\r\n<li>八选一数据选择器74151</li>\r\n<li>双四选一数据选择器74153</li>\r\n<li>数据选择器的更多运用</li>\r\n</ol>\r\n<h4 id=\"用香农展开定理搭配多路选择器实现逻辑函数\">5.1\r\n用香农展开定理搭配多路选择器实现逻辑函数</h4>\r\n<ul>\r\n<li><p>香农展开定理：</p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(f\\left(w_{1}, w_{2}, \\ldots . .\r\nw_{\\mathrm{n}}\\right)=\\overline{w_{1}} f\\left(0, w_{2}, \\ldots . .\r\nw_{\\mathrm{n}}\\right)+w_{1} f\\left(1, w_{2}, \\ldots . .\r\nw_{\\mathrm{n}}\\right)\\)</span></p>\r\n<ul>\r\n<li><p>↑展开一个变量</p></li>\r\n<li><p>在香农表达式中<span\r\nclass=\"math inline\">\\(f\\left(0,w_{2}....w_{\\mathrm{n}}\\right)\\)</span>\r\n项称为对应于<span\r\nclass=\"math inline\">\\(\\bar{w}_{\\mathrm{1}}\\)</span>的<span\r\nclass=\"math inline\">\\(f\\)</span>的余因子式, 简写做<span\r\nclass=\"math inline\">\\(f_{\\overline{w}_1}\\)</span>。 同样的,<span\r\nclass=\"math inline\">\\(f(1,w_2.....w_n)\\)</span> 项称为对应于<span\r\nclass=\"math inline\">\\(w_{_1}\\)</span>的<span\r\nclass=\"math inline\">\\(f\\)</span>的余因子式,简写做<span\r\nclass=\"math inline\">\\(f_{_{w_1}}\\)</span>。所以香农展开定理可以简写成：\r\n<span class=\"math display\">\\[\r\nf=\\overline{w}_{1}f_{\\overline{w}_{1}}+w_{1}f_{w_{1}}\r\n\\]</span></p></li>\r\n</ul></li>\r\n<li><p><span class=\"math inline\">\\(f(w_1,w_2,....,w_n)=\\\\\r\n\\overline{w_1}\\overline{w_2}f(0,0,w_3....w_n)+\\overline{w_1}w_2f(0,1,w_3,.....w_n)+w_1\\overline{w_2}f(1,0,w_3,.....w_n)+\r\n\\\\ w_1w_2f(1,1,w_3,.....w_n)\\)</span></p>\r\n<ul>\r\n<li>↑展开多个变量</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<p>那如何用香农展开定理实现逻辑函数呢？举个例子，比如<span\r\nclass=\"math inline\">\\(f=\\overline{w}_{1}\\overline{w}_{3}+w_{1}w_{2}+w_{1}w_{3}\\)</span></p>\r\n<p>将f以w1用香农展开定理展开，得到<span\r\nclass=\"math inline\">\\(f=\\overline{w}_1f_{\\overline{w}_1}+w_1f_{w_1}=\\overline{w}_1(\\overline{w}_3)+w_1(w_2+w_3)\\)</span></p>\r\n<p>然后选用二路选择器，w1是选择器，数据输入通道2个分别是<span\r\nclass=\"math inline\">\\(\\overline{w_3}\\)</span>和<span\r\nclass=\"math inline\">\\(w_2 +\r\nw_3\\)</span>，数据输出通道一个为f。实现电路图如下：</p>\r\n<p><img src=\"46.png\" /></p>\r\n<p>同理，如果用香农展开定理展开两个变量，则搭配一个四路选择器也可以实现上述函数f。</p>\r\n<h4 id=\"八选一数据选择器74151\">5.2 八选一数据选择器74151</h4>\r\n<p>74151MUX的样子和真值表如下图</p>\r\n<p><img src=\"47.png\" /></p>\r\n<h4 id=\"双四选一数据选择器74153\">5.3 双四选一数据选择器74153</h4>\r\n<p>就是俩独立的四路选择器放一起，如图。（个人觉得左图很不直观，下面练习中的74153比较直观）</p>\r\n<p><img src=\"48.png\" /></p>\r\n<blockquote>\r\n<p>练习：如何用74153构建一个74151？</p>\r\n</blockquote>\r\n<p>很简单，跟以前练习题一样的套路。只要保证两个四选一板子有且只能有一块板子在工作就行了。看答案吧，很简单。</p>\r\n<p><img src=\"49.png\" /></p>\r\n<p>A2还有G1就是为了实现”只能有一个四选一“板子在工作我们自己加上去的电路。</p>\r\n<h4 id=\"小补充\">5.4 小补充</h4>\r\n<p>感觉代号多了有点乱了。让我来梳理一下。</p>\r\n<p>74148是最常见的8线-3线优先编码器。</p>\r\n<p>74138是最常见的二进制译码器。（3个输入、8个输出）</p>\r\n<p>数据分配器DEMUX可用74138实现。</p>\r\n<p>数据选择器MUX有74151（八路）、74153（俩独立四路放一起）</p>\r\n<h4 id=\"数据选择器的更多运用\">5.5 数据选择器的更多运用</h4>\r\n<ol type=\"1\">\r\n<li><p>与DEMUX实现多路信号分时传送</p>\r\n<p><img src=\"50.png\" /></p></li>\r\n<li><p>实现逻辑函数</p>\r\n<ul>\r\n<li><p>用MUX实现逻辑函数的方法有许多。</p>\r\n<ol type=\"1\">\r\n<li>直接列真值表实现</li>\r\n<li>列完真值表，对真值表优化后实现</li>\r\n<li>用香农展开公式后实现</li>\r\n<li>列引入变量的卡诺图实现</li>\r\n</ol></li>\r\n<li><p>前三种方法前面都介绍过了，这里放一个用第四种方法的例题。</p>\r\n<p><img src=\"51.png\" /></p></li>\r\n<li><p>因为74151是八位选择器，所以只能有3个选择变量。所以画卡诺图引入了一个变量。然后8个信号输入端口就输入0/1/D/<span\r\nclass=\"math inline\">\\(\\overline{D}\\)</span>即可。</p></li>\r\n<li><blockquote>\r\n<p>练习：请用一片74151实现逻辑函数<span\r\nclass=\"math inline\">\\(F(A,B,C,D,E)=A\\overline{B}C\\overline{D}E+AB\\overline{C}\\overline{D}\\overline{E}+A\\overline{B}C\\overline{D}\\overline{E}+\\overline{A}\\overline{B}\\overline{C}DE+\\overline{A}B\\overline{C}\\overline{D}\\overline{E}\\)</span></p>\r\n</blockquote></li>\r\n<li><p>74151是八路选择器，所以要有三个选择变量。但是这里F有5个，所以第一想法是用香农展开定理展开3个变量，但是这样太麻烦了。所以用第四种方法，引入两个变量进卡诺图即可。</p>\r\n<p><img src=\"52.png\" /></p></li>\r\n</ul></li>\r\n<li><p>数据选择器的扩展</p>\r\n<ul>\r\n<li><p>很好理解，看图即可。</p>\r\n<p><img src=\"53.png\" /></p></li>\r\n</ul></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"六.-组合逻辑电路6\">六. 组合逻辑电路(6)</h3>\r\n<h4 id=\"数值比较器\">6.1 数值比较器</h4>\r\n<ul>\r\n<li><strong>一位数值比较器</strong></li>\r\n</ul>\r\n<p>两个1位二进制数A,B相比的情况有以下几种: 1. A&gt;B，则<span\r\nclass=\"math inline\">\\(A\\overline{B}=1\\)</span>，所以可用<span\r\nclass=\"math inline\">\\(A\\overline{B}\\)</span>作为A&gt;B的输出信号<span\r\nclass=\"math inline\">\\({Y}_{(A&gt;B)}\\)</span> 。<br />\r\n2. 同理可用 <span class=\"math inline\">\\(\\overline{AB}\\)</span>\r\n作为A&lt;B的输出信号 <span class=\"math inline\">\\({Y}_{(A&lt;B)}\\)</span>\r\n。 3. 同理可用<span class=\"math inline\">\\(A \\odot B\\)</span>\r\n作为A=B的输出信号 <span class=\"math inline\">\\(Y_{A=B}\\)</span></p>\r\n<p>于是可以设计出如下电路（注意是低电平有效）</p>\r\n<p><img src=\"54.png\" /></p>\r\n<ul>\r\n<li><strong>多位数值比较器</strong></li>\r\n</ul>\r\n<p>多位数值比较器的原理就是从高位到低位逐位比较，最常见的是4位比较器14585，下面是其逻辑函数和电路图：</p>\r\n<p><img src=\"55.png\" /></p>\r\n<p><img src=\"56.png\" /></p>\r\n<p>这个图有4个要注意的地方，首先看蓝色箭头的地方，为啥这个地方用与非门呢？很简单，将上面的逻辑表达式进行进一步化简：\r\n<span class=\"math display\">\\[\r\nY_{A&lt;B} = \\overline{\\overline{\\overline{A_3}B_3} \\cdot\r\n\\overline{\\overline{A_3 \\oplus B_3}\\overline{A_2}B_2} \\cdot ...} \\,\r\n\\cdot I_{A&lt;B}  \\\\\r\n= \\overline{\\overline{\\overline{A_3}B_3} \\cdot ((A_3 \\oplus B_3) +\r\n\\overline{\\overline{A_2}B_2}) \\cdot \\, ...} \\, \\cdot I_{A&lt;B}\r\n\\]</span> 现在知道蓝色箭头为啥用与非门了吧=w=。</p>\r\n<p>那为啥绿色箭头那要用或门呢？还是看上面化简的式子，注意看第二项，第二项就是或门=w=。</p>\r\n<p>那为啥棕色箭头用或非门呢？还是化简上面的式子： <span\r\nclass=\"math display\">\\[\r\nY_{A=B} = \\overline{(A_3 \\oplus B_3) + (A_2 \\oplus B_2) + (略) + (略)}\r\n\\, \\cdot I_{A=B}\r\n\\]</span>\r\n很清楚吧=w=，就是一个或非门，每一项这里用异或表达了，其实就是图中判断是否每一项是否相等的那个逻辑门。</p>\r\n<p>那为啥红箭箭头那要用或非门呢？还是化简上面的式子： <span\r\nclass=\"math display\">\\[\r\nY_{A&gt;B} = \\overline{(Y_{A&lt;B} + Y_{A=B}) + \\overline{I_{A&gt;B}}}\r\n\\]</span> easy。</p>\r\n<p>还剩一个问题，那三个<span\r\nclass=\"math inline\">\\(I\\)</span>是干啥的。其实就是用来接收低位上的结果的。这样两块14585就能实现8位数字的比较。如下图：</p>\r\n<p><img src=\"57.png\" /></p>\r\n<p>有个问题，为啥左边的<span\r\nclass=\"math inline\">\\(Y_{A&gt;B}\\)</span>为啥不能连到右边的<span\r\nclass=\"math inline\">\\(I_{A=B}\\)</span>？</p>\r\n<p>其实可以，但是图中这样连也没问题。还是用逻辑表达式去解释：<span\r\nclass=\"math inline\">\\(Y_{A&gt;B} = \\overline{(Y_{A&lt;B} + Y_{A=B}) +\r\n\\overline{I_{A&gt;B}}}\\)</span>，可以发现必须要三者都是0才会使得<span\r\nclass=\"math inline\">\\(Y_{A&gt;B}=1\\)</span>，所以默认给<span\r\nclass=\"math inline\">\\(I_{A&gt;B}\\)</span>置为1不影响结果。</p>\r\n<h4 id=\"加法器\">6.2 加法器</h4>\r\n<ul>\r\n<li><strong>半加器</strong></li>\r\n</ul>\r\n<p>很简单，真值表、逻辑表达式、图形符号如下图：</p>\r\n<p><img src=\"58.png\" /></p>\r\n<ul>\r\n<li><strong>全加器</strong></li>\r\n</ul>\r\n<p>加了一个考虑上一位进位而已，也很简单，真值表、逻辑表达式、图形符号如下：</p>\r\n<p><img src=\"59.png\" /></p>\r\n<p>这里解释一下逻辑表达式，因为异或是不进位加法，所以S等于三者异或很合理。然后CO用或连接也很合理，无非就是A、B都是1可以进位，或者CI为1，A、B里任意一个为1也可以进位。</p>\r\n<ul>\r\n<li><strong>串行进位加法器</strong></li>\r\n</ul>\r\n<p>有了全加器之后，只需要将多个全加器串联起来就可以得到任意多位的加法器了。如下图：</p>\r\n<p><img src=\"60.png\" /></p>\r\n<p>虽然这样逻辑和电路都很简单，但是存在一个问题，就是速度过慢，如何解决呢？</p>\r\n<p>速度关键是慢在进行信号逐级传递的过程，所以要优化这个过程。不难发现，要想知道<span\r\nclass=\"math inline\">\\(CI_i\\)</span>，只需要知道<span\r\nclass=\"math inline\">\\(A_{i-1}A_{i-2}...A_0\\)</span>和<span\r\nclass=\"math inline\">\\(B_{i-1}B_{i-2}...B_0\\)</span>即可。</p>\r\n<p>个人觉得，这种优化思路就很像把递归函数展开来写了笑死。也有点像并查集路径压缩。</p>\r\n<ul>\r\n<li><strong>超前进位加法器</strong></li>\r\n</ul>\r\n<p>用上面提到的优化方法做成的加法器就叫做超前进位加法器。下图是74283的超前进位加法器电路图：</p>\r\n<p><img src=\"61.png\" /></p>\r\n<p>可以发现光4位加法器电路就那么复杂了，这或许就是空间换时间吧（笑）</p>\r\n<p>所以当我们需要更多位加法器的时候，可以拿74283超前进位加法器去串联做成一个多位的串行进位加法器。</p>\r\n<blockquote>\r\n<p>练习：用一片74283设计将BCD8421码转换成余3码的电路</p>\r\n</blockquote>\r\n<p>太简单啦！直接上图：</p>\r\n<p><img src=\"62.png\" /></p>\r\n<h4 id=\"竞争-冒险现象\">6.3 竞争-冒险现象</h4>\r\n<p>啊我懒得打很多字了，这里我放一个up主的视频，看完这道例题就知道什么是竞争-冒险现象了：（up主：海蓬莱）</p>\r\n<video src=\"video.mp4\" controls=\"controls\">\r\n</video>\r\n<p>视频中的险象就是这里的冒险。官方定义如下 ：</p>\r\n<p>竞争：一个逻辑门的两个输入端的信号同时向相反方向变化，而变化的时间有差异的现象。</p>\r\n<p>冒险：由于竞争而使电路输出发生瞬时错误</p>\r\n<p>注意，有竞争不一定会冒险（如视频中提到的非临界竞争）</p>\r\n<p>冒险分为两类：</p>\r\n<ol type=\"1\">\r\n<li>0型冒险：即本来是1的变成了0\r\n<ul>\r\n<li>当表达式在一定条件下能化成<span class=\"math inline\">\\(F = A +\r\n\\overline{A}\\)</span>时，就会出现0型冒险</li>\r\n</ul></li>\r\n<li>1型冒险：即本来是0的变成了1\r\n<ul>\r\n<li>当表达式在一定条件下能化成<span class=\"math inline\">\\(F = A \\cdot\r\n\\overline{A}\\)</span>时，就会出现1型冒险</li>\r\n</ul></li>\r\n</ol>\r\n<p>如何能消除竞争-冒险现象呢？ppt上给出了三种解决方案：</p>\r\n<ol type=\"1\">\r\n<li><p>接入滤波电容</p></li>\r\n<li><p>引入选通脉冲</p></li>\r\n<li><p>修改逻辑表达式</p>\r\n<ul>\r\n<li>前俩个反正我是没看懂，这里举个例子说一下第三种方法。比如有逻辑函数<span\r\nclass=\"math inline\">\\(F = AB + \\overline{A}C\\)</span>，当B = C =\r\n1时会出现0型冒险。所以可以修改一下逻辑表达式为：<span\r\nclass=\"math inline\">\\(F = AB + \\overline{A}C +\r\nBC\\)</span>，这样就不会出现0型冒险了。（为什么要这么修改呢？看下面的卡诺图你就知道了）</li>\r\n</ul>\r\n<p><img src=\"63.png\" /></p></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"七.-vivado的基本使用\">七. Vivado的基本使用</h3>\r\n<p>先来了解一下EDA技术：即电子设计自动化，其依赖功能强大的计算机，在\r\nEDA工具软件平台上，对以硬件描述语言(HDL)为系统逻辑描述手段完成的设计文件，自动地完成逻辑编译、逻辑化简、逻辑分割、逻辑综合、布局布线，以及逻辑优化和仿真测试，直至物理实现既定的电子设计系统功能。</p>\r\n<p>以我浅薄的理解，EDA = IDE，Verilog =\r\nC++，hhhhh，FPGA是可编程逻辑器件。</p>\r\n<h4 id=\"用verilog-hdl设计电路\">7.1 用Verilog HDL设计电路</h4>\r\n<p>写一个模块大致分为以下几步：</p>\r\n<ol type=\"1\">\r\n<li>打开Vivado，创建一个项目（根据自己开发板选型号，我的是xc7a35tcpg236-1）</li>\r\n<li>新建一个design文件，在里头写程序</li>\r\n<li>新建一个sim文件，在里头写仿真程序（初始化 + 实例化 +\r\n仿真过程代码）</li>\r\n<li>运行仿真，观察仿真结果是否跟设想一样</li>\r\n<li>封装IP核，以便此模块以后可被其它项目使用</li>\r\n</ol>\r\n<h4 id=\"用block-design设计电路\">7.2 用Block Design设计电路</h4>\r\n<ol type=\"1\">\r\n<li>打开Vivado，创建一个项目</li>\r\n<li>左侧新建一个Block Design项目</li>\r\n<li>引入IP核，开始画图</li>\r\n<li>新建一个sim文件，写仿真程序</li>\r\n<li>运行仿真，观察仿真结果是否跟设想一样</li>\r\n</ol>\r\n<h4 id=\"用rtl看电路图\">7.3 用RTL看电路图</h4>\r\n<p>点左侧RTL分析即可生成。</p>\r\n<h4 id=\"下板\">7.4 下板</h4>\r\n<ol type=\"1\">\r\n<li>写好constraint文件（我直接用的老师给的模板文件上修改）</li>\r\n<li>运行左侧Synthesis</li>\r\n<li>运行Implementation（记得勾选第二项产生二进制文件，然后选择Open\r\nHardware Manager）</li>\r\n<li>通过USB连上FPGA</li>\r\n<li>点击Auto Connect，连接成功后选择Program\r\nDevice下载刚才的二进制文件</li>\r\n<li>可以愉快的用板子观察程序结果啦~</li>\r\n</ol>\r\n<p>但是断电后程序就会丢失，为了解决这个问题，需要把程序烧录进ROM里：</p>\r\n<ol type=\"1\">\r\n<li>生成bin文件，Tools -&gt; Settings -&gt; Bitstream -&gt;\r\n勾选-bin-file* -&gt; OK，左侧Generate\r\nBitstream重新生成bit文件（此时就会生成bin文件）</li>\r\n<li>右键芯片选择Add Configuration Memory Device，选择合适的闪存型号</li>\r\n</ol>\r\n<h4 id=\"总结\">7.5 总结</h4>\r\n<p>Vivado这个软件其实蛮简单使用的。首先不考虑板子的话，只在电脑上设计电路有两种方法，第一种就是直接创建design文件写，第二种就是用Block\r\nDesign（若某个模块想封装成IP核必须要仿真过先）。然后想看设计的对不对，就创建仿真文件来看。另外，用RTL可以看设计好的电路。</p>\r\n<p>下板的话就需要通过constraint文件指定管脚，然后左侧Synthesis +\r\nImplementation + 生成二进制文件 + 连板子 + Auto Connect + Program\r\nDevice就可以在板子上观察了。</p>\r\n<hr />\r\n<p>现在是2023/10/28，又准备要做时序逻辑电路的实验了。所以继续把这个自学笔记写完吧hhhh</p>\r\n<h3 id=\"八.-触发器\">八. 触发器</h3>\r\n<p>定义：触发器是具有记忆功能的基本逻辑单元，一个触发器可以存储一个二值信号。</p>\r\n<h4 id=\"rs触发器\">8.1 RS触发器</h4>\r\n<p><img src=\"64.png\" /></p>\r\n<p>首先需要知道与非门的特点，对于与非门，如果有一端为0，那么输出就为1。如果两端都为1，那么输出才为0。所以对于上图，如果S=0,\r\nR=1，那么Q = 1, Q反馈回去得到<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>=0。如果R=0, Q=1，那么<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>=1，反馈回去得到Q=0。</p>\r\n<p>其实S为set，R为reset，Q为输出。而且S、R都是低电平有效。所以S=0,R=1的时候，输出将置位为1。R=0,\r\nS=1时，输出将reset为0。</p>\r\n<p>如果S = R = 1呢？按照感性理解就是set和reset都不起效，也就是Q和<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>维持上一个状态。让我们来验证一下，假设Q=0，则反馈回去<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>=1，再反馈回来Q=0。假设Q=1，则反馈回去<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>=0，再反馈回来Q=1。没有问题，就是维持上一个状态。</p>\r\n<p>如果S = R =\r\n0呢？按照感性理解就是set和reset都起效，那必然会存在一个“竞争”问题。也就是存在不唯一性。让我们来验证一下，假设S\r\n= R = 0，那么Q和<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>都将会为1。好，假设下一个时刻S\r\n= R = 1, 按照上面的分析应该维持原状对吧。但是假如Q先传回去，则<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>=0，再传回来Q=1，新状态Q=1,\r\n<span class=\"math inline\">\\(\\overline{Q}\\)</span>=0；假如<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>先传回去，则Q=0,\r\n再传回来<span class=\"math inline\">\\(\\overline{Q}\\)</span>=1，新状态Q=0,\r\n<span\r\nclass=\"math inline\">\\(\\overline{Q}=1\\)</span>。所以我们是要禁止出现S = R\r\n= 0的情况的！因为下一个时刻就会出现<strong>“不唯一性”</strong>。</p>\r\n<p>经过上面的分析，下面的真值表就十分清楚了：</p>\r\n<p><img src=\"65.png\" /></p>\r\n<p>用逻辑表达式<span class=\"math inline\">\\(Q^{n+1}=\\overline{S} + R(Q^n)\r\n\\quad ,R + S = 1,\\)</span>也可以表示上面的真值表（用卡诺图推）</p>\r\n<h4 id=\"钟控触发器\">8.2 钟控触发器</h4>\r\n<p>钟控触发器是在普通触发器上的一个改进。因为有时候我们只希望在某一个信号到来的时候，Q才随R和S改变。而其余时候，都希望Q维持原状，也就是这个触发器被“锁”起来。那么钟控触发器就可以实现这个功能。</p>\r\n<p>钟控触发器也分为几种：可控R-S触发器、主从式J-K触发器、D型触发器、T型触发器。</p>\r\n<ul>\r\n<li><strong>可控R-S触发器</strong></li>\r\n</ul>\r\n<p>先来看它的电路图和装置图：</p>\r\n<p><img src=\"66.png\" /></p>\r\n<p>可以发现，可控R-S触发器无非就是在R-S触发器的前面加了俩与非门。因为我们知道对于与非门，只要有一端是0，输出就为1。所以当cp为0时，Q将维持原状，触发器被“锁”住。当cp为1时，R、S的输入就可以影响到Q。可是注意，因为多了俩与非门的存在，所以本来对于R、S是低电平有效，现在变成了高电平有效了。也就是S\r\n= 1, R = 0时，Q = 1；S = 0, R = 1时，Q = 0；S = R = 0时维持原状；S = R =\r\n1时为不稳定态。</p>\r\n<p>总结来说，cp=0时锁触发器，cp=1时激活触发器，但是会变为高电平有效。</p>\r\n<p>逻辑表达式为：<span class=\"math inline\">\\(Q^{n+1} = S +\r\n\\overline{R}Q^n \\quad ,R \\cdot S = 0, CP = 1\\)</span></p>\r\n<ul>\r\n<li><strong>主从式J-K触发器</strong></li>\r\n</ul>\r\n<p>J-K触发器是可控R-S触发器的一个升级版，它的J、K分别对应R、S，而且允许J和K同时取1。同时取1的时候不会引入“竞争”，而是会翻转输出Q的结果。</p>\r\n<p>具体来说，当cp=0时，触发器被锁住。当cp=1时，触发器激活，J、K高电平有效。J\r\n= 1, K = 0时Q = 1；J = 0, K = 1时Q = 0；J = K = 0时保持原状；J = K =\r\n1时翻转Q。</p>\r\n<p>下面是它的逻辑表达式和电路图：</p>\r\n<p><span class=\"math inline\">\\(Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\r\n\\quad ,CP = 1\\)</span></p>\r\n<p><img src=\"67.png\" /></p>\r\n<ul>\r\n<li><strong>D型触发器</strong></li>\r\n</ul>\r\n<p>这个触发器最直观，只有两个输入端：cp和D。D输出什么，这个触发器就存储什么（我已经预感到实验会大量使用到这个触发器了hhhh）。</p>\r\n<p>详细来说，cp=0时，触发器被锁住。cp=1时，若D = 0，则Q = 0；若D =\r\n1，则Q = 1。</p>\r\n<p>它的电路图如下：（其实所有触发器都是在R-S触发器的基础上在输入端进行改动）</p>\r\n<p><img src=\"68.png\" /></p>\r\n<p>这个公式推导挺有趣的。R-S基础触发器的公式是：<span\r\nclass=\"math inline\">\\(Q^{n+1}=\\overline{S} + R(Q^n)\\)</span>。</p>\r\n<p>然后由图中可以推出，<span class=\"math inline\">\\(R = \\overline{CP\r\n\\cdot (\\overline{CP \\cdot D})} = \\overline{CP \\cdot \\overline{D}} \\quad\r\n, S = \\overline{CP \\cdot D}\\)</span>。</p>\r\n<p>将上面的R、S带入原始公式：<span class=\"math inline\">\\(Q^{n+1} = CP\r\n\\cdot D + (\\overline{CP} + D)Q^n = D(CP + Q^n) +\r\n\\overline{CP}Q^n\\)</span></p>\r\n<p><span class=\"math inline\">\\(CP=0\\)</span>时，<span\r\nclass=\"math inline\">\\(Q^{n+1} = DQ^n + Q^n = Q^n\\)</span></p>\r\n<p><span class=\"math inline\">\\(CP = 1\\)</span>时，<span\r\nclass=\"math inline\">\\(Q^{n+1} = D\\)</span></p>\r\n<p>完整公式：<span class=\"math inline\">\\(Q^{n+1} = D\\cdot CP +\r\n\\overline{CP}Q^n\\)</span></p>\r\n<ul>\r\n<li><strong>T型触发器</strong></li>\r\n</ul>\r\n<p>这个触发器也是只有两个输入端：cp和T。cp=0时，触发器被锁住。cp=1时，T=0时维持原态，T=1时翻转输出。</p>\r\n<p>它的电路图如下：</p>\r\n<p><img src=\"69.png\" /></p>\r\n<p>可以看出，T触发器就是在J-K触发器的基础上，把J和K变成一个接口T了。所以J-K触发器的公式：<span\r\nclass=\"math inline\">\\(Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\)</span>就应该改为<span\r\nclass=\"math inline\">\\(Q^{n+1} = T \\oplus Q^n\\)</span>。</p>\r\n<h4 id=\"总结-1\">8.3 总结</h4>\r\n<p>触发器这块，R-S触发器是最经典的，后续所有的钟控触发器都是由R-S触发器修改得到。所以R-S触发器的公式和电路图要记住：<span\r\nclass=\"math inline\">\\(Q^{n+1} = \\overline{S} +\r\nRQ^n\\)</span>。然后它是低电平有效，后续的钟控触发器都是高电平有效。它有两个缺点：</p>\r\n<ol type=\"1\">\r\n<li>没有时钟控制</li>\r\n<li>R、S不能同时为0</li>\r\n</ol>\r\n<p>可控R-S触发器就是在R-S的基础上加了两个与非门，多连了一个CP。公式为<span\r\nclass=\"math inline\">\\(Q^{n+1} = S +\r\n\\overline{R}Q^n\\)</span>。解决了缺点2。</p>\r\n<p>J-K触发器就是在可控R-S触发器的基础上将两个输出连接到J、K输入端，公式为<span\r\nclass=\"math inline\">\\(Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\)</span>。又解决了缺点1。</p>\r\n<p>D触发器和T触发器背一下就好了，不要求掌握其电路图。D触发器就是CP=1时D是什么，Q就是什么。T触发器就是CP=1时T=0为维持原状，T=1为翻转输出，公式为<span\r\nclass=\"math inline\">\\(Q^{n+1} = T \\oplus Q^n\\)</span></p>\r\n<hr />\r\n<h3 id=\"九.-时序逻辑电路1\">九. 时序逻辑电路(1)</h3>\r\n<h4 id=\"概述-1\">9.1 概述</h4>\r\n<p>时序电路一般都是由两个部分构成的：组合电路和存储电路。</p>\r\n<p>存储电路的输出必须反馈到组合电路的输入端，从而与输入信号一起决定组合电路的输出。</p>\r\n<p>下面这两张图能很好的解释时序逻辑电路的特点：</p>\r\n<p><img src=\"70.png\" /></p>\r\n<p><img src=\"71.png\" /></p>\r\n<p>时序逻辑电路分类的话有两种分类方式：</p>\r\n<ul>\r\n<li><p>按触发器的动作特点分类</p>\r\n<ol type=\"1\">\r\n<li>同步时序逻辑电路（有统一的CP）</li>\r\n<li>异步时序逻辑电路（无统一的CP）</li>\r\n</ol></li>\r\n<li><p>按输出信号的特点分类</p>\r\n<ol type=\"1\">\r\n<li><p>米利型（输出跟输入变量和存储电路有关）</p>\r\n<p><img src=\"72.png\" /></p></li>\r\n<li><p>莫尔型（输出只跟存储电路有关）</p>\r\n<p><img src=\"73.png\" /></p></li>\r\n</ol></li>\r\n</ul>\r\n<h4 id=\"时序逻辑电路的描述方法\">9.2 时序逻辑电路的描述方法</h4>\r\n<p>从理论上：输出方程(通过输入和现态算输出) + 驱动方程 +\r\n状态方程(通过现态算次态)</p>\r\n<p>从图表上：状态转换表、状态转换图、时序图</p>\r\n<ul>\r\n<li><strong>状态转换表</strong></li>\r\n</ul>\r\n<p>若将任何一组输入变量及电路初态的取值代入状态方程和输出方程，即可算出电路的次态和现态下的输出值。如此继续下去，把全部的计算结果列成真值表的形式，就得到了状态转换表。</p>\r\n<p>通过下面这个例子就很容易看懂。左边第一、二个是状态方程，第三个是输出方程。右边是状态转换表。</p>\r\n<p><img src=\"74.png\" /></p>\r\n<ul>\r\n<li><strong>状态转换图</strong></li>\r\n</ul>\r\n<p>就是状态转换表形象化的表示。以小圆圈表示电路的各个状态，圆圈中填入存储单元的状态值，圆圈之间用箭头表示状态转换的方向，在箭头旁注明状态转换前的输入变量取值和输出值。</p>\r\n<p>下面这张图就是上面那个状态转换表的状态转换图，很容易理解。</p>\r\n<p><img src=\"75.png\" /></p>\r\n<ul>\r\n<li><strong>时序图</strong></li>\r\n</ul>\r\n<p>就是波形图。</p>\r\n<hr />\r\n<h3 id=\"十.-时序逻辑电路2\">十. 时序逻辑电路(2)</h3>\r\n<h4 id=\"同步时序逻辑电路的分析\">10.1 同步时序逻辑电路的分析</h4>\r\n<p>跟分析组合逻辑电路一样，也是画出真值表（状态转换表），然后观察得出功能。</p>\r\n<p>具体来说，分为下面几步：</p>\r\n<ol type=\"1\">\r\n<li>写出输出方程</li>\r\n<li>写出驱动方程</li>\r\n<li>写出状态方程</li>\r\n<li>根据方程画出状态转换表</li>\r\n</ol>\r\n<p>下面用一道例题来感受：</p>\r\n<p><img src=\"76.png\" /></p>\r\n<p>输出方程：<span class=\"math inline\">\\(Y = Q_0^nQ_2^n\\)</span></p>\r\n<p>驱动方程： <span class=\"math display\">\\[\r\nJ_0 = K_0 = 1 \\\\\r\nJ_1 = K_1 = \\overline{Q_2^n}Q_0^n \\\\\r\nJ_2 = Q_1^nQ_0^n, K_2 = Q_0^n\r\n\\]</span> 状态方程： <span class=\"math display\">\\[\r\nQ_0^{n+1} = J_0\\overline{Q_0^n} + \\overline{K_0}Q_0^n = \\overline{Q_0^n}\r\n\\\\\r\nQ_1^{n+1} = J_1\\overline{Q_1^n} + \\overline{K_1}Q_1^n =\r\n\\overline{Q_2^n}Q_0^n \\oplus Q_1^n \\\\\r\nQ_2^{n+1} = J_2\\overline{Q_2^n} + K_2Q_2^n = Q_1^nQ_0^n\\overline{Q_2^n}\r\n+ \\overline{Q_0^n}Q_2^n\r\n\\]</span> 根据状态方程和输出方程写出状态转换表：</p>\r\n<p>设电路初始状态为<span class=\"math inline\">\\(Q_2Q_1Q_0 =\r\n000\\)</span>，则</p>\r\n<p><img src=\"77.png\" /></p>\r\n<p>（注意，当出现循环（红圈）时，即可停下）。</p>\r\n<p>若有需要，还可以根据状态转换表画出状态转换图和时序图：</p>\r\n<p><img src=\"78.png\" /></p>\r\n<p>注意，CP是系统时钟，因为状态转换表中有6条不同的数据，电路又是低电平激发，所以CP需要有6次下沿，所以时序图中CP就有6次下沿信号。</p>\r\n<h4 id=\"异步时序逻辑电路的分析\">10.2 异步时序逻辑电路的分析</h4>\r\n<p>异步时序逻辑特点就是所有触发器的CP端并没有完全连接到一起。</p>\r\n<p>还是以一道例题来讲解：</p>\r\n<p><img src=\"79.png\" /></p>\r\n<p>分析跟同步时序逻辑一样的套路，但是多一个“时钟方程”</p>\r\n<p>时钟方程：</p>\r\n<p><span class=\"math inline\">\\(CP_0 = CP_2 = CP\\)</span></p>\r\n<p><span class=\"math inline\">\\(CP_1 = Q_0\\)</span></p>\r\n<p>输出方程：</p>\r\n<p><span class=\"math inline\">\\(Y = Q_2^n\\)</span></p>\r\n<p>驱动方程：</p>\r\n<p><span class=\"math inline\">\\(J_0 = \\overline{Q_2^n}, K_0 =\r\n1\\)</span></p>\r\n<p><span class=\"math inline\">\\(J_1 = K_1 = 1\\)</span></p>\r\n<p><span class=\"math inline\">\\(J_2 = Q_1^nQ_0^n, K_2 = 1\\)</span></p>\r\n状态方程： $$ .{\r\n<span\r\nclass=\"math display\">\\[\\begin{aligned}Q_0^{n+1}&amp;=\\overline{Q_2^n}\\overline{\\mathcal{Q_0}^n}\r\n\\qquad CP↓有效\\\\\r\n\r\nQ_1^{n+1}&amp;=\\overline{Q_1^n} \\qquad Q_0↓有效\\\\\r\n\r\nQ_2^{n+1}&amp;=Q_1^n\\mathcal{Q_0}^n\\overline{\\mathcal{Q_2}^n} \\qquad\r\nCP↓有效\r\n\r\n\\end{aligned}\\]</span>\r\n<p>.. $$ 有了上面的四个方程，就可以写出状态转换表：</p>\r\n<p><img src=\"80.png\" /></p>\r\n<p>注意，因为<span class=\"math inline\">\\(Q_1\\)</span>的更新是受<span\r\nclass=\"math inline\">\\(Q_0\\)</span>↓控制的，所以当更新<span\r\nclass=\"math inline\">\\(Q_1^{n+1}\\)</span>时，应该先更新<span\r\nclass=\"math inline\">\\(Q_0^{n+1}\\)</span>，然后得出<span\r\nclass=\"math inline\">\\(CP_1\\)</span>是↑还是↓，然后才能去更新<span\r\nclass=\"math inline\">\\(Q_1^{n+1}\\)</span>。</p>\r\n<p>有了状态转换表后就可以画出状态转换图和时序图：</p>\r\n<p><img src=\"81.png\" /></p>\r\n<hr />\r\n<h3 id=\"十一.-时序逻辑电路3\">十一. 时序逻辑电路(3)</h3>\r\n<h4 id=\"同步时序逻辑电路的设计\">11.1 同步时序逻辑电路的设计</h4>\r\n<p>套路为：</p>\r\n<ol type=\"1\">\r\n<li>进行逻辑抽象，并写出逻辑状态转换表，并进行化简合并</li>\r\n<li>将逻辑状态转换表映射到二进制状态转换表</li>\r\n<li>根据二进制状态转换表分别求出输出方程和状态方程</li>\r\n<li>选用一种触发器，根据触发器公式和状态方程推出驱动方程</li>\r\n<li>根据输出、驱动、状态方程画出电路图</li>\r\n<li>检查此电路是否有自启动能力</li>\r\n</ol>\r\n<p>以一道例题来举例：</p>\r\n<blockquote>\r\n<p>试设计一个串行数据检测器。对它的要求是：连续输入三个或三个以上的’1’时输出为’1’，其它情况输出为’0’(试用上边沿JK-FF完成设计)。</p>\r\n</blockquote>\r\n<ul>\r\n<li>逻辑抽象</li>\r\n</ul>\r\n<p>令输入数据为输入变量，用X表示。令检测结果为输出变量，用Y表示。设电路在没有输入‘1’以前的状态为S0；输入1个‘1’后电路转入S1状态；连续输入2个‘1’后电路转入S2状态；连续输入3个或3个以上‘1’以后电路转入S3状态。</p>\r\n<p><img src=\"82.png\" /></p>\r\n<ul>\r\n<li>状态化简</li>\r\n</ul>\r\n<p>将状态转换表和图化简后如下：（如何化简参考下面的化简教学）</p>\r\n<p><img src=\"86.png\" /></p>\r\n<ul>\r\n<li>状态分配（这一步是将逻辑状态映射到数字状态）</li>\r\n</ul>\r\n<p>用二进制表示状态，比如说有4个状态<span class=\"math inline\">\\(S_0 -\r\nS_2​\\)</span>，然后用00表示<span\r\nclass=\"math inline\">\\(S_0​\\)</span>，01表示<span\r\nclass=\"math inline\">\\(S_1​\\)</span>，11表示<span\r\nclass=\"math inline\">\\(S_2​\\)</span>。然后上面那个的表可以改写为：</p>\r\n<p><img src=\"87.png\" /></p>\r\n<p>根据这个表，就可以写出输出方程和状态方程：</p>\r\n<p><img src=\"88.png\" /></p>\r\n<p>即</p>\r\n<p><span class=\"math inline\">\\(Y = XQ_1^n\\)</span></p>\r\n<p><span class=\"math inline\">\\(Q_0^{n+1} = X\\)</span></p>\r\n<p><span class=\"math inline\">\\(Q_1^{n+1} = XQ_0^{n}\\)</span></p>\r\n<p>选用JK触发器，结合公式<span class=\"math inline\">\\(Q^{n+1} =\r\nJ\\overline{Q^n} + \\overline{K}Q^n\\)</span>和<span\r\nclass=\"math inline\">\\(Q_0^{n+1} = X = X(\\overline{Q_0^n} + Q_0^n) =\r\nX\\overline{Q_0^n} + XQ_0^n\\)</span></p>\r\n<p>可以得到，<span class=\"math inline\">\\(J_0 = X, K_0 =\r\n\\overline{X}\\)</span></p>\r\n<p>同理，可得到<span class=\"math inline\">\\(J_1 = XQ_0^n, K_1 =\r\n\\overline{XQ_0^n}\\)</span></p>\r\n<p>所以，全部方程如下：</p>\r\n<p>输出方程：<span class=\"math inline\">\\(Y = XQ_1^n\\)</span></p>\r\n<p>状态方程： <span class=\"math display\">\\[\r\nQ_0^{n+1} = X \\\\\r\nQ_1^{n+1} = XQ_0^{n}\r\n\\]</span> 驱动方程： <span class=\"math display\">\\[\r\nJ_0 = X \\qquad K_0 = \\overline{X} \\\\\r\nJ_1 = XQ_0^n \\qquad K_1 = \\overline{XQ_0^n}\r\n\\]</span> 所以根据方程即可画出电路图：</p>\r\n<p><img src=\"89.png\" /></p>\r\n<ul>\r\n<li>检查是否有自启动能力</li>\r\n</ul>\r\n<p>因为在映射的时候有一些数字状态没被用到，所以就要将没用到的数字状态代入方程中去看看得到的次态是否仍然是没用到的数字状态。如果是的话说明此电路没有自启动能力。如果次态都可以回到用到的数字状态，那么此电路拥有自启动能力。</p>\r\n<p>化简教学：</p>\r\n<ol type=\"1\">\r\n<li>次态相同</li>\r\n</ol>\r\n<p><img src=\"83.png\" /></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>次态交错</li>\r\n</ol>\r\n<p><img src=\"84.png\" /></p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>次态维持</li>\r\n</ol>\r\n<p><img src=\"85.png\" /></p>\r\n<hr />\r\n<h3 id=\"十二.-时序逻辑电路4\">十二. 时序逻辑电路(4)</h3>\r\n<p>接下来介绍几种常用的时序逻辑电路。</p>\r\n<h4 id=\"计数器\">12.1 计数器</h4>\r\n<p>计数器功能就是记录输入脉冲的个数，计数器所能记录的最大脉冲个数称为计数器的“模”。</p>\r\n<p>计数器有三种分类方式，如图：</p>\r\n<p><img src=\"91.png\" /></p>\r\n<p>先来看一个最简单的3位异步二进制加法计数器。</p>\r\n<p>原理就是用JK触发器实现每次激活后输出Q翻转。第一位的CP连系统时钟，第二位的CP连第一位的输出，第三位的CP连第二位的输出。</p>\r\n<p>这样子的话，每当第一位从1 -&gt;\r\n0时，第二位才会被激活从而翻转，也就实现了“进位”的感觉。</p>\r\n<p>电路图如下：</p>\r\n<p><img src=\"92.png\" /></p>\r\n<p>再来看一下异步二进制减法计数器。（学会了上面的思想这个就很简单了）</p>\r\n<p>首先二进制减法的规则是：若低位是1，则输入一个脉冲后应当翻转为0。若低位已经是0，则应翻转为1，然后令高位翻转。</p>\r\n<p>所以根据这个需求，设计就很简单了。所以也是用JK触发器实现翻转功能。然后第一位的CP连系统时钟，第二位的CP连第一位的输出的反，第三位的CP连第二位的输出的反。</p>\r\n<p>电路图如下：</p>\r\n<p><img src=\"93.png\" /></p>\r\n<p>其实还可以用同步时序逻辑去实现加法/减法计数器。但是比较复杂，我觉得考到的概率不大，所以这里就不展开了。</p>\r\n<hr />\r\n<h3 id=\"十三.-有限状态机设计\">十三. 有限状态机设计</h3>\r\n<p>状态机就跟上面同步时序逻辑电路的设计使用的思想一模一样。就是将现实问题建模成一个个状态，那么整个问题就是在这些状态中转移。</p>\r\n<hr />\r\n<h3 id=\"复习\">复习</h3>\r\n<ul>\r\n<li>组合逻辑设计：\r\n<ul>\r\n<li>第一道题：传统方法做组合逻辑设计：即写出逻辑函数表达式然后画电路图</li>\r\n<li>第二道题：利用已有的逻辑器件实现逻辑函数</li>\r\n<li>第三道题：利用已有的逻辑器件实现逻辑函数（函数与第二道题一样）</li>\r\n<li>8421、余3、BCD，有概率前三题会涉及到</li>\r\n</ul></li>\r\n<li>异步时序逻辑分析：\r\n<ul>\r\n<li>ppt上有两个例子，把那两个例子搞明白就差不多了</li>\r\n</ul></li>\r\n<li>时序逻辑设计：\r\n<ul>\r\n<li>第一道题：设计一个器件</li>\r\n<li>第二道题：设计一个器件</li>\r\n<li>第三道题：状态机，上课讲过一些例子，没那么复杂</li>\r\n<li>代码要写注释</li>\r\n</ul></li>\r\n</ul>\r\n<p><img src=\"90.png\" /></p>\r\n","categories":["4. 大学","计算机专业课"]},{"title":"数据库自学笔记","url":"/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"<p>懒得解释了，反正之前没咋认真听过课（其实是去做数据库期末项目了）。今天终于有点时间了抽空看了一下之前的内容，做一下笔记记录一下免得以后忘了。学点东西顺便应付一下期末考试。</p>\r\n<span id=\"more\"></span>\r\n<p>upd: (2024/1/14)：这门课满绩了，考试很简单，都是笔记里的东西。</p>\r\n<hr />\r\n<h3 id=\"数据库基础概念相关\">数据库基础概念相关</h3>\r\n<ol type=\"1\">\r\n<li><p>数据(Data)、数据库(DB)、数据库系统(DBS)、数据库管理系统(DBMS)数据定义</p>\r\n<ol type=\"1\">\r\n<li>数据是描述事物的符号记录。</li>\r\n<li>数据库是指长期存储在计算机内的、有组织的、可共享的大量数据集合。</li>\r\n<li>数据库系统是指在计算机系统中引入数据库后的系统构成，由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员(和用户)构成。</li>\r\n<li>数据库管理系统是位于用户(应用程序)与操作系统之间的一层数据库管理软件。</li>\r\n</ol></li>\r\n<li><p>数据库系统的开发环节</p>\r\n<p><img src=\"6.png\" /></p>\r\n<p>​\r\n概念设计：通常使用实体-关系模型（ER模型）来表示数据和数据间的关系。</p>\r\n<p>​\r\n逻辑设计：通常是关系模型(还有层次/网状模型)，包括了表/列/数据类型、约束（如主键、外键）等。</p>\r\n<p>​\r\n物理设计：确定如何在物理存储层面上存储数据，包括文件组织、索引结构、数据分布、存储分配等。</p></li>\r\n<li><p>数据管理的四个发展阶段：手工阶段、程序阶段、文件阶段、数据库阶段</p></li>\r\n<li><p>数据库、数据库系统、数据库管理系统的功能</p>\r\n<ol type=\"1\">\r\n<li>DB：存储、检索、维护数据</li>\r\n<li>DBS：管理数据库以及环境、支持用户与数据库交互、控制数据库权限及安全</li>\r\n<li>DBMS：提供数据定义(DDL)、数据操作(DML)、数据控制(DCL)语言，同时维护数据库，确保数据库的完整性、性能优化和恢复管理</li>\r\n</ol></li>\r\n<li><p>概念模型：是对现实世界的系统、概念或其他复杂对象的抽象表示。例如：层次模型(类似树)、网状模型(类似图)、关系模型(现在的数据库模型)、实体-联系模型(不是数据库模型，是一种用于数据库设计的高层次概念模型(ER图)</p></li>\r\n<li><p>关系模型的完整性约束</p>\r\n<ol type=\"1\">\r\n<li>实体完整性：确保每个表的主键是唯一的，且不允许为NULL。</li>\r\n<li>参照完整性：如果表A中的某个字段是表B中主键的外键，则表A中所有的外键值必须在表B中有相对应的主键值，或者是NULL。</li>\r\n<li>域完整性：数据列中的每个值都必须是定义的数据域中的有效值。</li>\r\n<li>用户定义完整性：是针对特定业务规则定制的约束条件。</li>\r\n</ol></li>\r\n<li><p>关系型数据库和非关系型数据库的主要区别是什么？并举出相应的软件产品</p>\r\n<ul>\r\n<li>关系数据库是基于关系模型的，数据以表格的形式组织，表格中的行表示记录，列表示属性。常见关系型数据库有MySql、PostgreSQL、SQL\r\nServer等；非关系型数据库采用不同的数据组织方式，如文档存储、键值对存储或图形数据库。常见的非关系型数据库有MongoDB、Hbase等。</li>\r\n</ul></li>\r\n<li><p>视图（Note：仅在少数简单视图上可以更新数据）</p></li>\r\n</ol>\r\n<ul>\r\n<li>定义：是一种虚拟表，其内容由查询定义，但不在数据库中以存储数据的形式存在。</li>\r\n<li>特点：\r\n<ul>\r\n<li>虚拟性：视图不存储数据，它是一个查询的结果集。</li>\r\n<li>逻辑独立性：可以更改底层数据表的结构而不影响视图。</li>\r\n<li>安全性：可以仅展示用户需要或允许看到的数据。</li>\r\n<li>简化复杂查询：可以创建视图来简化用户的操作。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"数据库范式相关\">数据库范式相关</h3>\r\n<h4\r\nid=\"函数依赖函数依赖集依赖的推导\">函数依赖、函数依赖集、依赖的推导</h4>\r\n<ul>\r\n<li>函数依赖(FD)。</li>\r\n</ul>\r\n<p>假设在一张表中，任意挑俩元组i, j，若发现若<span\r\nclass=\"math inline\">\\(A_i = A_j\\)</span>，则<span\r\nclass=\"math inline\">\\(B_i = B_j\\)</span>，则说明属性A可推出B，写作<span\r\nclass=\"math inline\">\\(A \\rightarrow B\\)</span>，称为B依赖于A。</p>\r\n<ul>\r\n<li>函数依赖集(FDs)。</li>\r\n</ul>\r\n<p>就是一个集合，里头的元素是函数依赖。</p>\r\n<ul>\r\n<li>依赖的推导</li>\r\n</ul>\r\n<p>三个公理（要记住。这个其实感性理解很好理解）：</p>\r\n<ol type=\"1\">\r\n<li>如果Y是X的子集，则<span class=\"math inline\">\\(X \\rightarrow\r\nY\\)</span></li>\r\n<li>如果<span class=\"math inline\">\\(X \\rightarrow Y\\)</span>，则<span\r\nclass=\"math inline\">\\(XZ \\rightarrow YZ\\)</span></li>\r\n<li>如果<span class=\"math inline\">\\(X \\rightarrow Y, Y \\rightarrow\r\nZ\\)</span>，则<span class=\"math inline\">\\(X \\rightarrow Z\\)</span></li>\r\n</ol>\r\n<p>两个定理</p>\r\n<ol type=\"1\">\r\n<li>若<span class=\"math inline\">\\(X \\rightarrow Y, X \\rightarrow\r\nZ\\)</span>，则<span class=\"math inline\">\\(X \\rightarrow YZ\\)</span>\r\n<ul>\r\n<li>证明：因为<span class=\"math inline\">\\(X \\rightarrow\r\nY\\)</span>，所以<span class=\"math inline\">\\(XZ \\rightarrow\r\nYZ\\)</span></li>\r\n<li>因为<span class=\"math inline\">\\(X \\rightarrow Z\\)</span>，所以<span\r\nclass=\"math inline\">\\(X \\rightarrow XZ\\)</span></li>\r\n<li>所以<span class=\"math inline\">\\(X \\rightarrow XZ \\rightarrow\r\nYZ\\)</span></li>\r\n</ul></li>\r\n<li>若<span class=\"math inline\">\\(X \\rightarrow YZ\\)</span>，则<span\r\nclass=\"math inline\">\\(X \\rightarrow Y, X \\rightarrow Z\\)</span>\r\n<ul>\r\n<li>证明：因为Y, Z是YZ子集，所以<span class=\"math inline\">\\(YZ\r\n\\rightarrow Y, YZ \\rightarrow Z\\)</span></li>\r\n<li>所以<span class=\"math inline\">\\(X \\rightarrow YZ \\rightarrow Y, X\r\n\\rightarrow YZ \\rightarrow Z\\)</span></li>\r\n</ul></li>\r\n</ol>\r\n<p>任何的依赖推导用上面这五条性质一般都可以推出来了。</p>\r\n<h4 id=\"候选码非主属性主属性超键\">候选码、非主属性、主属性、超键</h4>\r\n<ul>\r\n<li>候选码：能唯一标识一个关系的属性集合且集合大小要保证最小\r\n<ul>\r\n<li>注意，一个关系R中可能存在多个候选码</li>\r\n</ul></li>\r\n<li>非主属性：只要有一个属性，它不属于任何一个候选码的属性，它就是非主属性</li>\r\n<li>主属性：只要有一个属性，它属于某一个候选码，它就是主属性</li>\r\n<li>超键：能唯一标识一个关系的属性集合\r\n<ul>\r\n<li>注意，跟候选码不同的是，候选码的要求是在能唯一标识的基础上，保证集合大小最小。但是超键则无所谓，多大都ok。</li>\r\n<li>注意，一个关系R中可能存在多个超键</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"函数依赖集的闭包属性的闭包\">函数依赖集的闭包、属性的闭包</h4>\r\n<p>一般关系都是R表示，关系的函数依赖集一般用F表示。函数依赖集的闭包用<span\r\nclass=\"math inline\">\\(F^+\\)</span>表示。</p>\r\n<p>求<span\r\nclass=\"math inline\">\\(F^+\\)</span>就是用F中的依赖把所有能推出来的依赖都推出来（画树状图+用5条性质去推），就是<span\r\nclass=\"math inline\">\\(F^+\\)</span>。</p>\r\n<p>假设有一个属性A，则属性A的闭包写作<span\r\nclass=\"math inline\">\\(A^+\\)</span>。推<span\r\nclass=\"math inline\">\\(A^+\\)</span>的方法用“背包材料”的理念。最初背包中只有A这一个材料，所以首先拿A去推，能推出来的东西都放入“背包”中。然后再用背包中的材料（材料可以组合）去推，依次类推。直到没有东西可以放入背包中。</p>\r\n<p>属性闭包蛮有用的，具体作用有如下2条：</p>\r\n<ol type=\"1\">\r\n<li>判断<span class=\"math inline\">\\(X \\rightarrow Y\\)</span>是否在<span\r\nclass=\"math inline\">\\(F^+\\)</span>里。\r\n<ul>\r\n<li>正常思路是先写出F+，然后就知道<span class=\"math inline\">\\(X\r\n\\rightarrow Y\\)</span>在不在F+里了。但其实可以先写出<span\r\nclass=\"math inline\">\\(X^+\\)</span>，只要<span\r\nclass=\"math inline\">\\(X^+\\)</span>里有Y，那么<span\r\nclass=\"math inline\">\\(X \\rightarrow Y\\)</span>就在<span\r\nclass=\"math inline\">\\(F^+\\)</span>里。</li>\r\n</ul></li>\r\n<li>判断某个属性集合是否是超键\r\n<ul>\r\n<li>假设属性集合叫S，那写出<span\r\nclass=\"math inline\">\\(S^+\\)</span>，如果<span\r\nclass=\"math inline\">\\(S^+\\)</span>里包含了所有属性，那么属性集合S就是超键。</li>\r\n</ul></li>\r\n</ol>\r\n<p>补充：假定有关系R和函数依赖集F，如何推出候补码？</p>\r\n<p>观察F，然后使用口诀：“只在左边的一定是，只在右边的一定不是，两边都在的试一试”</p>\r\n<p>具体来说，如果属性A在F中只出现在箭头的左边，那么A一定属于任意一个候补码。如果属性A在F中只出现在箭头的右边，那么A一定不属于任意一个候补码（即非主属性）。如果在箭头左右都出现过，那就试一试，用属性的闭包去验证一下即可。</p>\r\n<h4\r\nid=\"无损分解分解后是否保持函数依赖\">无损分解、分解后是否保持函数依赖</h4>\r\n<p>分解一个表有时是很有必要的。假设一个表有属性“学生等级”和“学生评价”。且我们知道，如果一个学生的等级是A、B、C，他的评价分别是优秀、良好、差。如果不分解的话每次记录都要把其等级和评价记下来。但是这显然没必要，只需要记录任意一个就好。因为他们俩只要知道其中一个，另外一个是可以推出来的。</p>\r\n<p>所以可以将表分解成两张表，第一张记录了其它数据 +\r\n学生等级，第二张表记录学生等级 + 学生评价。</p>\r\n<p>上面这个例子就是解释分解是什么个意思。接下来讨论无损分解。</p>\r\n<p>无损分解就是说分解成的两个表经过自然连接后可以得到原表。不会有额外数据的增添。</p>\r\n<p>先讲结论，如果讲表R分解为<span class=\"math inline\">\\(R_1,\r\nR_2\\)</span>，如果​俩表之交能通过FDs推出任意其中一个表，则这必然是一个无损分解。</p>\r\n<p>这很好感性理解，自然连接本质就是找到俩表相同的公共部分然后连接。所以如果俩表的公共部分可以推出其中一个表，就说明不会有额外数据的增添。看下面这个例子就很好理解。</p>\r\n<p><img src=\"1.png\" /></p>\r\n<p>至于分解后是否保持函数依赖，要看F。</p>\r\n<p>也就是F中的每一对依赖X、Y，必须出现在某个子表<span\r\nclass=\"math inline\">\\(R_i\\)</span>中。这样就分解后就保持函数依赖。</p>\r\n<h4 id=\"bcnf\">BCNF</h4>\r\n<p>BCNF是3.5NF，如果一个关系是3.5NF，那么它必定是3NF。</p>\r\n<p>如果一个关系R满足BCNF，那么这张表中就不存在“冗余”。所以BCNF是很棒的。</p>\r\n<p>如果一个关系R不满足BCNF呢？那么就将R分解成若干个子表，使得每个子表都满足BCNF，这样也就不会有冗余了，这样也是很棒的。</p>\r\n<p>所以问题的关键就是如何判断一个表是否满足BCNF？以及如果一个表不满足BCNF，如何将它分解成满足BCNF的子表？</p>\r\n<p>先讲第一个问题，如何判断一个表是否满足BCNF。</p>\r\n<p>假定现在有关系R，函数依赖集F。对于F中每一条关系<span\r\nclass=\"math inline\">\\(X \\rightarrow\r\nY\\)</span>，必须满足下面任意一条，则R满足BCNF。</p>\r\n<ol type=\"1\">\r\n<li>X是超键</li>\r\n<li>X包含Y</li>\r\n</ol>\r\n<p>下面讨论第二个问题，如何将一个不满足BCNF的表分解为满足BCNF的若干子表。</p>\r\n<p>若<span class=\"math inline\">\\(X \\rightarrow\r\nY\\)</span>不满足2条规则中任意一条，则将R分解为<span\r\nclass=\"math inline\">\\(R_1 = R - Y\\)</span>与<span\r\nclass=\"math inline\">\\(R_2 = X +\r\nY\\)</span>。显然，这是个无损分解（很容易证明，公共部分是X，且X可推出R2）。而且<span\r\nclass=\"math inline\">\\(R_1, R_2\\)</span>也是满足BCNF的。</p>\r\n<p>如果有多个依赖不满足规则呢？那就依次分解即可（注意，不同分解顺序带来的结果并不相同不过都是对的）</p>\r\n<p>综上，在设计自己的数据库时，我们要尽可能的使表都满足BCNF，这样就不会产生数据的冗余。但是BCNF有一个缺点，就是分解后不一定能保持函数的依赖。比如下面这个例子：</p>\r\n<p><img src=\"2.png\" /></p>\r\n<p><span class=\"math inline\">\\(L \\rightarrow\r\nK\\)</span>不满足规则，所以将R分解为<span class=\"math inline\">\\(R_1 = (J,\r\nL), R_2 = (L,\r\nK)\\)</span>。函数依赖有两个，第二个在R2中可得到保持，第一个在R1或R2都不能得到保持，所以分解后没能保持函数依赖。</p>\r\n<p>这就是BCNF的一个缺点，所以接下来就要介绍3NF。3NF的优点就是它可以保持函数的依赖，但是它的缺点就是仍然会存在一些冗余。</p>\r\n<h4 id=\"nf\">3NF</h4>\r\n<p>跟BCNF一样，3NF还是两个灵魂问题：（1）如何判断关系R是否满足3NF（2）如果R不满足3NF，如何将它分解为若干子表使得它们满足3NF</p>\r\n<p>先来解决第一个问题。</p>\r\n<p>假定现在有关系R，函数依赖集F。对于F中每一条关系<span\r\nclass=\"math inline\">\\(X \\rightarrow\r\nY\\)</span>，必须满足下面任意一条，则R满足3NF。</p>\r\n<ol type=\"1\">\r\n<li>X是超键</li>\r\n<li>Y被包含在X里</li>\r\n<li>Y属于候补码（注意不是超键噢）（所以先要求出候补码）</li>\r\n</ol>\r\n<p>现在来解决第二个问题。</p>\r\n<p>分为以下几步：</p>\r\n<ol type=\"1\">\r\n<li>求F最小覆盖集<span class=\"math inline\">\\(F_c\\)</span>\r\n<ol type=\"1\">\r\n<li>从第一个检查到最后一个，把能用其它依赖推出来的依赖去掉</li>\r\n<li>从第一个检查到最后一个，把左右边的变量尽量减少</li>\r\n<li>回到第一步，若第一步去不掉则进入第四步</li>\r\n<li>对于左边相同的，把右边合并起来</li>\r\n</ol></li>\r\n<li>将<span\r\nclass=\"math inline\">\\(F_c\\)</span>中每一个依赖拿出来组成新表</li>\r\n<li>求候选码</li>\r\n<li>看候选码在不在其中一个新表中，不在的话就新加一个表，表的属性就是候选码</li>\r\n</ol>\r\n<p>综上，3NF的好处就是可以保持函数依赖（而且也是无损分解），缺点就是会存在点冗余。</p>\r\n<h4 id=\"范式总结nf\">范式总结（NF）</h4>\r\n<p>第三范式前面是用“规则”定义出来的，其实它还有另一种定义。</p>\r\n<ul>\r\n<li>第一范式（1NF）：每个属性都是原子属性，本质上所有关系的都满足第一范式。</li>\r\n<li>第二范式（2NF）：在满足第一范式的前提下，满足所有非主属性必须依赖于整个候选码而不能依赖于候选码的部分属性。</li>\r\n<li>第三范式（3NF）：在满足第二范式的前提下，满足F中不能有非主属性之间的依赖传递。</li>\r\n</ul>\r\n<h3 id=\"数据库存储相关\">数据库存储相关</h3>\r\n<ol type=\"1\">\r\n<li><p>文件中记录的表示方式</p>\r\n<ol type=\"1\">\r\n<li>定长记录：每个记录的大小是固定的。每个字段（或属性）在记录中分配有固定数量的字节。这种方式简化了记录的定位和访问，因为可以直接计算出任何记录的位置。</li>\r\n<li>变长记录：不同记录可能有不同的长度。需要额外的信息来确定记录的确切位置和长度。</li>\r\n</ol></li>\r\n<li><p>文件中记录集合的组织方式</p>\r\n<ol type=\"1\">\r\n<li>堆文件：记录在文件空间中任意放置</li>\r\n<li>顺序文件：按一定的顺序在文件中组织记录</li>\r\n<li>散列文件：按照散列函数计算值存放相应记录</li>\r\n<li>多表簇集文件：不同关系表里的记录存放在同一个文件中</li>\r\n</ol></li>\r\n<li><p>元数据是指一个关系数据库系统需要维护关于关系的数据。元数据存储在称为“数据字典”或“系统目录”的结构中</p></li>\r\n<li><p>数据库缓冲区管理器的工作原理</p>\r\n<ul>\r\n<li>大致可以概括为以下几个步骤</li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>数据页的加载：当需要读取数据时，首先检查所需的数据页是否已经在缓冲区中。如果是，它就直接从缓冲区读取数据，反之则从硬盘上读取数据页，并将其加载到缓冲区中。</li>\r\n<li>缓冲区的替换策略：由于缓冲区的大小是有限的，当缓冲区满时，缓冲区管理器必须决定哪些数据页被保留，哪些被替换。</li>\r\n<li>脏页的写回：如果一个数据页在缓冲区中被修改，在它被替换出缓冲区之前，这些更改需要被写回到硬盘上以保持数据的持久性。</li>\r\n<li>并发控制：缓冲区管理器还需要处理多个事务或操作同时访问同一数据页的情况。这通常涉及锁定机制或乐观并发控制来保证数据的完整性和一致性。</li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"数据库索引相关\">数据库索引相关</h3>\r\n<ol type=\"1\">\r\n<li><p>索引分类</p>\r\n<ol type=\"1\">\r\n<li>顺序索引（按照排好的顺序储存搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。）\r\n<ol type=\"1\">\r\n<li>主索引(聚集索引)</li>\r\n<li>辅助索引(非聚集索引)(二级索引)</li>\r\n</ol></li>\r\n<li>B+树索引</li>\r\n<li>散列索引（基于将值平均分布到若干桶中，一个值所属的桶由散列函数决定）\r\n<ol type=\"1\">\r\n<li>静态索引：就是普通的桶</li>\r\n<li>动态索引：就是用二进制实现的桶</li>\r\n</ol></li>\r\n</ol>\r\n<ul>\r\n<li><p>稠密索引就是每条记录都有一个索引指针会指向它，稀疏索引就是只有部分索引会指向它。</p></li>\r\n<li><p>注意，稀疏索引必须是主索引，二级索引必须是稠密索引。因为主索引的顺序就是记录排列的顺序，所以主索引可以是稀疏索引。但是二级不行，因为二级的索引顺序不是记录排列的顺序，所以如果二级是稀疏索引的话，就有可能无法查到目标数据。所以二级索引必须是稠密索引，稀疏索引必须是主索引。</p></li>\r\n<li><p>稀疏索引的优点是占用空间小，缺点是速度慢，精确率相对较低；稠密索引的优点是查找效率快，方面插入和删除。缺点是占用空间大。</p></li>\r\n</ul></li>\r\n</ol>\r\n<h3 id=\"数据库查询有关\">数据库查询有关</h3>\r\n<ol type=\"1\">\r\n<li>对于一条SQL语句，先经过<strong>语法分析器</strong>分析语法是否正确，然后经过<strong>翻译器</strong>被翻译为关系代数表达式，这个关系代数表达式再经过<strong>优化器</strong>，得到一个执行计划，最后通过<strong>执行引擎</strong>被执行。</li>\r\n<li>两个表连接操作的几种实现方法：\r\n<ol type=\"1\">\r\n<li>嵌套循环连接：<span class=\"math inline\">\\(O(n^2)\\)</span></li>\r\n<li>排序-合并连接：<span class=\"math inline\">\\(O(nlogn +\r\nn)\\)</span></li>\r\n<li>索引连接：<span class=\"math inline\">\\(O(nlogn)\\)</span></li>\r\n<li>Hash连接：最好情况下<span class=\"math inline\">\\(O(n)\\)</span></li>\r\n</ol></li>\r\n<li>优化器要做的事：\r\n<ol type=\"1\">\r\n<li>将关系代数表达式转换为查询树</li>\r\n<li>对查询树做变换</li>\r\n<li>生成执行计划</li>\r\n</ol></li>\r\n<li>代数优化就是先做选择操作、再做连接操作。物理优化就是优化器决定是采用全盘扫描还是索引扫描，如果采用索引扫描的话是用顺序索引还是B+树索引还是Hash索引。</li>\r\n</ol>\r\n<h3 id=\"数据库事务相关\">数据库事务相关</h3>\r\n<ol type=\"1\">\r\n<li><p>事务的基本特性(ACID)（以银行转账为例）</p>\r\n<ul>\r\n<li>事务定义：事务是指构成单一逻辑单元的操作集合。</li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>A：原子性：事务要么就不执行，那么就执行，不会执行到一半退出去。</li>\r\n<li>C：一致性：事务的执行不会改变所有钱的总和。</li>\r\n<li>I：隔离性：尽管可能存在多个事务同时并发执行的情况，但系统保证，每个事务都感觉不到中其它事务在并发的执行。</li>\r\n<li>D：持久性：一旦事务完成，其对数据库的影响就是持久的。</li>\r\n</ol></li>\r\n<li><p>事务状态</p>\r\n<ul>\r\n<li><p>活动的：事务执行时的状态</p></li>\r\n<li><p>部分提交的：最后一条语句执行后</p></li>\r\n<li><p>提交的：成功完成后</p></li>\r\n<li><p>失败的：发现不能执行后</p></li>\r\n<li><p>中止的：事务回滚并且数据库已恢复到事务开始执行前的状态后</p></li>\r\n<li><p>事务状态图：</p>\r\n<p><img src=\"3.png\" /></p></li>\r\n</ul></li>\r\n<li><p>调度</p>\r\n<ol type=\"1\">\r\n<li><p>调度分类</p>\r\n<ol type=\"1\">\r\n<li>串行调度：一个事务完成后再去执行下一个事务</li>\r\n<li>并行调度：调度中多个事务的指令在时间上相互交叉地进行</li>\r\n<li>可串行化调度：这个概念是针对于并行调度的。一个并行调度可能是可串行化调度，也可能不是。如果存在一个串行调度，使得其运行结果等于一个并行调度，则称这个并行调度为可串行化调度。</li>\r\n</ol></li>\r\n<li><p>冲突可串行化</p>\r\n<ol type=\"1\">\r\n<li>冲突操作：如果俩操作属于不同事务，且至少有一个wire操作，且作用于相同数据项，则这俩操作是冲突的。</li>\r\n<li>注意，如果一个并行调度是可串行化调度，那么它就是冲突可串行化的。</li>\r\n<li>冲突可串行化的判定方法：如果一个并行调度不存在死锁，则可以转换为一个串行调度，也就是这个并行调度是冲突可串行化的。</li>\r\n<li>并行调度转换为串行调度的方法：先画出调度优先图，然后其拓扑序就是串行调度。</li>\r\n</ol></li>\r\n<li><p>调度优先图</p>\r\n<ul>\r\n<li><p>这个名字起的很烂，我愿意叫它“死锁图”。是一种用来检测事务调度中是否存在死锁的工具。</p></li>\r\n<li><p>图中的每一个节点代表一个事务，如果事务A需要等待B释放资源才能进行，则A向B连一条边。如果图中存在环，则存在死锁。</p></li>\r\n<li><p><img src=\"4.png\" /></p></li>\r\n<li><p>例如这个图，以数据Y举例，对于所有对Y的read/wire操作，若其时间后有其冲突操作，则俩事务之间连一条边。</p></li>\r\n</ul></li>\r\n<li><p>预防死锁的方法</p>\r\n<ol type=\"1\">\r\n<li>wait-die机制：当事务<span\r\nclass=\"math inline\">\\(T_i\\)</span>申请的数据项当前被<span\r\nclass=\"math inline\">\\(T_j\\)</span>持有，仅当<span\r\nclass=\"math inline\">\\(T_i\\)</span>的时间戳小于<span\r\nclass=\"math inline\">\\(T_j\\)</span>的时间戳时，允许<span\r\nclass=\"math inline\">\\(T_i\\)</span>等待。否则<span\r\nclass=\"math inline\">\\(T_i\\)</span>回滚。</li>\r\n<li>wound-die机制：当事务<span\r\nclass=\"math inline\">\\(T_i\\)</span>申请的数据项当前被<span\r\nclass=\"math inline\">\\(T_j\\)</span>持有，仅当<span\r\nclass=\"math inline\">\\(T_i\\)</span>的时间戳大于<span\r\nclass=\"math inline\">\\(T_j\\)</span>的时间戳时，允许<span\r\nclass=\"math inline\">\\(T_i\\)</span>等待。否则，<span\r\nclass=\"math inline\">\\(T_j\\)</span>回滚。</li>\r\n</ol></li>\r\n<li><p>解决死锁的方法</p>\r\n<ul>\r\n<li>选择一个或多个事务进行回滚，释放它们所占用的资源。通常会选择代价最小的事务进行回滚，代价的衡量标准可能包括事务的执行时间、所占用资源数量、距离完成的远近等。为了改进，可以采用部分回滚，这要求需要更多的额外信息。</li>\r\n</ul></li>\r\n<li><p>可恢复调度 &amp; 无级联调度</p>\r\n<ul>\r\n<li>对于调度中的任意俩事务A, B，如果B read 了A之前 wire\r\n的同个数据，则事务A必须在事务B之前提交。</li>\r\n<li>对于调度中的任意俩事务A, B，如果B read 了A之前 wire\r\n的同个数据，则事务A必须在事务B的read操作之前提交。</li>\r\n</ul></li>\r\n</ol></li>\r\n<li><p>事务的隔离级别</p>\r\n<ol type=\"1\">\r\n<li><p>读未提交：允许事务read未被其它事务提交的更改</p></li>\r\n<li><p>读提交：事务只能read已经被提交的更改（数据库的默认隔离级别）</p></li>\r\n<li><p>可重复读：确保在事务执行期间，如果事务重新读取之前已读取的数据，则会看到相同的数据。</p>\r\n<ul>\r\n<li><p>脏读：一个事务读取了另一个事务尚未提交的数据时。</p></li>\r\n<li><p>不可重复读：事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发\r\n生了改变。因此产生了不可重复读。</p></li>\r\n<li><p>幻读：与不可重复读类似，它发生在当一个事务T1读取了一系列符合特定条件的行，然后另一个并发事务T2插入或删除了一些符合T1搜索条件的新行并提交。当T1再次执行相同的查询时，它将“神奇地”看到之前不存在的新行（即“幻行”）。</p></li>\r\n</ul></li>\r\n<li><p>串行化：调度中事务只能串行运行</p></li>\r\n</ol>\r\n<p><img src=\"5.png\" /></p></li>\r\n</ol>\r\n<h3 id=\"数据库锁相关\">数据库锁相关</h3>\r\n<p>为了保证数据的一致性(事务的隔离性)和提高系统的并发处理能力，或者说为了保证应用的有效性，所以引入锁。封锁协议定义了事务如何获取和释放锁的规则。</p>\r\n<ol type=\"1\">\r\n<li><p>锁</p>\r\n<ol type=\"1\">\r\n<li>共享锁(S)：当一个事务想要读取数据时，它会在相应的数据项上放置一个共享锁。共享锁的特点是它允许多个读取事务并发地访问同一个数据项，因为读取操作不会互相冲突。所以如果一个事务获得了数据项的共享锁，则它可read但不能wire该数据项。</li>\r\n<li>排他锁(X)：当一个数据上了排他锁后，当某事务想要修改或读数据时，它会请求并获得排他锁。只有获得了排他锁，才能对其修改。而且注意，一旦一个数据的排他锁被拿了，那么其它事务就不能获得该数据的排他锁和共享锁，直至其排他锁被归还。</li>\r\n</ol></li>\r\n<li><p>封锁协议</p>\r\n<ol type=\"1\">\r\n<li><p>二阶段锁定协议</p>\r\n<ul>\r\n<li><p>最常用的就是二阶段锁定协议，即要求每个事务分两个阶段对数据进行锁定和解锁。增长阶段：事务可以获得锁，但不能释放锁。缩减阶段：事务可以释放锁，但不能获得新的锁。</p></li>\r\n<li><p>二阶段锁定协议特点：</p>\r\n<ol type=\"1\">\r\n<li>把两个阶段的定义抄一遍</li>\r\n<li>可以保证冲突可串行化：多个事务根据封锁点的顺序进行排序即是可串行化顺序。</li>\r\n</ol></li>\r\n<li><p>二阶段锁定协议保证了不会出现脏读的问题。但是不可重复读、死锁、活锁、级联回滚问题仍然可能会出现。另外，虽然两阶段封锁协议保证冲突可串行化，但是冲突可串行化未必符合两阶段封锁。</p></li>\r\n</ul></li>\r\n<li><p>严格两阶段封锁协议</p>\r\n<ul>\r\n<li>定义：在2PL的基础上，要求事务所持排他锁必须在事务提交后方可释放。这个要求保证了在提交前防止其它事务读这些数据。可以避免出现级联回滚。</li>\r\n</ul></li>\r\n<li><p>强两阶段封锁协议</p>\r\n<ul>\r\n<li>定义：要求事务提交之前不能释放任何锁。</li>\r\n</ul></li>\r\n<li><p>树形协议</p>\r\n<ul>\r\n<li>定义：树形协议是一种数据库并发控制机制，用于管理在树状数据结构（如B树索引）上的锁。它规定了事务在获得和释放锁的顺序，以确保在访问树形数据结构的不同部分时维护一致性和隔离性。事务必须按照从根节点到叶节点的顺序来获取锁，并且在向下遍历树时不能返回到已经释放锁的节点。这种方法避免了死锁的发生，因为它不允许事务在树结构中回溯并重新获取锁。</li>\r\n<li>优点：保证了冲突可串行化；不会产生死锁，不需要回滚；可较早地释放锁，以减少事务间的等待时间，从而可增强调度的并发性。</li>\r\n<li>缺点：不能保证事务的可恢复性；不能保证不发生级联回滚；可能会给那些根本不访问的数据项加锁，从而增加了锁的开销和额外的等待时间，使并发性降低。</li>\r\n</ul></li>\r\n<li><p>多粒度封锁协议</p>\r\n<ul>\r\n<li>规则：\r\n<ol type=\"1\">\r\n<li>引入意向锁，并规定了与S/X锁的兼容性规则</li>\r\n<li>事务必须首先在高级别上获取意向锁，然后才能在低级别上获取实际的共享或排他锁。</li>\r\n<li>锁可以在事务的任何时候释放，但一旦释放，事务就不能再在那个级别或更低级别上获取新的锁。</li>\r\n</ol></li>\r\n<li>特点：\r\n<ol type=\"1\">\r\n<li>事务可以根据需要锁定细粒度（如行）或粗粒度（如整个表）的数据，从而提高了系统的并发性。</li>\r\n<li>通过允许在不同粒度上加锁，多粒度封锁减少了锁冲突的可能性，提高了并发访问的效率。</li>\r\n</ol></li>\r\n</ul></li>\r\n<li><p>锁转换</p>\r\n<ul>\r\n<li>定义：允许一个事务在其执行过程中改变已经获得的锁的模式。锁转换分为两种情况：升级和降级。</li>\r\n</ul></li>\r\n<li><p>时间戳排序协议</p>\r\n<ul>\r\n<li>是数据库并发控制中使用的一种机制，用于在没有使用锁的情况下管理事务的并发执行。它通过为每个事务分配一个唯一的时间戳来确保数据库的一致性和隔离性。</li>\r\n</ul>\r\n<p><img src=\"9.png\" /></p></li>\r\n<li><p>快照隔离</p>\r\n<ul>\r\n<li>是数据库系统中一种并发控制方法，它允许事务看到数据库在某一特定时间点的一致性视图。这意味着即使其他事务对数据库进行了修改，一个在快照隔离级别下运行的事务也会看到它开始时数据库的状态，而不会看到这些修改。</li>\r\n</ul></li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"数据库日志相关\">数据库日志相关</h3>\r\n<ol type=\"1\">\r\n<li><p>故障种类</p>\r\n<ol type=\"1\">\r\n<li>事务故障\r\n<ol type=\"1\">\r\n<li>逻辑错误：如非法输入、找不到数据、溢出或超出资源限制。</li>\r\n<li>系统错误：系统进入一种不良状态（如死锁），结果事务无法正常执行。</li>\r\n</ol></li>\r\n<li>系统崩溃：硬件故障，或者是数据库软件或操作系统的漏洞，导致易失性存储器内容的丢失，并使得事务处理停止。</li>\r\n<li>磁盘故障：在数据传送操作过程中由于磁头损坏或故障造成磁盘块上的内容丢失。</li>\r\n</ol></li>\r\n<li><p>什么是基于日志的恢复机制</p>\r\n<ul>\r\n<li>是DBMS中用来保证数据一致性和完整性的一种技术。这种机制依赖于日志文件，它记录了对数据库所做的所有修改。通过redo和undo操作，使得数据库能够在发生故障后恢复到一个一致的状态，保证了即使在系统崩溃后，也不会丢失已提交的数据，并且不会有未完成事务的残留影响。是实现持久性的关键机制。</li>\r\n</ul></li>\r\n<li><p>事务和日志的关系</p>\r\n<ul>\r\n<li>事务执行依赖于日志来记录和维护操作的历史，而日志则提供了必要的机制来保证事务的完整性和数据库的恢复能力。这种依赖关系是现代数据库系统实现高可靠性和数据一致性的基础。</li>\r\n</ul></li>\r\n<li><p>如何根据日志写出恢复日志（看图片+做题吧，懒得讲了）</p>\r\n<p><img src=\"7.png\" /></p>\r\n<p><img src=\"8.png\" /></p></li>\r\n</ol>\r\n<h3 id=\"数据库错题相关\">数据库错题相关</h3>\r\n<ol type=\"1\">\r\n<li><p><img src=\"10.png\" /></p></li>\r\n<li><p><img src=\"11.png\" /></p></li>\r\n<li><p>ER图的时候，n对n中间要新开一张表，左右俩表的主键分别为外键，整体作为主键。</p></li>\r\n<li><p>写关系代数/SQL的时候如果只是需要ID的话其实很多情况下不用与另一张表自然连接；注意有时候题目会强制让你写笛卡尔积的sql/关系代数；如果写关系代数没思路时，可以试试俩同样的表做自然连接或者group\r\nby或者用“-”</p></li>\r\n<li><p>3NF时如果被包含记得要删掉</p></li>\r\n<li><p>求BCNF的俩例子</p></li>\r\n</ol>\r\n<p><img src=\"12.png\" /></p>\r\n","categories":["4. 大学","计算机专业课"]},{"title":"操作系统自学笔记","url":"/2024/09/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"<p>文字、程序、图片来源包括但不限于蒋老师的课件、我OS/计组老师的课件、助教的实验文档、我的个人理解</p>\r\n<span id=\"more\"></span>\r\n<hr />\r\n<h3 id=\"导言\">导言</h3>\r\n<ul>\r\n<li>操作系统是一个典型的\r\n“system”——它完成对计算机硬件系统的抽象，提供应用程序的运行环境</li>\r\n<li>从应用程序的视角看，操作系统定义了一系列的对象\r\n(进程/线程、地址空间、文件、设备……) 和操纵它们的 API\r\n(系统调用)。这组强大的 API\r\n把计算机的硬件资源有序地管理起来，它不仅能实现应用程序\r\n(浏览器、游戏……)，还支持着各类神奇的系统程序\r\n(容器、虚拟机、调试器、游戏外挂……)</li>\r\n<li>从硬件的视角看，操作系统是一个拥有访问全部硬件功能的程序\r\n(操作系统就是个 C\r\n程序，不用怕)。硬件会帮助操作系统完成最初的初始化和加载，之后，操作系统加载完第一个程序后，从此作为\r\n“中断处理程序” 在后台管理整个计算机系统</li>\r\n<li>操作系统为什么难学？最主要原因是操作系统里的主题很多，有些主题对大家来说并不太熟悉。例如，同学们到目前为止编写的大部分代码都是串行的，打个比方，就是写一个程序模仿\r\n“一个人”，一次执行一步动作。但操作系统引入了并发编程，也就是你需要协同多个共享内存的\r\n“多个人” 时，会遇到很多你也许意料之外的问题。</li>\r\n<li>AMD是芯片公司造芯片的；x86是Intel提出的指令集，用在AMD造出的芯片上；windows/linux是操作系统</li>\r\n</ul>\r\n<h3 id=\"什么是程序如何理解程序\">什么是程序？如何理解程序？</h3>\r\n<h4 id=\"logisim_1.c\">logisim_1.c</h4>\r\n<ul>\r\n<li><p>讲这个程序的目的，首先是为了让你学习宏的一些用法，其次是为了让你感受X-macro的设计美学(用于处理状态机)。</p></li>\r\n<li><p>该程序的功能：两位bit，4状态循环模拟器。</p></li>\r\n<li><p>X-macro 是一种在 C 和 C++\r\n编程中使用的技术，通过预处理器宏来简化代码的维护和扩展。它的核心思想是将重复代码的部分抽象为一个宏列表，从而避免硬编码多次相似的代码。X-macro\r\n技术主要用于需要在多个地方使用相同一组常量、结构或函数定义的情况，通常在枚举、状态机、错误代码处理等场景下非常有用。</p></li>\r\n<li><p>你需要了解一下宏。</p></li>\r\n<li><p>简单理解宏就是简单替换。</p></li>\r\n<li><p>宏还可以带参数，例如<code>#define FUN(a, b) (a &gt; b ? a : b)</code>。</p></li>\r\n<li><p>如果想输出参数的名字，例如<code>#define PRINT_VAR(var) printf(#var \" = %d\\n\", var)</code></p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span></span><br><span class=\"line\">using namespace <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PRINT_VAR(var) (printf(#var <span class=\"string\">&quot; = %d\\n&quot;</span>, var))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">    PRINT_VAR(x);</span><br><span class=\"line\">    <span class=\"comment\">// 宏会被展开为：printf(&quot;x = %d\\n&quot;, x);</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\r\n<li><p>##起到拼接的作用，例如<code>#define DEFINE(X) static int X, X##1</code>。宏展开后相当于<code>int X, X1</code></p></li>\r\n<li><p>下面让我们来阅读一下logisim.c</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REGS_FOREACH(_) _(X) _(Y)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RUN_LOGIC \\</span></span><br><span class=\"line\"><span class=\"meta\">    X1 = (X ^ Y); \\</span></span><br><span class=\"line\"><span class=\"meta\">    Y1 = (Y == 0 ? 1 : 0); \\</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DEFINE(X) static int X, X##1;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UPDATE(X) X = X##1;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PRINT(X) printf(#X <span class=\"string\">&quot; = %d; &quot;</span>, X);</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    REGS_FOREACH(DEFINE); <span class=\"comment\">// 定义 X 和 Y</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123; <span class=\"comment\">// 无限循环，模拟时钟周期</span></span><br><span class=\"line\">        RUN_LOGIC; <span class=\"comment\">// 执行逻辑运算，计算 X1 和 Y1 的值</span></span><br><span class=\"line\">        REGS_FOREACH(PRINT); <span class=\"comment\">// 打印当前的 X 和 Y 的值</span></span><br><span class=\"line\">        REGS_FOREACH(UPDATE); <span class=\"comment\">// 更新 X 和 Y 为 X1 和 Y1</span></span><br><span class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;\\n&#x27;</span>); <span class=\"comment\">// 换行</span></span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>); <span class=\"comment\">// 程序暂停 1 秒，模拟时钟的周期</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li><p><code>&lt;unistd.h&gt;</code> 是\r\nPOSIX（可移植操作系统接口）标准中的头文件，提供了对各种操作系统服务的访问，如文件操作、进程控制、用户身份管理等。在上述程序中，<code>sleep</code>用到它了。</p></li>\r\n<li><p><code>static</code> 在 C\r\n语言中用于声明具有静态存储类别的变量或函数，这些变量或函数的生命周期贯穿整个程序运行期间，但它们的作用域仅限于定义它们的文件内部，从而提供了数据的持久性和封装性，防止了全局命名空间的污染。</p></li>\r\n<li><p>第一行<code>#define REGS_FOREACH(_) _(X) _(Y)</code>，这个宏的意思是对X和Y做名为_的函数操作。从main函数可以推理出，_是个函数名。</p></li>\r\n<li><p>第二行的<code>RUN_LOGIC</code>意思就是根据X和Y算出X1、Y1的值。'\\'表示续行</p></li>\r\n<li><p>... ...</p></li>\r\n<li><p>所以上面宏的逻辑就是，先写好各种功能宏（DEFINE、UPDATE、PRINT），功能宏传入的参数是一个变量，因为它是作用于一个变量的。</p></li>\r\n<li><p>然后为了一次作用于多个变量，要再写个循环宏（REGS_FOREACH），循环宏传入的参数是一个功能宏，因为它展开就是把功能宏作用到各个变量上。所以各个变量的名字就要在循环宏里写好。</p>\r\n<blockquote>\r\n<p>练习：理解后，试着写出上述程序</p>\r\n</blockquote></li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"logisim_2.c\">logisim_2.c</h4>\r\n<ul>\r\n<li><p>讲这个程序的目的，是为了让你感受到管道符的魅力，以及前后端结合的魅力。</p></li>\r\n<li><p>该程序功能：通过两个变量X、Y，4种状态对应数字0、1、2、3。控制对应的七个变量的输出（与下文的seven-seg.py配合使用）</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> DEFINE(x) static int x, x##1;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UPDATE(x) x = x##1;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> RUN_LOGIC \\</span></span><br><span class=\"line\"><span class=\"meta\">    x1 = (x ^ y); \\</span></span><br><span class=\"line\"><span class=\"meta\">    y1 = (y == 0 ? 1 : 0); \\</span></span><br><span class=\"line\"><span class=\"meta\">    A = (y == 0); \\</span></span><br><span class=\"line\"><span class=\"meta\">    B = (x == y); \\</span></span><br><span class=\"line\"><span class=\"meta\">    C = (1); \\</span></span><br><span class=\"line\"><span class=\"meta\">    D = (x == 1); \\</span></span><br><span class=\"line\"><span class=\"meta\">    E = (y == 0); \\</span></span><br><span class=\"line\"><span class=\"meta\">    F = !(x == 1 &amp;&amp; y == 0); \\</span></span><br><span class=\"line\"><span class=\"meta\">    G = (y == 0);</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PRINT(x) printf(#x<span class=\"string\">&quot; = %d; &quot;</span>, x);</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REGS_FOREACH(_) _(x) _(y)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OUTS_FOREACH(_) _(A) _(B) _(C) _(D) _(E) _(F) _(G)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    REGS_FOREACH(DEFINE);</span><br><span class=\"line\">    OUTS_FOREACH(DEFINE);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        RUN_LOGIC;              <span class=\"comment\">// 得到x1, y1, (ABCDEFG)由x,y得到</span></span><br><span class=\"line\">        REGS_FOREACH(UPDATE);   <span class=\"comment\">// 更新x, y</span></span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        OUTS_FOREACH(PRINT);</span><br><span class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>练习：试着自己写出这个程序（RUN_LOGIC部分可借鉴）</p>\r\n</blockquote></li>\r\n</ul>\r\n<h4 id=\"seven-seg.py\">seven-seg.py</h4>\r\n<ul>\r\n<li><p>该程序功能：接受一行字符串代表7个灯的亮灭情况，输出对应的数字</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># \\033[2J: 清楚整个屏幕</span></span><br><span class=\"line\"><span class=\"comment\"># \\-33[1;1f: 将光标移到左上角</span></span><br><span class=\"line\">TEMPLATE = <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">\\033[2J\\033[1;1f</span></span><br><span class=\"line\"><span class=\"string\">     AAAAAAAAA</span></span><br><span class=\"line\"><span class=\"string\">    BB       CC</span></span><br><span class=\"line\"><span class=\"string\">    BB       CC</span></span><br><span class=\"line\"><span class=\"string\">    BB       CC</span></span><br><span class=\"line\"><span class=\"string\">    BB       CC</span></span><br><span class=\"line\"><span class=\"string\">    DDDDDDDDD</span></span><br><span class=\"line\"><span class=\"string\">   EE       FF</span></span><br><span class=\"line\"><span class=\"string\">   EE       FF</span></span><br><span class=\"line\"><span class=\"string\">   EE       FF</span></span><br><span class=\"line\"><span class=\"string\">   EE       FF</span></span><br><span class=\"line\"><span class=\"string\">    GGGGGGGGGG</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span> </span><br><span class=\"line\"></span><br><span class=\"line\">BLOCK = &#123;</span><br><span class=\"line\">    <span class=\"number\">0</span>: <span class=\"string\">&#x27;\\033[37m░\\033[0m&#x27;</span>,  <span class=\"comment\"># \\033[37m表示设置字体颜色为白色，░是一个字符，\\033[0m表示重置颜色</span></span><br><span class=\"line\">    <span class=\"number\">1</span>: <span class=\"string\">&#x27;\\033[31m█\\033[0m&#x27;</span>,  <span class=\"comment\"># \\033[31m表示设置字体颜色为红色，█是一个字符</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">VARS = <span class=\"string\">&#x27;ABCDEFG&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> VARS:</span><br><span class=\"line\">    <span class=\"comment\"># Example: globals()[&#x27;my_var&#x27;] = 42  # 动态创建一个名为 my_var 的全局变量并赋值为 42</span></span><br><span class=\"line\">    <span class=\"built_in\">globals</span>()[v] = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从 stdin 逐行读取</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    line = sys.stdin.readline().strip()  <span class=\"comment\"># 使用 readline 逐行读取来自管道的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> line:</span><br><span class=\"line\">        <span class=\"built_in\">exec</span>(line)</span><br><span class=\"line\">        pic = TEMPLATE</span><br><span class=\"line\">        <span class=\"keyword\">for</span> v <span class=\"keyword\">in</span> VARS:</span><br><span class=\"line\">            pic = pic.replace(v, BLOCK[<span class=\"built_in\">globals</span>()[v]]) <span class=\"comment\"># &#x27;A&#x27; -&gt; BLOCK[A], ...</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(pic)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;Received line: <span class=\"subst\">&#123;line&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>练习：看懂这个py程序</p>\r\n</blockquote></li>\r\n</ul>\r\n<h4 id=\"hanoi-r.c\">hanoi-r.c</h4>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">hanoi</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">char</span> from, <span class=\"type\">char</span> to, <span class=\"type\">char</span> via)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c -&gt; %c\\n&quot;</span>, from, to);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        hanoi(n - <span class=\"number\">1</span>, from, via, to);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c -&gt; %c\\n&quot;</span>, from, to);</span><br><span class=\"line\">        hanoi(n - <span class=\"number\">1</span>, via, to, from);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span> <span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    hanoi(<span class=\"number\">3</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;B&#x27;</span>, <span class=\"string\">&#x27;C&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<blockquote>\r\n<p>练习：自己写出这个汉诺塔程序</p>\r\n</blockquote>\r\n<ul>\r\n<li><p>讲这个程序的目的，是为了让你会用vscode\r\ngdb调试，以及引出如何用cpu执行角度去理解c语言程序</p></li>\r\n<li><p>首先你先自己写出这个程序</p></li>\r\n<li><p>然后去配置一下vscode里的gdb，配置完了试下各种功能以及反汇编视图是否可用</p></li>\r\n<li><p>几个快捷键要熟悉：F5启动调试，shift+F5关闭调试，F11单步调试(会进入函数内部)，F10逐过程(把函数当作一条语句处理)</p></li>\r\n<li><p>然后思考一下带递归的程序是如何从汇编角度和cpu执行角度去理解：</p>\r\n<ul>\r\n<li><p>假设你写了一个带递归的程序hanio-r.c，然后你可以得到它的汇编。</p></li>\r\n<li><p>回忆一下当时用vivado做计组项目的时候，是不是将一段汇编硬编码到rom里了？（哈佛结构）所以说，汇编程序本质上也是一段线性的，就是靠着PC在上下跳来跳去来实现的。</p></li>\r\n<li><p>先思考下循环在汇编里的逻辑，本质就是PC加或者减某个数在每行的汇编里跳来跳去。</p></li>\r\n<li><p>再思考下递归在汇编里的逻辑，递归里会开局部变量，这又是如何实现的呢？我以下面的代码来举例：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fact</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> n * fact(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 参数n在寄存器x10中</span></span><br><span class=\"line\"><span class=\"comment\">// 为了尽可能少用通用寄存器，尽量复用，所以结果也分配在x10</span></span><br></pre></td></tr></table></figure></li>\r\n<li><p>下面是对应的汇编：</p>\r\n<p><img src=\"1.png\" /></p></li>\r\n<li><p>哈佛结构除了ROM里存汇编，RAM里是存数据的。数据存储本质上也是一个“数组”。你可以想象数组长度很长，其实的某一段拿来当栈空间，栈空间的起点就是sp，它是栈空间数组的下标。</p></li>\r\n<li><p>cpu执行角度是没有什么全局变量/局部变量这种说法的，数据要么就是通用寄存器，那么就存在RAM里。sp在通用regs里。</p></li>\r\n<li><p>除了sp外，通用寄存器里，我们还需要一个x1。x1是RAM里数组的一个下标，其对应的数据是“最后一次”发生跳转的那条汇编的PC值+4。</p></li>\r\n<li><p>举个例子，比如我在主函数里调用了fact()函数，那么调用这条语句的PC加4之后的PC'，就被存到了data[x1]里。然后如果我想return回主函数，只需jalr\r\nx0, 0(x1)即可，那么PC就跳到了PC'。</p></li>\r\n<li><p>所以，为了实现函数调用，x1和sp必不可少 。</p></li>\r\n<li><p>那么局部变量和嵌套调用如何实现呢？</p></li>\r\n<li><p>仔细看上面的汇编，进入函数的第一件事，是将当前的x1和x10(结果)存到RAM里的栈空间内，这样后续嵌套递归的话，x1和x10的值一定会被更改，但没事，因为我们已经将当前这一层调用的x1,\r\nx10存到RAM里了，当后续的调用return回当前层时，从RAM里重新取出即可。</p></li>\r\n<li><p>听了我以上的讲解，相信我已经能完全看懂上面的汇编了，也就完全理解C语言里的递归在cpu执行角度是如何理解的了。</p></li>\r\n<li><p>总结一下，cpu执行角度没有全局变量/局部变量之说，数据存储要不就在通用寄存器，要不就在RAM里。通用寄存器里俩很重要的分别是sp和x1，sp掌管着RAM里栈空间的下标，x1掌管着RAM里\"调用PC+4\"这个元素的下标。</p></li>\r\n<li><p>递归本质就是一进入当前层时，把当前层信息(x1 +\r\n数据信息)压入栈中(sp减一个数)，当前层return的时候就弹栈(sp加回来)。如果在当前层嵌套调用了自己(语句1)，那么在当前层语句1之后的语句，若用到了当前层的数据，就从栈里取出来。不这么做的话，数据信息其实是已经被污染，因为CPU没有作用域这种说法。</p></li>\r\n</ul></li>\r\n<li><p>Well，了解了cpu执行角度的c语言程序，我们就可以做一个高抽象性的概括了，即：C语言本质就是状态机，状态为（通用寄存器,\r\nRAM），C语言里的每一条语句，即每一条汇编的执行，都是一个状态到另一个状态的改变。这个状态机不是自发运行的，而是按照ROM里的指令去实现状态之间的改变。</p></li>\r\n</ul>\r\n<h4 id=\"syscall\">syscall</h4>\r\n<ul>\r\n<li>一条神奇的指令，即调用操作系统</li>\r\n<li>从上面的讲解，我们知道，任意程序本质上就是对状态机（通用寄存器,\r\nRAM）状态改变的指挥棒。那么当一个程序调用syscall的时候，就会执行操作系统里的程序，也就是指挥棒交到了操作系统手上。</li>\r\n<li>在程序眼里，操作系统就是syscall这条指令，syscall指令的各种api包罗万象。你想用屏幕？可以，syscall请求一下。你想与别的进程交互？可以，syscall请求一下。So，没什么神奇的，所有的程序与操作系统交互都是通过syscall。</li>\r\n<li>由此，就实现了操作系统与任意程序的交互。</li>\r\n</ul>\r\n<h3 id=\"lab0-裸机程序\">lab0-裸机程序</h3>\r\n<h4 id=\"预备知识\">预备知识</h4>\r\n<ul>\r\n<li><p>makefile<a\r\nhref=\"https://www.bilibili.com/video/BV1tyWWeeEpp/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0\">快速入门</a>：</p></li>\r\n<li><p><code>gcc test.c</code>：编译test.c并生成可执行文件a.out</p></li>\r\n<li><p><code>gcc test.c -o yyy</code>：编译test.c并将可执行文件重命名为yyy</p></li>\r\n<li><p><code>gcc test.c -c</code>：编译test.c但不链接，生成目标文件test.o</p></li>\r\n<li><p><code>gcc test.c -c -o yyy</code>：编译test.c但不链接，将目标文件改名为yyy</p></li>\r\n<li><p>最普通的makefile写法</p></li>\r\n</ul>\r\n<figure class=\"highlight makefile\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">hello: hello.o print.o</span></span><br><span class=\"line\">    gcc hello.o print.o -o hello</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">hello.o: hello.c</span></span><br><span class=\"line\">    gcc hello.c -c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"section\">print.o: print.c</span></span><br><span class=\"line\">    gcc print.c -c</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"section\">clean:</span></span><br><span class=\"line\">    rm -f *.o</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>.PHONY 后面跟着的东西，就可以使你make\r\nxxx的时候执行的是makefile里xxx的逻辑。</li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>局部变量：函数结束就销毁</p></li>\r\n<li><p>静态局部变量：静态局部变量永远在，直到程序结束。但仍只能被本函数访问</p></li>\r\n<li><p>全局变量：任何文件，只要通过extern关键字，就可以访问它</p></li>\r\n<li><p>静态全局变量：只有本文件能够访问它</p></li>\r\n<li><p>静态变量 = 静态局部变量 + 静态全局变量</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><code>objdump -h test.o</code>：查看目标文件test.o的段头\r\n<ul>\r\n<li>什么是段头？就是程序编译过后的ELF文件的头（元数据）</li>\r\n<li><code>.text</code>段：存放程序编译后生成的机器码</li>\r\n<li><code>.data</code>段：存放已初始化过的死不了的东西，即初始化过的全局变量和静态变量\r\n<ul>\r\n<li>在ELF文件中，已经记录了这些变量的初始值，运行时便会加载到内存中</li>\r\n</ul></li>\r\n<li><code>.bss</code>段：存放未初始化过的死不了的东西，即未初始化过的全局变量和静态变量\r\n<ul>\r\n<li>在ELF文件中，没有这些变量的初始值，但是会告诉OS在运行时将他们初始化为0/NULL</li>\r\n</ul></li>\r\n<li><code>.rodata</code>段：存在只读的常量，若试图修改，会导致运行错误</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"实现裸机hello-world\">实现裸机Hello world!</h4>\r\n<ul>\r\n<li>我们以往写用户程序时，通常都只关注代码本身，而将运行时的环境交给了编译器等系统软件进行处理，但我们若要编写裸机程序，就需要进一步揭开运行时环境的神秘面纱。</li>\r\n<li>下表揭示了裸机程序与用户程序的区别：</li>\r\n</ul>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 9%\" />\r\n<col style=\"width: 48%\" />\r\n<col style=\"width: 42%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>对比对象</th>\r\n<th>裸机程序</th>\r\n<th>常规用户程序</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>内存地址空间</td>\r\n<td>自行管理物理地址空间，可以自行对虚拟内存进行配置后使自己运行在虚拟地址空间</td>\r\n<td>由操作系统管理的虚拟地址空间（不考虑Linux NOMMU模式）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>系统调用</td>\r\n<td>调用自己</td>\r\n<td>调用更高特权级的操作系统/固件</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>栈的初始化</td>\r\n<td>自行完成</td>\r\n<td>操作系统载入用户进程时完成（毕竟还要通过栈传递参数）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>BSS段的清空</td>\r\n<td>自行完成</td>\r\n<td>操作系统分配虚拟页面时完成清零</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<ul>\r\n<li>ok，那开始吧！首先先写一个用于初始化的汇编代码。（用于初始化虚实地址映射方式、栈初始化、执行main）</li>\r\n<li>注释写的非常详细了，请仔细阅读：</li>\r\n</ul>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 告诉汇编器main这个东西是外部C语言的main函数</span><br><span class=\"line\"># 不用担心路径，因为在makefile的时候会把C程序和汇编程序绑在一起</span><br><span class=\"line\"># 也不用担心有多个C程序从而有多个main，如果是这样的话会报错的，因为一个项目里只能有一个main函数</span><br><span class=\"line\">.extern main</span><br><span class=\"line\"></span><br><span class=\"line\"># .text 伪指令用于指定代码段的开始，通常放在需要生成机器码的指令之前</span><br><span class=\"line\">.text</span><br><span class=\"line\"></span><br><span class=\"line\"># 声明_start为全局符号</span><br><span class=\"line\">.globl _start</span><br><span class=\"line\"></span><br><span class=\"line\">_start:</span><br><span class=\"line\">    # li.w的意思是load immediate word，就是加载一个立即数的意思，就是把0xa0000011加载到t0里</span><br><span class=\"line\">    # 为什么要选择t0? 没有什么特殊含义，因为t0是通用寄存器，用于存储临时数据，所以顺手就用它了</span><br><span class=\"line\">    # 0xa0000011 = 1010 0000 0000 0000 0000 0000 0001 0001</span><br><span class=\"line\">    li.w    $t0, 0xa0000011</span><br><span class=\"line\"></span><br><span class=\"line\">    # 什么是CSR?（Control and Status Registers）</span><br><span class=\"line\">    # 简单理解，CSR就是一组寄存器，跟registers里的寄存器一样，只不过这组寄存器的不同的取值会使cpu做一些事情（具体请看龙芯32位手册_v1.02的p65）</span><br><span class=\"line\">    # 需要通过特殊的命令，例如csrwr, csrrw来读取和写入</span><br><span class=\"line\">    # 下面这句话就是说，把t0的值写入地位为“0x180”的这个CSR里。csrwr的意思是csr write</span><br><span class=\"line\">    </span><br><span class=\"line\">    # 然后补一下关于虚拟地址、物理地址、地址映射的知识</span><br><span class=\"line\">    /*</span><br><span class=\"line\">        * 物理地址：是内存的实际地址，即内存芯片上的实际位置</span><br><span class=\"line\">        * 虚拟地址：由程序生成的地址，不是实际的物理地址</span><br><span class=\"line\">        * 地址映射：将虚拟地址转换为物理地址的过程。这种映射通常由硬件（如 MMU，内存管理单元）和操作系统共同完成</span><br><span class=\"line\">        * 龙芯中，mmu支持两种翻译模式：直接地址翻译(直接窗口)、映射地址翻译(页表)。优先级直接 &gt; 页表</span><br><span class=\"line\">        * 直接窗口：直接窗口是一种地址映射机制，用于将虚拟地址直接映射到物理地址</span><br><span class=\"line\">        * 配置直接窗口：直接窗口是一种机制，所以我们需要配置其具体机制的设置，那么在龙芯里，就通过地址为“0x180”这个csr（其实叫CSR_DMWIN0）来</span><br><span class=\"line\">                      配置第0个直接窗口的设置</span><br><span class=\"line\">     */</span><br><span class=\"line\">    /*</span><br><span class=\"line\">        * 知道了CSR_DMWIN0这个csr寄存器是第0个直接窗口的配置信息之后，我们需要了解具体什么数对应着什么配置：</span><br><span class=\"line\">        * 参考龙芯32位手册_v1.02的p76</span><br><span class=\"line\">        * 第31-29位：虚地址的[31:29]位</span><br><span class=\"line\">        * 第27-25位：物理地址的[31:29]位</span><br><span class=\"line\">        * 第3位：为1表示在特权等级PLV3(用户态)下可以使用该直接窗口进行地址翻译</span><br><span class=\"line\">        * 第0位：为1表示在特权等级PLV0(内核态)下可以使用该直接窗口进行地址翻译</span><br><span class=\"line\">        * ... ...</span><br><span class=\"line\">     */</span><br><span class=\"line\">    csrwr   $t0, 0x180  # 所以这里CSR_DMWIN0被配置为：“起始地址0xa0000000, PLV0时该直接窗口激活”</span><br><span class=\"line\"></span><br><span class=\"line\">    # 下面这两行跟上面两行一样，只不过是配置CSR_DMWIN1，它被配置为：“起始地址0x80000000, PLV0时该直接窗口激活”</span><br><span class=\"line\">    # 0x80000001 = 10000000000000000000000000000001</span><br><span class=\"line\">    li.w    $t0, 0x80000001</span><br><span class=\"line\">    csrrw   $t0, 0x181</span><br><span class=\"line\"></span><br><span class=\"line\">    # -----------------------------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">    li.w    $t0, 0xb0   # 0000 0000 0000 0000 0000 0000 1011 0000</span><br><span class=\"line\">    # 地址为0x0的csr是CSR_CRMD，所以我们需要了解CSR_CRMD（Control and Status Register for Control and Management）是什么</span><br><span class=\"line\">    # 详细参考龙芯32位手册_v1.02的p67</span><br><span class=\"line\">    /*</span><br><span class=\"line\">        * PLV(Privilege Level)</span><br><span class=\"line\">            位范围：第1-0位</span><br><span class=\"line\">            取值：</span><br><span class=\"line\">                00：内核模式（内核模式下的代码可以执行所有操作，包括直接访问硬件资源、修改系统状态等）</span><br><span class=\"line\">                11：用户模式（用户模式下的代码不能执行某些敏感操作，如直接访问硬件资源、修改关键系统状态等）</span><br><span class=\"line\">        * DA</span><br><span class=\"line\">            位范围：第3位</span><br><span class=\"line\">            取值：</span><br><span class=\"line\">                0：静默使用直接翻译（实际上当DA=0, PG=1时仍然会静默开启直接翻译）</span><br><span class=\"line\">                1：启用使用直接翻译</span><br><span class=\"line\">        * PG(Page Enable)</span><br><span class=\"line\">            位范围：第4位</span><br><span class=\"line\">            取值：</span><br><span class=\"line\">                0：禁用分页翻译</span><br><span class=\"line\">                1：启动分页翻译（直接翻译仍会起效且优先级比页表翻译高）</span><br><span class=\"line\">        * ... ...</span><br><span class=\"line\">     */</span><br><span class=\"line\">    csrwr   $t0, 0x0    # 所以这里CSR_CRMD被配置为：“内核模式 + 启用分页翻译”</span><br><span class=\"line\"></span><br><span class=\"line\">    # -----------------------------------------------------------------------------------------------------</span><br><span class=\"line\"></span><br><span class=\"line\">    # la的意思是load address</span><br><span class=\"line\">    # 初始化栈指针为bootstacktop这个地址</span><br><span class=\"line\">    la  $sp, bootstacktop</span><br><span class=\"line\"></span><br><span class=\"line\">    # 将main标签的地址给t0</span><br><span class=\"line\">    la  $t0, main</span><br><span class=\"line\">    # 跳转到main标签的地址，即开始执行main函数</span><br><span class=\"line\">    jr  $t0</span><br><span class=\"line\"></span><br><span class=\"line\"># 当main函数执行完后，会回到汇编这里，然后_stack就执行完了，自然会执行到poweroff这里</span><br><span class=\"line\">poweroff:</span><br><span class=\"line\">    b poweroff  # b是branch的意思，即无条件跳转到poweroff，形成死循环</span><br><span class=\"line\">    # 通过 b poweroff 形成的无限循环，可以确保程序在 main 函数返回后不会继续执行无效的代码，防止未定义行为的发生。</span><br><span class=\"line\"></span><br><span class=\"line\"># ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class=\"line\"></span><br><span class=\"line\"># _stack是一个标签，没用</span><br><span class=\"line\">_stack:</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换段为数据段</span><br><span class=\"line\"># 需要注意.data里的分配动作在链接阶段就会分配内存空间</span><br><span class=\"line\">.section .data</span><br><span class=\"line\"></span><br><span class=\"line\"># 声明bootstack为全局符号</span><br><span class=\"line\">.global bootstack</span><br><span class=\"line\">bootstack:</span><br><span class=\"line\">    .space 1024 # 从bootstack这个地址开始，分配1024个空间</span><br><span class=\"line\"></span><br><span class=\"line\"># 声明bootstacktop为全局符号</span><br><span class=\"line\">.global bootstacktop</span><br><span class=\"line\">bootstacktop:</span><br><span class=\"line\">    .space 64   # 从bootstacktop这个地址开始，分配64个空间</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">    更多相关知识介绍：https://osdocs.cqu.ai/lab0/intro/#io</span><br><span class=\"line\"></span><br><span class=\"line\">    总结：</span><br><span class=\"line\">    这段汇编首先配置了 PLV0下的俩直接翻译窗口CSR_DMWIN0, CSR_DMWIN1，即分别将虚拟地址0xa0000011、0x80000000映射到物理地址上</span><br><span class=\"line\">    然后设置了CSR_CRMD，即启用PLV0内核模式 + 启用分页翻译模式（此时也会静默启动直接翻译，因为其优先级高）</span><br><span class=\"line\">    然后初始化了栈顶地址($sp)，栈的大小在.data中已设置</span><br><span class=\"line\"> */</span><br></pre></td></tr></table></figure>\r\n","categories":["4. 大学","计算机专业课"]},{"title":"线性代数1","url":"/2024/09/11/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/","content":"<p>方程组、矩阵、消元、向量空间、秩、解方程</p>\r\n<p>还差P23、P27没学，等学完微分方程后回来看。</p>\r\n<span id=\"more\"></span>\r\n<hr />\r\n<p>课程是<a\r\nhref=\"https://www.bilibili.com/video/BV16Z4y1U7oU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0\">链接</a></p>\r\n<p>Gilbert Strang老爷子的MIT 18.06 Linear\r\nAlgebra。非常经典的一门课程，是理解性讲课而不是像国内多数高校式的应试性讲课。</p>\r\n<p>线性代数作为诸多工程应用的基石，其重要性毋庸置疑。所以对于这份笔记，我的看法是常看常新，多看不亏，越多看，越能把全部知识串联起来。</p>\r\n<p>在铺垫好线性代数的基石后，最好修一门常微分方程(mit\r\n18.03)。学有余力的话，把单变量微积分mit 18.01和多变量微积分mit\r\n18.02修了。如果想提高应用数学视野的可以去修Gilbert\r\nStrang的计算科学与工程mit 18.085+18.086。</p>\r\n<h3 id=\"一.-方程组的几何解释\">一. 方程组的几何解释</h3>\r\n<ul>\r\n<li>考虑一个一元二次方程组，我们的几何理解就是一个方程是一条直线。这样的理解是初高中理解</li>\r\n<li>但是到了大学，我们应该竖着去看方程组，也就是x乘一个列向量，y乘一个列向量，加起来，得到一个列向量，也就是这种形式：</li>\r\n<li><span class=\"math inline\">\\(\\begin{bmatrix}2 \\\\ -1\\end{bmatrix}x +\r\n\\begin{bmatrix}-1 \\\\ 2\\end{bmatrix}y = \\begin{bmatrix}0 \\\\\r\n3\\end{bmatrix}\\)</span></li>\r\n<li>上面这种“竖着理解方程组的方式”，叫做“线性组合”，是贯穿这门课的一个思想</li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>考虑线性组合的几何意义，假设有m个未知数，n个方程。</p></li>\r\n<li><p>那么就有m个列向量。首先把这m个维度为<span\r\nclass=\"math inline\">\\(\\mathbb{R}^{n}\\)</span>的列向量画到<span\r\nclass=\"math inline\">\\(\\mathbb{R}^n\\)</span>上。</p></li>\r\n<li><p>然后m个未知数就是这m个向量的系数，去线性组合这些向量，得到答案向量。</p></li>\r\n<li><p>是不是很巧妙？在2维以上的空间内，用向量的线性组合去考虑问题会大大的简化问题。</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>为了不每次都写出上面那个<span class=\"math inline\">\\(x \\cdot [2,\r\n-1]^\\mathrm{T} + y \\cdot [-1, 2]^\\mathrm{T} = [0,\r\n3]\\)</span>这种线性组合，太麻烦了，所以我们引入了矩阵来简化表达</p></li>\r\n<li><p>具体来说，一个m个未知数，n个方程的方程组，用系数矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>、未知数向量<span\r\nclass=\"math inline\">\\(\\textbf{x}\\)</span>、答案向量<span\r\nclass=\"math inline\">\\(b\\)</span>来描述这个方程组</p></li>\r\n<li><p>当你看到一个形如<span class=\"math inline\">\\(A\\textbf{x} =\r\nb\\)</span>的方程的时候，你要明白，本质就是m个维度为<span\r\nclass=\"math inline\">\\(\\mathbb{R}^n\\)</span>的向量的线性组合 =\r\n常向量的求解问题</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>现在我们思考一个问题：n个方程，m个未知数的方程组是否永远有解？</p></li>\r\n<li><p>用线性组合的观点就是，m个维度为<span\r\nclass=\"math inline\">\\(\\mathbb{R}^n\\)</span>的向量的线性组合是否可以覆盖整个<span\r\nclass=\"math inline\">\\(\\mathbb{R}^n\\)</span>空间？</p></li>\r\n<li><p>可以发现，问题的关键，就是在这m个向量身上，换句话说，也就是在系数矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>身上。这m个向量具有什么样的特点 / <span\r\nclass=\"math inline\">\\(A\\)</span>具有什么样的特点时，方程组会有解？会有几个解？这就是以后会讨论到的问题。</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li>相信看到这，已经能感受到线性代数的绝妙吸引力了。它能带你在高维空间里遨游，让你熟练的玩弄高维空间。</li>\r\n<li>数学真神奇，不是吗？</li>\r\n</ul>\r\n<h3 id=\"二.-矩阵消元\">二. 矩阵消元</h3>\r\n<ul>\r\n<li><p>这节学习的是用消元法解方程组，计算机解方程都是用这种方法</p></li>\r\n<li><p>首先先按国内大部分高校的讲法讲一遍：</p></li>\r\n<li><p>消元就是初高中学的那个消元，消元前后矩阵是等价的，对系数矩阵进行求上三角过程</p></li>\r\n<li><p>其实求上三角的过程，就是在依次确定基向量，基向量的意思就是能对解空间产生贡献的向量。假设向量俩俩正交，那么它们都是基向量。</p></li>\r\n<li><p>对于n个方程，m个未知数的方程。若通过求上三角后，有k个主元（主元就是每列最后一个非零元素），说明有k个维度为<span\r\nclass=\"math inline\">\\(\\mathbb{R}^n\\)</span>的基向量，那么若<span\r\nclass=\"math inline\">\\(k \\ge\r\nn\\)</span>，则方程组必定有解，因为此时m个向量可以线性组合出整个<span\r\nclass=\"math inline\">\\(\\mathbb{R}^n\\)</span>空间。反之，则不一定有解。</p></li>\r\n<li><p>换句话说，有几个主元，方程组的向量们就能线性组合出几维的空间</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>回到正题，如何求解方程组呢？（考虑一定有解的情况）</p></li>\r\n<li><p>首先把答案向量<span class=\"math inline\">\\(b\\)</span>加入到<span\r\nclass=\"math inline\">\\(A\\)</span>中作为新的一列，此时称<span\r\nclass=\"math inline\">\\(A\\)</span>为增光矩阵<span\r\nclass=\"math inline\">\\(\\overline{A}\\)</span></p></li>\r\n<li><p>对<span\r\nclass=\"math inline\">\\(\\overline{A}\\)</span>消元求上三角，然后将消元后的矩阵重新写成方程组去算就行了</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>好了，现在用我在mit学到的讲法讲一遍：</p></li>\r\n<li><p>上面的讲法中，对<span\r\nclass=\"math inline\">\\(\\overline{A}\\)</span>消元求上三角的过程，我们的视角还是用初高中的做法去做的，但现在，仍然是消元求上三角的过程，我想用矩阵去做</p></li>\r\n<li><p>在做之前，我想介绍“行的线性组合“</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>我们之前讲了，对于方程<span\r\nclass=\"math inline\">\\(A\\textbf{x}=b\\)</span>，我们的理解方式就是看成m个列向量的线性组合，这其实是“列的线性组合“</p></li>\r\n<li><p>现在我们来看这个方程：<span\r\nclass=\"math inline\">\\(\\textbf{x}^{\\mathrm{T}}A =\r\nb^{\\mathrm{T}}\\)</span>，<span\r\nclass=\"math inline\">\\(\\textbf{x}^{\\mathrm{T}}\\)</span>是一个有n个未知数的行向量，<span\r\nclass=\"math inline\">\\(A\\)</span>仍然是一个<span\r\nclass=\"math inline\">\\(\\mathbb{R}^{n \\times m}\\)</span>的矩阵，<span\r\nclass=\"math inline\">\\(b^{\\mathrm{T}}\\)</span>是一个常行向量。</p></li>\r\n<li><p>此时我们需要把这个方程理解为“行的线性组合“，也就是<span\r\nclass=\"math inline\">\\(A\\)</span>的每一行就是一个向量，然后这些向量线性组合，系数就是<span\r\nclass=\"math inline\">\\(x^{\\mathrm{T}}\\)</span>里的分量。</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li>ok，回到对矩阵的消元。</li>\r\n</ul>\r\n<p>假设有一个矩阵：</p>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{array}{c}\r\n1 &amp; 2 &amp; 1 \\\\\r\n3 &amp; 8 &amp; 1 \\\\\r\n0 &amp; 4 &amp; 1\r\n\\end{array}\\right]\r\n\\]</span></p>\r\n<p>首先我想用第一行把(2,\r\n1)消掉，那么第一行是不变的，第三行是不变的，第二行应该变为<span\r\nclass=\"math inline\">\\([0, 2,\r\n-2]\\)</span>，也就是第二行加上负三倍的第一行。首先第一行是不变的，利用“行的线性组合”思想，我们可以对<span\r\nclass=\"math inline\">\\(A\\)</span>左乘一个行向量：</p>\r\n<p><span class=\"math display\">\\[\r\n[1, 0, 0]\\left[\\begin{array}{c}\r\n1 &amp; 2 &amp; 1 \\\\\r\n3 &amp; 8 &amp; 1 \\\\\r\n0 &amp; 4 &amp; 1\r\n\\end{array}\\right]=[1, 2, 1]\r\n\\]</span></p>\r\n<p>然后第三行也是不变的，所以我们继续左乘：</p>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{array}{c}\r\n1 &amp; 0 &amp; 0 \\\\\r\n? &amp; ? &amp; ? \\\\\r\n0 &amp; 0 &amp; 1\r\n\\end{array}\\right]\r\n\\left[\\begin{array}{c}\r\n1 &amp; 2 &amp; 1 \\\\\r\n3 &amp; 8 &amp; 1 \\\\\r\n0 &amp; 4 &amp; 1\r\n\\end{array}\\right]=\r\n\\left[\\begin{array}{c}\r\n1 &amp; 2 &amp; 1 \\\\\r\n? &amp; ? &amp; ? \\\\\r\n0 &amp; 4 &amp; 1\r\n\\end{array}\\right]\r\n\\]</span></p>\r\n<p>显然对于结果矩阵的第二行，我们是想让<span\r\nclass=\"math inline\">\\(A\\)</span>的原第二行加上三倍负第一行的，所以线性组合就是(-3)\r\n* 第一行 + (1) * 第二行 + (0) *\r\n第三行，所以把系数填进左乘的矩阵，即可得到：</p>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{array}{c}\r\n1 &amp; 0 &amp; 0 \\\\\r\n-3 &amp; 1 &amp; 0 \\\\\r\n0 &amp; 0 &amp; 1\r\n\\end{array}\\right]\r\n\\left[\\begin{array}{c}\r\n1 &amp; 2 &amp; 1 \\\\\r\n3 &amp; 8 &amp; 1 \\\\\r\n0 &amp; 4 &amp; 1\r\n\\end{array}\\right]=\r\n\\left[\\begin{array}{c}\r\n1 &amp; 2 &amp; 1 \\\\\r\n0 &amp; 2 &amp; -2 \\\\\r\n0 &amp; 4 &amp; 1\r\n\\end{array}\\right]\r\n\\]</span></p>\r\n<p>这里我们把左乘的这个矩阵记为<span\r\nclass=\"math inline\">\\(E_{21}\\)</span>（因为是想对(2,\r\n1)这个位置进行消除）。这种矩阵叫做初等矩阵</p>\r\n<p>下一步做法依次类推：</p>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{array}{c}\r\n1 &amp; 0 &amp; 0 \\\\\r\n0 &amp; 1 &amp; 0 \\\\\r\n0 &amp; -2 &amp; 1\r\n\\end{array}\\right]\r\n\\left[\\begin{array}{c}\r\n1 &amp; 2 &amp; 1 \\\\\r\n0 &amp; 2 &amp; -2 \\\\\r\n0 &amp; 4 &amp; 1\r\n\\end{array}\\right]=\r\n\\left[\\begin{array}{c}\r\n1 &amp; 2 &amp; 1 \\\\\r\n0 &amp; 2 &amp; -2 \\\\\r\n0 &amp; 0 &amp; 5\r\n\\end{array}\\right]\r\n\\]</span></p>\r\n<p>同样的，我们把左乘的这个矩阵叫做<span\r\nclass=\"math inline\">\\(E_{32}\\)</span>，因为是对位置(3, 2)消除</p>\r\n<p>以上，就是用矩阵去描述消元的全过程。最后，用矩阵来做个大总结的话，就是：</p>\r\n<p><span class=\"math inline\">\\(E_{32}E_{21}A = U\\)</span></p>\r\n<hr />\r\n<ul>\r\n<li>这里再跑点题，多讲一下“初等矩阵”这个概念</li>\r\n<li>前面的<span class=\"math inline\">\\(E_{21},\r\nE_{32}\\)</span>本质上，就是对矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>做了一次\"操作\"，也就是某行减掉了另一行的几倍。</li>\r\n<li>所以我们把能\"操作\"矩阵的矩阵称为初等矩阵</li>\r\n<li>除了某行减掉了另一行几倍，当然还有别的操作，例如交换两行。</li>\r\n<li>很容易啊，一样用\"行的线性组合\"思想，假设要交换第一第二行，那么初等矩阵的第一行就是[0,\r\n1, ..., 0]，第二行就是[1, 0, ..., 0]</li>\r\n<li>对于能交换矩阵行和列的矩阵，也是一种初等矩阵，我们记为<span\r\nclass=\"math inline\">\\(P\\)</span>（置换矩阵）</li>\r\n</ul>\r\n<h3 id=\"三.-矩阵乘法和逆矩阵\">三. 矩阵乘法和逆矩阵</h3>\r\n<ul>\r\n<li><p>假设矩阵<span class=\"math inline\">\\(A\\)</span>乘<span\r\nclass=\"math inline\">\\(B\\)</span>得到矩阵<span\r\nclass=\"math inline\">\\(C\\)</span>。考虑<span\r\nclass=\"math inline\">\\(C\\)</span>的某个元素<span\r\nclass=\"math inline\">\\(c_{ij}\\)</span>，我们都知道这个元素是由<span\r\nclass=\"math inline\">\\(A\\)</span>的第i行与<span\r\nclass=\"math inline\">\\(B\\)</span>的第j列做点乘得到的。</p></li>\r\n<li><p>但是我们如果再用“行的线性组合”的思想，就可以知道，首先，<span\r\nclass=\"math inline\">\\(C\\)</span>的第i行是由<span\r\nclass=\"math inline\">\\(B\\)</span>的每一行线性组合得到的，系数是<span\r\nclass=\"math inline\">\\(A\\)</span>的第i行。那如果我只看<span\r\nclass=\"math inline\">\\(C\\)</span>第i行的第j个，那么也就是<span\r\nclass=\"math inline\">\\(B\\)</span>每一行的第j个（也就是<span\r\nclass=\"math inline\">\\(B\\)</span>的第j列）的线性组合，系数是<span\r\nclass=\"math inline\">\\(A\\)</span>的第i行。从这个角度来看，就清晰多了。</p></li>\r\n<li><p>好的，我们前面讨论的矩阵都是方阵。但其实，矩阵相乘不一定是方阵。假设<span\r\nclass=\"math inline\">\\(A\\)</span>为<span\r\nclass=\"math inline\">\\(\\mathbb{R}^{m \\times n}\\)</span>, <span\r\nclass=\"math inline\">\\(B\\)</span>为<span\r\nclass=\"math inline\">\\(\\mathbb{R}^{n \\times p}\\)</span>, <span\r\nclass=\"math inline\">\\(C\\)</span>为多少呢？</p></li>\r\n<li><p>通过前面“行的线性组合”思想可以推出来，首先<span\r\nclass=\"math inline\">\\(A\\)</span>有m行，那么<span\r\nclass=\"math inline\">\\(C\\)</span>一定有m行，<span\r\nclass=\"math inline\">\\(C\\)</span>的每i行是由<span\r\nclass=\"math inline\">\\(B\\)</span>的每一行线性组合得到的，系数是<span\r\nclass=\"math inline\">\\(A\\)</span>的第i行。所以<span\r\nclass=\"math inline\">\\(C\\)</span>每一行的维度由<span\r\nclass=\"math inline\">\\(B\\)</span>每一行的维度决定，所以<span\r\nclass=\"math inline\">\\(C\\)</span>的维度就是<span\r\nclass=\"math inline\">\\(\\mathbb{R}^{m \\times p}\\)</span></p></li>\r\n<li><p>好的，还可以通过“列的线性组合”思想来推出来。首先<span\r\nclass=\"math inline\">\\(C\\)</span>的第i列是由<span\r\nclass=\"math inline\">\\(A\\)</span>的每一列的线性组合得到的，系数是<span\r\nclass=\"math inline\">\\(B\\)</span>的第i列。所以<span\r\nclass=\"math inline\">\\(C\\)</span>每一列的维度跟<span\r\nclass=\"math inline\">\\(A\\)</span>一样，有m个分量，然后因为<span\r\nclass=\"math inline\">\\(B\\)</span>有p列，所以<span\r\nclass=\"math inline\">\\(C\\)</span>也有p列，所以<span\r\nclass=\"math inline\">\\(C\\)</span>的维度就是<span\r\nclass=\"math inline\">\\(\\mathbb{R}^{m \\times p}\\)</span></p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>但是，还有第三种方法去理解矩阵乘法。就是将矩阵乘法拆成若干个矩阵的加法。我们先考虑一个例子，一个列向量乘一个行向量，假设维度分别为<span\r\nclass=\"math inline\">\\(\\mathbb{R}^{m \\times 1}, \\mathbb{R} ^ {1 \\times\r\nn}\\)</span>，那么显然结果是一个矩阵。这个矩阵的得到可以用“行线组”或者“列线组”去理解都行。</p></li>\r\n<li><p>ok，那么接下里看这个例子：</p></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{array}{c}\r\n2 &amp; 7 \\\\\r\n3 &amp; 8 \\\\\r\n4 &amp; 9\r\n\\end{array}\\right]\r\n\\left[\\begin{array}{c}\r\n1 &amp; 6 \\\\\r\n0 &amp; 0\r\n\\end{array}\\right]\r\n\\]</span></p>\r\n<p>我可以把它看成：第一列乘第一行 + 第二列乘第二行</p>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{array}{c}\r\n2 &amp; 7 \\\\\r\n3 &amp; 8 \\\\\r\n4 &amp; 9\r\n\\end{array}\\right]\r\n\\left[\\begin{array}{c}\r\n1 &amp; 6 \\\\\r\n0 &amp; 0\r\n\\end{array}\\right]=\r\n\\left[\\begin{array}{c}\r\n2 \\\\\r\n3 \\\\\r\n4\r\n\\end{array}\\right]\r\n\\left[\\begin{array}{c}\r\n1 &amp; 6\r\n\\end{array}\\right]+\r\n\\left[\\begin{array}{c}\r\n7 \\\\\r\n8 \\\\\r\n9\r\n\\end{array}\\right]\r\n\\left[\\begin{array}{c}\r\n0 &amp; 0\r\n\\end{array}\\right]\r\n\\]</span></p>\r\n<ul>\r\n<li>好了，现在理解矩阵乘法就有至少三种方法了：行的线性组合、列的线性组合、拆为列向量与对应行向量相乘转为矩阵加法</li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li>其实还有一种理解的方法，就是分块矩阵，可以把俩相乘的矩阵分成对应的块，例如下图：</li>\r\n</ul>\r\n<p><img src=\"1.png\" /></p>\r\n<p>那么其实就可以把<span class=\"math inline\">\\(A_1, A_2, A_3, A_4, B_1,\r\nB_2, B_3, B_4\\)</span>看作“元素”，那么就跟之前的三种理解方式一样了。</p>\r\n<p>可以通过行线组思想来理解，那么<span\r\nclass=\"math inline\">\\(C\\)</span>的第一行就是<span\r\nclass=\"math inline\">\\(A_1[B_1, B_2] + A_2[B_3,\r\nB_4]\\)</span>，第二行就是<span class=\"math inline\">\\(A_3[B_1, B_2] +\r\nA_4[B_3, B_4]\\)</span></p>\r\n<hr />\r\n<ul>\r\n<li><p>对于那些有逆的矩阵，我们称为可逆矩阵或者非奇异矩阵。</p></li>\r\n<li><p>好消息是对于方阵<span\r\nclass=\"math inline\">\\(A\\)</span>，其左逆和右逆是一样的。对于非方阵则不是，因为维度都不同，对于非方阵的逆，称为“伪逆”，这个之后再谈</p></li>\r\n<li><p>所以方阵到底有没有逆，就是一个很重要的问题。</p></li>\r\n<li><p>先来讨论一下奇异矩阵，也就是没有逆的矩阵</p></li>\r\n<li><p>对于一个方阵<span class=\"math inline\">\\(A \\in \\mathbb{R}^{n\r\n\\times n}\\)</span>，假设它的逆为<span\r\nclass=\"math inline\">\\(B\\)</span>，那么<span\r\nclass=\"math inline\">\\(AB=E\\)</span>，<span\r\nclass=\"math inline\">\\(E\\)</span>是一组<span\r\nclass=\"math inline\">\\(\\mathbb{R}^{n \\times\r\nn}\\)</span>的基向量，换句话说，用“列的线性组合”思想思考，<span\r\nclass=\"math inline\">\\(A\\)</span>通过<span\r\nclass=\"math inline\">\\(B\\)</span>做线性变换后，能得到一组基向量，也就是说明<span\r\nclass=\"math inline\">\\(A\\)</span>的列向量们是俩俩线性无关的。（若存在线性有关的情况，则不可能线组出一组基向量，因为一组基向量就代表着空间内任意向量都可以线组出来）</p></li>\r\n<li><p>所以，用几何的思想去思考，一个方阵<span\r\nclass=\"math inline\">\\(A\\)</span>是否可逆，取决于它的列向量们是否俩俩线性无关。若有关，则不可逆，若无关，则可逆。</p></li>\r\n<li><p>那能进一步思考吗？其实从刚才的思考可以发现，只要<span\r\nclass=\"math inline\">\\(A\\)</span>能线性组合出<span\r\nclass=\"math inline\">\\(\\mathbb{R}^{n \\times\r\nn}\\)</span>中的任意一个向量，那么<span\r\nclass=\"math inline\">\\(A\\)</span>就可逆，反之不行。</p></li>\r\n<li><p>“线性无关”这个条件，可以从<span class=\"math inline\">\\(Ax =\r\n0\\)</span>这个代数方程去思考。如果这个方程有非零解，即<span\r\nclass=\"math inline\">\\(col_1 \\cdot x_1 + col_2 \\cdot x_2 + ... + col_n\r\n\\cdot x_n = 0\\)</span>，移项得到：<span\r\nclass=\"math inline\">\\((-\\frac{1}{x_n}) \\cdot (col_1 \\cdot x_1 + col_2\r\n\\cdot x_2 + ...) = col_n\\)</span>，（因为非零解，所以必然可保证<span\r\nclass=\"math inline\">\\(x_n \\ne\r\n0\\)</span>），即这些列向量是线性有关的，那么就不可逆了。</p></li>\r\n<li><p>关于这个结论的证明还可以用反证法，我们的结论是：若能找到<span\r\nclass=\"math inline\">\\(x\\)</span>不是非零解，使得<span\r\nclass=\"math inline\">\\(Ax = 0\\)</span>，则<span\r\nclass=\"math inline\">\\(A\\)</span>不可逆，反之可逆。好，那现在假设<span\r\nclass=\"math inline\">\\(A\\)</span>可逆，那么有<span\r\nclass=\"math inline\">\\(A^{-1}A = E\\)</span>，所以<span\r\nclass=\"math inline\">\\(A^{-1}Ax = A^{-1}0\\)</span>，则<span\r\nclass=\"math inline\">\\(x = 0\\)</span>，但是前面说了<span\r\nclass=\"math inline\">\\(x\\)</span>不是非零解，所以假设不成立。</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li>那么知道一个矩阵有逆后，如何求呢？</li>\r\n<li>使用Gauss-Jordan消元法。具体来说，假设你想求<span\r\nclass=\"math inline\">\\(A\\)</span>的逆。那么就写一个增光矩阵: <span\r\nclass=\"math inline\">\\([A | I]\\)</span>，然后把<span\r\nclass=\"math inline\">\\(A\\)</span>消元为<span\r\nclass=\"math inline\">\\(I\\)</span>，那么此时<span\r\nclass=\"math inline\">\\(I\\)</span>就会变为<span\r\nclass=\"math inline\">\\(A^{-1}\\)</span>，即<span class=\"math inline\">\\([A\r\n| I] \\rightarrow [I | A^{-1}]\\)</span></li>\r\n<li>原理很简单，消元的过程还记得前面讲的吗，消元的本质就是对消元的矩阵乘“初等矩阵”，那么上面消元的过程我可以用下面这个式子表达：</li>\r\n<li><span class=\"math inline\">\\(E_1E_2E_3...E_k[A | I] = E&#39;[A | I] =\r\n[I | E&#39;I]\\)</span></li>\r\n<li>因为<span class=\"math inline\">\\(E&#39;A=I\\)</span>，所以<span\r\nclass=\"math inline\">\\(E&#39;\\)</span>是<span\r\nclass=\"math inline\">\\(A^{-1}\\)</span>，所以<span\r\nclass=\"math inline\">\\(E&#39;I\\)</span>是<span\r\nclass=\"math inline\">\\(A^{-1}\\)</span>。</li>\r\n<li>所以<span class=\"math inline\">\\([A | I] \\rightarrow [I |\r\nA^{-1}]\\)</span></li>\r\n</ul>\r\n<h3 id=\"四.-矩阵a的lu分解\">四. 矩阵A的LU分解</h3>\r\n<ul>\r\n<li>A的LU分解，L是下三角矩阵的意思，U是上三角矩阵的意思</li>\r\n<li>那A的LU分解有什么用呢？</li>\r\n<li>主要是拿来多次解方程组，后续讲完你就懂了。</li>\r\n<li>先用初等矩阵把A消元一下，得到上三角矩阵U，例如：</li>\r\n<li><span class=\"math inline\">\\(E_{21}E_{31}E_{32}A = U\\)</span></li>\r\n<li>然后同乘这些初等矩阵的逆，记为L：</li>\r\n<li><span class=\"math inline\">\\(A = LU\\)</span></li>\r\n<li>即可把<span\r\nclass=\"math inline\">\\(A\\)</span>分解为下三角和上三角矩阵的乘积</li>\r\n<li>好了，那么有什么用呢？</li>\r\n<li>假设要你解<span class=\"math inline\">\\(Ax = b_1, Ax = b_2, ... Ax =\r\nb_n\\)</span></li>\r\n<li>第一种方法是都对每个方程都Gauss消元一次，每次复杂度都是<span\r\nclass=\"math inline\">\\(\\mathcal{O}(n^3)\\)</span>。</li>\r\n<li>第二次方法是求出<span\r\nclass=\"math inline\">\\(A^{-1}\\)</span>，然后对于不同的b，直接拿<span\r\nclass=\"math inline\">\\(A^{-1}\\)</span>与b相乘即可。这样会快很多。</li>\r\n<li>第三种方法就是用A的LU分解，先分解得到LU，然后即L(Ux) = b</li>\r\n<li>然后先解<span class=\"math inline\">\\(Ly = b\\)</span>得到y，再解<span\r\nclass=\"math inline\">\\(Ux = y\\)</span>得到x。</li>\r\n<li>由于L和U都是三角，所以解上述俩方程的复杂度都是<span\r\nclass=\"math inline\">\\(\\mathcal{O}(n^2)\\)</span></li>\r\n</ul>\r\n<h3 id=\"五.-置换-转置-向量空间\">五. 置换, 转置, 向量空间</h3>\r\n<ul>\r\n<li><p>先讲一下置换矩阵<span class=\"math inline\">\\(P\\)</span></p></li>\r\n<li><p>置换矩阵是初等矩阵的一种，意思就是交换行或者列的矩阵</p></li>\r\n<li><p>比如<span\r\nclass=\"math inline\">\\(P_{12}\\)</span>，就是交换行1和行2的矩阵</p></li>\r\n<li><p>思考一个问题，<span\r\nclass=\"math inline\">\\(P_{ij}\\)</span>的逆矩阵是谁？</p></li>\r\n<li><p>容易知道，它的逆就是<span\r\nclass=\"math inline\">\\(P_{ji}\\)</span>，因为<span\r\nclass=\"math inline\">\\(P_{ij}P_{ji} = E\\)</span>。</p></li>\r\n<li><p>所以，思考一下不难得出，对于置换矩阵<span\r\nclass=\"math inline\">\\(P\\)</span>，有<span class=\"math inline\">\\(P^{-1} =\r\nP^\\mathrm{T}\\)</span></p></li>\r\n<li><p>题外话，<span class=\"math inline\">\\(n \\times\r\nn\\)</span>的置换矩阵<span\r\nclass=\"math inline\">\\(P\\)</span>有多少种呢？</p></li>\r\n<li><p>置换矩阵的本质就是规定了行的顺序，那么行有多少种排列顺序，就有多少种置换矩阵。所以维度为n的置换矩阵的形态有<span\r\nclass=\"math inline\">\\(n!\\)</span>种（全排列）</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li>置换矩阵<span class=\"math inline\">\\(P\\)</span>在上一节讲过的<span\r\nclass=\"math inline\">\\(A=LU\\)</span>分解中可以用到。因为在对<span\r\nclass=\"math inline\">\\(A\\)</span>求上三角<span\r\nclass=\"math inline\">\\(U\\)</span>的时候，可能会碰到主元为0的情况，这是我们不想看到的。所以在一开始，就应该把<span\r\nclass=\"math inline\">\\(A\\)</span>的行顺序给调配好，然后再开始进行LU分解。所以，上一节讲到的公式，更一般的应该写成：<span\r\nclass=\"math inline\">\\(PA = LU\\)</span></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>讲完置换矩阵，我要讲，转置</p></li>\r\n<li><p>转置就是<span\r\nclass=\"math inline\">\\(\\mathrm{T}\\)</span>，转置很简单，我想讲的是对称矩阵，就是满足<span\r\nclass=\"math inline\">\\(A^{\\mathrm{T}}=A\\)</span>的矩阵</p></li>\r\n<li><p>对称矩阵很常见，为什么说它常见呢？因为任意一个矩阵<span\r\nclass=\"math inline\">\\(M\\)</span>，与自身的转置<span\r\nclass=\"math inline\">\\(M^{\\mathrm{T}}\\)</span>相乘，就可以得到一个对称矩阵<span\r\nclass=\"math inline\">\\(MM^{\\mathrm{T}}\\)</span></p></li>\r\n<li><p>证明一下：<span\r\nclass=\"math inline\">\\((MM^{\\mathrm{T}})^{\\mathrm{T}} =\r\nMM^{\\mathrm{T}}\\)</span></p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>下面来说一下向量空间</p></li>\r\n<li><p>最常见的向量空间就是<span\r\nclass=\"math inline\">\\(\\mathbb{R}^n\\)</span>，其中最常见的就是<span\r\nclass=\"math inline\">\\(\\mathbb{R}^2\\)</span></p></li>\r\n<li><p>向量空间我觉得跟群的概念有点像，本质就是一个封闭的集合。对于向量空间来说，空间里的向量任意线性组合之后必须仍然要在空间内，才能称为向量空间</p></li>\r\n<li><p>前面说了<span\r\nclass=\"math inline\">\\(\\mathbb{R}^n\\)</span>是最常见的向量空间，但其实，我们更关心包含在其中的空间，即子空间</p></li>\r\n<li><p>就拿<span class=\"math inline\">\\(\\mathbb{R}^2\\)</span>举例，<span\r\nclass=\"math inline\">\\(\\mathbb{R}^2\\)</span>的子空间有谁呢？</p></li>\r\n<li><p>首先，自己肯定是自己的子空间，这很容易。</p></li>\r\n<li><p>然后是直线，即穿过原点的任意直线，也是<span\r\nclass=\"math inline\">\\(\\mathbb{R}^2\\)</span>的子空间</p></li>\r\n<li><p>第三个就是一个点，零向量</p></li>\r\n<li><p>总结一下，能构成向量空间的规则，就是向量空间里的向量任意线性组合之后仍然在向量空间内，这就是向量空间</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li>接下来，我们谈论一下，如何通过矩阵来构造子空间</li>\r\n<li>对于一个矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>，假设其有n行m列，那么它的m个列向量线性组合出来的向量空间叫做矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>的列空间，记作<span\r\nclass=\"math inline\">\\(C(A)\\)</span></li>\r\n</ul>\r\n<h3 id=\"六.-列空间和零空间\">六. 列空间和零空间</h3>\r\n<ul>\r\n<li><p>若有子空间<span class=\"math inline\">\\(S\\)</span>和<span\r\nclass=\"math inline\">\\(T\\)</span>，那么<span class=\"math inline\">\\(S\r\n\\bigcap T\\)</span>是不是子空间，答案显然是的。</p></li>\r\n<li><p>从感性上，稍微思考一下可以很容易的理解</p></li>\r\n<li><p>理性证明也很好证：</p></li>\r\n</ul>\r\n<blockquote>\r\n<p>设<span class=\"math inline\">\\(v, w \\in S \\bigcap T\\)</span>, 则</p>\r\n<p><span class=\"math inline\">\\(v \\in S, v \\in T\\)</span>; <span\r\nclass=\"math inline\">\\(w \\in S, w \\in T\\)</span></p>\r\n<p>所以<span class=\"math inline\">\\(v, w\\)</span>的线性组合既在<span\r\nclass=\"math inline\">\\(S\\)</span>，也在<span\r\nclass=\"math inline\">\\(T\\)</span>中</p>\r\n<p>所以<span class=\"math inline\">\\(v, w\\)</span>的线组在<span\r\nclass=\"math inline\">\\(S \\bigcap T\\)</span>中</p>\r\n<p>所以<span class=\"math inline\">\\(S \\bigcap T\\)</span>是一个子空间</p>\r\n</blockquote>\r\n<hr />\r\n<ul>\r\n<li><p>好了，现在要把子空间的概念与方程的解联系起来</p></li>\r\n<li><p>之前我们有讨论过<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>何时有解的情况</p></li>\r\n<li><p>之前我们说的是，若A的列向量们线组无法线组出来b，那么方程就是无解。</p></li>\r\n<li><p>现在有了子空间这个概念，我们可以把上面那句话说的更专业一点：</p></li>\r\n<li><p>若<span class=\"math inline\">\\(b \\notin\r\nC(A)\\)</span>，则无解（若b不在A的列空间内则无解）；反之有解</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>接下来介绍一下零空间的概念</p></li>\r\n<li><p>对于<span class=\"math inline\">\\(Ax=b\\)</span>这个方程，当<span\r\nclass=\"math inline\">\\(b=0\\)</span>的时候，其的解集称为<span\r\nclass=\"math inline\">\\(A\\)</span>的零空间，记为<span\r\nclass=\"math inline\">\\(N(A)\\)</span></p></li>\r\n<li><p>需要注意的是，对于一个矩阵<span class=\"math inline\">\\(A \\in\r\n\\mathbb{R}^{n \\times m}\\)</span>，其列空间<span\r\nclass=\"math inline\">\\(C(A)\\)</span>是<span\r\nclass=\"math inline\">\\(\\mathbb{R}^{n}\\)</span>维的（因为每个列向量有n个分量），而其零空间<span\r\nclass=\"math inline\">\\(N(A)\\)</span>是<span\r\nclass=\"math inline\">\\(\\mathbb{R}^m\\)</span>维的（因为有m个列向量，所以有m个系数）</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>好了，前面介绍了零空间的概念。但是，我想请问，零空间一定是子空间吗？</p></li>\r\n<li><p>答案：是的</p></li>\r\n<li><p>证明过程很简单，如下：</p></li>\r\n</ul>\r\n<blockquote>\r\n<p>if <span class=\"math inline\">\\(v, w \\in N(A)\\)</span>, i.e., <span\r\nclass=\"math inline\">\\(Av=0, Aw=0\\)</span></p>\r\n<p>then <span class=\"math inline\">\\(A(k_1v + k_2w) = Ak_1v + Ak_2w =\r\nk_1(Av) + k_2(Aw) = 0\\)</span></p>\r\n<p>so <span class=\"math inline\">\\(k_1v + k_2w \\in N(A)\\)</span> for any\r\n<span class=\"math inline\">\\(v, w \\in N(A)\\)</span></p>\r\n<p>so <span class=\"math inline\">\\(N(A)\\)</span> is a subspace.</p>\r\n</blockquote>\r\n<h3 id=\"七.-求解ax0\">七. 求解Ax=0</h3>\r\n<ul>\r\n<li><p>这节先介绍解<span\r\nclass=\"math inline\">\\(Ax=0\\)</span>的算法</p></li>\r\n<li><p>先对<span class=\"math inline\">\\(A\\)</span>消元</p></li>\r\n<li><p>当然，可能出现主元为0的情况，不影响</p></li>\r\n<li><p>如果所有主元都不为0，可以得到一个上三角矩阵，如果有主元为0，那么得到的将是一个阶梯型矩阵</p></li>\r\n<li><p>主元的个数很重要，它有个名字：秩</p></li>\r\n<li><p>OK，回到解<span\r\nclass=\"math inline\">\\(Ax=0\\)</span>的问题。假设现在我们通过消元得到了一个阶梯型矩阵<span\r\nclass=\"math inline\">\\(U\\)</span>，那么现在要解决的问题就是<span\r\nclass=\"math inline\">\\(Ux=0\\)</span>的解</p></li>\r\n<li><p>我们把<span\r\nclass=\"math inline\">\\(U\\)</span>里阶梯的每个凸角那列叫做“主列”，其余列叫做“自由列”。（之所以叫自由列因为它们可以被其余的主列线组出来）</p></li>\r\n<li><p>对于自由列对应的解，我们叫做“自由变量”。自由变量可以随便取，取完之后，就可以反代解出主列对应的解。从而可以得到一组解。</p></li>\r\n<li><p>通常，假设有k个自由变量，那么我们会求k组特殊解，自由变量的取值就是枚举k个人，第i个人是1其余人是0，得到k组特殊解。</p></li>\r\n<li><p>解空间<span\r\nclass=\"math inline\">\\(N(A)\\)</span>就是这k个特殊解的线性组合</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>好了，现在来总结一下上面的算法流程</p></li>\r\n<li><p>首先对于一个维度为<span class=\"math inline\">\\(\\mathbb{R}^{m\r\n\\times n}\\)</span>的矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>，假设有<span\r\nclass=\"math inline\">\\(r\\)</span>个主元，也就是秩为<span\r\nclass=\"math inline\">\\(r\\)</span>。那么主列就有<span\r\nclass=\"math inline\">\\(r\\)</span>列，那么自由列就有<span\r\nclass=\"math inline\">\\(n - r\\)</span>列，那么就有<span\r\nclass=\"math inline\">\\(n - r\\)</span>个自由变量。</p></li>\r\n<li><p>那么分别对这<span class=\"math inline\">\\(n -\r\nr\\)</span>个自由变量取1其余取0，反代，就可以得到<span\r\nclass=\"math inline\">\\(n - r\\)</span>组特殊解。</p></li>\r\n<li><p>这<span class=\"math inline\">\\(n -\r\nr\\)</span>个特殊解的线性组合就是<span\r\nclass=\"math inline\">\\(N(A)\\)</span></p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>如何理解上面的算法流程呢？</p></li>\r\n<li><p>首先要知道，对于<span class=\"math inline\">\\(Ax=0, A \\in\r\n\\mathbb{R}^{m \\times\r\nn}\\)</span>本质就是令n个列向量的线性组合为零向量。那么假设我找到一组解，那么这个解的倍数仍然是解。</p></li>\r\n<li><p>ok，然后消元后我们可以知道哪些列是主列，哪些列是自由列，自由列的意思就是说它可以被别人线组出来。所以它对应的解（自由变量）就可以随便取。</p></li>\r\n<li><p>那如何表示出所有的自由变量的取值呢？</p></li>\r\n<li><p>答案：线性组合</p></li>\r\n<li><p>假设有<span class=\"math inline\">\\(n -\r\nr\\)</span>个自由变量，那么就搞<span class=\"math inline\">\\(n -\r\nr\\)</span>次，每次就是其中一个自由变量为1，其余自由变量为0，得到<span\r\nclass=\"math inline\">\\(n -\r\nr\\)</span>组特解。（跟基向量的感觉比较像）</p></li>\r\n<li><p>那么这<span class=\"math inline\">\\(n -\r\nr\\)</span>组特解的线性组合就是解空间，即零空间<span\r\nclass=\"math inline\">\\(N(A)\\)</span></p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>好了，接下来讲点好玩的东西</p></li>\r\n<li><p>前面我们已经知道了<span\r\nclass=\"math inline\">\\(Ax=0\\)</span>的解法。</p></li>\r\n<li><p>OK，现在我们再进一步思考，前面的算法仍然有回代这一步，这一步往往是计算机不喜欢的，能不能使算法更加“程序化”一些？</p></li>\r\n<li><p>答案是可以的，假设我们已经通过消元得到了阶梯型矩阵<span\r\nclass=\"math inline\">\\(U \\in \\mathbb{R}^{m \\times n}\\)</span></p></li>\r\n<li><p>对于<span\r\nclass=\"math inline\">\\(U\\)</span>中的主列，将它主元的头上面全面消元为0。</p></li>\r\n<li><p>然后把主列全挪到前面，后面放自由列。</p></li>\r\n<li><p>这样，对于<span\r\nclass=\"math inline\">\\(r\\)</span>列主列，其实就得到了一个<span\r\nclass=\"math inline\">\\(m \\times r\\)</span>的矩阵，这个矩阵上半部分是<span\r\nclass=\"math inline\">\\(r \\times r\\)</span>的单位阵<span\r\nclass=\"math inline\">\\(I\\)</span>，下半部分是<span\r\nclass=\"math inline\">\\((m - r) \\times r\\)</span>的全零矩阵。</p></li>\r\n<li><p>然后对于<span class=\"math inline\">\\(n -\r\nr\\)</span>列自由列，其实是一个<span class=\"math inline\">\\(m \\times (n -\r\nr)\\)</span>的矩阵，这个矩阵上半部分是<span class=\"math inline\">\\(r\r\n\\times (n - r)\\)</span>的矩阵<span\r\nclass=\"math inline\">\\(F\\)</span>，下半部分是<span\r\nclass=\"math inline\">\\((m - r) \\times (n -\r\nr)\\)</span>的全零矩阵。</p></li>\r\n<li><p>写出来的话，就是：</p></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{array}{c}\r\nI &amp; F \\\\\r\nO &amp; O\r\n\\end{array}\\right]\r\n\\]</span></p>\r\n<ul>\r\n<li><p>把这个矩阵记为<span\r\nclass=\"math inline\">\\(R\\)</span>，那么现在问题就变成了<span\r\nclass=\"math inline\">\\(Rx=0\\)</span></p></li>\r\n<li><p>那我更进一步，我想直接求出<span class=\"math inline\">\\(X \\in n\r\n\\times (n - r)\\)</span>，<span\r\nclass=\"math inline\">\\(X\\)</span>中的每一列都是<span\r\nclass=\"math inline\">\\(Rx=0\\)</span>的一组特解。（其实就是求出<span\r\nclass=\"math inline\">\\(n - r\\)</span>组特解，然后拼一起得到的矩阵<span\r\nclass=\"math inline\">\\(X\\)</span>）</p></li>\r\n<li><p>用公式写出来即</p></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{array}{c}\r\nI_{r \\times r} &amp; F_{r \\times (n - r)} \\\\\r\nO_{(m - r) \\times r} &amp; O_{(m - r) \\times (n - r)}\r\n\\end{array}\\right]X = O\r\n\\]</span></p>\r\n<ul>\r\n<li>显然</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nX=\\left[\\begin{array}{c}\r\n-F_{r \\times (n - r)} \\\\\r\nI_{(n - r) \\times (n - r)}\r\n\\end{array}\\right]\r\n\\]</span></p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(X\\)</span>的列空间<span\r\nclass=\"math inline\">\\(C(X)\\)</span>就是<span\r\nclass=\"math inline\">\\(Ax=0\\)</span>的零空间<span\r\nclass=\"math inline\">\\(N(A)\\)</span></p></li>\r\n<li><p>多看几遍上面的过程吧，非常优美的解法。</p></li>\r\n</ul>\r\n<h3 id=\"八.-求解axb\">八. 求解Ax=b</h3>\r\n<ul>\r\n<li><p>上节的内容是求<span\r\nclass=\"math inline\">\\(Ax=0\\)</span>的零空间<span\r\nclass=\"math inline\">\\(N(A)\\)</span></p></li>\r\n<li><p>这节的目标是讨论<span\r\nclass=\"math inline\">\\(Ax=b\\)</span></p></li>\r\n<li><p>首先这个方程有可能有解，也有可能无解。如果有解的话，是否有多解，并求出所有解，这是本节要讨论的问题。</p></li>\r\n<li><p>显然，通过前面所学，很容易可知，如果<span class=\"math inline\">\\(b\r\n\\in N(A)\\)</span>，那么方程<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>就有解。</p></li>\r\n<li><p>那有解的时候，如何求出所有解呢？</p></li>\r\n<li><p>假设矩阵<span class=\"math inline\">\\(A \\in \\mathbb{R}^{m \\times\r\nn}\\)</span>，秩为<span class=\"math inline\">\\(r\\)</span>，那么就有<span\r\nclass=\"math inline\">\\(n - r\\)</span>个自由变量。令这<span\r\nclass=\"math inline\">\\(n -\r\nr\\)</span>个自由变量全取0，即可求出一组特解<span\r\nclass=\"math inline\">\\(x_p\\)</span>。</p></li>\r\n<li><p>那么<span class=\"math inline\">\\(Ax = b\\)</span>的解空间就是<span\r\nclass=\"math inline\">\\(x_p + N(A)\\)</span></p></li>\r\n<li><p>注意，<span class=\"math inline\">\\(N(A)\\)</span>就是<span\r\nclass=\"math inline\">\\(Ax=0\\)</span>的解空间，它是一个向量空间</p></li>\r\n<li><p>但是<span class=\"math inline\">\\(x_p +\r\nN(A)\\)</span>就不一定是一个向量空间了，因为它可能不过零向量</p></li>\r\n<li><p>总之，<span class=\"math inline\">\\(Ax=0\\)</span>的解空间是<span\r\nclass=\"math inline\">\\(N(A)\\)</span>，<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>的解空间是<span\r\nclass=\"math inline\">\\(x_p + N(A)\\)</span>，<span\r\nclass=\"math inline\">\\(x_p\\)</span>是自由变量全取0时算出来的一组特解</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>到现在，其实你已经学会了解<span class=\"math inline\">\\(Ax=0,\r\nAx=b\\)</span>了。</p></li>\r\n<li><p>回顾一下，首先是<span\r\nclass=\"math inline\">\\(Ax=0\\)</span>，先消元，得到秩r，如果r =\r\nn，那么就没有自由变量了， 那么<span\r\nclass=\"math inline\">\\(N(A)\\)</span>里只有零向量。</p></li>\r\n<li><p>如果r &lt; n，那么就有n - r个自由变量，那么就可以求出n -\r\nr组特解，这n - r组特解的线性组合就是<span\r\nclass=\"math inline\">\\(N(A)\\)</span></p></li>\r\n<li><p>再来回顾<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>，先消元，得到秩r，如果r =\r\nn，那么就没有自由变量了，那么<span\r\nclass=\"math inline\">\\(N(A)\\)</span>里只有零向量。然后看看<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>是否有特解<span\r\nclass=\"math inline\">\\(x_p\\)</span>，有的话，那么<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>的解集就只有<span\r\nclass=\"math inline\">\\(x_p\\)</span>了。如果没有，那么<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>就没解。</p></li>\r\n<li><p>如果r &lt; n，那么可以就可以先把<span\r\nclass=\"math inline\">\\(N(A)\\)</span>求出来。然后求<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>的特解<span\r\nclass=\"math inline\">\\(x_p\\)</span>，然后<span class=\"math inline\">\\(x_p\r\n+ N(A)\\)</span>就是<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>的解集。</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li>OK，现在再从秩的角度来思考这个问题（<span class=\"math inline\">\\(A\r\n\\in \\mathbb{R}^{m \\times n}\\)</span>）</li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>r = m = n\r\n<ul>\r\n<li>此时是方阵，且<span\r\nclass=\"math inline\">\\(A\\)</span>消元后是单位阵，所以肯定有且只有唯一解</li>\r\n<li>另一个角度，满秩的方阵是可逆矩阵，所以<span class=\"math inline\">\\(x\r\n= bA^{-1}\\)</span>，从这个角度也可以证明有且只有唯一解</li>\r\n</ul></li>\r\n<li>r = n &lt; m\r\n<ul>\r\n<li>此时<span class=\"math inline\">\\(A\\)</span>消元之后可得到 $ $</li>\r\n<li>因为n - r = 0，所以没有自由变量，所以<span\r\nclass=\"math inline\">\\(N(A)\\)</span>里只有零向量。所以<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>要不没解，要不只有唯一解（就是特解）</li>\r\n</ul></li>\r\n<li>r = m &lt; n\r\n<ul>\r\n<li>此时<span class=\"math inline\">\\(A\\)</span>消元之后可得到 $ $</li>\r\n<li>此时n - r &gt; 0，所以有自由变量，所以<span\r\nclass=\"math inline\">\\(N(A)\\)</span>里是有无限多向量的。所以只要<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>有特解<span\r\nclass=\"math inline\">\\(x_p\\)</span>，那么<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>就有无穷多解了。</li>\r\n<li>显然，<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>可以找到特解，因为消元之后没有出现全为0的行，所以肯定能凑出一组解</li>\r\n<li>所以这种情况下，方程<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>有无穷多组解。</li>\r\n</ul></li>\r\n<li>r &lt; m, r &lt; n\r\n<ul>\r\n<li>此时<span class=\"math inline\">\\(A\\)</span>消元之后可得到 $ $</li>\r\n<li>此时n - r &gt; 0，所以有自由变量，所以<span\r\nclass=\"math inline\">\\(N(A)\\)</span>里是有无限多向量的。所以只要<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>有特解<span\r\nclass=\"math inline\">\\(x_p\\)</span>，那么<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>就有无穷多解了。</li>\r\n<li>但是，这里化简之后出现了全0行，所以用增广矩阵去看全0行的那几行b方程可能无法满足。</li>\r\n<li>所以，如果能满足的话，就是无穷多组解。如果无法满足的话，那么就没有解</li>\r\n</ul></li>\r\n</ol>\r\n<ul>\r\n<li>用一句话总结，矩阵的秩说明了方程解的情况。</li>\r\n</ul>\r\n<h3 id=\"九.-线性相关-基-维数\">九. 线性相关, 基, 维数</h3>\r\n<ul>\r\n<li><p>线性相关的标准定义就是，如果一组向量能线性组合出零向量（系数不能全为0），那么这组向量就线性有关；反之线性无关</p></li>\r\n<li><p>向量空间的一组基，是指这么一组向量，这组向量满足两个性质：</p>\r\n<ol type=\"1\">\r\n<li>向量组线性无关</li>\r\n<li>它们恰好能生成整个空间，少一个不行</li>\r\n</ol></li>\r\n<li><p>对于一个向量空间，它的基有很多。但是，所有的基中的向量的个数都相同，这个数量称为该向量空间的维数</p></li>\r\n<li><p><del>所以知道一个向量空间的维数很重要，假设知道了维数dim =\r\nk，还知道向量的维度，那么只需要找k个线性无关的该维度的向量即是这个向量空间的一组基。</del>（upd：这句话是错误的！！！）</p></li>\r\n<li><p>错误原因是因为当时我没意识到行变换会改变列空间。我举一个反例：</p></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{array}{c}\r\n1 &amp; 0 \\\\\r\n0 &amp; 1 \\\\\r\n0 &amp; 0 \\\\\r\n\\end{array}\\right]\r\n\\]</span></p>\r\n<ul>\r\n<li><p>这组列向量产生的向量空间是三维空间里的二维过原点的水平平面。</p></li>\r\n<li><p>ok，如果上面那句话是对的。那么看下面这组由上面那组向量行变换的哀悼的列向量：</p></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\left[\\begin{array}{c}\r\n1 &amp; 1 \\\\\r\n0 &amp; 1 \\\\\r\n2 &amp; 2 \\\\\r\n\\end{array}\\right]\r\n\\]</span></p>\r\n<ul>\r\n<li><p>俩列向量线性无关，但是形成的向量空间显然不是一个水平的平面。故上面那句话是错的。</p></li>\r\n<li><p>行变换不会改变列向量的线性关系，所以求向量空间的基的时候，可以随便用行变换。这为下面<span\r\nclass=\"math inline\">\\(\\mathrm{dim}C(A) = \\mathrm{dim}C(R) =\r\nr\\)</span>的结论做了铺垫。</p></li>\r\n<li><p>但是行变换会改变列空间，所以求向量空间的时候，一定要注意，求的是列空间还是行空间，如果是列空间的话，就要想到行变换会改变列空间这个坑点。</p></li>\r\n</ul>\r\n<blockquote>\r\n<p>为什么行变换不会改变列向量的线性关系？这里给出证明：</p>\r\n<p>考虑<span class=\"math inline\">\\(k_1b_1 + k_2b_2 + ... + k_nb_n =\r\n0\\)</span></p>\r\n<p>做一次行变换后，假设<span\r\nclass=\"math inline\">\\(b_i\\)</span>行变成了<span\r\nclass=\"math inline\">\\(b_i +\r\ncb_j\\)</span>，那么列出n列的线性组合表达式，还是能整理为<span\r\nclass=\"math inline\">\\(k_1b_1 + k_2b_2 + ... + k_nb_n =\r\n0\\)</span>的形式。</p>\r\n<p>所以变换前后，俩矩阵的列向量的线性组合可以化为同一种形式，所以线性关系是相同的</p>\r\n<p>（上面这个证法是自己想的，若错误或者有更好的方法欢迎讨论哇）</p>\r\n</blockquote>\r\n<hr />\r\n<ul>\r\n<li>现在，让我们把基、维数的概念用到矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>中</li>\r\n<li>首先，对于矩阵<span class=\"math inline\">\\(A\\)</span>的列空间<span\r\nclass=\"math inline\">\\(C(A)\\)</span>，它的基是啥？维数是多少？</li>\r\n<li>很显然，<span\r\nclass=\"math inline\">\\(A\\)</span>消元后可知道秩r，表示的是主列的个数，这个秩其实就是列空间<span\r\nclass=\"math inline\">\\(C(A)\\)</span>的维数<span\r\nclass=\"math inline\">\\(\\mathrm{dim}C(A) = r\\)</span></li>\r\n<li><span class=\"math inline\">\\(A\\)</span>的主列们就是<span\r\nclass=\"math inline\">\\(C(A)\\)</span>的一组基（注意这里我说的是<span\r\nclass=\"math inline\">\\(A\\)</span>的主列们而不是<span\r\nclass=\"math inline\">\\(A\\)</span>经过行变换后<span\r\nclass=\"math inline\">\\(R\\)</span>的主列们）</li>\r\n<li>OK，那对于<span class=\"math inline\">\\(A\\)</span>的零空间<span\r\nclass=\"math inline\">\\(N(A)\\)</span>呢？它的基是啥？维数是多少？</li>\r\n<li>回顾求解<span class=\"math inline\">\\(N(A)\\)</span>的过程，就是找n -\r\nr组特解（有n - r个自由变量）。所以n - r就是<span\r\nclass=\"math inline\">\\(N(A)\\)</span>的维数<span\r\nclass=\"math inline\">\\(\\mathrm{dim}N(A) = n - r\\)</span>。这n -\r\nr组特解就是<span class=\"math inline\">\\(N(A)\\)</span>的一组基。</li>\r\n</ul>\r\n<h3 id=\"十.-四个基本子空间\">十. 四个基本子空间</h3>\r\n<ul>\r\n<li><p>四个基本子空间是：列空间、零空间、行空间、左零空间</p></li>\r\n<li><p>列空间老朋友了，<span\r\nclass=\"math inline\">\\(C(A)\\)</span></p></li>\r\n<li><p>零空间也是老朋友了，<span\r\nclass=\"math inline\">\\(N(A)\\)</span></p></li>\r\n<li><p>行空间其实可以写成这样，<span\r\nclass=\"math inline\">\\(C(A^{\\mathrm{T}})\\)</span></p></li>\r\n<li><p>左零空间其实就是，<span\r\nclass=\"math inline\">\\(N(A^{\\mathrm{T}})\\)</span></p></li>\r\n<li><p>为什么要叫左零空间呢？其实是这样的，<span\r\nclass=\"math inline\">\\(A^{\\mathrm{T}}y = 0\\)</span>，转置，得到，<span\r\nclass=\"math inline\">\\(y^{\\mathrm{T}}A = 0^{\\mathrm{T}}\\)</span></p></li>\r\n<li><p>这里的解在左边，所以就叫左零空间</p></li>\r\n</ul>\r\n<hr />\r\n<ul>\r\n<li><p>现在我们来讨论一下这四个空间的维数dim和基</p></li>\r\n<li><p>首先是列空间，列空间的维数是r。基是多少呢？</p></li>\r\n<li><p>这里我要强调一点，<span class=\"math inline\">\\(C(A) \\ne\r\nC(R)\\)</span>（<span class=\"math inline\">\\(R\\)</span>是<span\r\nclass=\"math inline\">\\(A\\)</span>经过行变换得到的）</p></li>\r\n<li><p>因为做行变换会改变列空间，但不会改变行空间</p></li>\r\n<li><p>但为什么做行变换之后还能求解呢？因为你在做行变换（高斯消元）的过程的时候，是对增广矩阵做的。所以<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>与<span\r\nclass=\"math inline\">\\(Rx=b&#39;\\)</span>是等价的，而不是<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>与<span\r\nclass=\"math inline\">\\(Rx=b\\)</span>是等价的。</p></li>\r\n<li><p>好了，所以<span\r\nclass=\"math inline\">\\(C(A)\\)</span>的维数是r，基是<span\r\nclass=\"math inline\">\\(A\\)</span>的主列们</p></li>\r\n<li><p>然后讨论零空间<span\r\nclass=\"math inline\">\\(N(A)\\)</span>，零空间关心的是解集，所以不用关心行变换会影响到<span\r\nclass=\"math inline\">\\(N(A)\\)</span>。所以<span\r\nclass=\"math inline\">\\(N(A)\\)</span>的维数是n - r，基就是n -\r\nr组特解</p></li>\r\n<li><p>接下来讨论行空间<span\r\nclass=\"math inline\">\\(C(A^\\mathrm{T})\\)</span>，它的维数是r，基呢？</p></li>\r\n<li><p>其实直接对<span class=\"math inline\">\\(A\\)</span>做消元得到<span\r\nclass=\"math inline\">\\(R\\)</span>，<span\r\nclass=\"math inline\">\\(R\\)</span>的主行们就是<span\r\nclass=\"math inline\">\\(C(A^\\mathrm{T})\\)</span>。因为行变换不会改变行空间，所以<span\r\nclass=\"math inline\">\\(A\\)</span>与<span\r\nclass=\"math inline\">\\(R\\)</span>的行空间是相同的。</p></li>\r\n<li><p>最后来讨论左零空间<span\r\nclass=\"math inline\">\\(N(A^\\mathrm{T})\\)</span>。左零空间的维数是m -\r\nr很显然，那么基呢？最简单的方法就是对<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}\\)</span>消元，然后m -\r\nr组特解就是左零向量的一组基。</p></li>\r\n</ul>\r\n<h3 id=\"十一.-矩阵空间\">十一. 矩阵空间</h3>\r\n<p>既然有向量空间，那么其实也有矩阵空间。其实任意东西都可以抽象成“向量空间”。</p>\r\n<p>想象一个以3X3矩阵构成的空间M为例。你从M中任挑俩矩阵，相加或者做数乘，发现仍然得到3X3矩阵，所以这是一个矩阵空间。</p>\r\n<p>这个矩阵空间还有一些有意思的子空间，比如3X3对称矩阵这个子空间、3X3的上三角矩阵这个子空间。</p>\r\n<p>显然，M的一组基是9个矩阵，所以M的维数是9（dimM=9）。</p>\r\n<p>记3X3对称矩阵构成的空间为S，那么显然S的一组基是6个矩阵，dimS=6。</p>\r\n<p>记3X3上三角矩阵构成的空间为U，那么那么显然U的一组基也是6个矩阵，dimY=6。</p>\r\n<p>考虑<span class=\"math inline\">\\(S \\cap\r\nU\\)</span>，一个矩阵即是对称的又是上三角的，那么它就是对角的。所以<span\r\nclass=\"math inline\">\\(S \\cap\r\nU\\)</span>表示的是3X3对角矩阵这个子空间。显然，<span\r\nclass=\"math inline\">\\(\\mathrm{dim}(S \\cap U)=3\\)</span>。</p>\r\n<p>好，现在考虑一下<span class=\"math inline\">\\(S \\cup U\\)</span>和<span\r\nclass=\"math inline\">\\(S +\r\nU\\)</span>的区别。只要一个矩阵是对称的，或者上三角的，那么它就属于<span\r\nclass=\"math inline\">\\(S \\cup\r\nU\\)</span>，但是在这个空间对加法不封闭，所以<span\r\nclass=\"math inline\">\\(S \\cup U\\)</span>不是一个子空间；</p>\r\n<p><span class=\"math inline\">\\(S +\r\nU\\)</span>中的每一个矩阵都可以i表示为<span\r\nclass=\"math inline\">\\(S\\)</span>中的一个矩阵加上<span\r\nclass=\"math inline\">\\(U\\)</span>中的一个矩阵。所以<span\r\nclass=\"math inline\">\\(S + U\\)</span>是对加法和数乘封闭的，所以<span\r\nclass=\"math inline\">\\(S + U\\)</span>是一个子空间。另外，当在<span\r\nclass=\"math inline\">\\(S\\)</span>中任取时，<span\r\nclass=\"math inline\">\\(U\\)</span>中取零矩阵时，得到的就是<span\r\nclass=\"math inline\">\\(S\\)</span>。同理，在<span\r\nclass=\"math inline\">\\(U\\)</span>中任取时，<span\r\nclass=\"math inline\">\\(S\\)</span>中取零矩阵时， 得到的就是<span\r\nclass=\"math inline\">\\(U\\)</span>。所以<span class=\"math inline\">\\(S +\r\nU\\)</span>是包含<span class=\"math inline\">\\(S \\cup\r\nU\\)</span>的，换句话说，<span class=\"math inline\">\\((S \\cap U) \\subseteq\r\n(S \\cup U) \\subseteq (S + U)\\)</span>。</p>\r\n<p>进一步想想，<span class=\"math inline\">\\(S +\r\nU\\)</span>是什么，其实它就是<span\r\nclass=\"math inline\">\\(M\\)</span>这个空间。所以显然<span\r\nclass=\"math inline\">\\(dim(S + U) = dim(M) = 9\\)</span>。</p>\r\n<p>到这里，我们可以发现一个式子：<span class=\"math inline\">\\(dim(S) +\r\ndim(U) = dim(S + U) + dim(S \\cap U)\\)</span></p>\r\n<p>这不是碰巧，这确实是一个定理。</p>\r\n<p>所以总结一下，若有向量空间<span class=\"math inline\">\\(S,\r\nU\\)</span>，则<span class=\"math inline\">\\(S \\cap U\\)</span>和<span\r\nclass=\"math inline\">\\(S + U\\)</span>也是向量空间，但<span\r\nclass=\"math inline\">\\(S \\cup U\\)</span>不是。而且满足：<span\r\nclass=\"math inline\">\\(dim(S) + dim(U) = dim(S + U) + dim(S \\cap\r\nU)\\)</span></p>\r\n<hr />\r\n<p>下面来一个有趣的例题，假设列向量<span class=\"math inline\">\\(v \\in\r\n\\mathbb{R}^4\\)</span>，且满足其四个分量之和为0。那么<span\r\nclass=\"math inline\">\\(v\\)</span>是不是一个向量空间？如果是的话，基和维数是什么？</p>\r\n<p>首先，在v中任取俩v1,\r\nv2，做加法和数乘仍在v中，所以v是一个向量空间。</p>\r\n<p>然后它的基和维数是多少呢？</p>\r\n<p>因为v不是一个传统的给定数值的矩阵，所以它的秩不好求。所以这里需要转化思维，如果把v看作是某个矩阵A的零空间，那么只需求出<span\r\nclass=\"math inline\">\\(dim(N(A))\\)</span>就是v的基，同样，零空间的一组基就是n\r\n- r个特解。</p>\r\n<p>思考后不难发现，<span class=\"math inline\">\\(A = [1, 1, 1,\r\n1]\\)</span>，此时有<span class=\"math inline\">\\(Av = 0\\)</span>，<span\r\nclass=\"math inline\">\\(N(A) = v\\)</span>。</p>\r\n<p>显然对于矩阵<span class=\"math inline\">\\(A\\)</span>，秩为1，那么<span\r\nclass=\"math inline\">\\(dim(N(A)) = dim(v) = n - r = 3\\)</span></p>\r\n<p>主列为第一列，所以自由变量为后三个 ，所以分别可得出特解：<span\r\nclass=\"math inline\">\\([-1, 1, 0, 0]^\\mathrm{T}, [-1, 0, 1,\r\n0]^\\mathrm{T}, [-1, 0, 0, 1]^\\mathrm{T}]\\)</span>。这三个向量就是<span\r\nclass=\"math inline\">\\(v\\)</span>向量空间的一组基。</p>\r\n<p>这种解法非常的巧妙，既然正着不好求，就把其转换为矩阵的零空间，从而得到它的空间性质。</p>\r\n<h3 id=\"十二.-图和网络\">十二. 图和网络</h3>\r\n<p>本小节不涉及新的线性代数的知识，而是对于实际问题建模，用线性代数去解决，具有启发意义的一节。</p>\r\n<p>这篇<a\r\nhref=\"https://rqtn.github.io/mit-18.06/mit-18.06-lec12/\">博文</a>写的不错</p>\r\n<h3 id=\"十三.-复习课一\">十三. 复习课一</h3>\r\n<p><a\r\nhref=\"https://www.bilibili.com/video/BV16Z4y1U7oU?p=13&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0\">链接</a>：直接去听，如果都掌握了的话，全部内容是都可以听懂的。</p>\r\n<p>如果听不懂，说明前面的知识没掌握牢固，建议回到对应的位置重新温习后再来听这堂课。</p>\r\n","categories":["4. 大学","数学","线性代数"]},{"title":"机器学习课程自学笔记","url":"/2024/09/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"<p>参考内容：《机器学习》周志华</p>\r\n<span id=\"more\"></span>\r\n<hr />\r\n<p>成绩构成：</p>\r\n<ol type=\"1\">\r\n<li>考勤、作业、研讨：10%</li>\r\n<li>项目：40%</li>\r\n<li>期末：50%</li>\r\n</ol>\r\n<h3 id=\"一.-绪论\">一. 绪论</h3>\r\n<ol type=\"1\">\r\n<li><p>根据训练数据是否拥有标记数据，学习任务大致可分为两类：监督学习、无监督学习。</p>\r\n<ul>\r\n<li>分类和回归是前者的代表，聚类是后者的代表</li>\r\n<li>聚类意思是在训练过程中，机器会自动的对事物的潜在概念进行划分，并把物体分成若干组</li>\r\n</ul></li>\r\n<li><p>模型适用于新样本的能力，称为泛化能力</p></li>\r\n<li><p>通常假设样本空间中全体样本服从一个位置分布<span\r\nclass=\"math inline\">\\(\\mathcal{D}\\)</span>，我们获得的每个样本都是独立地从这个分布上采样得到的，即“独立同分布”。</p></li>\r\n<li><p>假设空间</p>\r\n<ul>\r\n<li>简单理解，就是所有输入的状态</li>\r\n<li>书中举了个例子，有A、B、C三种属性，分别有3、2、2种取值方式。学习目标是某个状态<span\r\nclass=\"math inline\">\\((a, b, c)\\)</span>是否是牛逼的？求所有状态数。\r\n<ul>\r\n<li>对于属性A，其实有4种状态，<span class=\"math inline\">\\(a_1, a_2, a_3,\r\n*\\)</span>，<span\r\nclass=\"math inline\">\\(*\\)</span>表示这个属性取什么无所谓。对于B、C属性同理</li>\r\n<li>那么状态数就有：<span class=\"math inline\">\\(4 * 3 * 3 =\r\n36\\)</span>种</li>\r\n<li>其实还漏了一种，还有一种状态是世界上没有\"牛逼\"这个概念，也就是<span\r\nclass=\"math inline\">\\(\\phi\\)</span>状态。</li>\r\n<li>所以这个例子的总状态数是37种。</li>\r\n<li>我来列举其中的几种：\r\n<ul>\r\n<li>A是<span class=\"math inline\">\\(a_1\\)</span>，B是<span\r\nclass=\"math inline\">\\(b_2\\)</span>，C是<span\r\nclass=\"math inline\">\\(c_3\\)</span>时，是牛逼的</li>\r\n<li>A是<span class=\"math inline\">\\(*\\)</span>，B是<span\r\nclass=\"math inline\">\\(b_1\\)</span>，C是<span\r\nclass=\"math inline\">\\(*\\)</span>时，是牛逼的</li>\r\n<li><span class=\"math inline\">\\(\\cdots\\)</span></li>\r\n<li>世界上没有\"牛逼\"这个东西</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>版本空间</p>\r\n<ul>\r\n<li><p>简单理解，就是把假设空间中不符合样本的所有假设剔除掉的空间</p></li>\r\n<li><p>以书中例子为例</p>\r\n<ul>\r\n<li>根据表1.1，我们知“好瓜”的概念是成立的，所以先删除 <span\r\nclass=\"math inline\">\\(\\phi\\)</span> 的假设</li>\r\n<li>根据样本（（色泽=青绿）<sup>（根蒂=蜷缩）</sup>（敲声=浊响））——&gt;好瓜，删除所有状态对不上的假设</li>\r\n<li>根据样本（（色泽=乌黑）<sup>（根蒂=蜷缩）</sup>（敲声=浊响））——&gt;好瓜，删除所有状态对不上的假设</li>\r\n</ul>\r\n<blockquote>\r\n<p>这里把（（色泽=乌黑）<sup>（根蒂=蜷缩）</sup>（敲声=浊响））删除，这个和样本2符合，不要觉得心虚，因为利用样本2进行删除的时候也会删掉（（色泽=青绿）<sup>（根蒂=蜷缩）</sup>（敲声=浊响））这样刚好留下了（（色泽=*）<sup>（根蒂=蜷缩）</sup>（敲声=浊响）</p>\r\n</blockquote>\r\n<ul>\r\n<li>根据样本（（色泽=青绿）<sup>（根蒂=硬挺）</sup>（敲声=清脆））——&gt;不是好瓜，删除所有状态对上的假设</li>\r\n<li>根据样本（（色泽=乌黑）<sup>（根蒂=稍蜷）</sup>（敲声=沉闷））——&gt;不是好瓜，删除所有状态对上的假设</li>\r\n<li>所以最后剩下了三个假设，这三个假设我们称之为版本空间：(色泽 = <em>,\r\n根蒂 = 蜷缩, 敲声 = </em>)、(色泽 = <em>, 根蒂 = </em>, 敲声 =\r\n清脆)、(色泽 = *, 根蒂 = 蜷缩, 敲声 = 清脆)</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>归纳偏好</p>\r\n<ul>\r\n<li>现实问题中，我们常面临很大的假设空间，但学习过程是根据有限的样本训练集进行的，那么对于不同版本的训练集，就会有不同的版本空间。版本空间内每一个假设都可以判断上面数据集中的每一条数据，是好瓜还是不是好瓜，但是用不同的假设判断一条新数据可能会得出不一样的结果，这就属于“归纳偏好”。</li>\r\n</ul></li>\r\n</ol>\r\n<h3 id=\"二.-模型评估与选择\">二. 模型评估与选择</h3>\r\n<ol type=\"1\">\r\n<li>精度 = 1 - 错误率</li>\r\n<li>学习器在训练集上的误差叫“训练误差”或“经验误差”</li>\r\n<li>学习器在新样本上的误差叫“泛化误差”。显然，我们想要泛化误差小的学习器。</li>\r\n<li>过拟合是指训练误差很小，但是泛化误差不理想。欠拟合是指俩误差都不理想。</li>\r\n</ol>\r\n<h4 id=\"模型评估方法\">模型评估方法</h4>\r\n<ul>\r\n<li><p>评估方法存在的意义：实际中，我们不可能直接拿到泛化误差，因为泛化误差是指实际情况的误差。产品都没开发出来咋获得嘛。而训练误差又由于过拟合现象的存在而不适合作为标准。所以，这时候就需要设计一些精妙的评估方法</p></li>\r\n<li><p>留出法</p>\r\n<ul>\r\n<li>将数据集D切为训练集S和验证集T</li>\r\n<li>需要注意，S和T的划分要尽可能保持数据分布的一致性。例如在分类任务中至少要保证样本的类别比例相似</li>\r\n<li>为了结果可靠，可以进行多次留出法，用平均值作为最终结果</li>\r\n<li>留出法的缺点：我们希望的是评估用D训练出的模型的性能，但留出法本质上是评估的S训练出来的模型的性能。这就会陷入一个窘境：若S包含绝大多数样本，虽然S与D的差距拉近，但是T太小导致评估结果可能不稳定；若S太少，S与D的差距就更远了。所以这个bug没有完全的解决方案，常见做法是将约1/5\r\n~ 1/3的样本用于测试，剩下的用于训练</li>\r\n</ul></li>\r\n<li><p>交叉验证法</p>\r\n<ul>\r\n<li>将D划分为k个大小相似的互斥子集：<span class=\"math inline\">\\(D = D_1\r\n\\cup D_2 \\cup \\cdots \\cup D_k\\)</span>。然后枚举<span\r\nclass=\"math inline\">\\(D_i\\)</span>，每次(全集 - <span\r\nclass=\"math inline\">\\(D_i\\)</span>)作为训练集，<span\r\nclass=\"math inline\">\\(D_i\\)</span>作为验证集。进行k次训练测试，最后返回k次结果的均值。</li>\r\n<li>可以发现，交叉验证法的稳定性和保真性很大程度取决于k，通常取10，称为10折交叉验证</li>\r\n<li>需要注意，<span\r\nclass=\"math inline\">\\(D_i\\)</span>尽可能保持数据分布的一致性</li>\r\n<li>为了结果可靠，可以进行多次交叉验证法，用均值作为最终结果。常见的有：10次10折交叉验证</li>\r\n<li>（当k = D样本数量时，是交叉验证法的一个特例，称为留一法）</li>\r\n</ul></li>\r\n<li><p>自助法</p>\r\n<ul>\r\n<li>无论是留出法还是交叉验证法，S !=\r\nD，所以必然会存在一定偏差。留一法虽然可以使得S <span\r\nclass=\"math inline\">\\(\\to\\)</span>\r\nD，但是训练集太大计算复杂度太高。有没有两全其美的方法呢——自助法。</li>\r\n<li>做法：假设D样本数为m，则进行放回随机采样m次，得到D'。用D'作为训练集，D'作为验证集。</li>\r\n<li>样本在m次采样始终不被采到的概率：</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\lim_{m\\mapsto\\infty}\\left(1-\\frac1m\\right)^m\\mapsto\\frac1e\\approx0.368\r\n\\]</span></p>\r\n<ul>\r\n<li>即数据集D中约36.8%的样本不会出现在D'中。</li>\r\n<li>优点：评估的模型和期望评估的模型都使用了m个样本，但仍有1/3的数据供我们验证。在数据集较小或难以划分训练/验证集时很有用。</li>\r\n<li>缺点：自助法生产的数据集改变了初始数据集分布，会引入估计偏差。因此数据量充足时，留出法和交叉验证法更常用</li>\r\n</ul></li>\r\n<li><p>在进行完模型评估（也就是训练和评估）后，需要再将数据集D全部丢进模型训练一次。这么做是因为模型评估时S\r\n!= D。</p></li>\r\n</ul>\r\n<h4 id=\"性能度量\">性能度量</h4>\r\n<ul>\r\n<li>当得到一个模型后，如何评估它的泛化能力呢？显然需要去度量它的性能，衡量模型泛化能力的评价标准，就叫性能度量。不同的性能度量往往会导致不同的评判结果。</li>\r\n<li>回归任务最常用的性能度量是“均方误差”：\r\n<ul>\r\n<li>离散：<span class=\"math inline\">\\(E(f; D) =\r\n\\frac1m\\sum_{i=1}^m(f(x_i) - y_i)^2\\)</span></li>\r\n<li>一般：<span class=\"math inline\">\\(E(f; \\mathcal{D}) = \\int_{x \\sim\r\n\\mathcal{D}}(f(x) - y)^2p(x)dx\\)</span></li>\r\n</ul></li>\r\n<li>ok，接下来介绍分类任务的性能度量</li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li><p>错误率和精度</p>\r\n<ul>\r\n<li>错误率定义\r\n<ul>\r\n<li>离散：<span class=\"math inline\">\\(E(f; D) =\r\n\\frac1m\\sum_{i=1}^m\\mathbb{I}(f(x_i) \\ne y_i)\\)</span></li>\r\n<li>一般：<span class=\"math inline\">\\(E(f; \\mathcal{D}) = \\int_{x \\sim\r\n\\mathcal{D}}\\mathbb{I}(f(x)\\ne y)p(x)dx\\)</span></li>\r\n</ul></li>\r\n<li>精度定义\r\n<ul>\r\n<li>离散：<span class=\"math inline\">\\(acc(f; D) =\r\n\\frac1m\\sum_{i=1}^m\\mathbb{I}(f(x_i)=y_i)=1-E(f; D)\\)</span></li>\r\n<li>一般：<span class=\"math inline\">\\(acc(f; \\mathcal{D}) = \\int_{x \\sim\r\n\\mathcal{D}}\\mathbb{I}(f(x)=y)p(x)dx=1-E(f; \\mathcal{D})\\)</span></li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>查准率、查全率、F1</p>\r\n<ul>\r\n<li>举个例子，若我们关心“挑出的西瓜中有多少比例是好瓜”以及“所有好瓜中有多少比例被挑了出来”。前者我们用“查准率”(precision)描述，后者用\"查全率\"(recall)来描述。</li>\r\n<li>对二分类来说，我们将预测结果抽象为混淆矩阵：</li>\r\n<li><img src=\"1.png\" /></li>\r\n<li>（TP, true positive表示它确实是正例，表示我们预测对了。TN, true\r\nnegative表示它确实是反例，表示我们预测对了。）</li>\r\n<li>显然$TP + FN + FP + TN = $样例总数</li>\r\n<li>查准率：<span class=\"math inline\">\\(P = \\frac{TP}{TP +\r\nFP}\\)</span></li>\r\n<li>查全率：<span class=\"math inline\">\\(R = \\frac{TP}{TP +\r\nFN}\\)</span></li>\r\n<li>可以发现，查准率和查全率都兼顾有些困难。因为如果想让查全率高，那么就要增加选瓜数量，但是选瓜数量增加后，选出的瓜中是好瓜的概率可能就下降，即查准率下降；若希望选出的好瓜比例高，那么只挑选最有把握的瓜，这样难免就会漏掉不少好瓜，即查全率较低。通常只有在一些简单任务中，才能使P和R都很高。</li>\r\n<li>所以，有没有直观的比较方法呢——PR图。</li>\r\n<li>我们根据学习器的预测结果对样例排序，＂最可能＂是正例的排在最前边或者说最左边，＂最不可能＂是正例的排在最后边或者说最右边．按此顺序逐个把样本作为正例进行预测，每次计算测试样本的查准率和查全率并把这两项作为PR曲线的纵轴和横轴。</li>\r\n<li><img src=\"3.png\" /></li>\r\n<li>显然若一条曲线包住了另一条曲线，那么说明它在任意时刻表现都好。如果俩曲线有相交，那么就比较下俩曲线所形成的面积，谁大谁牛逼。</li>\r\n<li>当然面积可能不好算，所以我们直接用“平衡点”（BEP, 即P =\r\nR时的R坐标）来衡量，谁平衡点大谁牛逼。但是平衡点这方法还是太简陋了，所以我们使用F1度量（谁大谁牛逼）：</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\frac{1}{F_1} = \\frac12\\cdot (\\frac1P + \\frac1R)\r\n\\]</span></p>\r\n<ul>\r\n<li>为了更定制化，还可以使用<span\r\nclass=\"math inline\">\\(F_\\beta\\)</span>度量（<span\r\nclass=\"math inline\">\\(F_1\\)</span>是调和平均，<span\r\nclass=\"math inline\">\\(F_\\beta\\)</span>是加权调和平均）：</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\frac{1}{F_\\beta} = \\frac{1}{1+\\beta^2}\\cdot (\\frac1P +\r\n\\frac{\\beta^2}{R})\r\n\\]</span></p>\r\n<ul>\r\n<li><span\r\nclass=\"math inline\">\\(\\beta\\)</span>度量了查全率对查准率的相对重要性，<span\r\nclass=\"math inline\">\\(\\beta=1\\)</span>为一样重要，<span\r\nclass=\"math inline\">\\(\\beta &gt; 1\\)</span>表示我们更重视查全率。</li>\r\n<li>如果有多个混淆矩阵呢？</li>\r\n<li>第一种方法，直接对所有P、R、F1取均值作为最终结果。这样得到的结果叫做：宏查准率、宏查全率、宏F1</li>\r\n<li>第二种方法，先对所有混淆矩阵对应四个位置取均值，再算出对应的P、R、F1。这样得到的结果叫做：微查准率、微查全率、微F1</li>\r\n</ul></li>\r\n<li><p>ROC和AUC</p>\r\n<ul>\r\n<li>ROC曲线跟PR曲线绘制流程一样，只是横坐标换为了“假正例率”（FPR），纵坐标换为了“真正例率”（TPR）。</li>\r\n<li><span class=\"math inline\">\\(TPR = \\frac{TP}{TP + FN}, \\quad FPR =\r\n\\frac{FP}{FP + FN}\\)</span></li>\r\n<li>TPR表示对于全部好瓜，你预测对了百分之TPR；FPR表示对于全部坏瓜，你预测错了百分之FPR。</li>\r\n<li>显然TPR越高越好，FPR越低越好。</li>\r\n<li>ROC曲线画出来的感觉如下：</li>\r\n<li><img src=\"2.png\" /></li>\r\n<li>AUC是ROC曲线的面积。显然如果一个曲线包住另一个，但它就更牛逼。如果俩线有相交，那么就看看谁的AUC更大，越大越牛逼。</li>\r\n</ul></li>\r\n<li><p>代价敏感错误率和代价曲线</p>\r\n<ul>\r\n<li>在现实中同样是判断错误，但是后果可能不同。比如门禁系统错误的把陌生人放进来的危害肯定比把可通行人拦在外边危害更大。所以同样是判断错误，我们需要赋予其不同的权值。最后的目标是使平均代价最小。</li>\r\n<li>所以可以抽象出代价矩阵的概念：</li>\r\n<li><img src=\"4.png\" /></li>\r\n<li>代价敏感错误率：</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nE(f; D; cost) = \\frac1m(\\sum_{x_i \\in D^+}\\mathbb{I}(f(x_i) \\ne y_i)\r\n\\times cost_{01} + \\sum_{x_i \\in D^-}\\mathbb{I}(f(x_i) \\ne y_i) \\times\r\ncost_{10})\r\n\\]</span></p>\r\n<ul>\r\n<li>当不同后果的权重不同时，上面说的ROC曲线就不能直接反映出学习器的期望总体代价了。所以这时候我们需要“代价曲线”。</li>\r\n<li>略</li>\r\n</ul></li>\r\n</ol>\r\n<h4 id=\"比较检验\">比较检验</h4>\r\n<ul>\r\n<li><p>目前，我们已经可以使用某种模型评估方法，测出某个性能度量的结果。</p></li>\r\n<li><p>但是泛化性能是对新样本进行预测的性能，新样本看成一个总体，那么这个总体我们永远无法完整获得，也就是真实泛化性能永远也不知道是多少。从这个总体中抽样得到一个样本集合，也就是我们通常说的“测试集”，很显然，每次抽样，获得的测试集都不相同，从而从测试集计算得到的性能值也就不同。从测试集得到的性能值可以看成是总体泛化性能的一个估计值，基于这个估计值可以对总体泛化性能进行假设检验和区间估计。</p></li>\r\n<li><p>如果<span\r\nclass=\"math inline\">\\(\\mathcal{D}\\)</span>是服从二项分布的。那么测试集样本容量n你是知道的，错误次数k你也是知道的。那么你可以开始玩假设检验。比如假设<span\r\nclass=\"math inline\">\\(H_0: p_0 \\le\r\n0.5\\)</span>。然后你就假设你这个假设是对的呗，然后算一算在此假设下，错误次数为k的概率。如果算出来的概率小于<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>（显著性水平），说明在此假设下发生这件事的概率极低，那么说明你假设是错的。如果概率大于了<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>，说明至少我不能信心满满的否决你的假设了，我只能说我有<span\r\nclass=\"math inline\">\\(1 -\r\n\\alpha\\)</span>置信度认为你的假设是正确的。</p></li>\r\n<li><p>很多时候我们并非做一次留出法估计，而是多次。所以我们会得到k个测试错误率。则我们可以计算平均错误率及其方差。那么检验统计量<span\r\nclass=\"math inline\">\\(\\tau_t = \\frac{\\sqrt{k}(\\mu -\r\n\\epsilon_0)}{\\sigma}\\)</span>服从t分布。（<span\r\nclass=\"math inline\">\\(\\mu\\)</span>是平均错误率，<span\r\nclass=\"math inline\">\\(\\epsilon_0\\)</span>是假设的错误率， <span\r\nclass=\"math inline\">\\(\\sigma\\)</span>是前面算的方差）</p></li>\r\n<li><p>如果算出来的<span class=\"math inline\">\\(\\tau_t\\)</span>落在<span\r\nclass=\"math inline\">\\([t_{-\\alpha/2},\r\nt_{\\alpha/2}]\\)</span>内，则可下置信度为<span class=\"math inline\">\\(1 -\r\n\\alpha\\)</span>的判断认为真实错误率为<span\r\nclass=\"math inline\">\\(\\epsilon_0\\)</span>；反之则可下真是错误率不为<span\r\nclass=\"math inline\">\\(\\epsilon_0\\)</span>的判断。</p></li>\r\n<li><p>以上俩方法都是关于对单个学习器泛化性能的假设进行的检验，但在实际任务中，更多时候我们需要对不同学习器的性能进行比较，方法有：交叉验证t检验、McNemar检验、Friedman检验、Nemenyi后续检验</p></li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li><p>交叉验证t检验</p>\r\n<ul>\r\n<li>略</li>\r\n</ul></li>\r\n<li><p>McNemar检验</p>\r\n<ul>\r\n<li><p>对二分类问题，使用留出法不仅可估计出学习器A、B的测试错误率，还可以获得俩学习器分类结果的差别，即：两者都分类正确、都错误、A对B错，A错B对的次数，即“列联表”：</p></li>\r\n<li><p><img src=\"5.png\" /></p></li>\r\n<li><p>若我们的假设是俩学习器性能相同，则应有<span\r\nclass=\"math inline\">\\(e_{01} = e_{10}\\)</span>。则<span\r\nclass=\"math inline\">\\(|e_{01} - e_{10}| \\sim N(1, e_{01} +\r\ne_{10})\\)</span>。</p></li>\r\n<li><p>则有：<span class=\"math inline\">\\(\\tau_{\\chi^2}=\\frac{(|e_{01} -\r\ne_{10}| - 1) ^ 2}{e_{01} + e_{10}}\\)</span></p></li>\r\n<li><p>即<span\r\nclass=\"math inline\">\\(\\tau_{\\chi^2}\\)</span>服从自由度为1的卡方分布。</p></li>\r\n<li><p>当<span\r\nclass=\"math inline\">\\(\\tau_{\\chi^2}\\)</span>小于临界值<span\r\nclass=\"math inline\">\\(\\chi_\\alpha^2\\)</span>时，即认为俩学习器性能没有显著差别；反之则认为有显著差别，平均错误率小的那个更牛逼。</p></li>\r\n</ul></li>\r\n<li><p>Friedman检验</p>\r\n<ul>\r\n<li>略</li>\r\n</ul></li>\r\n<li><p>Nemenyi后续检验</p>\r\n<ul>\r\n<li>略</li>\r\n</ul></li>\r\n</ol>\r\n<h4 id=\"偏差与方差\">偏差与方差</h4>\r\n<ul>\r\n<li>为取得良好的泛化能力，则需使偏差较小，此时能够充分拟合数据。并且要使方差较小，因为越小的方差表示受数据扰动的影响小。</li>\r\n<li>但是往往两全不能齐美，称为偏差-方差窘境。</li>\r\n<li>具体内容略。</li>\r\n</ul>\r\n<h3 id=\"三.-线性模型\">三. 线性模型</h3>\r\n<h4 id=\"线性回归\">线性回归</h4>\r\n<p>形如<span class=\"math inline\">\\(f(x) = w^\\mathrm{T}x +\r\nb\\)</span>的，就是线性回归</p>\r\n<p>对于有顺序关系的属性，可以将他们赋值为连续或者离散有顺序的数字。对于无顺序关系的属性，用one-hot。</p>\r\n<p>线性回归的loss函数是MSE。</p>\r\n<p>对于偏置项<span\r\nclass=\"math inline\">\\(b\\)</span>，有一个小技巧就是把它纳入特征里，然后<span\r\nclass=\"math inline\">\\(w\\)</span>里多加一项，这样就相当于<span\r\nclass=\"math inline\">\\(Xw = \\hat{y}\\)</span>了。然后如果<span\r\nclass=\"math inline\">\\(X^\\mathrm{T}X\\)</span>满秩的话，就直接用线代解出最优解就行了。</p>\r\n<p>如果不满秩，可以引入正则化项，</p>\r\n<h4 id=\"对数几率回归\">对数几率回归</h4>\r\n<p>也叫逻辑回归。</p>\r\n<p>起始就是把前面线性回归<span class=\"math inline\">\\(w^\\mathrm{T}x +\r\nb\\)</span>这个值通过sigmoid函数映射到0 ~\r\n1之间。通常用来作二分类问题。</p>\r\n<p>sigmoid函数：<span class=\"math inline\">\\(y = \\frac{1}{1 +\r\ne^{-z}}\\)</span></p>\r\n<p>逻辑回归：<span class=\"math inline\">\\(y = \\frac{1}{1 +\r\ne^{-w^\\mathrm{T}x + b}}\\)</span></p>\r\n<p>另一种写法：<span class=\"math inline\">\\(\\ln \\frac{y}{1 - y} =\r\nw^\\mathrm{T}x + b\\)</span></p>\r\n<p>其loss函数是交叉熵。</p>\r\n<h4 id=\"线性判别分析\">线性判别分析</h4>\r\n<p>略</p>\r\n<h4 id=\"多分类学习\">多分类学习</h4>\r\n<p>OvO（One vs One）、OvR（One vs Other）、MvM（Many vs Many）</p>\r\n<p>假设有n个类，OvO就是有<span\r\nclass=\"math inline\">\\(n(n-1)/2\\)</span>个二分类器，俩俩类别有一个分类器。对于一个样例，经过这<span\r\nclass=\"math inline\">\\(n(n-1)/2\\)</span>个分类器过一遍，而是看看哪些类别得分最高，就判定这个样例为哪个类别。这就是OvO的思路。</p>\r\n<p>对于OvR，就是对于每个类别有一个分类器，就是分是当前这个类或者不是。所以一共n个分类器。结果就是看这n个分类器哪个的概率最大，就判定这个样例为哪个类别。</p>\r\n<p>MvM就是每次将若干个类作为正类，若干个类作为负类。MvM中，最常见的一种分类技术叫“纠错输出码(ECOC)”</p>\r\n<p>ECOC，具体来说，就是对n个类别做m次划分，每次划分是一个二分类器，将一部分类别划为正类，一部分划为负类。然后对于一个样例，经过这m个分类器跑一遍，得到预测向量，看看预测向量与类别自身向量的欧氏距离或者海明距离。去差距最小的那个类别作为预测值。</p>\r\n<p>具体看下面这幅图，一目了然。</p>\r\n<p><img src=\"6.png\" /></p>\r\n<p>上面这幅图中，一共有5个分类器，4个类别。然后对于一个样例，经过5个分类器，跑出了(-1,\r\n-1, +1, -1, +1)这个预测向量。记此向量为x。那么x与<span\r\nclass=\"math inline\">\\(C_1\\)</span>的向量(-1, +1, -1, +1,\r\n+1)的欧氏距离是<span\r\nclass=\"math inline\">\\(2\\sqrt{3}\\)</span>，海明距离(即不同的个数)是3。</p>\r\n<p>通过观察，可以发现预测向量与<span\r\nclass=\"math inline\">\\(C_3\\)</span>的欧氏距离和海明距离均最小，那么就判定该样例属于<span\r\nclass=\"math inline\">\\(C_3\\)</span>。</p>\r\n<p>可以发现，EOOC编码越长(分类器越多)，那么纠错能力越强(鲁棒性越好)。</p>\r\n<p>而且可以发现，两个类别<span class=\"math inline\">\\(C_i,\r\nC_j\\)</span>的编码距离越远越好，这样子区分度就越高。所以我们称任意俩类别之间编码距离最远的编码方式为理论最优编码。</p>\r\n<h4 id=\"类别不平衡问题\">类别不平衡问题</h4>\r\n<p>如果有很多个类别，但是训练集中每个类别的样本数不同，这样会不好。所以说有三种方式解决这个问题(假设正样本多，负样本少)：第一就是删掉一些正样本，第二就是增加一些负样本，第三就是使用“再放缩”。</p>\r\n<p>什么叫“再放缩”，具体来说，原本二分类逻辑回归实际是在执行：若<span\r\nclass=\"math inline\">\\(\\frac{y}{1 - y} &gt;\r\n1\\)</span>，则预测为正例。那么改一改，改为：若<span\r\nclass=\"math inline\">\\(\\frac{y}{1 - y} &gt;\r\n\\frac{m+}{m-}\\)</span>，则预测为正例，其中<span\r\nclass=\"math inline\">\\(m+\\)</span>是正样本数，<span\r\nclass=\"math inline\">\\(m-\\)</span>是负样本数。</p>\r\n<h3 id=\"四.-决策树\">四. 决策树</h3>\r\n<h4 id=\"基本流程\">基本流程</h4>\r\n<p>就是一种模拟人脑决策的模型。</p>\r\n<p>举个例子，就明白了。</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th></th>\r\n<th>性别</th>\r\n<th>年龄</th>\r\n<th>城市</th>\r\n<th>类别</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>A</td>\r\n<td>男</td>\r\n<td>老年</td>\r\n<td>北京</td>\r\n<td>1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>B</td>\r\n<td>男</td>\r\n<td>老年</td>\r\n<td>上海</td>\r\n<td>1</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>C</td>\r\n<td>女</td>\r\n<td>青年</td>\r\n<td>北京</td>\r\n<td>1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>D</td>\r\n<td>女</td>\r\n<td>中年</td>\r\n<td>北京</td>\r\n<td>1</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>E</td>\r\n<td>女</td>\r\n<td>青年</td>\r\n<td>北京</td>\r\n<td>2</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>F</td>\r\n<td>女</td>\r\n<td>青年</td>\r\n<td>北京</td>\r\n<td>2</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>G</td>\r\n<td>女</td>\r\n<td>中年</td>\r\n<td>北京</td>\r\n<td>2</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>H</td>\r\n<td>女</td>\r\n<td>中年</td>\r\n<td>上海</td>\r\n<td>2</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>ok来吧，把决策树建出来把。</p>\r\n<p>首先先按性别分呗，那么就会分出：</p>\r\n<p><img src=\"7.png\" style=\"zoom: 50%;\" /></p>\r\n<p>因为A、B都属于1类，属于没必要继续分下去了，所以直接以叶子节点类别1结束。</p>\r\n<p>ok，那么就右边需要分了，性别这个属性用完了，那么就用年龄开分！</p>\r\n<p><img src=\"8.png\" style=\"zoom:67%;\" /></p>\r\n<p>老年，因为没有样本被分到这，所以这里的叶子节点的类别就要看父节点，也就是（C、D、E、F、G、H\r\n+\r\n年龄/城市）这个点哪个类别多，可以发现属于类别2的人多，所以老年这个节点就以类别2的叶子节点结束。</p>\r\n<p>然后可以目光看向青年，发现C、E、F都在北京，所以没什么好分的了，那么直接接叶子节点，类别就看看哪个类别人多就哪个，E、F都是2，所以接类别2的叶子节点。</p>\r\n<p>还剩（D、G、H + 城市）这个点了，继续分！</p>\r\n<p><img src=\"9.png\" /></p>\r\n<p>分完H那个点只有它自己了，所以直接接自己类别的叶子节点即可。</p>\r\n<p>然后（D、G）这个点，因为没有属性可用了，所以不用分了。哪个类别多接哪个类别的叶子节点。发现D是1，G是2，一样多，那随便了，我就接了一个类别为1的叶子节点。</p>\r\n<p>至此，我们利用这个数据集，建出了一颗决策树！</p>\r\n<p>相信聪明的你也发现了，我们用按顺序去用每一个属性的，那能不能调换顺序呢？顺序有什么讲究呢？这里头是有学问的，留到下一节讲。</p>\r\n<h4 id=\"划分选择\">划分选择</h4>\r\n<ul>\r\n<li>决策树学习的关键在于如何选择最优划分属性，一般而言，随着划分过程不断进行，我们希望决策树的分支节点所包含的样本尽可能属于同一类别。</li>\r\n<li>经典的属性划分方法有：信息增益、增益率、基尼指数</li>\r\n</ul>\r\n<h5 id=\"信息增益\">信息增益</h5>\r\n<ul>\r\n<li><p>首先要知道什么是信息量，信息量具有以下几个性质：</p>\r\n<ol type=\"1\">\r\n<li>非负性：不存在负信息量的事件</li>\r\n<li>单调性：事件发生的概率越大，其信息量越小</li>\r\n<li>累加性：多个相互独立事件信息量等于各事件信息量之和</li>\r\n</ol></li>\r\n<li><p>香农提出了信息量这个概念，然后他用了一个数学函数，以满足上面的三条性质：<span\r\nclass=\"math inline\">\\(I(x) = \\log \\frac{1}{P(x)} = -\\log\r\nP(x)\\)</span></p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(I(x)\\)</span>是事件<span\r\nclass=\"math inline\">\\(x\\)</span>的信息量，<span\r\nclass=\"math inline\">\\(P(x)\\)</span>是事件<span\r\nclass=\"math inline\">\\(x\\)</span>发生的概率</p></li>\r\n<li><p>图像长这样：</p>\r\n<p><img src=\"10.png\" style=\"zoom: 80%;\" /></p></li>\r\n</ul></li>\r\n<li><p>信息量是针对某个具体事件的一种度量方式，香农觉得不够，于是定义了一个名叫“信息熵”的概念。信息熵度量的是随机变量的不确定性：<span\r\nclass=\"math inline\">\\(H(X) = E[-\\log P(X)] = -\\sum_{x \\in X} P(x)\\log\r\nP(x)\\)</span></p>\r\n<ul>\r\n<li>信息熵其实就是“随机变量的信息量的期望”，展开后就是所有事件概率与其信息量乘积之和</li>\r\n<li><span class=\"math inline\">\\(H(X)\\)</span>是随机变量<span\r\nclass=\"math inline\">\\(X\\)</span>的信息熵</li>\r\n<li><span class=\"math inline\">\\(H(X)\\)</span>是非负的，如果<span\r\nclass=\"math inline\">\\(X\\)</span>的可能性越多(越混乱)，那么<span\r\nclass=\"math inline\">\\(H(X)\\)</span>越大</li>\r\n</ul></li>\r\n<li><p>条件熵也是一种信息熵，它考虑的是有两个随机变量的情况，且其中一个随机变量已知的情况时的期望信息熵：</p></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align*}\r\nH(Y | X) &amp;= \\sum_{x \\in X}P(x)H(Y|X=x) \\\\\r\n&amp;= -\\sum_{x \\in X}P(x) \\sum_{y \\in Y} P(y|x)\\log P(y|x) \\\\\r\n&amp;= -\\sum_{x \\in X}\\sum_{y \\in Y}P(x,y)\\log P(y|x)\r\n\\end{align*}\r\n\\]</span></p>\r\n<hr />\r\n<ul>\r\n<li>OK，知道了这几个概念，我们来看看如何将信息熵的概念用到决策树的划分选择上！</li>\r\n<li>对于样本集D，每个样本不是有一个label嘛，假设有k种label，那么样本集D的信息熵<span\r\nclass=\"math inline\">\\(H(D)\\)</span>就为：</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nH(D) = -\\sum p_k \\cdot \\log p_k\r\n\\]</span></p>\r\n<ul>\r\n<li><span\r\nclass=\"math inline\">\\(p_k\\)</span>是第k个label占全部label的比例。这个定义很好理解，如果全部样本都是同一个label，那么信息熵就是0。如果有很多个label，那么信息熵就比较大，说明混乱程序比较高，不确定性程度高。</li>\r\n<li>那如何知道按照什么属性划分会比较好呢？我们希望的是划分之后所产生的子数据集的纯度越高越好，所以有一个很自然的想法就冒出来了：我要找到一个属性A，使得<span\r\nclass=\"math inline\">\\(H(D) -\r\nH(D|A)\\)</span>最大，即划分后的信息熵尽可能小，这样就满足了划分后数据集纯度尽可能大的要求了。bingo，<span\r\nclass=\"math inline\">\\(H(D) -\r\nH(D|A)\\)</span>有个名字，“信息增益”。信息增益越大，意味着使用属性A来进行划分所获得的纯度提升越大。</li>\r\n<li>用数学公式表示maybe会更直观些：</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align*}\r\n    &amp;G(D, A) = H(D) - H(D | A) \\\\\r\n    &amp;H(D) = -\\sum p_k \\cdot \\log p_k \\\\\r\n    &amp;H(D | A) = \\sum_{i=1}^{C} \\frac{cnt_{D_i}}{cnt_D} \\cdot H(D_i)\r\n\\end{align*}\r\n\\]</span></p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(G(D, A)\\)</span>就是考虑用属性<span\r\nclass=\"math inline\">\\(A\\)</span>进行划分时的信息增益；<span\r\nclass=\"math inline\">\\(cnt_D\\)</span>是数据集<span\r\nclass=\"math inline\">\\(D\\)</span>的样本数量；<span\r\nclass=\"math inline\">\\(cnt_{D_i}\\)</span>是数据集按照<span\r\nclass=\"math inline\">\\(A\\)</span>划分后，第<span\r\nclass=\"math inline\">\\(i\\)</span>类的样本数量；<span\r\nclass=\"math inline\">\\(C\\)</span>是按照<span\r\nclass=\"math inline\">\\(A\\)</span>划分后，划分出的类别数。</p></li>\r\n<li><p>至此，如何构建一棵决策树就显然易见了，是一个递归的过程，每次先算出当前数据集D的信息熵<span\r\nclass=\"math inline\">\\(H(D)\\)</span>，然后依次算当前所有属性划分划分之后的信息熵<span\r\nclass=\"math inline\">\\(H(D|(A/B/C/...))\\)</span>，看看哪个的信息增益越大，选最大的划分，划分后得到了新的数据集<span\r\nclass=\"math inline\">\\(D&#39;\\)</span>和属性集，然后对新的数据集和属性集递归做就好了。递归终止条件就是当前数据集的label全一样，或者属性集空了，或者数据集空了。</p></li>\r\n<li><p>上面就是用信息增益(ID3)来建树的算法</p></li>\r\n</ul>\r\n<h5 id=\"增益率c4.5\">增益率、C4.5</h5>\r\n<ul>\r\n<li><p>上面的信息增益算法其实我们没考虑到一个东西，就是不同属性天生包含的类别数不同，例如属性A可能有高、中、矮，但是属性B可能只有瘦、胖。类别多的属性它混乱的几率就会大。为了考虑这一点，所以我们在信息增益的基础上，引入增益率的概念。</p></li>\r\n<li><p>直接给出数学定义，<span class=\"math inline\">\\(G(D,\r\nA)\\)</span>是信息增益(Gain)，<span class=\"math inline\">\\(Gr(D,\r\nA)\\)</span>是增益率(Gain ratio)</p></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n\\begin{align*}\r\n    &amp;G(D, A) = H(D) - H(D | A) \\\\\r\n    &amp;Gr(D, A) = \\frac{G(D, A)}{H(A)} \\\\\r\n    &amp;H(A) = -\\sum p_k \\log p_k\r\n\\end{align*}\r\n\\]</span></p>\r\n<ul>\r\n<li><p>例如属性A有2个类别，第一个类别占1/2，第二个类别占1/2，那么<span\r\nclass=\"math inline\">\\(H(A)\\)</span>就是<span\r\nclass=\"math inline\">\\(-(\\frac12 \\cdot \\log \\frac12 \\cdot\r\n2)=1\\)</span></p></li>\r\n<li><p>稍微改进一下上面的算法，把每次选择最大信息增益改为选择最大增益率的属性。</p></li>\r\n<li><p>但简单这样改还不够好，因为增益率对类别数少的属性有偏好。</p></li>\r\n<li><p>所以C4.5算法就说：先选出信息增益高于平均信息增益的属性，然后再在这些属性中选出增益率最高的属性作为划分属性！</p></li>\r\n</ul>\r\n<h5 id=\"基尼指数\">基尼指数</h5>\r\n<ul>\r\n<li>OK，前面用熵去衡量数据集“纯度”的做法确实很优美。那现在，基尼指数就是另一种衡量数据集“纯度”的东西。</li>\r\n<li>数据集<span\r\nclass=\"math inline\">\\(D\\)</span>的纯度可用基尼值(Gini)来衡量：</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nGn(D) = \\sum_{i=1}^{C}\\sum_{j=1}^{C}p_ip_j = 1 - \\sum_{k=1}^{C}p_k^2,\r\n\\quad i \\ne j\r\n\\]</span></p>\r\n<ul>\r\n<li>可以发现，基于指数反映了从<span\r\nclass=\"math inline\">\\(D\\)</span>中随机抽取两个样本，其类别lable不一致的概率。假设有2种label，且样本数对半开，那么<span\r\nclass=\"math inline\">\\(Gn(D)\\)</span>就是<span\r\nclass=\"math inline\">\\(\\frac12 \\cdot \\frac12 =\r\n\\frac14\\)</span>；假设有2种lable，且样本数为9:1，那么<span\r\nclass=\"math inline\">\\(Gn(D)\\)</span>就是<span\r\nclass=\"math inline\">\\(\\frac{9}{10} \\cdot \\frac{1}{10} =\r\n\\frac{9}{100}\\)</span>。可以发现，基尼系数越小，数据集纯度越高。</li>\r\n<li>那么用属性A划分后的基尼指数是多少？</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nGn(D, A) = \\sum_{k=1}^{C} \\frac{cnt_{D_i}}{cnt_D}Gn(D_i)\r\n\\]</span></p>\r\n<ul>\r\n<li>CART算法就是利用基尼指数来建决策树的算法，它每次看看用哪个属性划分后的基尼指数最小，就用它划分。</li>\r\n</ul>\r\n<h4 id=\"剪枝处理\">剪枝处理</h4>\r\n<ul>\r\n<li><p>剪枝的目的，就是为了避免把训练集自身的一些特点当作所有数据都具有的一般性质而导致的过拟合。</p></li>\r\n<li><p>剪枝的基本策略分为预剪枝和后剪枝。</p></li>\r\n<li><p>判断决策树泛化性能是否提升的方法：留出法(留出一部分作为验证集)</p></li>\r\n</ul>\r\n<h5 id=\"预剪枝\">预剪枝</h5>\r\n<ul>\r\n<li>很简单，就是在划分节点的时候，拿验证集跑一跑，如果划分后效果反而不如不划分，那么就不继续划分该节点了，直接连个叶子节点上去，类别就是该节点内人数最多的类别。（从上到下）</li>\r\n<li>优点：降低过拟合风险，显著减少训练时间</li>\r\n<li>缺点：欠拟合风险</li>\r\n</ul>\r\n<h5 id=\"后剪枝\">后剪枝</h5>\r\n<ul>\r\n<li>很简单，就是先用算法生成一棵决策树，然后从下到上依次考察是否将节点替换为叶子节点会更优，如果更优，就替换</li>\r\n<li>优点：比预剪枝保留了更多分支，欠拟合风险更小</li>\r\n<li>缺点：训练时间大</li>\r\n</ul>\r\n<h4 id=\"连续与缺失值\">连续与缺失值</h4>\r\n<p>连续值和缺失值都是针对属性的值说的。因为在前面讨论的决策树中，我们属性的值都是离散的，例如高、矮、胖、瘦，都是离散的。而现实中可能会存在很多连续值，例如身高是多少cm；也有可能会存在缺失值，比如有个属性是自我性别认知，可能有些人是未知。</p>\r\n<p>首先来看如何处理连续值吧，思路很简单，就是设立划分点，就拿身高这个属性举例，假设样本中，有n个不同的身高，那么划分点就有n个，每确定一个划分点t，其实就可以算出按照t去划分身高这个属性之后得到的信息增益<span\r\nclass=\"math inline\">\\(G(D, A,\r\nt)\\)</span>。以用信息增益算法建树举例，那么划分身高这个属性的时候，就是找一个划分点t，使得<span\r\nclass=\"math inline\">\\(H(D) - G(D, A, t)\\)</span>最大即可。</p>\r\n<p>需要注意的是，连续值与离散值有一个地方不同就是，离散值的属性如果用过，那么后面就不会再用来划分了。但是连续值的属性可以再次使用，比如第一次划分是身高是否低于180，进入子节点后可以继续用身高这个属性划分，身高是否低于160。</p>\r\n<p>OK，现在来讨论缺失值。</p>\r\n<p>还是用信息增益算法来举例，当你计算<span class=\"math inline\">\\(H(D),\r\nG(D, A)\\)</span>的时候，<span\r\nclass=\"math inline\">\\(D\\)</span>就是剔除<span\r\nclass=\"math inline\">\\(A\\)</span>属性有缺失值得到样本子集，然后信息增益就是<span\r\nclass=\"math inline\">\\(\\rho(H(D) - G(D, A))\\)</span>，<span\r\nclass=\"math inline\">\\(\\rho\\)</span>是无缺失值样本数量占总样本数量的比例。然后选择信息增益最大的属性作为当前的划分属性。</p>\r\n<p>ok，划分属性确定好了，如何划分呢？答案就是给每个样本一个全局变量<span\r\nclass=\"math inline\">\\(w_i\\)</span>，为自己的权重，初始为1。对于那些属性<span\r\nclass=\"math inline\">\\(A\\)</span>无缺失的样本呢，直接划分到对应子集中，对应进入的权重为<span\r\nclass=\"math inline\">\\(w_i\\)</span>；对于那些属性<span\r\nclass=\"math inline\">\\(A\\)</span>缺失的样本，就等无缺失的样本都划分完后，然后划分到每一个子集中，对应进入的权重变为<span\r\nclass=\"math inline\">\\(w_i \\cdot\r\n\\frac{\\sum\\text{子集中样本的}w_i}{\\sum\\text{当前属性无缺失的样本的}w_i}\\)</span>。同时将<span\r\nclass=\"math inline\">\\(\\frac{\\sum\\text{子集中样本的}w_i}{\\sum\\text{当前属性无缺失的样本的}w_i}\\)</span>记录下来作为该子节点的权重（后面验证时会用到）。</p>\r\n<p>那么按照这样的算法，决策树就可以建立起来了。</p>\r\n<p>那么验证时，对于属性缺失的样本，它该进入哪呢？</p>\r\n<p>答案就是当建树的时候发现有缺失时，在验证的时候，就给每一个要验证的样本带一个权重<span\r\nclass=\"math inline\">\\(w\\)</span>，初始值为1。假设走到某个属性A，若该样本在属性A上无缺失，则进入到对应子节点to，<span\r\nclass=\"math inline\">\\(dfs(to,\r\nw)\\)</span>；若有缺失，则dfs每个子集都进入，但是进入的权重要乘对应子节点的权重，<span\r\nclass=\"math inline\">\\(dfs(to_i, w \\cdot\r\nw_i)\\)</span>，对应子节点的权重在建树时已经算好。那么最终会进入到多个叶子节点，选择权重最大的叶子节点的类别判定为该样本的label。</p>\r\n<p>但是这么做，可能会存在对应子节点没有权重，也就是训练时该属性无缺失的情况，那么此时也还是要dfs每个子集都进入，只是把进入的权重改为乘<span\r\nclass=\"math inline\">\\(\\frac{1}{\\text{该节点儿子个数}}\\)</span>，即等比例进入每个儿子节点。</p>\r\n<h4 id=\"多变量决策树\">多变量决策树</h4>\r\n<p>略</p>\r\n","categories":["4. 大学","计算机专业课"]},{"title":"数字逻辑实验笔记","url":"/2023/10/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/","content":"<p>这一部分主要是verilog语法，比较简单。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"两种声明方式\">两种声明方式</h3>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> AND4(a, b, out);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] a, b;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] out;</span><br><span class=\"line\">    <span class=\"keyword\">assign</span> out = a &amp; b;</span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> AND4(<span class=\"keyword\">input</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] a, <span class=\"keyword\">input</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] b, <span class=\"keyword\">output</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] out);</span><br><span class=\"line\">    <span class=\"keyword\">assign</span> out = a &amp; b;</span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"数据类型\">数据类型</h3>\r\n<p>掌握wire和reg即可。</p>\r\n<p>wire就是对应着电路里的线。reg就是对应着电路里的寄存器。</p>\r\n<p>常量用parameter定义，例如parameter width = 3;\r\n但是常量也可以重定义，例如下面这个例子：</p>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> adder(a, b, sum);</span><br><span class=\"line\">    <span class=\"keyword\">parameter</span> time_delay = <span class=\"number\">5</span>, time_count = <span class=\"number\">10</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span> top;</span><br><span class=\"line\">    <span class=\"keyword\">wire</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] a1, b1;</span><br><span class=\"line\">    <span class=\"keyword\">wire</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] sum1;</span><br><span class=\"line\">    <span class=\"keyword\">wire</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] a2, b2;</span><br><span class=\"line\">    <span class=\"keyword\">wire</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] sum2;</span><br><span class=\"line\">    adder <span class=\"variable\">#(4, 8) AD1(a1, b1, sum1)</span>;    <span class=\"comment\">//time_delay=4, time_count=8</span></span><br><span class=\"line\">    adder <span class=\"variable\">#(12) AD2(a2, b2, sum2)</span>;    <span class=\"comment\">//time_delay=12, time_count=10</span></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"数据的表达方式\">数据的表达方式</h3>\r\n<p><位宽>'<进制><数字>：4'b0101 / 4‘h5</p>\r\n<p><进制><数字>：位宽一般默认是32位。h5</p>\r\n<p><数字>：位宽默认32位，进制默认为十进制。5</p>\r\n<h3 id=\"拼接运算符\">拼接运算符</h3>\r\n<p>{a, b[3:0], w, 3'b101} 等价于 {a, b[3], b[2], b[1], b[0], w, 1'b1,\r\n1'b0, 1'b1}</p>\r\n<p>{4{w}} 等价于 {w, w, w, w}</p>\r\n<p>{b, 3{a, b}} 等价于 {b, a, b, a, b, a, b}</p>\r\n<h3 id=\"赋值语句\">赋值语句</h3>\r\n<p>assign只能对wire类型赋值。assign的作用通常就是把reg的结果用一个wire接收。</p>\r\n<p>initial里对reg变量赋初值。</p>\r\n<p>always里的=(阻塞赋值)/&lt;=(非阻塞赋值)对always块里的reg类型赋值。</p>\r\n<p>always语句</p>\r\n<p>always @ (clk) //只要clk发生变化就触发 always @ (posedge clk)\r\n//clk上升沿触发（从0-&gt;1触发）</p>\r\n<p>always @ (negedge clk) //clk下降沿触发（从1-&gt;0触发）</p>\r\n<p>always @ (*) //always块内任何输入信号变化了就触发</p>\r\n<h3 id=\"条件语句\">条件语句</h3>\r\n<p>条件语句只能用于always或initial内部。只需要掌握if-else和case语句即可。</p>\r\n<p>if-else语句：跟C++一样，只不过多条语句时将{}换成begin-end</p>\r\n<p>case语句：有case/casex/casez可以选择。casex就是分支表达式中可以有?作为通配符。</p>\r\n<h3 id=\"循环语句\">循环语句</h3>\r\n<p>一般循环语句都是用来写仿真文件的。因为循环次数不确定的循环语句是不能被综合的！</p>\r\n<p>所以一般用循环语句来写源代码都是用for循环</p>\r\n<hr />\r\n<p>接下来的内容就是实验了，实验代码自己手撸的。而且只学了基本语法就开干了，所以代码自我感觉很丑不优美。</p>\r\n<h3 id=\"实验一\">实验一</h3>\r\n<p><img src=\"1.png\" /></p>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> demo02_verilog #(<span class=\"keyword\">parameter</span> W1 = <span class=\"number\">1</span>, W2 = <span class=\"number\">3</span>) (</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [(W1 - <span class=\"number\">1</span>) : <span class=\"number\">0</span>] sw15, sw14,</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [(W2 - <span class=\"number\">1</span>) : <span class=\"number\">0</span>] in1, in2, in3, in4,</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [(W2 - <span class=\"number\">1</span>) : <span class=\"number\">0</span>] ld</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"comment\">//错误代码：assign ld = (~sw15 &amp; ~sw14 &amp; in1) | (~sw15 &amp; sw14 &amp; in2) | (sw15 &amp; ~sw14 &amp; in3) | (sw15 &amp; sw14 &amp; in4);</span></span><br><span class=\"line\">    <span class=\"keyword\">assign</span> ld = sw15 ? (sw14 ? in4 : in3) : (sw14 ? in2 : in1);</span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"实验二\">实验二</h3>\r\n<p><img src=\"2.png\" /></p>\r\n<ul>\r\n<li>top.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> top(a, b, t, e, l1, l2, l3, clk, reset, an, led);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] a, b;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> t, e;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> l1, l2, l3;  <span class=\"comment\">//控制负数亮灯</span></span><br><span class=\"line\">    <span class=\"keyword\">wire</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] out;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk, reset;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] an;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">6</span>:<span class=\"number\">0</span>] led;</span><br><span class=\"line\">    </span><br><span class=\"line\">    add <span class=\"variable\">#(4) f1(.a(a), .b(b), .out(out), .t(t), .e(e))</span>;</span><br><span class=\"line\">    show(<span class=\"variable\">.clk</span>(clk), <span class=\"variable\">.reset</span>(reset),</span><br><span class=\"line\">         <span class=\"variable\">.hex0</span>(out), <span class=\"variable\">.hex2</span>(b), <span class=\"variable\">.hex3</span>(a),</span><br><span class=\"line\">         <span class=\"variable\">.an</span>(an), <span class=\"variable\">.sseg</span>(led), <span class=\"variable\">.l1</span>(l1), <span class=\"variable\">.l2</span>(l2), <span class=\"variable\">.l3</span>(l3));</span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>add.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//进位不影响补码运算的正确性，溢出影响正确性，溢出的本质就是超过了位宽能表达的范围</span></span><br><span class=\"line\"><span class=\"keyword\">module</span> add (a, b, out, t, e);</span><br><span class=\"line\">    <span class=\"keyword\">parameter</span> W = <span class=\"number\">32</span>;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [W-<span class=\"number\">1</span>:<span class=\"number\">0</span>] a, b;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [W-<span class=\"number\">1</span>:<span class=\"number\">0</span>] out;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> t, e;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [W-<span class=\"number\">1</span>:<span class=\"number\">0</span>] a_, b_; <span class=\"comment\">//补码</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [W-<span class=\"number\">1</span>:<span class=\"number\">0</span>] out_;   <span class=\"comment\">//运算后的补码</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [W-<span class=\"number\">1</span>:<span class=\"number\">0</span>] out;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] i;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> t = <span class=\"number\">0</span>, e = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (*) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"comment\">//都转为补码</span></span><br><span class=\"line\">        a_ = a;</span><br><span class=\"line\">        b_ = b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W - <span class=\"number\">1</span>; i = i + <span class=\"number\">1</span>) a_[i] = ~a[i];</span><br><span class=\"line\">            t = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    tt = a_[i];</span><br><span class=\"line\">                    a_[i] = a_[i] ^ <span class=\"number\">1</span> ^ t;</span><br><span class=\"line\">                    t = (tt &amp; <span class=\"number\">1</span>) | (t &amp; (tt | <span class=\"number\">1</span>));</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    tt = a_[i];</span><br><span class=\"line\">                    a_[i] = a_[i] ^ <span class=\"number\">0</span> ^ t;</span><br><span class=\"line\">                    t = (tt &amp; <span class=\"number\">0</span>) | (t &amp; (tt | <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W - <span class=\"number\">1</span>; i = i + <span class=\"number\">1</span>) b_[i] = ~b[i];</span><br><span class=\"line\">            t = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    tt = b_[i];</span><br><span class=\"line\">                    b_[i] = b_[i] ^ <span class=\"number\">1</span> ^ t;</span><br><span class=\"line\">                    t = (tt &amp; <span class=\"number\">1</span>) | (t &amp; (tt | <span class=\"number\">1</span>));</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    tt = b_[i];</span><br><span class=\"line\">                    b_[i] = b_[i] ^ <span class=\"number\">0</span> ^ t;</span><br><span class=\"line\">                    t = (tt &amp; <span class=\"number\">0</span>) | (t &amp; (tt | <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"comment\">//俩补码运算</span></span><br><span class=\"line\">        t = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            out_[i] = a_[i] ^ b_[i] ^ t;</span><br><span class=\"line\">            t = (a_[i] &amp; b_[i]) | (t &amp; (a_[i] | b_[i]));</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"comment\">//检测是否溢出</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a_[W-<span class=\"number\">1</span>] == <span class=\"number\">0</span> &amp;&amp; b_[W-<span class=\"number\">1</span>] == <span class=\"number\">0</span> &amp;&amp; out_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span>) e = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span> &amp;&amp; b_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span> &amp;&amp; out_[W-<span class=\"number\">1</span>] == <span class=\"number\">0</span>) e = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> e = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//将补码转为原码</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (out_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"comment\">//变反码</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                a_[i] = out_[i];</span><br><span class=\"line\">                b_[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                out_[i] = a_[i] ^ b_[i] ^ tt;</span><br><span class=\"line\">                tt = (a_[i] &amp; b_[i]) | (tt &amp; (a_[i] | b_[i]));</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"comment\">//变原码</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W - <span class=\"number\">1</span>; i = i + <span class=\"number\">1</span>) out_[i] = ~out_[i];</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"comment\">//赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) out[i] = out_[i];</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>show.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> show(clk, reset, hex0, hex1, hex2, hex3, an, sseg, l1, l2, l3);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk, reset;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] hex0, hex1, hex2, hex3; <span class=\"comment\">//分别存储4个灯要显示的数字（0-15）</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] an;                    <span class=\"comment\">//控制每个灯是否工作，0为工作</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">6</span>:<span class=\"number\">0</span>] sseg;                  <span class=\"comment\">//存储数字在数码管上的表示</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> l1, l2, l3;                  <span class=\"comment\">//控制负数亮灯</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">assign</span> l1 = hex3[<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">assign</span> l2 = hex2[<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">assign</span> l3 = hex0[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">localparam</span> N = <span class=\"number\">18</span>;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [N-<span class=\"number\">1</span>:<span class=\"number\">0</span>] regN;</span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk, <span class=\"keyword\">posedge</span> reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(reset) regN &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> regN &lt;= regN + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] an;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] hex_in;   <span class=\"comment\">//存储当前要展示的数字</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (*) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span>(regN[N-<span class=\"number\">1</span> : N-<span class=\"number\">2</span>])</span><br><span class=\"line\">            <span class=\"number\">2&#x27;b00</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                an = <span class=\"number\">4&#x27;b1110</span>; </span><br><span class=\"line\">                hex_in = hex0;  </span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"number\">2&#x27;b01</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                an = <span class=\"number\">4&#x27;b1101</span>; </span><br><span class=\"line\">                hex_in = hex1;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"number\">2&#x27;b10</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                an = <span class=\"number\">4&#x27;b1011</span>;</span><br><span class=\"line\">                hex_in = hex2;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                an = <span class=\"number\">4&#x27;b0111</span>;</span><br><span class=\"line\">                hex_in = hex3;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">6</span>:<span class=\"number\">0</span>] sseg;</span><br><span class=\"line\">    <span class=\"keyword\">always</span>@(<span class=\"keyword\">posedge</span> clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span>(hex_in[<span class=\"number\">2</span>:<span class=\"number\">0</span>])</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h0</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0000001</span>; </span><br><span class=\"line\">            <span class=\"number\">4&#x27;h1</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b1001111</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h2</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0010010</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h3</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0000110</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h4</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b1001100</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h5</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0100100</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h6</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0100000</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h7</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0001111</span>;</span><br><span class=\"line\">        <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"实验三\">实验三</h3>\r\n<p><img src=\"3.png\" /></p>\r\n<ul>\r\n<li>top.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> top(clk, A, B, sum, t);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] A, B;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] sum;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> t;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] Lsm_d1;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] Aup_d1, Bup_d1;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> Carry_d1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        &#123;Carry_d1, Lsm_d1&#125; = A[<span class=\"number\">15</span>:<span class=\"number\">0</span>] + B[<span class=\"number\">15</span>:<span class=\"number\">0</span>];</span><br><span class=\"line\">        Aup_d1 = A[<span class=\"number\">31</span>:<span class=\"number\">16</span>];</span><br><span class=\"line\">        Bup_d1 = B[<span class=\"number\">31</span>:<span class=\"number\">16</span>];</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        sum[<span class=\"number\">15</span>:<span class=\"number\">0</span>] = Lsm_d1;</span><br><span class=\"line\">        &#123;t, sum[<span class=\"number\">31</span>:<span class=\"number\">16</span>]&#125; = Aup_d1 + Bup_d1 + Carry_d1;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"实验四\">实验四</h3>\r\n<p><img src=\"4.png\" /></p>\r\n<ul>\r\n<li>top.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// top 模块：整合时钟分频器和交通灯控制器</span></span><br><span class=\"line\"><span class=\"keyword\">module</span> top(</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk,        <span class=\"comment\">// 输入：主时钟信号</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> rst_n,      <span class=\"comment\">// 输入：复位信号</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] light_NS, <span class=\"comment\">// 输出：南北方向交通灯状态</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] light_EW  <span class=\"comment\">// 输出：东西方向交通灯状态</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">wire</span> clk_out;  <span class=\"comment\">// 内部线网：用于从时钟分频器传递分频后的时钟</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 实例化时钟分频器模块</span></span><br><span class=\"line\">    clockdivider u1(</span><br><span class=\"line\">        <span class=\"variable\">.clk</span>(clk),</span><br><span class=\"line\">        <span class=\"variable\">.rst_n</span>(rst_n),</span><br><span class=\"line\">        <span class=\"variable\">.clk_out</span>(clk_out)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"comment\">// 实例化交通灯控制模块</span></span><br><span class=\"line\">    traffic_light u2(</span><br><span class=\"line\">        <span class=\"variable\">.clk</span>(clk_out),  <span class=\"comment\">// 使用分频后的时钟</span></span><br><span class=\"line\">        <span class=\"variable\">.rst_n</span>(rst_n),</span><br><span class=\"line\">        <span class=\"variable\">.light_NS</span>(light_NS),  <span class=\"comment\">// 南北方向交通灯状态</span></span><br><span class=\"line\">        <span class=\"variable\">.light_EW</span>(light_EW)   <span class=\"comment\">// 东西方向交通灯状态</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>clockdivider.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// clockdivider 模块：用于将输入时钟分频</span></span><br><span class=\"line\"><span class=\"keyword\">module</span> clockdivider(</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk,           <span class=\"comment\">// 输入：原始的高频时钟信号</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> rst_n,         <span class=\"comment\">// 输入：复位信号</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> clk_out   <span class=\"comment\">// 输出：分频后的时钟信号</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">parameter</span> DIVISOR = <span class=\"number\">32&#x27;d1666_6667</span>; <span class=\"comment\">// 分频因子</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] counter = <span class=\"number\">32&#x27;d0</span>;        <span class=\"comment\">// 计数器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 时钟分频逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">posedge</span> rst_n) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst_n) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"comment\">// 复位时，重置计数器和输出时钟</span></span><br><span class=\"line\">            counter &lt;= <span class=\"number\">32&#x27;d0</span>;</span><br><span class=\"line\">            clk_out &lt;= <span class=\"number\">1&#x27;b0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"comment\">// 计数器达到分频因子时，翻转输出时钟并重置计数器</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (counter == DIVISOR - <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                clk_out &lt;= ~clk_out;</span><br><span class=\"line\">                counter &lt;= <span class=\"number\">32&#x27;d0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">                <span class=\"comment\">// 否则，计数器递增</span></span><br><span class=\"line\">                counter &lt;= counter + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>traffic_light.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// traffic_light 模块：控制交通灯状态</span></span><br><span class=\"line\"><span class=\"keyword\">module</span> traffic_light(</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk,           <span class=\"comment\">// 输入：时钟信号</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> rst_n,         <span class=\"comment\">// 输入：复位信号</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] light_NS, <span class=\"comment\">// 输出：南北方向交通灯状态</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] light_EW  <span class=\"comment\">// 输出：东西方向交通灯状态</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 状态定义</span></span><br><span class=\"line\">    <span class=\"keyword\">parameter</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] GREEN_NS_RED_EW   = <span class=\"number\">3&#x27;b000</span>,</span><br><span class=\"line\">                     YELLOW_NS_RED_EW  = <span class=\"number\">3&#x27;b001</span>,</span><br><span class=\"line\">                     RED_NS_RED_EW_1   = <span class=\"number\">3&#x27;b010</span>,</span><br><span class=\"line\">                     RED_NS_GREEN_EW   = <span class=\"number\">3&#x27;b011</span>,</span><br><span class=\"line\">                     RED_NS_YELLOW_EW  = <span class=\"number\">3&#x27;b100</span>,</span><br><span class=\"line\">                     RED_NS_RED_EW_2   = <span class=\"number\">3&#x27;b101</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] state = GREEN_NS_RED_EW; <span class=\"comment\">// 当前状态</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] counter = <span class=\"number\">4&#x27;b0000</span>;       <span class=\"comment\">// 计时器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 时钟边沿触发的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">posedge</span> rst_n) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst_n) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"comment\">// 复位逻辑</span></span><br><span class=\"line\">            state &lt;= GREEN_NS_RED_EW;</span><br><span class=\"line\">            counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">        <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"comment\">// 状态转换逻辑</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> (state)</span><br><span class=\"line\">                GREEN_NS_RED_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b1111</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 15时钟周期</span></span><br><span class=\"line\">                        state &lt;= YELLOW_NS_RED_EW;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                YELLOW_NS_RED_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b0011</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 3时钟周期</span></span><br><span class=\"line\">                        state &lt;= RED_NS_RED_EW_1;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_RED_EW_1: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b0011</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 3时钟周期，短暂的全红状态</span></span><br><span class=\"line\">                        state &lt;= RED_NS_GREEN_EW;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_GREEN_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b1111</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 15时钟周期</span></span><br><span class=\"line\">                        state &lt;= RED_NS_YELLOW_EW;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_YELLOW_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b0011</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 3时钟周期</span></span><br><span class=\"line\">                        state &lt;= RED_NS_RED_EW_2;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_RED_EW_2: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b0011</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 3时钟周期</span></span><br><span class=\"line\">                        state &lt;= GREEN_NS_RED_EW;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">endcase</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 计数器递增</span></span><br><span class=\"line\">            counter &lt;= counter + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 根据当前状态更新交通灯输出</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> (state)</span><br><span class=\"line\">                GREEN_NS_RED_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b010</span>; <span class=\"comment\">// 南北绿灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 东西红灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                YELLOW_NS_RED_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b001</span>; <span class=\"comment\">// 南北黄灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 东西红灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_RED_EW_1: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 南北红灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 东西红灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_GREEN_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 南北红灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b010</span>; <span class=\"comment\">// 东西绿灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_YELLOW_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 南北红灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b001</span>; <span class=\"comment\">// 东西黄灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_RED_EW_2: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 南北红灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 东西红灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">endcase</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"大作业\">大作业</h3>\r\n<p><img src=\"5.png\" /></p>\r\n<figure>\r\n<img src=\"6.png\" alt=\"1705202189606\" />\r\n<figcaption aria-hidden=\"true\">1705202189606</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"7.png\" alt=\"1705202209567\" />\r\n<figcaption aria-hidden=\"true\">1705202209567</figcaption>\r\n</figure>\r\n<ul>\r\n<li>top.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> top(clk, reset, btn, an, sseg, current_floor, goal_floor);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> reset;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] an;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">6</span>:<span class=\"number\">0</span>] sseg;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] hex_in;        <span class=\"comment\">//存储要显示的楼层数字</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] btn;                 <span class=\"comment\">// 按钮输入</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] current_floor;      <span class=\"comment\">// 当前楼层（例如01000）</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span>  [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] goal_floor;      <span class=\"comment\">// 呼叫的楼层（例如01000）</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">localparam</span> N = <span class=\"number\">18</span>;         <span class=\"comment\">//分频系数(50MHZ/2^16)</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [N-<span class=\"number\">1</span>:<span class=\"number\">0</span>] regN;          <span class=\"comment\">//高两位作为控制信号，低16位为计数器，对时钟进行分频</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk, <span class=\"keyword\">posedge</span> reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(reset) regN &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> regN &lt;= regN + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">solve</span> u1(<span class=\"variable\">.clk</span>(clk),</span><br><span class=\"line\">             <span class=\"variable\">.rst</span>(reset),</span><br><span class=\"line\">             <span class=\"variable\">.btn</span>(btn),</span><br><span class=\"line\">             <span class=\"variable\">.key_pulse</span>(),</span><br><span class=\"line\">             <span class=\"variable\">.current_floor</span>(current_floor),</span><br><span class=\"line\">             <span class=\"variable\">.goal_floor</span>(goal_floor)</span><br><span class=\"line\">             );</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ * <span class=\"keyword\">begin</span></span><br><span class=\"line\">       <span class=\"keyword\">case</span>(regN[N-<span class=\"number\">1</span> : N-<span class=\"number\">2</span>])</span><br><span class=\"line\">           <span class=\"number\">2&#x27;b00</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">               an = <span class=\"number\">4&#x27;b0111</span>; <span class=\"comment\">//选中第1个数码管</span></span><br><span class=\"line\">               hex_in = current_floor;</span><br><span class=\"line\">           <span class=\"keyword\">end</span></span><br><span class=\"line\">           <span class=\"number\">2&#x27;b11</span>:<span class=\"keyword\">begin</span></span><br><span class=\"line\">               an = <span class=\"number\">4&#x27;b1110</span>;<span class=\"comment\">//选中第四个数码管</span></span><br><span class=\"line\">               hex_in =  goal_floor;</span><br><span class=\"line\">           <span class=\"keyword\">end</span></span><br><span class=\"line\">       <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">always</span>@ * <span class=\"keyword\">begin</span></span><br><span class=\"line\">       <span class=\"keyword\">case</span>(hex_in)</span><br><span class=\"line\">           <span class=\"number\">5&#x27;b00000</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0000001</span>;</span><br><span class=\"line\">           <span class=\"number\">5&#x27;b00001</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b1001111</span>;</span><br><span class=\"line\">           <span class=\"number\">5&#x27;b00010</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0010010</span>;</span><br><span class=\"line\">           <span class=\"number\">5&#x27;b00100</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0000110</span>;</span><br><span class=\"line\">           <span class=\"number\">5&#x27;b01000</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b1001100</span>;</span><br><span class=\"line\">           <span class=\"number\">5&#x27;b10000</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0100100</span>;</span><br><span class=\"line\">           <span class=\"keyword\">default</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b1111111</span>;</span><br><span class=\"line\">       <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>solve.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> <span class=\"keyword\">solve</span>(clk, rst, btn, key_pulse, current_floor, goal_floor);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> rst;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] btn;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] current_floor;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] goal_floor; </span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">wire</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] key_edge;         <span class=\"comment\">// 按键松开时，其为1，使得cnt清零，产生延时</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] key_lat;           <span class=\"comment\">// 存储上一个触发时的按键值</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] key_now;           <span class=\"comment\">// 存储当前时刻触发的按键值</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">negedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            key_now &lt;= &#123;<span class=\"number\">5</span>&#123;<span class=\"number\">1&#x27;b1</span>&#125;&#125;;</span><br><span class=\"line\">            key_lat &lt;= &#123;<span class=\"number\">5</span>&#123;<span class=\"number\">1&#x27;b1</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">            key_now &lt;= btn;</span><br><span class=\"line\">            key_lat &lt;= key_now;</span><br><span class=\"line\">        <span class=\"keyword\">end</span>    </span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">assign</span>  key_edge = key_lat &amp; (~key_now);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//产生20ms延时，当检测到key_edge有效是计数器清零开始计数</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span>    [<span class=\"number\">17</span>:<span class=\"number\">0</span>] cnt;    </span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">negedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rst) cnt &lt;= <span class=\"number\">18&#x27;h0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key_edge) cnt &lt;= <span class=\"number\">18&#x27;h0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> cnt &lt;= cnt + <span class=\"number\">1&#x27;h1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 用f1、f2俩变量来控制实现&quot;只用按一次按钮就可以，不用一直按&quot;的效果</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] f1;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] f2;</span><br><span class=\"line\">    <span class=\"comment\">// 延时更新f1</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">negedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst) f1 &lt;= &#123;<span class=\"number\">5</span>&#123;<span class=\"number\">1&#x27;b0</span>&#125;&#125;;                </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cnt==<span class=\"number\">18&#x27;h3ffff</span>) f1 &lt;= btn;  </span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"comment\">// f2随时保持f1的节奏</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">negedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst) f2 &lt;= &#123;<span class=\"number\">5</span>&#123;<span class=\"number\">1&#x27;b0</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> f2 &lt;= f1;             </span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 一开始俩都是0000，所以key_pulse不会改变</span></span><br><span class=\"line\">    <span class=\"comment\">// 一直按住某个按键的话，就会出现f2 = 0, f1 = 1的情况，此时key_pulse会翻转为1</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果按住某个按键，然后松开的话，那么会使得cnt重新为0。也就是f1 = 1的情况会延时一段时间，此时f2趁机更新为1。</span></span><br><span class=\"line\">    <span class=\"comment\">// 从而延时这段时间，不会使得key_pulse翻转</span></span><br><span class=\"line\">    <span class=\"comment\">// 当延时到了，就会出现，key_sec更新为0，f2 = 1的情况。此时也不会使得key_pulse翻转</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后重新回到俩都是0的情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 当再按一次时，就会出现如上的情况，从而实现&quot;取消&quot;的功能</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] key_pulse;      <span class=\"comment\">// 处理后的按键状态</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">negedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst) key_pulse &lt;= &#123;<span class=\"number\">5</span>&#123;<span class=\"number\">1&#x27;b0</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span>                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~f2[<span class=\"number\">4</span>] &amp; f1[<span class=\"number\">4</span>]) key_pulse[<span class=\"number\">4</span>] &lt;= ~key_pulse[<span class=\"number\">4</span>];    </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~f2[<span class=\"number\">3</span>] &amp; f1[<span class=\"number\">3</span>]) key_pulse[<span class=\"number\">3</span>] &lt;= ~key_pulse[<span class=\"number\">3</span>];   </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~f2[<span class=\"number\">2</span>] &amp; f1[<span class=\"number\">2</span>]) key_pulse[<span class=\"number\">2</span>] &lt;= ~key_pulse[<span class=\"number\">2</span>];    </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~f2[<span class=\"number\">1</span>] &amp; f1[<span class=\"number\">1</span>]) key_pulse[<span class=\"number\">1</span>] &lt;= ~key_pulse[<span class=\"number\">1</span>];  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~f2[<span class=\"number\">0</span>] &amp; f1[<span class=\"number\">0</span>]) key_pulse[<span class=\"number\">0</span>] &lt;= ~key_pulse[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">end</span>  </span><br><span class=\"line\">    <span class=\"keyword\">end</span>  </span><br><span class=\"line\">       </span><br><span class=\"line\"></span><br><span class=\"line\">    get_floor u2(<span class=\"variable\">.clk</span>(clk),</span><br><span class=\"line\">                 <span class=\"variable\">.rst</span>(rst),</span><br><span class=\"line\">                 <span class=\"variable\">.key_pulse</span>(key_pulse),</span><br><span class=\"line\">                 <span class=\"variable\">.current_floor</span>(current_floor),</span><br><span class=\"line\">                 <span class=\"variable\">.goal_floor</span>(goal_floor)</span><br><span class=\"line\">                 );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>get_floor.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> get_floor(clk, rst, key_pulse, current_floor, goal_floor);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> rst;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">4</span>:<span class=\"number\">0</span>] key_pulse;    </span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">4</span>:<span class=\"number\">0</span>] current_floor;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">4</span>:<span class=\"number\">0</span>] goal_floor; </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">initial</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">        goal_floor = <span class=\"number\">5&#x27;b00001</span>;</span><br><span class=\"line\">        current_floor = <span class=\"number\">5&#x27;b00001</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// 时钟分频器：每过1s，clk_out=~clk_out。实现&quot;每一秒钟，电梯移动一层&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">30</span>:<span class=\"number\">0</span>] cnt = <span class=\"number\">30&#x27;b0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">parameter</span> M = <span class=\"number\">100000000</span>;  <span class=\"comment\">//1s=1000000000ns</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> clk_out = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rst) clk_out = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cnt == M-<span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            clk_out = ~clk_out;</span><br><span class=\"line\">            cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">            clk_out = <span class=\"number\">0</span>;</span><br><span class=\"line\">            cnt = cnt + <span class=\"number\">1&#x27;d1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">// 更新goal_floor</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (*) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rst) goal_floor = <span class=\"number\">5&#x27;b00001</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> goal_floor = key_pulse;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"comment\">// 更新current_floor     </span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk_out <span class=\"keyword\">or</span> <span class=\"keyword\">posedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rst) current_floor = <span class=\"number\">5&#x27;b00001</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(goal_floor != <span class=\"number\">5&#x27;b00000</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(current_floor &lt; goal_floor)               <span class=\"comment\">//电梯所在楼层低于目标楼层则上升</span></span><br><span class=\"line\">                current_floor = &#123;current_floor[<span class=\"number\">3</span>:<span class=\"number\">0</span>], current_floor[<span class=\"number\">4</span>]&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(current_floor &gt; goal_floor)         <span class=\"comment\">//电梯所在楼层高于目标楼层则下降</span></span><br><span class=\"line\">                current_floor = &#123;current_floor[<span class=\"number\">0</span>], current_floor[<span class=\"number\">4</span>:<span class=\"number\">1</span>]&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">           </span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n","categories":["4. 大学","计算机专业课"]},{"title":"数学知识补充","url":"/2023/10/31/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/","content":"<p>论文中涉及到许多基础数学知识，但是在论文里单独展开篇幅太长了。所以统一在这篇blog里记录。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"lipschitz连续\">Lipschitz连续</h3>\r\n<p>先看连续的定义：函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>在点<span class=\"math inline\">\\(x =\r\nx_0\\)</span>连续<span class=\"math inline\">\\(\\iff\\)</span> <span\r\nclass=\"math inline\">\\(\\lim_{x \\rightarrow x_0}f(x) = f(x_0) \\iff \\forall\r\n\\varepsilon&gt;0, \\exists\\delta = \\delta(\\varepsilon)&gt;0\\)</span>,\r\n使得当<span class=\"math inline\">\\(|x - x_0| &lt;\r\n\\delta\\)</span>时，有<span class=\"math inline\">\\(|f(x) - f(x_0)| &lt;\r\n\\varepsilon\\)</span></p>\r\n<p>在此定义中，<span class=\"math inline\">\\(\\delta\\)</span>不仅与<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>有关，而且与<span\r\nclass=\"math inline\">\\(x_0\\)</span>有关，应记为<span\r\nclass=\"math inline\">\\(\\delta = \\delta(x_0,\r\n\\varepsilon)\\)</span>。也就是说，对于同一个<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>，在不同的<span\r\nclass=\"math inline\">\\(x_0\\)</span>处，使<span\r\nclass=\"math inline\">\\(|f(x) - f(x_0)| &lt;\r\n\\varepsilon\\)</span>的x取值范围可以差得很多。</p>\r\n<p>所以我们自然会问，对于<span class=\"math inline\">\\(\\forall \\varepsilon\r\n&gt; 0\\)</span>，是否存在只与<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>有关的<span\r\nclass=\"math inline\">\\(\\delta\\)</span>，使得对于区间中任意两点<span\r\nclass=\"math inline\">\\(x_1, x_2\\)</span>，只要满足<span\r\nclass=\"math inline\">\\(|x_1 - x_2| &lt; \\delta\\)</span>，就成立<span\r\nclass=\"math inline\">\\(|f(x_1) - f(x_2)| &lt; \\varepsilon\\)</span>？</p>\r\n<p>这就引出了一致连续的定义：设函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>在区间X上有定义，若<span\r\nclass=\"math inline\">\\(\\forall \\varepsilon &gt; 0, \\exists\\delta =\r\n\\delta(\\varepsilon) &gt; 0\\)</span>，使得对于区间X中的任意两点<span\r\nclass=\"math inline\">\\(x_1, x_2\\)</span>，只要满足<span\r\nclass=\"math inline\">\\(|x_1 - x_2| &lt; \\delta\\)</span>，就成立<span\r\nclass=\"math inline\">\\(|f(x_1) - f(x_2)| &lt;\r\n\\varepsilon\\)</span>，则称函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>在区间X上一致连续。</p>\r\n<p>可以发现一致连续是比连续更强的一个条件。接下来要讲的Lipschitz连续，是比一致连续还要强的一个条件。</p>\r\n<p>先给出Lipschitz连续的定义：设函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>在区间X上有定义，若存在<span\r\nclass=\"math inline\">\\(L &gt; 0\\)</span>，使得对于区间X中的任意两点<span\r\nclass=\"math inline\">\\(x_1, x_2\\)</span>，都满足<span\r\nclass=\"math inline\">\\(|f(x_1) - f(x_2)| \\le L|x_1 -\r\nx_2|\\)</span>，则称<span\r\nclass=\"math inline\">\\(f(x)\\)</span>在区间X上是Lipschitz连续。</p>\r\n<blockquote>\r\n<p>下面证明Lipschitz连续是比一致连续更强的一个条件：</p>\r\n<p>证明：<span class=\"math inline\">\\(\\forall \\varepsilon &gt;\r\n0\\)</span>，取<span class=\"math inline\">\\(\\delta = \\frac{\\varepsilon}{L}\r\n&gt; 0\\)</span>，则<span class=\"math inline\">\\(\\forall x_1, x_2 \\in\r\nX\\)</span>，当<span class=\"math inline\">\\(|x_1 - x_2| &lt;\r\n\\delta\\)</span>时，<span class=\"math inline\">\\(|f(x1) - f(x_2)| \\le\r\nL|x_1 - x_2| &lt; L\\delta = L \\cdot \\frac{\\varepsilon}{L} =\r\n\\varepsilon\\)</span>，得证。</p>\r\n</blockquote>\r\n<h3 id=\"矩阵范数\">矩阵范数</h3>\r\n<h4 id=\"矩阵范数定义\">1. 矩阵范数定义</h4>\r\n<p>矩阵范数的定义如下：</p>\r\n<p>若函数<span class=\"math inline\">\\(f: R^{n \\times n} \\rightarrow\r\nR\\)</span>满足：</p>\r\n<ol type=\"1\">\r\n<li>正定性：<span class=\"math inline\">\\(f(A) \\ge 0, \\forall A \\in R^{n\r\n\\times n}\\)</span>，等号当且仅当<span class=\"math inline\">\\(A =\r\n0\\)</span>成立</li>\r\n<li>齐次性：<span class=\"math inline\">\\(f(\\alpha A) = |\\alpha| \\cdot\r\nf(A), \\forall A \\in R^{n \\times n}, \\alpha \\in R\\)</span></li>\r\n<li>三角不等式：<span class=\"math inline\">\\(f(A \\pm B) \\le f(A) + f(B),\r\n\\forall A, B \\in R^{n \\times n}\\)</span></li>\r\n<li>相容性：<span class=\"math inline\">\\(f(AB) \\le f(A) \\cdot f(B),\r\n\\forall A, B \\in R^{n \\times n}\\)</span></li>\r\n</ol>\r\n<p>则将<span class=\"math inline\">\\(f(x)\\)</span>称为<span\r\nclass=\"math inline\">\\(R^{n \\times n}\\)</span>上的范数，记作<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|\\)</span></p>\r\n<p>还有一条性质，有些矩阵范数也是满足的，即与向量的相容性：</p>\r\n<p><span class=\"math inline\">\\(f(Ax) \\le f(A) \\cdot f(x), \\forall A \\in\r\nR^{n \\times n}, x \\in R^{n}\\)</span></p>\r\n<h4 id=\"算子从属范数\">2. 算子(从属)范数</h4>\r\n<p>矩阵范数跟向量范数一样，有很多种。但大多数情况都是用的算子(从属)范数中的二范数（谱范数）。</p>\r\n<p>先来介绍一下算子范数</p>\r\n<p>定义：设<span class=\"math inline\">\\(\\|\\cdot\\|\\)</span>是<span\r\nclass=\"math inline\">\\(R^n\\)</span>上的任意一个范数，若对<span\r\nclass=\"math inline\">\\(\\forall A \\in R^{n \\times n}\\)</span>满足 <span\r\nclass=\"math display\">\\[\r\n\\|A\\| = max_{x \\ne 0} \\frac{\\|Ax\\|}{\\|x\\|} = max_{\\|x\\| = 1} \\|Ax\\|\r\n\\]</span> 则矩阵范数<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|\\)</span>称为从属于向量范数的矩阵范数。也叫由向量范数诱导出来的算子范数。</p>\r\n<p>算子范数肯定是满足矩阵范数的四条定义的，而且它还满足与向量的相容性！（证明网上一大堆略）</p>\r\n<p>另外，对于所有的矩阵算子范数，它们都是等价的。俩矩阵范数等价的定义如下：</p>\r\n<p>俩矩阵范数<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|_\\alpha\\)</span>与<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|_\\beta\\)</span>等价，当且仅当存在两个正数<span\r\nclass=\"math inline\">\\(d_1, d_2\\)</span>，使得对于任意矩阵A，都有<span\r\nclass=\"math inline\">\\(d_1\\|A\\|_\\beta \\le \\|A\\|_\\alpha \\le\r\nd_2\\|A\\|_\\beta\\)</span></p>\r\n<p>一般我们推导不常用范数的有界性时，先推容易算的范数的有界性，再用所有范数等价这条性质来放缩。</p>\r\n<h4 id=\"矩阵二范数谱范数\">3. 矩阵二范数（谱范数）</h4>\r\n<p>如果算子范数角标取2，就变成了谱范数： <span class=\"math display\">\\[\r\n\\|A\\|_2 = max_{x \\ne 0} \\frac{\\|Ax\\|_2}{\\|x\\|_2} = max_{\\|x\\|_2 = 1}\r\n\\|Ax\\|_2\r\n\\]</span>\r\n矩阵A的谱范数的实际意义是”矩阵A能将向量放大的最大倍数“。在数值上为矩阵A的最大奇异值（<span\r\nclass=\"math inline\">\\(\\sqrt{\\lambda_{max}(A^TA)}\\)</span>）。</p>\r\n<p>那为啥要叫谱范数呢？它跟谱半径又有什么关系呢？</p>\r\n<p>先回忆一下矩阵谱半径的定义：<span\r\nclass=\"math inline\">\\(\\rho(A)=\\max\\{|\\lambda|:\\lambda\\in\\lambda(A)\\}\\)</span></p>\r\n<p>当<span\r\nclass=\"math inline\">\\(A\\)</span>为对称矩阵时，其特征值的绝对值就是它的奇异值。所以有<span\r\nclass=\"math inline\">\\(\\rho(A) = \\sqrt{\\lambda_{max}(A^TA)} =\r\n\\|A\\|_2\\)</span></p>\r\n<p>这就是为什么矩阵二范数别称叫谱范数的原因hhhh。</p>\r\n<h4 id=\"几个与谱半径有关的定理\">4. 几个与谱半径有关的定理</h4>\r\n<h5 id=\"section\">4.1</h5>\r\n<p>定理：谱半径小于等于任意一种范数</p>\r\n<p>证明：设<span\r\nclass=\"math inline\">\\(\\lambda\\)</span>为A的特征值，则<span\r\nclass=\"math inline\">\\(A\\alpha =\r\n\\lambda\\alpha\\)</span>，两边同时取范数得<span\r\nclass=\"math inline\">\\(\\|A\\alpha\\| = \\|\\lambda\\alpha\\|\\)</span>。</p>\r\n<p>由于算子范数满足与向量的相容性和齐次性，所以有：<span\r\nclass=\"math inline\">\\(\\|A\\alpha\\| = |\\lambda|\\|\\alpha\\| \\le\r\n\\|\\alpha\\|\\|A\\|\\)</span></p>\r\n<p>同除<span class=\"math inline\">\\(\\|\\alpha\\|\\)</span>，得：<span\r\nclass=\"math inline\">\\(|\\lambda| \\le \\|A\\|\\)</span></p>\r\n<p>所以<span class=\"math inline\">\\(\\rho(A) = |\\lambda|_{max} \\le\r\n\\|A\\|\\)</span>，得证。</p>\r\n<h5 id=\"section-1\">4.2</h5>\r\n<p>定理：<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}A^k=0\\Leftrightarrow\\rho(A)&lt;1\\)</span></p>\r\n<p>充分性：因为<span class=\"math inline\">\\(\\rho(A) &lt;\r\n1\\)</span>，所以必然可以找到一个矩阵范数，s.t. <span\r\nclass=\"math inline\">\\(\\|A\\| &lt; 1\\)</span>。</p>\r\n<p>所以<span class=\"math inline\">\\(\\|A^k\\| \\le \\|A\\|^k\\)</span>，当<span\r\nclass=\"math inline\">\\(k \\rightarrow \\infty\\)</span>时，<span\r\nclass=\"math inline\">\\(\\|A^k\\| \\le \\|A\\|^k \\rightarrow 0\\)</span>。</p>\r\n<p>又因为矩阵范数满足正定性，所以<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}A^k=0\\)</span></p>\r\n<p>必要性（反证法）：假设<span class=\"math inline\">\\(\\rho(A) \\ge\r\n1\\)</span>，设<span class=\"math inline\">\\(\\lambda\\)</span>为满足<span\r\nclass=\"math inline\">\\(|\\lambda| \\ge 1\\)</span>的特征值，假设<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>为对应的特征向量，则有<span\r\nclass=\"math inline\">\\(A^k\\alpha = \\lambda^k\\alpha\\)</span></p>\r\n<p>两边取范数，得：<span\r\nclass=\"math inline\">\\(\\left\\|A^k\\alpha\\right\\|=\\left\\|\\lambda^k\\alpha\\right\\|=\\left|\\lambda^k\\right|\\left\\|\\alpha\\right\\|\\geq\\left\\|\\alpha\\right\\|\\)</span></p>\r\n<p>又因为<span\r\nclass=\"math inline\">\\(\\|A^k\\alpha\\|\\leq\\|A^k\\|\\|\\alpha\\|\\)</span></p>\r\n<p>所以<span class=\"math inline\">\\(\\|A^k\\|\\|\\alpha\\| \\ge\r\n\\|\\alpha\\|\\)</span></p>\r\n<p>同除，得：<span class=\"math inline\">\\(\\|A^k\\| \\ge 1\\)</span></p>\r\n<p>与<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}A^k=0\\)</span>矛盾，所以假设不成立，所以<span\r\nclass=\"math inline\">\\(\\rho(A) &lt; 1\\)</span>，得证。</p>\r\n<h5 id=\"section-2\">4.3</h5>\r\n<p>设<span class=\"math inline\">\\(A \\in R^{n \\times\r\nn}\\)</span>，则有：</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(\\sum_{k=0}^{\\infty}A^{k}\\)</span>收敛\r\n可推出 <span class=\"math inline\">\\(\\rho(A) &lt; 1\\)</span></p></li>\r\n<li><p>当<span\r\nclass=\"math inline\">\\(\\sum_{k=0}^{\\infty}A^{k}\\)</span>收敛时，它将收敛于：\r\n<span class=\"math display\">\\[\r\n\\sum_{k=0}^{\\infty}A^{k} = (I - A)^{-1}\r\n\\]</span> 而且存在一种算子范数<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|\\)</span>，使得 <span\r\nclass=\"math display\">\\[\r\n\\|(I-A)^{-1}-\\sum_{k=0}^mA^k\\|\\leq\\frac{\\|A\\|^{m+1}}{1-\\|A\\|}, m \\in\r\n\\mathbb{N}\r\n\\]</span></p></li>\r\n</ol>\r\n<p>证明：第一条很容易证明，当收敛时它的第无穷项肯定是收敛于0的，然后由4.2即可推出。</p>\r\n<p>下面证明第二条：</p>\r\n<p>因为<span class=\"math inline\">\\(\\rho(A) &lt; 1\\)</span>，所以<span\r\nclass=\"math inline\">\\(I - A\\)</span>的特征值<span\r\nclass=\"math inline\">\\(1 - \\lambda \\ne 0\\)</span>，因此<span\r\nclass=\"math inline\">\\(|I - A| \\ne 0\\)</span>，所以<span\r\nclass=\"math inline\">\\(I - A\\)</span>可逆。</p>\r\n<p>又因为<span\r\nclass=\"math inline\">\\((I-A)(I+A+\\ldots+A^k)=I-A^{k+1}\\)</span></p>\r\n<p>所以<span\r\nclass=\"math inline\">\\((I+A+\\ldots+A^k)=(I-A)^{-1}(I-A^{k+1})\\)</span></p>\r\n<p>又因为<span class=\"math inline\">\\(k \\rightarrow 0\\)</span>时，<span\r\nclass=\"math inline\">\\(A^{k+1} \\rightarrow 0\\)</span></p>\r\n<p>所以<span\r\nclass=\"math inline\">\\((I+A+\\ldots+A^k)=(I-A)^{-1}\\)</span></p>\r\n<p>即<span\r\nclass=\"math inline\">\\(\\sum_{k=0}^{\\infty}A^k=(I-A)^{-1}\\)</span></p>\r\n<h4 id=\"总结\">5. 总结</h4>\r\n<p>介绍了矩阵范数。重点讲解了矩阵二范数（谱范数）。以及介绍了与谱半径相关的定理。</p>\r\n<ol type=\"1\">\r\n<li>定理1是将谱半径与矩阵范数联系起来</li>\r\n<li>定理2讨论了矩阵阶乘收敛问题</li>\r\n<li>定理3讨论了矩阵阶乘数列之和收敛问题</li>\r\n</ol>\r\n","categories":["1. 科研","分布式"]},{"title":"线性代数2","url":"/2024/09/12/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/","content":"<p>正交向量/空间、对向量/空间投影、正交矩阵、正交化、行列式、特征值/特征向量、(特征值)对角化、马尔可夫矩阵/傅里叶级数</p>\r\n<span id=\"more\"></span>\r\n<hr />\r\n<h3 id=\"一.-正交向量与子空间\">一. 正交向量与子空间</h3>\r\n<p><img src=\"1.png\" /></p>\r\n<p>先来欣赏下这幅图，这幅图的意思就是对于矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>，其行空间<span\r\nclass=\"math inline\">\\(C(A^\\mathrm{T})\\)</span>与零空间<span\r\nclass=\"math inline\">\\(N(A)\\)</span>正交，其列空间<span\r\nclass=\"math inline\">\\(C(A)\\)</span>与左零空间<span\r\nclass=\"math inline\">\\(N(A^\\mathrm{T})\\)</span>正交。</p>\r\n<p>什么是向量正交？俩向量正交就是他们俩间夹角呈90度。如果判别俩向量正交？若<span\r\nclass=\"math inline\">\\(x^\\mathrm{T} \\cdot y =\r\n0\\)</span>，则x与y正交。</p>\r\n<p>上面那个公式如何推导的呢？</p>\r\n<p>首先思考如何描述一个向量的长度，假设有一个向量（1,2,3），那么它的长度显然是<span\r\nclass=\"math inline\">\\(\\sqrt{1^2 + 2^2 +\r\n3^2}\\)</span>对吧，用向量表示就是<span\r\nclass=\"math inline\">\\(\\sqrt{x^Tx}\\)</span>。</p>\r\n<p>好的，知道了如何表示向量长度又如何，假设我给你向量<span\r\nclass=\"math inline\">\\(x, y\\)</span>，你咋判断呢？</p>\r\n<p>首先思考下<span class=\"math inline\">\\(x +\r\ny\\)</span>是什么？很容易想到，可以把x和y看作三角形的两边，那么<span\r\nclass=\"math inline\">\\(x +\r\ny\\)</span>就是斜边。那么三条边都知道了，如果xy正交的话，那么就会有<span\r\nclass=\"math inline\">\\(x^\\mathrm{T}x + y^\\mathrm{T}y =\r\n(x+y)^\\mathrm{T}(x+y)\\)</span>,化简可得：<span\r\nclass=\"math inline\">\\(x^\\mathrm{T}x + y^\\mathrm{T}y = x^\\mathrm{T}x +\r\nx^\\mathrm{T}y + y^\\mathrm{T}x + y^\\mathrm{T}y\\)</span>，继续化简：<span\r\nclass=\"math inline\">\\(x^\\mathrm{T}y + y^\\mathrm{T}x =\r\n0\\)</span>，继续化简：<span\r\nclass=\"math inline\">\\(2x^\\mathrm{T}y=0\\)</span>，所以得到<span\r\nclass=\"math inline\">\\(x^\\mathrm{T}y = 0\\)</span>。</p>\r\n<hr />\r\n<p>向量正交很容易理解，但如果我说，俩子空间正交，又是什么意思呢？</p>\r\n<p>假设我有子空间<span class=\"math inline\">\\(S\\)</span>和<span\r\nclass=\"math inline\">\\(T\\)</span>，那么S和T正交，当且仅当S中的每个向量和T中的每个向量正交。</p>\r\n<p>ok，举个反直觉的实际例子：墙壁和地面正交吗？答案是否，因为墙壁和地面的交集边缝，边缝自己和自己不正交，所以不满足定义。</p>\r\n<p>所以需要注意的是，若两个空间正交，那么它们一定不会交于某个非零向量。</p>\r\n<p>所以在实际例子中，最常见的正交就是两条不重合的过原点且为90度的直线，它们是正交的。</p>\r\n<hr />\r\n<p>回到四个基本子空间，现在我要给出结论：行空间正交与零空间。</p>\r\n<p>为什么，看下面这幅图（Ax=0）：</p>\r\n<p><img src=\"2.png\" /></p>\r\n<p>可以发现，row1和x做点乘为0，row2和x做点乘为0，...\r\n...，所以x与所有行都正交。行空间可以表示为这些行的线性组合，即<span\r\nclass=\"math inline\">\\(k_1row_1 + k_2row_2 + ... +\r\nk_mrow_m\\)</span>，显然，做下点乘：<span class=\"math inline\">\\(x \\cdot\r\n(k_1row_1 + k_2row_2 + ... + k_mrow_m) =\r\n0\\)</span>，所以行空间与零空间正交。</p>\r\n<p>同样的，我们可以得出结论：列空间与左零空间正交。道理一样我就不证了。</p>\r\n<hr />\r\n<p>还有有趣的一点，实际上，行空间 + 零空间 = <span\r\nclass=\"math inline\">\\(\\mathbb{R}^n\\)</span>，列空间 + 左零空间 = <span\r\nclass=\"math inline\">\\(\\mathbb{R}^m\\)</span>。</p>\r\n<p>从上一节的公式就可以一窥究竟：<span class=\"math inline\">\\(dim(S) +\r\ndim(U) = dim(S + U) + dim(S \\cap U)\\)</span>。</p>\r\n<p>把行空间和零空间代入，秩分别为r和n - r，所以(行空间 +\r\n零空间)的维素就是n，而且行空间和零空间的分量个数都为n，所以(行空间 +\r\n零空间)就等于<span class=\"math inline\">\\(\\mathbb{R}^n\\)</span>。</p>\r\n<p>列空间 + 左零空间 = <span\r\nclass=\"math inline\">\\(\\mathbb{R}^m\\)</span>同理，我就不证了。</p>\r\n<p>为了定义这种现象，我们把行空间和零空间称为正交补的。即：行空间与零空间正交补，列空间与左零空间正交补。</p>\r\n<h3 id=\"二.-子空间投影\">二. 子空间投影</h3>\r\n<p>首先先从最简单的一个例子开始：</p>\r\n<p><img src=\"3.png\" /></p>\r\n<p>我们将向量b投影到向量a上，投影向量为p，误差向量为e。可以发现，p是a的某倍。所以问题的关键，就是在找到这个系数x。</p>\r\n<p>ok，由几何性质我们知道，向量e与a正交，所以：<span\r\nclass=\"math inline\">\\((b - xa)^\\mathrm{T}a = 0\\)</span>，整理可得：<span\r\nclass=\"math inline\">\\(b^\\mathrm{T}a =\r\nxa^\\mathrm{T}a\\)</span>，继续：<span class=\"math inline\">\\(x =\r\n\\frac{b^\\mathrm{T}a}{a^\\mathrm{T}a}\\)</span>。当然也可以写成：<span\r\nclass=\"math inline\">\\(x =\r\n\\frac{a^\\mathrm{T}b}{a^\\mathrm{T}a}\\)</span>。</p>\r\n<p>所以<span class=\"math inline\">\\(p = a \\cdot\r\n\\frac{a^\\mathrm{T}b}{a^\\mathrm{T}a}\\)</span>。</p>\r\n<p>ok上个这个小例子推出来的公式可以留个印象。现在我们进一步抽象化，把投影这个动作看作一种运算，也就是最好弄出一个投影矩阵P，然后b左乘一下这个投影矩阵Pb，就可以得到p，这是我们想要的。</p>\r\n<p>其实通过上面的公式就可看出，<span class=\"math inline\">\\(P =\r\n\\frac{aa^\\mathrm{T}}{a^\\mathrm{T}a}\\)</span>。非常优美的式子。</p>\r\n<p>我们来思考一下这个投影矩阵P的列空间。它的列空间是啥呢？</p>\r\n<p>考虑<span\r\nclass=\"math inline\">\\(Px\\)</span>，x可取任意向量，那么就相当于对P的列向量做任意线性组合，也就是生成了<span\r\nclass=\"math inline\">\\(C(P)\\)</span>。通过几何意义我们可以知道，<span\r\nclass=\"math inline\">\\(C(P)\\)</span>就是通过a的一条线，而且<span\r\nclass=\"math inline\">\\(r(P) = 1\\)</span>。</p>\r\n<p>这个投影矩阵<span\r\nclass=\"math inline\">\\(P\\)</span>还有一些好玩的性质，比如通过其公式，显然看出它是一个对称矩阵，所以<span\r\nclass=\"math inline\">\\(P^\\mathrm{T} = P\\)</span>。</p>\r\n<p>以及<span class=\"math inline\">\\(P^2 =\r\nP\\)</span>，为什么呢？前面我们说了<span\r\nclass=\"math inline\">\\(C(P)\\)</span>就是通过a的一条线，而且<span\r\nclass=\"math inline\">\\(r(P) = 1\\)</span>，说明<span\r\nclass=\"math inline\">\\(P\\)</span>的每一个列向量都在a那条直线上，所以<span\r\nclass=\"math inline\">\\(P \\cdot P\\)</span>相当于对<span\r\nclass=\"math inline\">\\(P\\)</span>的每一列做投影，那么通过几何性质，若一个向量本就在线上，投影之后位置仍不变，所以<span\r\nclass=\"math inline\">\\(P \\cdot P = P\\)</span>。</p>\r\n<p>总结一下：</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(x =\r\n\\frac{a^\\mathrm{T}b}{a^\\mathrm{T}a}\\)</span>，<span\r\nclass=\"math inline\">\\(p = ax = a \\cdot\r\n\\frac{a^\\mathrm{T}b}{a^\\mathrm{T}a}\\)</span></li>\r\n<li><span class=\"math inline\">\\(P =\r\n\\frac{aa^\\mathrm{T}}{a^\\mathrm{T}a}\\)</span>， <span\r\nclass=\"math inline\">\\(p = Pb\\)</span></li>\r\n<li><span class=\"math inline\">\\(C(p) = \\text{过a的线}\\)</span>， <span\r\nclass=\"math inline\">\\(r(P) = 1\\)</span></li>\r\n<li><span class=\"math inline\">\\(P^\\mathrm{T} = P\\)</span>，<span\r\nclass=\"math inline\">\\(P^2 = P\\)</span></li>\r\n</ol>\r\n<hr />\r\n<p>现在让我们进入更高维度的投影。</p>\r\n<p>先剧透一下，学这个可以解决什么问题呢？我们知道，Ax =\r\nb并不100%有解，有时候，我们在无解的情况下，就想找到最优近似解，也就是误差向量<span\r\nclass=\"math inline\">\\(e\\)</span>最小。</p>\r\n<p>怎么做呢？很自然的就联想到投影。因为此时b不在<span\r\nclass=\"math inline\">\\(C(A)\\)</span>上，所以我们就要将<span\r\nclass=\"math inline\">\\(b\\)</span>投影到<span\r\nclass=\"math inline\">\\(C(A)\\)</span>上，得到投影向量p。那么此时求解<span\r\nclass=\"math inline\">\\(A\\hat{x} = p\\)</span>，得到的<span\r\nclass=\"math inline\">\\(\\hat{x}\\)</span>就是最优近似解。</p>\r\n<p>很巧妙不是吗？这用到了向量对空间的投影。</p>\r\n<p>继续思考，我们要做的事情，就是找到一个x，使得b与(Ax)的误差向量e垂直C(A)。此时的x就是<span\r\nclass=\"math inline\">\\(\\hat{x}\\)</span>。</p>\r\n<p>把上面的语言转化为数学语言： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n    &amp;p = A\\hat{x} \\\\\r\n    &amp;e = b - p = b - (A\\hat{x}) \\\\\r\n    &amp;e^\\mathrm{T}A = 0\r\n\\end{align*}\r\n\\]</span> （<span class=\"math inline\">\\(e\\)</span>垂直与<span\r\nclass=\"math inline\">\\(C(A)\\)</span>与<span\r\nclass=\"math inline\">\\(e^\\mathrm{T}A=0\\)</span>等价，因为<span\r\nclass=\"math inline\">\\(C(A)\\)</span>可由列向量线组出来，所以只要<span\r\nclass=\"math inline\">\\(e\\)</span>垂直于<span\r\nclass=\"math inline\">\\(A\\)</span>的每一个列向量，那么<span\r\nclass=\"math inline\">\\(e\\)</span>就垂直于<span\r\nclass=\"math inline\">\\(C(A)\\)</span>）</p>\r\n<p>（上面的方程我们还可以发现一点有趣的事实，显然<span\r\nclass=\"math inline\">\\(e\\)</span>位于<span\r\nclass=\"math inline\">\\(A\\)</span>的左零空间内，而通过几何意义我们知道，<span\r\nclass=\"math inline\">\\(e\\)</span>与<span\r\nclass=\"math inline\">\\(C(A)\\)</span>正交。很巧的事情，<span\r\nclass=\"math inline\">\\(N(A^\\mathrm{T})\\)</span>与<span\r\nclass=\"math inline\">\\(C(A)\\)</span>正交。一切都对上了，是不是？）</p>\r\n<p>OK，整理上面的方程，可以得到：<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}A\\hat{x} =\r\nA^\\mathrm{T}b\\)</span>。</p>\r\n<p>如果<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}A\\)</span>是可逆的，那么直接乘它的可逆矩阵，即可求出<span\r\nclass=\"math inline\">\\(\\hat{x}\\)</span>。</p>\r\n<p>对应的投影向量为：<span class=\"math inline\">\\(p = A \\cdot\r\n(A^\\mathrm{T}A)^{-1} \\cdot A^\\mathrm{T}b\\)</span></p>\r\n<p>对应的投影矩阵为：<span class=\"math inline\">\\(P = A \\cdot\r\n(A^\\mathrm{T}A)^{-1} \\cdot A^\\mathrm{T}\\)</span></p>\r\n<p>生成投影向量的线组系数：<span class=\"math inline\">\\(\\hat{x} =\r\n(A^\\mathrm{T}A)^{-1} \\cdot A^\\mathrm{T}b\\)</span></p>\r\n<p>类比上面的向量对向量投影的公式，是不是形式一样？只需把<span\r\nclass=\"math inline\">\\(a\\)</span>换为<span\r\nclass=\"math inline\">\\(A\\)</span>，分号改为逆就好啦？美妙的公式。</p>\r\n<p>同理，此时的投影矩阵<span\r\nclass=\"math inline\">\\(P\\)</span>同样满足：<span\r\nclass=\"math inline\">\\(P^\\mathrm{T} = P\\)</span>，<span\r\nclass=\"math inline\">\\(P^2 = P\\)</span></p>\r\n<hr />\r\n<p>ok，让我们讨论剩下的一点细节，前面我们是把<span\r\nclass=\"math inline\">\\(b\\)</span>投影到<span\r\nclass=\"math inline\">\\(C(A)\\)</span>中。那如果我想把<span\r\nclass=\"math inline\">\\(b\\)</span>投到与<span\r\nclass=\"math inline\">\\(C(A)\\)</span>正交的空间，也就是<span\r\nclass=\"math inline\">\\(N(A^\\mathrm{T})\\)</span>呢？显然，通过几何意义可以看出，答案就是<span\r\nclass=\"math inline\">\\(e\\)</span>，即<span class=\"math inline\">\\(b -\r\np\\)</span>。</p>\r\n<p>所以投影到<span\r\nclass=\"math inline\">\\(N(A^\\mathrm{T})\\)</span>就是：<span\r\nclass=\"math inline\">\\(b - p = b - Pb = (I -\r\nP)b\\)</span>。所以对应的投影矩阵就是<span class=\"math inline\">\\(I -\r\nP\\)</span>。同样的，<span\r\nclass=\"math inline\">\\(P\\)</span>满足的性质，<span\r\nclass=\"math inline\">\\(I - P\\)</span>也都满足。</p>\r\n<p>以及，前面提到，必须<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}A\\)</span>是可逆矩阵，才能解出<span\r\nclass=\"math inline\">\\(\\hat{x}\\)</span>。但是，如何判断它可逆呢？有一个判断方法：若<span\r\nclass=\"math inline\">\\(A\\)</span>的各列线性无关，那么<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}A\\)</span>就是可逆矩阵。下面来证明一下：</p>\r\n<blockquote>\r\n<p>假设<span class=\"math inline\">\\(A\\)</span>的各列线性无关。</p>\r\n<p>考虑方程<span class=\"math inline\">\\(A^\\mathrm{T}Ax = 0\\)</span></p>\r\n<p>两边同乘<span class=\"math inline\">\\(x^\\mathrm{T}\\)</span>，得：<span\r\nclass=\"math inline\">\\(x^\\mathrm{T}A^\\mathrm{T}Ax = 0\\)</span></p>\r\n<p>整理：<span class=\"math inline\">\\((Ax)^\\mathrm{T}(Ax)=0\\)</span></p>\r\n<p>所以说嘛向量<span\r\nclass=\"math inline\">\\((Ax)\\)</span>长度为0，也就是它为零向量，所以：<span\r\nclass=\"math inline\">\\(Ax=0\\)</span></p>\r\n<p>因为<span class=\"math inline\">\\(A\\)</span>的各列线性无关，所以<span\r\nclass=\"math inline\">\\(dim(N(A)) = 0\\)</span>，所以<span\r\nclass=\"math inline\">\\(x\\)</span>只能去零向量。</p>\r\n<p>所以对于方程<span class=\"math inline\">\\(A^\\mathrm{T}Ax =\r\n0\\)</span>，<span class=\"math inline\">\\(x\\)</span>只能取零向量。</p>\r\n<p>而只有当<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}A\\)</span>可逆的时候，上面的方程才只有零解。证毕。</p>\r\n</blockquote>\r\n<hr />\r\n<p>最后，让我们举一个用投影来解决的实际例子：最小二乘。</p>\r\n<p>平面上有n个点，要找到一条直线，尽可能的拟合这些点，怎么办？</p>\r\n<p>假设有这么一条理想直线：y = kx + b，可以拟合所有点，那么就会有方程：\r\n<span class=\"math display\">\\[\r\n\\begin{align*}\r\n    kx_1 + b &amp;= y_1 \\\\\r\n    kx_2 + b &amp;= y_2 \\\\\r\n    ... \\\\\r\n    kx_n + b &amp;= y_n\r\n\\end{align*}\r\n\\]</span> 我们要求k和b，所以把k和b看为未知数。</p>\r\n<p>那么即可建模为<span class=\"math inline\">\\(Ax=b\\)</span>，<span\r\nclass=\"math inline\">\\(A = \\begin{bmatrix} x_1 &amp; 1 \\\\ x_2 &amp; 1 \\\\\r\n... &amp; ... \\\\ x_n &amp; 1 \\end{bmatrix}\\)</span>，<span\r\nclass=\"math inline\">\\(x = \\begin{bmatrix} k \\\\ b\r\n\\end{bmatrix}\\)</span>，<span class=\"math inline\">\\(b = \\begin{bmatrix}\r\ny_1 \\\\ y_2 \\\\ ... \\\\ y_n \\end{bmatrix}\\)</span></p>\r\n<p>这个方程大概率是无解的，因为不存在这么一条完美直线，所以就把<span\r\nclass=\"math inline\">\\(b\\)</span>投影到<span\r\nclass=\"math inline\">\\(C(A)\\)</span>即可。</p>\r\n<p>巧妙的建模，相信你再一次感受到线代的魅力了！</p>\r\n<ul>\r\n<li>总结一下：\r\n<ul>\r\n<li>一维（向量b投影到向量a）：\r\n<ul>\r\n<li><span class=\"math inline\">\\(P =\r\n\\frac{aa^\\mathrm{T}}{a^\\mathrm{T}a}\\)</span>，<span\r\nclass=\"math inline\">\\(p = Pb\\)</span></li>\r\n</ul></li>\r\n<li>高维（向量b投影到空间C(A)）：\r\n<ul>\r\n<li><span class=\"math inline\">\\(P = A \\cdot (A^\\mathrm{T}A)^{-1} \\cdot\r\nA^\\mathrm{T}\\)</span></li>\r\n<li><span class=\"math inline\">\\(p = A \\cdot (A^\\mathrm{T}A)^{-1} \\cdot\r\nA^\\mathrm{T}b\\)</span></li>\r\n</ul></li>\r\n<li>判断对称矩阵<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}A\\)</span>是否可逆的方法：看<span\r\nclass=\"math inline\">\\(A\\)</span>的各列是否线性无关</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"三.-正交矩阵-schmidt正交化\">三. 正交矩阵, Schmidt正交化</h3>\r\n<p>在这一节里，我们用<span\r\nclass=\"math inline\">\\(Q\\)</span>来代表列向量全是正交且标准（长度为1）的矩阵。</p>\r\n<p>显然，这个<span class=\"math inline\">\\(Q\\)</span>满足下列定义：<span\r\nclass=\"math inline\">\\(q_{i}^{T}q_{j}=\\begin{cases}0&amp;,i\\neq\r\nj\\\\1&amp;,i=j\\end{cases}\\)</span></p>\r\n<p>讨论一下，<span\r\nclass=\"math inline\">\\(Q^\\mathrm{T}Q\\)</span>是什么？<span\r\nclass=\"math inline\">\\(Q = \\begin{bmatrix} q_1, q_2, ..., q_n\r\n\\end{bmatrix}\\)</span>，<span class=\"math inline\">\\(Q^\\mathrm{T} =\r\n\\begin{bmatrix} q_1^\\mathrm{T} \\\\ q_2^\\mathrm{T} \\\\ ... \\\\\r\nq_n^\\mathrm{T} \\end{bmatrix}\\)</span>。</p>\r\n<p>显然，<span class=\"math inline\">\\(Q^\\mathrm{T}Q = I\\)</span>。</p>\r\n<p>下面，我们对“正交矩阵”这个名词下一个定义：首先得是方阵，其次列向量都是互相正交且单位的。这样的矩阵就叫正交矩阵。</p>\r\n<p>（注意，本节的<span\r\nclass=\"math inline\">\\(Q\\)</span>不一定是方阵，若无特殊说明，是不是方阵都有可能）</p>\r\n<p>ok，让我们现在讨论一下正交矩阵的性质。</p>\r\n<p>正交矩阵也满足<span class=\"math inline\">\\(Q^\\mathrm{T}Q =\r\nI\\)</span>，而且因为为方阵，所以<span\r\nclass=\"math inline\">\\(Q\\)</span>有逆矩阵。所以可以推出<span\r\nclass=\"math inline\">\\(Q^\\mathrm{T} = Q^{-1}\\)</span>。</p>\r\n<p>OK，让我们思考一下正交矩阵的投影矩阵：<span class=\"math inline\">\\(P =\r\nQ(Q^\\mathrm{T}Q)^{-1}Q^\\mathrm{T} =\r\nQQ^\\mathrm{T}\\)</span>。因为是正交矩阵，所以<span\r\nclass=\"math inline\">\\(Q^\\mathrm{T} = Q^{-1}\\)</span>，所以<span\r\nclass=\"math inline\">\\(P =\r\nI\\)</span>，即正交矩阵的投影矩阵就是单位阵。如果<span\r\nclass=\"math inline\">\\(Q\\)</span>不是方阵的话，那么其投影矩阵就是<span\r\nclass=\"math inline\">\\(QQ^\\mathrm{T}\\)</span>。当然了，它们的投影矩阵都是满足那俩性质的：</p>\r\n<ol type=\"1\">\r\n<li>是对称矩阵</li>\r\n<li><span class=\"math inline\">\\(P^2 = P\\)</span></li>\r\n</ol>\r\n<hr />\r\n<p>正交且标准的性质是很好的，所以我们如何把一个虽然列向量互相线性无关（但是不正交）的矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>，转化为列向量互相正交且标准的矩阵<span\r\nclass=\"math inline\">\\(Q\\)</span>呢？下面来介绍格拉姆-施密特正交法：</p>\r\n<p>思考现在有向量<span class=\"math inline\">\\(a, b,\r\nc\\)</span>，它们互相线性无关，但是不正交，如果把它们转换为一组正交的呢？</p>\r\n<p>首先把<span\r\nclass=\"math inline\">\\(a\\)</span>单位化然后锁死，然后对于<span\r\nclass=\"math inline\">\\(b\\)</span>，<span\r\nclass=\"math inline\">\\(b\\)</span>减去<span\r\nclass=\"math inline\">\\(b\\)</span>在<span\r\nclass=\"math inline\">\\(a\\)</span>上的投影（也就是误差向量<span\r\nclass=\"math inline\">\\(e\\)</span>）就是我们想要的，所以<span\r\nclass=\"math inline\">\\(b&#39; = b - p = b - Pb = b -\r\n\\frac{aa^\\mathrm{T}}{a^\\mathrm{T}a}\\cdot\r\nb\\)</span>，然后单位化，锁死。</p>\r\n<p>然后对于<span class=\"math inline\">\\(c\\)</span>，先把在<span\r\nclass=\"math inline\">\\(a\\)</span>上的投影减掉，再把在更新后的<span\r\nclass=\"math inline\">\\(b\\)</span>上的投影减掉，就得到了正交于<span\r\nclass=\"math inline\">\\(a, b\\)</span>的向量：<span\r\nclass=\"math inline\">\\(c&#39; = c - p_a - p_b = c -\r\n\\frac{aa^\\mathrm{T}}{a^\\mathrm{T}a} \\cdot c -\r\n\\frac{bb^\\mathrm{T}}{b^\\mathrm{T}b} \\cdot\r\nc\\)</span>，然后单位化，锁死。</p>\r\n<p>其余的向量以此类推。</p>\r\n<p>很好，现在你学会了如何将一组虽然线性无关但是不是正交的向量转化为正交的向量组，恭喜。</p>\r\n<p>但是我要提个问题，转化前的矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>和转化后的矩阵<span\r\nclass=\"math inline\">\\(Q\\)</span>，它们的列空间一样吗？</p>\r\n<p>答案是肯定的，因为考虑我们转化的过程，例如<span\r\nclass=\"math inline\">\\(c = c - p_a - p_b\\)</span>，<span\r\nclass=\"math inline\">\\(p_a\\)</span>是<span\r\nclass=\"math inline\">\\(a\\)</span>的缩放，<span\r\nclass=\"math inline\">\\(p_b\\)</span>是<span\r\nclass=\"math inline\">\\(b\\)</span>的缩放，所以其实我们在正交化的过程中，仍然是用原向量组做线性组合（即列变换），所以转换后的矩阵，其列空间一样<span\r\nclass=\"math inline\">\\(C(Q)\\)</span>=<span\r\nclass=\"math inline\">\\(C(A)\\)</span>，零空间一样<span\r\nclass=\"math inline\">\\(N(Q) = N(A)\\)</span>。</p>\r\n<hr />\r\n<p>截止，你已经知道了正交的概念，也认识到了正交矩阵以及一些性质。甚至你还学会了如何将一组线性无关向量组转化为标准正交的向量组。</p>\r\n<p>但是，知道这些，有什么用呢？</p>\r\n<p>目前我知道的是，可以讲一个各列线性无关的矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>进行<span\r\nclass=\"math inline\">\\(QR\\)</span>分解：<span class=\"math inline\">\\(A =\r\nQR\\)</span>。<span\r\nclass=\"math inline\">\\(Q\\)</span>表示各列互相标准正交的向量，<span\r\nclass=\"math inline\">\\(R\\)</span>是一个上三角矩阵。</p>\r\n<p>为啥<span\r\nclass=\"math inline\">\\(R\\)</span>是一个上三角矩阵呢？我来证明一下：</p>\r\n<p>在正交化的过程中，对于<span\r\nclass=\"math inline\">\\(a_i\\)</span>，它依赖了<span\r\nclass=\"math inline\">\\(q_1, q_2, \\cdots, q_{i-1},\r\na_i\\)</span>，线组出了<span\r\nclass=\"math inline\">\\(q_i\\)</span>。所以，如果我有<span\r\nclass=\"math inline\">\\(q_1, q_2, \\cdots,\r\nq_i\\)</span>，那我就可线组出<span\r\nclass=\"math inline\">\\(a_i\\)</span>。所以对于<span\r\nclass=\"math inline\">\\(A = QR\\)</span>，<span\r\nclass=\"math inline\">\\(R\\)</span>就是线组的系数。而且可发现想线组出<span\r\nclass=\"math inline\">\\(a_i\\)</span>只需用到<span class=\"math inline\">\\(1\r\n\\sim i\\)</span>的<span class=\"math inline\">\\(q\\)</span>，所以<span\r\nclass=\"math inline\">\\(R\\)</span>自然就是一个上三角的了。</p>\r\n<h3 id=\"四.-行列式及其性质\">四. 行列式及其性质</h3>\r\n<p>行列式是方阵独属的浪漫，通常记为<span\r\nclass=\"math inline\">\\(det(A)\\)</span>或者<span\r\nclass=\"math inline\">\\(|A|\\)</span>。</p>\r\n<p>行列式这里性质特别多，可能需要一些记忆：</p>\r\n<ol type=\"1\">\r\n<li><p>单位阵的行列式为1</p></li>\r\n<li><p>交换两行，行列式符号会取反</p></li>\r\n<li><p><span class=\"math inline\">\\(\\begin{vmatrix}  ta &amp; tb \\\\  c\r\n&amp; d  \\end{vmatrix} = t\\begin{vmatrix}  a &amp; b \\\\  c &amp;\r\nd  \\end{vmatrix}\\)</span></p></li>\r\n<li><p><span class=\"math inline\">\\(\\begin{vmatrix}  a+a&#39; &amp;\r\nb+b&#39; \\\\  c &amp; d  \\end{vmatrix} = \\begin{vmatrix}  a &amp; b \\\\  c\r\n&amp; d  \\end{vmatrix} + \\begin{vmatrix}  a&#39; &amp; b&#39; \\\\  c\r\n&amp; d  \\end{vmatrix}\\)</span></p></li>\r\n<li><p>若有两行相等，则行列式为0</p></li>\r\n<li><p>行j减去行i的k倍，行列式不变</p></li>\r\n<li><p>如果有一行为0，那么行列式为0</p></li>\r\n<li><p>对于上三角方阵，其行列式为对角线元素乘积</p></li>\r\n<li><p><span class=\"math inline\">\\(det(A)=0 \\iff\\)</span> 矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>是奇异矩阵（奇异矩阵就是不满秩的方阵）</p></li>\r\n<li><p><span class=\"math inline\">\\(det(AB) = det(A) \\cdot\r\ndet(B)\\)</span></p></li>\r\n<li><p><span class=\"math inline\">\\(det(A^\\mathrm{T}) =\r\ndet(A)\\)</span></p>\r\n<ul>\r\n<li>有了这条性质，那么上面描述行的性质，同样可以描述列，例如：</li>\r\n<li>交换两列，行列式符号取反</li>\r\n<li>除了行有线性关系（性质3、4），列也具有</li>\r\n<li>若有两列相等，则行列式为0</li>\r\n<li>如果有一列为0，那么行列式为0</li>\r\n</ul></li>\r\n</ol>\r\n<p>所以如何求一个方阵的行列式？通常就是将其消元成上三角矩阵（注意过程中行交换会导致行列式符号取反），然后对角线相乘即可。</p>\r\n<hr />\r\n<p>行列式公式1：<span class=\"math inline\">\\(det(A) = \\sum (-1)^{r(k_1,\r\nk_2, k_3, ..., k_n)}a_{1k_1}a_{2k_2}a_{3k_3}...a_{nk_n}\\)</span></p>\r\n<p>​ <span class=\"math inline\">\\(r(k_1, k_2, ...,\r\nk_n)\\)</span>是排列的逆序数。</p>\r\n<p>代数余子式：位置(i, j)的代数余子式<span class=\"math inline\">\\(A_{ij}\r\n:= (-1)^{i+j}det(\\text{去掉第i行和第j列得到的矩阵})\\)</span></p>\r\n<p>行列式公式2：<span class=\"math inline\">\\(det(A) = a_{11}C_{11} +\r\na_{12}C_{12} + \\cdots + a_{1n}C_{1n}\\)</span></p>\r\n<h3 id=\"五.-克拉默法则-体积\">五. 克拉默法则, 体积</h3>\r\n<p>设<span class=\"math inline\">\\(A_{ij}\\)</span>是位置(i,\r\nj)的代数余子式，则矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>的伴随矩阵定义如下： <span\r\nclass=\"math display\">\\[\r\nA^* = \\begin{bmatrix}\r\nA_{11} &amp; A_{21} &amp; \\cdots &amp; A_{n1} \\\\\r\nA_{12} &amp; A_{22} &amp; \\cdots &amp; A_{n2} \\\\\r\n\\cdots \\\\\r\nA_{1n} &amp; A_{2n} &amp; \\cdots &amp; A_{nn}\r\n\\end{bmatrix}\r\n\\]</span> 它满足一个公式，通过代数法求逆：<span\r\nclass=\"math inline\">\\(A^{-1} = \\frac{A^*}{det(A)}\\)</span></p>\r\n<p>那么对于非奇异矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>，它的方程：<span\r\nclass=\"math inline\">\\(Ax=b\\)</span>就有一种新的解法。</p>\r\n<p><span class=\"math inline\">\\(x = A^{-1}b =\r\n\\frac{A^*b}{det(A)}\\)</span></p>\r\n<p>所以可得到以下式子： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n    x_1 &amp;= \\frac{det(\\text{把A的第一列换为b})}{det(A)} \\\\\r\n    x_2 &amp;= \\frac{det(\\text{把A的第二列换为b})}{det(A)} \\\\\r\n    \\cdots \\\\\r\n    x_n &amp;= \\frac{det(\\text{把A的第n列换为b})}{det(A)}\r\n\\end{align*}\r\n\\]</span>\r\n上面就是克拉默法则，用代数的方程解方程。但是我觉得，中看不中用，不如直接用矩阵的方程去解方程组。</p>\r\n<hr />\r\n<p>给出一个有意思的定理：行列式的绝对值其实是在计算“箱子”的体积。</p>\r\n<p>我举个例子，比如有矩阵<span class=\"math inline\">\\(A = \\begin{bmatrix}\r\na_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\\r\na_{31} &amp; a_{32} &amp; a_{33} \\end{bmatrix}\\)</span></p>\r\n<p>那么<span class=\"math inline\">\\(|det(A)|\\)</span>等于以<span\r\nclass=\"math inline\">\\((a_{11}, a_{12}, a_{13})\\)</span>，<span\r\nclass=\"math inline\">\\((a_{21}, a_{22}, a_{23})\\)</span>、<span\r\nclass=\"math inline\">\\((a_{31}, a_{32},\r\na_{33})\\)</span>为三边所形成的箱子的体积。</p>\r\n<p>同理，对于<span class=\"math inline\">\\(n \\times\r\nn\\)</span>的矩阵同样成立。</p>\r\n<h3 id=\"六.-特征值-特征向量\">六. 特征值, 特征向量</h3>\r\n<p>特征值是方阵独属的浪漫。</p>\r\n<p>首先来讲特征向量，矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>的特征向量就是那些进过<span\r\nclass=\"math inline\">\\(A\\)</span>线性变换后方向不改变的向量。用数学语言表达就是：<span\r\nclass=\"math inline\">\\(Ax = \\lambda x\\)</span>。满足上述方程的<span\r\nclass=\"math inline\">\\(x\\)</span>就是特征向量，<span\r\nclass=\"math inline\">\\(\\lambda\\)</span>就是特征值。</p>\r\n<p>对于特征值0，它对应的特征向量应满足<span\r\nclass=\"math inline\">\\(Ax=0\\)</span>，所以特征值0所对应的特征向量其实就是<span\r\nclass=\"math inline\">\\(N(A)\\)</span>。</p>\r\n<p>举点例子吧，考虑投影矩阵<span\r\nclass=\"math inline\">\\(P\\)</span>。对于那些本身就已经在投影面上的向量<span\r\nclass=\"math inline\">\\(x\\)</span>，满足<span class=\"math inline\">\\(Px =\r\nx\\)</span>，所以<span\r\nclass=\"math inline\">\\(P\\)</span>特征值为1的特征向量就是投影面上的向量。对于那些垂直于投影面的向量<span\r\nclass=\"math inline\">\\(x\\)</span>，满足<span class=\"math inline\">\\(Px =\r\n0\\)</span>，所以<span\r\nclass=\"math inline\">\\(P\\)</span>特征值为0的特征向量就是垂直于投影面的那些向量。</p>\r\n<p>ok，我提前透露几个特征值的性质：</p>\r\n<ol type=\"1\">\r\n<li>n阶方阵有n个特征值</li>\r\n<li>n个特征值的和加起来等于方阵对角线之和</li>\r\n<li>n个特征值的乘积等于方阵的特征值</li>\r\n<li>上三角方阵的特征值就是对角线上的元素</li>\r\n<li><span class=\"math inline\">\\(A\\)</span>的特征值等于<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}\\)</span>的特征值</li>\r\n<li><span class=\"math inline\">\\(A^{-1}\\)</span>的特征值等于<span\r\nclass=\"math inline\">\\(A\\)</span>的特征值取倒数</li>\r\n</ol>\r\n<hr />\r\n<p>好，那给你一个矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>，如何求出其特征值和对应的特征向量呢？</p>\r\n<p>很简单，首先列出定义：<span class=\"math inline\">\\(Ax = \\lambda\r\nx\\)</span>，移项：<span class=\"math inline\">\\((A - \\lambda I)x =\r\n0\\)</span>。要使这个方程有非零解，<span class=\"math inline\">\\((A -\r\n\\lambda I)\\)</span>要是奇异矩阵，也就是不满秩，也就是<span\r\nclass=\"math inline\">\\(|A - \\lambda I| = 0\\)</span>。</p>\r\n<p>解上面那个行列式，即可求出所有的特征值<span\r\nclass=\"math inline\">\\(\\lambda\\)</span>（n个特征值可能有重复）。</p>\r\n<p>然后反代回去，即可求出特征值对应的特征向量。</p>\r\n<h3 id=\"七.-对角化-a的幂\">七. 对角化, A的幂</h3>\r\n<p>上一节我们学会了如何求一个矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>的特征值和对应的特征向量。这一节我们来利用特征向量来分解矩阵。</p>\r\n<p>假设我们有一个矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>，它有n个线性无关的特征向量。那么我把这些向量排成一排得到矩阵<span\r\nclass=\"math inline\">\\(S\\)</span>，叫做特征向量矩阵。然后推导下面式子：</p>\r\n<p><span class=\"math inline\">\\(AS = A \\cdot \\begin{bmatrix} \\beta_1\r\n&amp; \\beta_2 \\cdots \\beta_n \\end{bmatrix} = \\begin{bmatrix}\r\n\\lambda_1\\beta_1 &amp; \\lambda_2\\beta_2 &amp; \\cdots &amp;\r\n\\lambda_n\\beta_n \\end{bmatrix} = \\begin{bmatrix} \\beta_1 &amp; \\beta_2\r\n&amp; \\cdots &amp; \\beta_n \\end{bmatrix}\\begin{bmatrix} \\lambda_1 &amp;\r\n&amp; &amp; &amp; \\\\ &amp; \\lambda_2 &amp; &amp; &amp; &amp; \\\\ &amp;\r\n&amp; \\lambda_3 &amp; &amp; \\\\ &amp; &amp; &amp; &amp; \\cdots\r\n\\end{bmatrix}\\)</span></p>\r\n<p>即：<span class=\"math inline\">\\(AS =S\\Lambda\\)</span>，<span\r\nclass=\"math inline\">\\(\\Lambda\\)</span>为用特征值生成的对角阵，也叫特征值矩阵</p>\r\n<p>进一步化简，得到： <span class=\"math display\">\\[\r\n\\Lambda = S^{-1}AS \\\\\r\nA = S\\Lambda S^{-1}\r\n\\]</span>\r\n这种对角化分解有什么用呢？答案：在处理矩阵的幂的时候非常有用</p>\r\n<p>首先来看一下<span class=\"math inline\">\\(A^2\\)</span>：<span\r\nclass=\"math inline\">\\(A^2 = S\\Lambda S^{-1} \\cdot S\\Lambda S^{-1} =\r\nS\\Lambda^2 S^{-1}\\)</span></p>\r\n<p>可以发现，<span class=\"math inline\">\\(A^2\\)</span>的特征值就是<span\r\nclass=\"math inline\">\\(A\\)</span>特征值的平方，<span\r\nclass=\"math inline\">\\(A^2\\)</span>的特征向量与<span\r\nclass=\"math inline\">\\(A\\)</span>一样。</p>\r\n<p>同理，<span class=\"math inline\">\\(A^k\\)</span>的特征值就是<span\r\nclass=\"math inline\">\\(A\\)</span>特征值的<span\r\nclass=\"math inline\">\\(k\\)</span>次方，<span\r\nclass=\"math inline\">\\(A^k\\)</span>的特征向量与<span\r\nclass=\"math inline\">\\(A\\)</span>一样。</p>\r\n<p>来个好玩的问题，当<span\r\nclass=\"math inline\">\\(A\\)</span>的特征值满足什么条件时，<span\r\nclass=\"math inline\">\\(A^k = O, k \\to \\infty\\)</span>？</p>\r\n<p>通过上面的公式，可得<span class=\"math inline\">\\(A^k =\r\nS\\Lambda^kS^{-1}\\)</span>，显然<span\r\nclass=\"math inline\">\\(S\\)</span>是固定的，所以关键就是看<span\r\nclass=\"math inline\">\\(\\Lambda\\)</span>。很容易想到，如果<span\r\nclass=\"math inline\">\\(A\\)</span>的所有特征值满足<span\r\nclass=\"math inline\">\\(|\\lambda_i| &lt; 1\\)</span>的话，那么矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>会收敛到零矩阵。</p>\r\n<p>（<strong>上面对角化分解非常有用，但需要注意分解的前提是<span\r\nclass=\"math inline\">\\(A\\)</span>有n个线性无关的特征向量。如何判断呢？这里给出一个定理：如果<span\r\nclass=\"math inline\">\\(A\\)</span>有n个互不相同的特征值，那么<span\r\nclass=\"math inline\">\\(A\\)</span>就有n个线性无关的特征向量；否则则不一定。</strong>）</p>\r\n<hr />\r\n<p>先介绍一阶差分方程，即：<span class=\"math inline\">\\(u_{k+1} =\r\nAu_k\\)</span>。（我们考虑理想的情况，即认为<span\r\nclass=\"math inline\">\\(A\\)</span>有n个互不相同的特征值。）</p>\r\n<p>那么可推出：<span class=\"math inline\">\\(u_k = A^ku_0\\)</span></p>\r\n<p>因为<span\r\nclass=\"math inline\">\\(A\\)</span>的各特征向量线性无关，所以<span\r\nclass=\"math inline\">\\(\\mathbb{R}^n\\)</span>可用特征向量线组出来，<span\r\nclass=\"math inline\">\\(u_0\\)</span>同样可以用特征向量线组出来，设线组的系数为<span\r\nclass=\"math inline\">\\(c\\)</span>列向量，那么<span\r\nclass=\"math inline\">\\(u_0\\)</span>可表示为<span\r\nclass=\"math inline\">\\(Sc\\)</span>。</p>\r\n<p>所以<span class=\"math inline\">\\(u_k = S\\Lambda^kS^{-1} \\cdot Sc =\r\nS\\Lambda^kc\\)</span>。</p>\r\n<p>下面我们来一道经典的例题，现有斐波拉契数列：0, 1, 1, 2, 3, 5, 8, ...\r\n...。试用矩阵求斐波拉契数列，并分析其增长速度。</p>\r\n<p>首先可写出递推式：<span class=\"math inline\">\\(F_{k+2} = F_{k+1} +\r\nF_k\\)</span>。可以发现这是一个二阶的差分方程，我们想把其转为前面的知识转为一阶的，所以我使用一个trick，就是再加入一个方程，然后引入新变量去表达方程组，使其变为一阶差分方程，具体如下：\r\n<span class=\"math display\">\\[\r\n\\begin{cases}\r\nF_{k+2} = F_{k+1} + F_k \\\\\r\nF_{k+1} = F_{k+1}\r\n\\end{cases}\r\n\\]</span> 设<span class=\"math inline\">\\(u_k = \\begin{bmatrix}F_{k+1} \\\\\r\nF_k\\end{bmatrix}\\)</span>，所以上述方程组可表达为一个一阶差分方程：<span\r\nclass=\"math inline\">\\(u_{k+1} = \\begin{bmatrix}1 &amp; 1 \\\\ 1 &amp;\r\n0\\end{bmatrix}u_k\\)</span>。</p>\r\n<p>好，先来看看矩阵<span class=\"math inline\">\\(A = \\begin{bmatrix}1\r\n&amp; 1 \\\\ 1 &amp; 0\\end{bmatrix}\\)</span>是否可对角化，有<span\r\nclass=\"math inline\">\\(\\begin{cases} \\lambda_1 + \\lambda_2 = 1 \\\\\r\n\\lambda_1 \\cdot \\lambda_2 = -1 \\end{cases}\\)</span>，解得：<span\r\nclass=\"math inline\">\\(\\begin{cases} \\lambda_1 = \\frac12(1 + \\sqrt{5})\r\n\\approx 1.618 \\\\ \\lambda_2 = \\frac12(1 - \\sqrt{5}) \\approx -0.618\r\n\\end{cases}\\)</span></p>\r\n<p>有俩不同特征值，由前面的判定定理可知，<span\r\nclass=\"math inline\">\\(A\\)</span>可对角化，那么可求出其特征向量矩阵<span\r\nclass=\"math inline\">\\(S = \\begin{bmatrix} \\lambda_1 &amp; \\lambda_2 \\\\ 1\r\n&amp; 1 \\end{bmatrix}\\)</span>。</p>\r\n<p>由前面的公式可知：<span class=\"math inline\">\\(u_k =\r\nS\\Lambda^kc\\)</span>。在这里，<span\r\nclass=\"math inline\">\\(c\\)</span>是用特征向量表示出<span\r\nclass=\"math inline\">\\(\\begin{bmatrix} F_1 \\\\ F_0\r\n\\end{bmatrix}\\)</span>的系数列向量。让我求一下：<span\r\nclass=\"math inline\">\\(u_0 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} =\r\nc_1\\begin{bmatrix} \\lambda_1 \\\\ 1 \\end{bmatrix} + c_2\\begin{bmatrix}\r\n\\lambda_2 \\\\ 1 \\end{bmatrix}\\)</span>，这里就不解了。</p>\r\n<p>所以现在<span class=\"math inline\">\\(S, \\Lambda,\r\nc\\)</span>都有了，那么<span\r\nclass=\"math inline\">\\(u_k\\)</span>就可求出来了，即<span\r\nclass=\"math inline\">\\(F_k\\)</span>就可求出来了。</p>\r\n<p>但是这个一阶差分方程的增长速度我们还没分析，其实观察<span\r\nclass=\"math inline\">\\(u_k =\r\nS\\Lambda^kc\\)</span>就可知道，增长速度由特征值决定，若<span\r\nclass=\"math inline\">\\(|\\lambda_i| &lt; 1\\)</span>，那么<span\r\nclass=\"math inline\">\\(u_k\\)</span>直接会收俩到0。</p>\r\n<p>对于那些<span class=\"math inline\">\\(|\\lambda_i| &gt;\r\n1\\)</span>的，越大的<span\r\nclass=\"math inline\">\\(|\\lambda_i|\\)</span>，只要对应的<span\r\nclass=\"math inline\">\\(c_i \\ne\r\n0\\)</span>，那么对应的特征向量增长速度就越快。</p>\r\n<p>这一节的内容稍微有点点难消化，不过这已经有点点科研证明的味道了。多看多理解。</p>\r\n<hr />\r\n<h3 id=\"八.-微分方程-expat\">八. 微分方程, exp(At)</h3>\r\n<p>在开始这节课之前，我觉得有必要补充介绍一点微分方程的概念。</p>\r\n<p>定义：含自变量（例如<span\r\nclass=\"math inline\">\\(x\\)</span>）、函数（例如<span\r\nclass=\"math inline\">\\(y\\)</span>）以及函数各阶导数（例如<span\r\nclass=\"math inline\">\\(\\dot{y},\r\n\\ddot{y}\\)</span>）的等式称为微分方程。</p>\r\n<p>抱歉，真听不懂，是我高数太垃圾了，回头补完微分方程再来听这节课。</p>\r\n<h3 id=\"九.-马尔可夫矩阵-傅里叶级数\">九. 马尔可夫矩阵, 傅里叶级数</h3>\r\n<p>什么是马尔可夫矩阵，若<span\r\nclass=\"math inline\">\\(A\\)</span>满足以下两条定义，则它是马尔可夫矩阵：</p>\r\n<ol type=\"1\">\r\n<li>所有元素大于0（概率值不能为负数）</li>\r\n<li>每一列元素和为1</li>\r\n<li>方阵</li>\r\n</ol>\r\n<p>对于马尔可夫矩阵，很容易发现，其幂即<span\r\nclass=\"math inline\">\\(A^k\\)</span>同样也是马尔可夫矩阵。</p>\r\n<p>这里我直接给出两个结论：</p>\r\n<ol type=\"1\">\r\n<li>马尔可夫矩阵有一个特征值为1</li>\r\n<li>马尔可夫矩阵其余特征值绝对值小于等于1</li>\r\n</ol>\r\n<p>根据上面的结果，我们可以知道，如果一个向量一直右边马尔可夫矩阵，那么最终会达到一个稳态。显然这个稳态是我们关心的，我们需要找到它。</p>\r\n<p>假设矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>有n个线性无关的特征向量<span\r\nclass=\"math inline\">\\(\\beta\\)</span>-s，那么对于式子：<span\r\nclass=\"math inline\">\\(u_k = A^ku_0\\)</span></p>\r\n<p><span class=\"math inline\">\\(u_0\\)</span>可以被表示为：<span\r\nclass=\"math inline\">\\(u_0 = c_1\\beta_1 + c_2\\beta_2 + \\cdots +\r\nc_n\\beta_n = Sc\\)</span></p>\r\n<p><span class=\"math inline\">\\(A^k\\)</span>根据前面所学可对角化为：<span\r\nclass=\"math inline\">\\(A_k = S\\Lambda^kS^{-1}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore u_k = S\\Lambda^kS^{-1}Sc =\r\nS\\Lambda^kc = c_1\\lambda_1\\beta_1 + c_2\\lambda_2\\beta_2 + \\cdots +\r\nc_n\\lambda_n\\beta_n\\)</span></p>\r\n<p>所以那些绝对值&lt;1的项最终会迭代没，绝对值为1的项加起来就是稳态。</p>\r\n<hr />\r\n<p>傅里叶级数是一个可用来拟合任意周期函数的工具，例如我想拟合一个周期为<span\r\nclass=\"math inline\">\\(2\\pi\\)</span>的函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>，可用傅立叶级数表达为下列形式：</p>\r\n<p><span class=\"math inline\">\\(f(x) = a_0\\cdot 1 + a_1\\cos x + b_1\\sin x\r\n+ a_2\\cos 2x + b_2\\sin 2x + \\cdots + a_n\\cos nx+ b_n\\sin nx\\)</span></p>\r\n<p>所以关键就是确定下系数<span class=\"math inline\">\\(a_i,\r\nb_i\\)</span>，那我们用线性代数来看待这个问题。</p>\r\n<p>可以把<span class=\"math inline\">\\(1, \\cos x, \\sin x, \\cos 2x, \\sin\r\n2x, \\cdots, \\cos nx, \\sin nx\\)</span>看作基<span\r\nclass=\"math inline\">\\(\\beta_i\\)</span>-s，<span\r\nclass=\"math inline\">\\(f(x)\\)</span>看作<span\r\nclass=\"math inline\">\\(b\\)</span>，那么<span class=\"math inline\">\\(a_i,\r\nb_i\\)</span>就是线性组合的系数。</p>\r\n<p>让我写成这种形式：<span class=\"math inline\">\\(c_0\\beta_0 + c_1\\beta_1\r\n+ c_2\\beta_2 + \\cdots + c_n\\beta_n = b\\)</span></p>\r\n<p>问题即为求出<span class=\"math inline\">\\(c_i\\)</span>。</p>\r\n<p>假设<span\r\nclass=\"math inline\">\\(\\beta_i\\)</span>-s们正交就好了，我们来检查一下是否正交。</p>\r\n<p>因为这里的“向量”是函数，所以离散型的点积在这里并不是适用，对于函数<span\r\nclass=\"math inline\">\\(f(x), g(x)\\)</span>，其实点积是<span\r\nclass=\"math inline\">\\(\\int_a^b f(x)g(x)\r\n\\mathrm{d}x\\)</span>，因为本题函数周期为<span\r\nclass=\"math inline\">\\(2\\pi\\)</span>，所以俩函数点积为：<span\r\nclass=\"math inline\">\\(\\int_0^{2\\pi}f(x)g(x)\r\n\\mathrm{d}x\\)</span>，检查一下发现这些“基”们确实是正交的。</p>\r\n<p>那么求系数<span\r\nclass=\"math inline\">\\(c_i\\)</span>就好办了，比如我要求<span\r\nclass=\"math inline\">\\(c_1\\)</span>，那么等式两边分别“点积”<span\r\nclass=\"math inline\">\\(\\beta_1\\)</span>，得：</p>\r\n<p><span class=\"math inline\">\\(c_1 \\int_0^{2\\pi}(cosx)^2\\mathrm{d}x =\r\n\\int_0^{2\\pi}f(x)\\cos x\\mathrm{d}x\\)</span></p>\r\n<p>因为正交性，非<span\r\nclass=\"math inline\">\\(\\beta_1\\)</span>的项都为0了，所以解这个方程即可把<span\r\nclass=\"math inline\">\\(c_1\\)</span>求出来，其余系数求法同理。</p>\r\n<p>非常巧妙优美的做法。</p>\r\n<h3 id=\"十.-复习课二\">十. 复习课二</h3>\r\n<p>主要因为这章的知识比较重要，所以适合来2道例题巩固一下。而且我想通过例题顺便补充下代数重数和几何重数的知识点。</p>\r\n<p><strong>例1.</strong> <span class=\"math inline\">\\(a = \\begin{bmatrix}\r\n2 \\\\ 1 \\\\ 2 \\end{bmatrix}\\)</span></p>\r\n<ol type=\"1\">\r\n<li>求投影到<span class=\"math inline\">\\(a\\)</span>的投影矩阵<span\r\nclass=\"math inline\">\\(P\\)</span></li>\r\n</ol>\r\n<p>套公式：<span class=\"math inline\">\\(P =\r\n\\frac{aa^\\mathrm{T}}{a^\\mathrm{T}a} = \\frac{1}{9} \\begin{bmatrix} 4\r\n&amp; 2 &amp; 4 \\\\ 2 &amp; 1 &amp; 2 \\\\ 4 &amp; 2 &amp; 4\r\n\\end{bmatrix}\\)</span></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>求<span class=\"math inline\">\\(P\\)</span>的秩</li>\r\n</ol>\r\n<p>因为<span class=\"math inline\">\\(P\\)</span>的列空间<span\r\nclass=\"math inline\">\\(C(P)\\)</span>是投影面，而投影面又是三维空间里的一维直线，所以<span\r\nclass=\"math inline\">\\(dim(C(A)) = r = 1\\)</span>。</p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>求<span class=\"math inline\">\\(P\\)</span>的特征值</li>\r\n</ol>\r\n<p>因为<span class=\"math inline\">\\(r(P) =\r\n1\\)</span>，所以它是奇异，所以<span class=\"math inline\">\\(det(P) =\r\n0\\)</span>，所以它必有一个特征值为0。</p>\r\n<p>我们知道特征值为0对应的特征向量就是<span\r\nclass=\"math inline\">\\(N(P)\\)</span>里的那些基们，而我们知道<span\r\nclass=\"math inline\">\\(dim(N(P)) = n - r =\r\n2\\)</span>，所以基里有俩向量，所以特征值0的几何重数为2，又因为几何重数\r\n&lt;= 代数重数，所以至少有两个特征值为0。</p>\r\n<p><span\r\nclass=\"math inline\">\\(P\\)</span>的迹又是1，所以不可能三个特征值都为0，所以可确定特征值0的代数重数也为2。所以特征值分别为0、0、1</p>\r\n<blockquote>\r\n<p>知识点补充：代数重数、几何重数</p>\r\n<p>代数重数就是某特征值重复的个数</p>\r\n<p>几何重数就是某特征值对应的互相线性无关的特征向量的个数。这些线性无关的特征向量组合的空间叫做特征子空间</p>\r\n<p>性质：几何重数 &lt;= 代数重数</p>\r\n</blockquote>\r\n<ol start=\"4\" type=\"1\">\r\n<li><span\r\nclass=\"math inline\">\\(P\\)</span>特征值为1对应的特征向量是啥</li>\r\n</ol>\r\n<p>其实就是问你<span class=\"math inline\">\\(Px=x\\)</span>的<span\r\nclass=\"math inline\">\\(x\\)</span>都有谁，根据几何意义，显然<span\r\nclass=\"math inline\">\\(x\\)</span>就在投影面上啊，即那条线，所以特征向量写<span\r\nclass=\"math inline\">\\(a\\)</span>就行了</p>\r\n<p><strong>例2.</strong> 已知一个4阶方阵<span\r\nclass=\"math inline\">\\(A\\)</span>具有特征值<span\r\nclass=\"math inline\">\\(\\lambda_1, \\lambda_2, \\lambda_3,\r\n\\lambda_4\\)</span></p>\r\n<ol type=\"1\">\r\n<li>特征值需要满足什么条件才能保证<span\r\nclass=\"math inline\">\\(A\\)</span>为可逆矩阵</li>\r\n</ol>\r\n<p>可逆矩阵说明<span class=\"math inline\">\\(r(A) =\r\nn\\)</span>，那么零空间的维数就为0。而如果有特征值为0，那么必然说明零空间有非零向量，即<span\r\nclass=\"math inline\">\\(r(A) \\ne\r\nn\\)</span>。所以必须满足所有特征值不为0，才能保证<span\r\nclass=\"math inline\">\\(A\\)</span>为可逆矩阵</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>求<span class=\"math inline\">\\(A^{-1}\\)</span>的行列式</li>\r\n</ol>\r\n<p>因为<span class=\"math inline\">\\(A^{-1}\\)</span>的特征值是<span\r\nclass=\"math inline\">\\(A\\)</span>特征值取倒数，行列式又是特征值之积，所以<span\r\nclass=\"math inline\">\\(det(A^{-1}) =\r\n\\frac{1}{\\lambda_1\\lambda_2\\lambda_3\\lambda_4}\\)</span></p>\r\n","categories":["4. 大学","数学","线性代数"]},{"title":"线性代数3","url":"/2024/09/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/","content":"<p>对称矩阵、复数矩阵、FFT、正定矩阵、相似矩阵、SVD分解、线性变换、图像压缩、左右逆/伪逆</p>\r\n<span id=\"more\"></span>\r\n<hr />\r\n<h3 id=\"一.-对称矩阵及其正定性\">一. 对称矩阵及其正定性</h3>\r\n<p>在这里我们只讨论实对称矩阵。</p>\r\n<p>我们很喜欢对称矩阵，因为它具有很好的性质。就拿实对称矩阵来举例，它具有下列两个性质：</p>\r\n<ol type=\"1\">\r\n<li>其特征值均为实数</li>\r\n<li>其一定可选出具有正交的特征向量。这里的“有”，是指可以选出一套完全正交的特征向量（例如在重特征值条件下，可能存在一个平面内向量都可以作为特征向量）</li>\r\n<li>特征值的符号与主元的符号相同，即正数的个数相同，负数的个数也相同</li>\r\n</ol>\r\n<p>上一章我们学过，若方阵<span\r\nclass=\"math inline\">\\(A\\)</span>具有n个线性无关的特征向量，那么其可以对角化为<span\r\nclass=\"math inline\">\\(S\\Lambda S^{-1}\\)</span>。</p>\r\n<p>对于有n个线性无关特征向量的对称矩阵来说，因为性质2，所以它的特征向量矩阵可化为一个正交阵<span\r\nclass=\"math inline\">\\(Q\\)</span>，正交阵满足<span\r\nclass=\"math inline\">\\(Q^\\mathrm{T} = Q^{=1}\\)</span></p>\r\n<p>所以对于具有n个线性无关特征向量的对称矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>来说，其可对角化为<span\r\nclass=\"math inline\">\\(Q\\Lambda Q^T\\)</span>。</p>\r\n<p>把上面的式子进一步展开：</p>\r\n<p><span class=\"math inline\">\\(A = Q\\Lambda Q^\\mathrm{T} =\r\n\\begin{bmatrix} q_1 &amp; q_2 &amp; \\cdots &amp; q_n \\end{bmatrix}\r\n\\begin{bmatrix} \\lambda_1 &amp; &amp; &amp; \\\\ &amp; \\lambda_2 &amp;\r\n&amp; \\\\ &amp; &amp; \\cdots &amp; \\\\ \\end{bmatrix} \\begin{bmatrix}\r\nq_1^\\mathrm{T} \\\\ q_2^\\mathrm{T} \\\\ \\cdots \\\\ \\end{bmatrix}\\)</span></p>\r\n<p>利用\"线性代数1\"讲的用拆分矩阵乘法为加法去理解这个式子，可以写成：</p>\r\n<p><span class=\"math inline\">\\(A = \\lambda_1q_1q_1^\\mathrm{T} +\r\n\\lambda_2q_2q_2^\\mathrm{T} + \\cdots +\r\n\\lambda_nq_nq_n^\\mathrm{T}\\)</span></p>\r\n<p>上面这个式子发现了吗，其实每一项都是一个系数乘一个投影矩阵，因为<span\r\nclass=\"math inline\">\\(Q\\)</span>是正交矩阵，所以<span\r\nclass=\"math inline\">\\(q_i^\\mathrm{T}q_i = 1\\)</span>。</p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(A\\)</span>可以理解为投影矩阵的线性组合，且投影方向都是互相正交的。</p>\r\n<hr />\r\n<p>下面来介绍正定矩阵。</p>\r\n<p>正定矩阵是对称矩阵的一个子类，且所有特征值&gt;0</p>\r\n<p>而且它的“子行列式”均&gt;0，子行列式指的是n阶矩阵左上角的所有<span\r\nclass=\"math inline\">\\(k \\times k, 1 \\le k \\le\r\nn\\)</span>子行列式数值均为正。这很好理解，由对称矩阵的性质3，我们知道，其所有主元都&gt;0。而行列式就等于主元之积，所以子行列式们自然都大于0。这就是用行列式判定矩阵正定的判据。</p>\r\n<h3 id=\"二.-复数矩阵-快速傅里叶变换\">二. 复数矩阵, 快速傅里叶变换</h3>\r\n<p>对不起我的高数很垃圾，这节我也听不懂。等我学完mit\r\n18.03再来听这一节课</p>\r\n<h3 id=\"三.-正定矩阵\">三. 正定矩阵</h3>\r\n<p>正定矩阵是很好的矩阵，它是对称的而且所有特征值都大于零。那么如何判定一个方阵是正定矩阵呢？这里我给出几种方法</p>\r\n<ol type=\"1\">\r\n<li>所有特征值<span class=\"math inline\">\\(\\lambda_i &gt; 0\\)</span></li>\r\n<li>所有主元大于零</li>\r\n<li>所有子行列式们大于零</li>\r\n<li><span class=\"math inline\">\\(x^\\mathrm{T}Ax &gt; 0, x \\ne\r\n\\textbf{0}\\)</span></li>\r\n</ol>\r\n<p>第一个是定义，第二个是因为对称矩阵有一个性质就是特征值正负号与主元相同，所以可根据(1)得到第二条等价条件。第三个是用行列式判断正定性(前面讲过)。第四个是新加的，我们很喜欢用第四个判据。让我们来看看为什么这个判据可以推出矩阵是正定的。</p>\r\n<p>对于<span\r\nclass=\"math inline\">\\(x^\\mathrm{T}Ax\\)</span>，我们将其展开： <span\r\nclass=\"math display\">\\[\r\nx^\\mathrm{T}Ax = \\begin{bmatrix}x_1, x_2, \\cdots,\r\nx_n\\end{bmatrix}\\begin{bmatrix} a_{11}x_1+a_{12}x_2+\\cdots+a_{1n}x_n \\\\\r\na_{21}x_1 + a_{22}x_2 + \\cdots + a_{2n}x_n \\\\ a_{31}x_1 + a_{32}x_2 +\r\n\\cdots + a_{3n}x_n \\\\ \\cdots \\\\ a_{n1}x_1 + a_{n2}x_2 + \\cdots +\r\na_{nn}x_n\\end{bmatrix} = \\\\ x_1(a_{11}x_1+a_{12}x_2+\\cdots+a_{1n}x_n)+\r\nx_2(a_{21}x_1 + a_{22}x_2 + \\cdots + a_{2n}x_n) + \\cdots + x_n(a_{n1}x_1\r\n+ a_{n2}x_2 + \\cdots + a_{nn}x_n)\r\n\\]</span>\r\n可以发现，每一项都是二次的。其实如果用图像去研究这个函数：<span\r\nclass=\"math inline\">\\(f(x) =\r\nx^\\mathrm{T}Ax\\)</span>，（这个函数也叫二次型）</p>\r\n<p>矩阵为正定时二次型图像见左上角，为半正定时图像见右下角，为非正定/半正定时图像见左下角，负定时图像见右上角</p>\r\n<p>这些图像研究的是二维方阵的二次型，xy轴是<span\r\nclass=\"math inline\">\\(x\\)</span>的俩分量<span class=\"math inline\">\\(x_1,\r\nx_2\\)</span>，z轴是<span\r\nclass=\"math inline\">\\(f(x)=x^\\mathrm{T}Ax\\)</span></p>\r\n<p><img src=\"1.png\" /></p>\r\n<hr />\r\n<p>下面继续讨论下正定矩阵还有哪些性质，假设<span\r\nclass=\"math inline\">\\(A, B\\)</span>为正定矩阵，<span\r\nclass=\"math inline\">\\(C\\)</span>为矩阵。</p>\r\n<p>那么<span\r\nclass=\"math inline\">\\(A\\)</span>是否可逆呢？答案是肯定的，因为我们知道<span\r\nclass=\"math inline\">\\(A\\)</span>的子行列式们都大于0，所以<span\r\nclass=\"math inline\">\\(det(A) &gt; 0\\)</span>，所以<span\r\nclass=\"math inline\">\\(A\\)</span>是非奇异的，即满秩可逆的。</p>\r\n<p>那么<span\r\nclass=\"math inline\">\\(A^{-1}\\)</span>是不是正定矩阵呢？答案是肯定的。因为我们知道<span\r\nclass=\"math inline\">\\(A^{-1}\\)</span>的特征值们就是<span\r\nclass=\"math inline\">\\(A\\)</span>的特征值取倒数，而<span\r\nclass=\"math inline\">\\(A\\)</span>的特征值都大于0，所以<span\r\nclass=\"math inline\">\\(A^{-1}\\)</span>的特征值也都大于0，所以<span\r\nclass=\"math inline\">\\(A^{-1}\\)</span>也为正定矩阵。</p>\r\n<p>那么<span class=\"math inline\">\\(A +\r\nB\\)</span>是不是正定矩阵呢？答案是肯定的。我们来看看<span\r\nclass=\"math inline\">\\(x^\\mathrm{T}(A+B)x = x^\\mathrm{T}Ax +\r\nx^\\mathrm{T}Bx &gt; 0\\)</span>，所以<span class=\"math inline\">\\(A +\r\nB\\)</span>也是正定矩阵。</p>\r\n<p>那么<span\r\nclass=\"math inline\">\\(C^\\mathrm{T}C\\)</span>是不是正定矩阵呢？答案是不一定。我们来看看<span\r\nclass=\"math inline\">\\(x^\\mathrm{T}(C^\\mathrm{T}C)x = (Cx)^\\mathrm{T}(CX)\r\n= \\|Cx\\|^2 \\ge 0\\)</span>。</p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(C^\\mathrm{T}C\\)</span>至少是半正定的，那什么时候是正定的呢？只要没有非零向量使得<span\r\nclass=\"math inline\">\\(Cx = \\textbf{0}\\)</span>，那么就可以保证：<span\r\nclass=\"math inline\">\\(x^\\mathrm{T}(C^\\mathrm{T}C)x &gt; 0\\)</span>。</p>\r\n<p>即要保证<span class=\"math inline\">\\(N(C) =\r\n\\{\\textbf{0}\\}\\)</span>，即要保证<span class=\"math inline\">\\(r(C) =\r\nn\\)</span>，即可保证<span\r\nclass=\"math inline\">\\(C^\\mathrm{T}C\\)</span>是正定矩阵。</p>\r\n<p>还记得<span\r\nclass=\"math inline\">\\(C^\\mathrm{T}C\\)</span>在哪用到吗？即最小二乘求最优近似解那里，最后方程为：<span\r\nclass=\"math inline\">\\(C\\hat{x}=Pb =\r\nC(C^\\mathrm{T}C)^{-1}C^\\mathrm{T}b\\)</span></p>\r\n<p>只要保证<span class=\"math inline\">\\(C\\)</span>各列线性无关，则<span\r\nclass=\"math inline\">\\(C^\\mathrm{T}C\\)</span>是正定矩阵，所以<span\r\nclass=\"math inline\">\\(C^\\mathrm{T}C\\)</span>可逆，则上述方程成立，同左乘<span\r\nclass=\"math inline\">\\(C^\\mathrm{T}\\)</span>，然后再左乘<span\r\nclass=\"math inline\">\\((C^\\mathrm{T}C)^{-1}\\)</span>，即可求出<span\r\nclass=\"math inline\">\\(\\hat{x}\\)</span>。</p>\r\n<h3 id=\"四.-相似矩阵\">四. 相似矩阵</h3>\r\n<p><span class=\"math inline\">\\(A, B\\)</span>均为<span\r\nclass=\"math inline\">\\(n \\times n\\)</span>的方阵，那么<span\r\nclass=\"math inline\">\\(A\\)</span>与<span\r\nclass=\"math inline\">\\(B\\)</span>相似，用数学语言表达为：存在可逆矩阵<span\r\nclass=\"math inline\">\\(M\\)</span>，使得<span class=\"math inline\">\\(B =\r\nM^{-1}AM\\)</span></p>\r\n<p>它具有一个性质：相似的矩阵拥有相同的特征值。</p>\r\n<blockquote>\r\n<p>证明：</p>\r\n<p><span class=\"math inline\">\\(Ax = \\lambda x\\)</span></p>\r\n<p><span class=\"math inline\">\\(A(MM^{-1})x = \\lambda x\\)</span></p>\r\n<p><span class=\"math inline\">\\(M^{-1}AMM^{-1}x = \\lambda\r\nM^{-1}x\\)</span></p>\r\n<p><span class=\"math inline\">\\(BM^{-1}x = \\lambda M^{-1}x\\)</span></p>\r\n<p><span class=\"math inline\">\\(B(M^{-1}x) = \\lambda\r\n(M^{-1}x)\\)</span></p>\r\n<p>证毕。且可看出特征值虽然不变，但是特征向量由<span\r\nclass=\"math inline\">\\(x\\)</span>变为了<span\r\nclass=\"math inline\">\\(M^{-1}x\\)</span>。</p>\r\n</blockquote>\r\n<p>举个例子，例如可对角化的矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>，其可分解为：<span\r\nclass=\"math inline\">\\(A = S^{-1}\\Lambda S\\)</span>。其中<span\r\nclass=\"math inline\">\\(S\\)</span>是可逆的，因为各特征向量线性无关。所以<span\r\nclass=\"math inline\">\\(A\\)</span>与<span\r\nclass=\"math inline\">\\(\\Lambda\\)</span>就相似。而且我们会发现，<span\r\nclass=\"math inline\">\\(A\\)</span>与<span\r\nclass=\"math inline\">\\(\\Lambda\\)</span>的特征值一样。</p>\r\n<h3 id=\"五.-奇异值分解\">五. 奇异值分解</h3>\r\n<p>SVD分解也是一种矩阵分解的形式。至今为止，我们已经学过了许多矩阵分解方法了：<span\r\nclass=\"math inline\">\\(LU\\)</span>、<span class=\"math inline\">\\(S\\Lambda\r\nS^{-1}\\)</span>（可对角矩阵）、<span class=\"math inline\">\\(Q\\Lambda\r\nQ^\\mathrm{T}\\)</span>（对称矩阵）、<span\r\nclass=\"math inline\">\\(QR\\)</span>（满秩矩阵）。</p>\r\n<p>可以发现，除了<span\r\nclass=\"math inline\">\\(LU\\)</span>分解，其余分解都对矩阵有限制条件。但是这节我要讲的SVD分解，对任意矩阵都成立。</p>\r\n<p>SVD用数学语言描述如下：</p>\r\n<p><span class=\"math inline\">\\(A = U\\Sigma V^\\mathrm{T}\\)</span></p>\r\n<p><span class=\"math inline\">\\(A \\in \\mathbb{R}^{m \\times\r\nn}\\)</span>是任意矩阵，<span class=\"math inline\">\\(U \\in \\mathbb{R}^{m\r\n\\times m}\\)</span>是正交阵，<span class=\"math inline\">\\(\\Sigma \\in\r\n\\mathbb{R}^{m \\times n}\\)</span>是\"对角阵\"，<span\r\nclass=\"math inline\">\\(V^\\mathrm{T} \\in \\mathbb{R}^{n \\times\r\nn}\\)</span>是正交阵。</p>\r\n<p>我们来看下在已知<span\r\nclass=\"math inline\">\\(A\\)</span>下，如何计算出<span\r\nclass=\"math inline\">\\(U, \\Sigma, V\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\because A = U\\Sigma\r\nV^\\mathrm{T}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore A^\\mathrm{T}A =\r\n(V\\Sigma^\\mathrm{T}U^\\mathrm{T})(U\\Sigma V^\\mathrm{T}) =\r\nV\\Sigma^\\mathrm{T}\\Sigma V^\\mathrm{T}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\because A^\\mathrm{T}A \\text{ is a\r\nsymmetric matrix}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore V \\text{ is } Q,\r\n\\Sigma^\\mathrm{T}\\Sigma \\text{ is } \\Lambda, \\text{ where }\r\nA^\\mathrm{T}A = Q\\Lambda Q^{\\mathrm{T}}\\)</span></p>\r\n<p>所以，对于<span class=\"math inline\">\\(A\\)</span>，求出<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}A\\)</span>的特征值开根和对应的相互正交的标准特征向量，对应排好就是<span\r\nclass=\"math inline\">\\(\\Sigma, V\\)</span></p>\r\n<p>那有了<span class=\"math inline\">\\(\\Sigma, V\\)</span>后，如何求<span\r\nclass=\"math inline\">\\(U\\)</span>呢？</p>\r\n<p><span class=\"math inline\">\\(\\because A = U\\Sigma\r\nV^\\mathrm{T}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\therefore AV = U\\Sigma V^\\mathrm{T}V =\r\nU\\Sigma\\)</span></p>\r\n<p>即再算出<span\r\nclass=\"math inline\">\\(AV\\)</span>，然后每一列除对应的奇异值，即可得到<span\r\nclass=\"math inline\">\\(U\\)</span>。</p>\r\n<hr />\r\n<p>多说无益，举个例子来看下如何将矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>分解为<span\r\nclass=\"math inline\">\\(U\\Sigma V^\\mathrm{T}\\)</span></p>\r\n<p>已知<span class=\"math inline\">\\(A = \\begin{bmatrix} 4 &amp; 4 \\\\ -3\r\n&amp; 3 \\end{bmatrix}\\)</span></p>\r\n<p>先算出<span class=\"math inline\">\\(A^\\mathrm{T}A = \\begin{bmatrix} 25\r\n&amp; 7 \\\\ 7 &amp; 25 \\end{bmatrix}\\)</span></p>\r\n<p>然后求其特征值和对应的互相正交的标准特征向量：</p>\r\n<p><span class=\"math inline\">\\(\\lambda_1 = 18, x_1 =\r\n\\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\lambda_2 = 32, x_2 =\r\n\\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\)</span></p>\r\n<p>即已经求出<span class=\"math inline\">\\(\\Sigma = \\begin{bmatrix}\r\n\\sqrt{18} &amp; \\\\ &amp; \\sqrt{32} \\end{bmatrix}, V =\r\n\\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 &amp; 1 \\\\ -1 &amp; 1\\end{bmatrix},\r\nV^\\mathrm{T} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 &amp; -1 \\\\ 1 &amp; 1\r\n\\end{bmatrix}\\)</span></p>\r\n<p>然后算出<span class=\"math inline\">\\(AV\\)</span>，即<span\r\nclass=\"math inline\">\\(U\\Sigma\\)</span>：<span\r\nclass=\"math inline\">\\(\\begin{bmatrix} 0 &amp; \\frac{8}{\\sqrt{2}} \\\\\r\n-\\frac{6}{\\sqrt{2}} &amp; 0\\end{bmatrix}\\)</span></p>\r\n<p>每一列除对应的<span\r\nclass=\"math inline\">\\(\\sqrt{\\lambda_i}\\)</span>，即第一列除<span\r\nclass=\"math inline\">\\(\\sqrt{18}\\)</span>，第二列除<span\r\nclass=\"math inline\">\\(\\sqrt{32}\\)</span>，得到<span\r\nclass=\"math inline\">\\(U\\)</span>：<span\r\nclass=\"math inline\">\\(\\begin{bmatrix} 0 &amp; 1 \\\\ -1 &amp; 0\r\n\\end{bmatrix}\\)</span></p>\r\n<p>现在所有东西都已求出来： <span class=\"math display\">\\[\r\nU = \\begin{bmatrix} 0 &amp; 1 \\\\ -1 &amp; 0 \\end{bmatrix}, \\Sigma =\r\n\\begin{bmatrix} \\sqrt{18} &amp; \\\\ &amp; \\sqrt{32} \\end{bmatrix},\r\nV^\\mathrm{T} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 &amp; -1 \\\\ 1 &amp; 1\r\n\\end{bmatrix}\r\n\\]</span> 我们来验证一下，将这仨乘起来，发现等于<span\r\nclass=\"math inline\">\\(A\\)</span>，check！</p>\r\n<hr />\r\n<p>SVD有什么用呢？我来举一个例子，例如某件事物需要用两个维度来刻画，即<span\r\nclass=\"math inline\">\\(f: (x, y) \\to\r\nz\\)</span>。那么适合用一个矩阵来表示，不妨表示为<span\r\nclass=\"math inline\">\\(A\\)</span>。</p>\r\n<p>如果我们将<span class=\"math inline\">\\(A\\)</span>进行SVD分解为<span\r\nclass=\"math inline\">\\(U\\Sigma\r\nV^\\mathrm{T}\\)</span>，进一步展开可以得到： <span\r\nclass=\"math display\">\\[\r\nA = U\\Sigma V^\\mathrm{T} = \\begin{bmatrix}u_1, u_2, \\cdots,\r\nu_n\\end{bmatrix} \\cdot \\begin{bmatrix}\\sigma_1 &amp; &amp; &amp; \\\\\r\n&amp; \\sigma_2 &amp; &amp; \\\\ &amp; &amp; \\cdots &amp; \\\\ &amp; &amp;\r\n&amp; \\sigma_n\\end{bmatrix} \\cdot \\begin{bmatrix}v_1^\\mathrm{T} \\\\\r\nv_2^\\mathrm{T} \\\\ \\cdots \\\\ v_n^\\mathrm{T}\\end{bmatrix} =\r\n\\sigma_1u_1v_1^\\mathrm{T} + \\sigma_2u_2v_2^\\mathrm{T} + \\cdots +\r\n\\sigma_nu_nv_n^\\mathrm{T}\r\n\\]</span> 可以发现，一个矩阵被拆解为若干矩阵相加，奇异值<span\r\nclass=\"math inline\">\\(\\sigma_i\\)</span>可以理解为矩阵所占的权重。那些<span\r\nclass=\"math inline\">\\(\\sigma_i\\)</span>大的矩阵说明对整体矩阵的影响越大。</p>\r\n<p>相当于对于一个模式<span\r\nclass=\"math inline\">\\(A\\)</span>，我可以知道<span\r\nclass=\"math inline\">\\(A\\)</span>重点体现在哪些子模式上，进而重点去优化那些子模式。</p>\r\n<h3 id=\"六.-线性变换\">六. 线性变换</h3>\r\n<p>什么是坐标？</p>\r\n<p>其实，世界上坐标不是天生存在的东西。而是人类以某些东西为标准，去测量其它东西的一种度量。</p>\r\n<p>例如我们通常认知的坐标系，其实上就是以俩正交的标准向量基为标准，坐标就是用这俩去线性组合的系数。</p>\r\n<p>所以如何理解一个线性变化？</p>\r\n<p>我这么说吧，假设我们已经确定好一组基(n个)，那么这组基作为我们的“观测基准”，可以以它们为标准观测出万物的状态<span\r\nclass=\"math inline\">\\((c_1, c_2, \\cdots, c_n)\\)</span>。（<span\r\nclass=\"math inline\">\\(c_i\\)</span>跟第i个基向量有关）</p>\r\n<p>但是现在，我想换一套观察工具，也就是换一组基(m个)，那么换完之后，<strong>同样</strong>的一个事物，在之前用旧基观测的时候，它的状态是<span\r\nclass=\"math inline\">\\((c_1, c_2, \\cdots,\r\nc_n)\\)</span>，用新基观测的时候，它的状态变为<span\r\nclass=\"math inline\">\\((d_1, d_2, \\cdots, d_m)\\)</span>。</p>\r\n<p>那么有没有一种映射，可以直接让我从<span class=\"math inline\">\\((c_1,\r\nc_2, \\cdots, c_n)\\)</span>直接可以得到<span class=\"math inline\">\\((d_1,\r\nd_2, \\cdots, d_m)\\)</span>？有，它就是——线性变换。</p>\r\n<p>如何构造这个线性变换呢？如下：</p>\r\n<p>对于旧基(<span\r\nclass=\"math inline\">\\(v\\)</span>)的每个基向量，我们都先用新基(<span\r\nclass=\"math inline\">\\(w\\)</span>)去观测它，并得到观测状态<span\r\nclass=\"math inline\">\\(a_{ij}\\)</span>： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n    v_1 &amp;= a_{11}w_1 + a_{21}w_2 + \\cdots + a_{m1}w_m \\\\\r\n    v_2 &amp;= a_{12}w_1 + a_{22}w_2 + \\cdots + a_{m2}w_m \\\\\r\n    &amp;\\cdots \\\\\r\n    v_n &amp;= a_{1n}w_1 + a_{2n}w_2 + \\cdots + a_{mn}w_m\r\n\\end{align*}\r\n\\]</span> 对于一件事物<span\r\nclass=\"math inline\">\\(x\\)</span>，用旧基观测可以得到：<span\r\nclass=\"math inline\">\\(x = c_1v_1 + c_2v_2 + \\cdots + c_nv_n\\)</span></p>\r\n<p>继续展开： <span class=\"math display\">\\[\r\n\\begin{align*}\r\n    x &amp;= c_1v_1 + c_2v_2 + \\cdots + c_nv_n \\\\\r\n      &amp;= c_1a_{11}w_1 + c_1a_{21}w_2 + \\cdots + c_1a_{m1}w_m + \\\\\r\n      &amp;~~~~~c_2a_{12}w_1 + c_2a_{22}w_2 + \\cdots + c_2a_{m2}w_m + \\\\\r\n      &amp;~~~~~\\cdots \\\\\r\n      &amp;~~~~~c_na_{1n}w_1 + c_na_{2n}w_2 + \\cdots + c_na_{mn}w_m \\\\\r\n      &amp;= (c_1a_{11}+c_2a_{12}+\\cdots+c_na_{1n})w_1 + \\\\\r\n      &amp;~~~~~(c_1a_{21}+c_2a_{22}+\\cdots+c_na_{2n})w_2 + \\\\\r\n      &amp;~~~~~\\cdots \\\\\r\n      &amp;~~~~~(c_1a_{m1}+c_2a_{m2}+\\cdots+c_na_{mn})w_m \\\\\r\n      &amp;=d_1w_1 + d_2w_2 + \\cdots + d_mw_m\r\n\\end{align*}\r\n\\]</span> 用矩阵形式表达： <span class=\"math display\">\\[\r\nAc = \\begin{bmatrix}\r\na_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\r\na_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\\r\n\\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\r\na_{m1} &amp; a_{m2} &amp; \\cdots &amp; a_{mn}\r\n\\end{bmatrix}\\begin{bmatrix}c_1 \\\\ c_2 \\\\ \\vdots \\\\ c_n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\na_{11}c_1 + a_{12}c_2 + \\cdots + a_{1n}c_n \\\\\r\na_{21}c_1 + a_{22}c_2 + \\cdots + a_{2n}c_n \\\\\r\n\\vdots \\\\\r\na_{m1}c_1 + a_{m2}c_2 + \\cdots + a_{mn}c_n\r\n\\end{bmatrix}=\r\n\\begin{bmatrix}\r\nd_1 \\\\\r\nd_2 \\\\\r\n\\vdots \\\\\r\nd_m\r\n\\end{bmatrix}\r\n\\]</span> 所以我们从旧观测状态<span class=\"math inline\">\\((c_1, c_2,\r\n\\cdots, c_n)\\)</span>得到了新观测状态<span class=\"math inline\">\\((d_1,\r\nd_2, \\cdots, d_m)\\)</span>。</p>\r\n<p>问题的关键就是确定这个<span\r\nclass=\"math inline\">\\(A\\)</span>矩阵，从旧基到新基的线性变换也就体现在这个<span\r\nclass=\"math inline\">\\(A\\)</span>矩阵上。</p>\r\n<p>那这个<span class=\"math inline\">\\(A\\)</span>咋求呢？<span\r\nclass=\"math inline\">\\(A\\)</span>的每一列其实就是每一个旧基的基向量用新基去观测得到的状态。</p>\r\n<p>至此，我们有了一种全新的视角去看待矩阵乘法<span\r\nclass=\"math inline\">\\(Ax = b\\)</span></p>\r\n<p><strong><span\r\nclass=\"math inline\">\\(x\\)</span>是旧基下对某事物的观测状态，<span\r\nclass=\"math inline\">\\(b\\)</span>是新基下对某事物的观测状态。而实现基转换功能的东西，就是<span\r\nclass=\"math inline\">\\(A\\)</span>。</strong></p>\r\n<p><strong><span\r\nclass=\"math inline\">\\(A\\)</span>的每一列其实就是每一个旧基的基向量用新基去观测得到的状态。</strong></p>\r\n<hr />\r\n<p>至此，线性变换与矩阵乘法彻底联系了起来。线性变换就是矩阵，矩阵就是线性变换。</p>\r\n<p>而我们知道，矩阵满足<span class=\"math inline\">\\((A + B)x = Ax + Bx,\r\n(cA)x = c(Ax)\\)</span>。所以线性变换<span\r\nclass=\"math inline\">\\(T\\)</span>是满足加法和数乘的，即：</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(T(v + w) = T(v) + T(w)\\)</span></li>\r\n<li><span class=\"math inline\">\\(T(cv) = cT(v)\\)</span></li>\r\n</ol>\r\n<p>其实线性变换一定满足<span class=\"math inline\">\\(T(0) =\r\n0\\)</span>，因为当<span class=\"math inline\">\\(v = w =\r\n0\\)</span>时，<span class=\"math inline\">\\(T(0) =\r\n2T(0)\\)</span>，所以<span class=\"math inline\">\\(T(0) =\r\n0\\)</span>。所以可以通过<span\r\nclass=\"math inline\">\\(T(0)\\)</span>是否等于0来快速排除一些不是线性变换的映射。</p>\r\n<hr />\r\n<p>告诉你三个有趣的事实：</p>\r\n<ol type=\"1\">\r\n<li>矩阵的逆就是线性变换的逆变换</li>\r\n<li>进行多次线性变换就是多个矩阵连乘，这样子矩阵乘法就有了几何上的直观理解</li>\r\n<li>正交阵相当于对空间进行旋转，对角阵相当于对空间进行拉伸</li>\r\n</ol>\r\n<h3 id=\"七.-图像压缩\">七. 图像压缩</h3>\r\n<p>思考一个<span class=\"math inline\">\\(512 \\times\r\n512\\)</span>的图像，我们需要<span class=\"math inline\">\\(512 \\times\r\n512\\)</span>个数来保存图像的状态。</p>\r\n<p>令<span class=\"math inline\">\\(n = 512 \\times 512\\)</span></p>\r\n<p>具体来说，一个状态可以用一个<span\r\nclass=\"math inline\">\\(\\mathbb{R}^{n}\\)</span>向量<span\r\nclass=\"math inline\">\\(x\\)</span>来描述（把矩阵拉成一个向量）</p>\r\n<p>而我们存储的<span class=\"math inline\">\\(512 \\times\r\n512\\)</span>个数，其实是标准基的系数： <span class=\"math display\">\\[\r\nx = c_1\\begin{bmatrix}1\\\\ \\\\ \\\\ \\\\ \\\\ \\end{bmatrix} +\r\nc_2\\begin{bmatrix}\\\\ 1 \\\\ \\\\ \\\\ \\\\ \\end{bmatrix} + \\cdots +\r\nc_n\\begin{bmatrix} \\\\ \\\\ \\\\ \\\\ 1\\end{bmatrix}\r\n\\]</span> 那如果换一组基呢？</p>\r\n<p>假设我们的旧基（即标准基）为<span\r\nclass=\"math inline\">\\(v\\)</span>，新基为<span\r\nclass=\"math inline\">\\(w\\)</span>。旧的观测状态为<span\r\nclass=\"math inline\">\\((c_1, c_2, ...,\r\nc_n)\\)</span>，那么新的观测状态<span class=\"math inline\">\\((d_1, d_2,\r\n..., d_n)\\)</span>需要通过<span\r\nclass=\"math inline\">\\(Ac\\)</span>才能得到，<span\r\nclass=\"math inline\">\\(A\\)</span>的每一列为每一个旧基的基向量用新基去观测得到的状态。</p>\r\n<p><span class=\"math inline\">\\(A^{-1} =\r\nB\\)</span>的每一列为每一个新基的基向量用旧基去观测的状态，所以<span\r\nclass=\"math inline\">\\(B\\)</span>其实就是把新基的基向量排成一排。</p>\r\n<p>所以我们新的观测状态：<span class=\"math inline\">\\(d =\r\nB^{-1}c\\)</span>。</p>\r\n<p>用新观测状态表示图片向量：<span class=\"math inline\">\\(x = d_1w_1 +\r\nd_2w_2 + \\cdots + d_nw_n\\)</span></p>\r\n<p>我们可以设定一个阈值，对于那些很小的<span\r\nclass=\"math inline\">\\(d_i\\)</span>那一项，我们就直接丢弃它，不存储了。例如我只要前5大的<span\r\nclass=\"math inline\">\\(d_i\\)</span>，那么我原本要存<span\r\nclass=\"math inline\">\\(n\\)</span>个数，现在我只需要存5个数了。</p>\r\n<p>我还原出来的图片向量即为：<span class=\"math inline\">\\(\\hat{x} =\r\nd_1w_1 + d_2w_2 + \\cdots + d_5w_5\\)</span>。</p>\r\n<p>非常巧妙，嗯哼？</p>\r\n<hr />\r\n<p>相当于用时间换空间，因为压缩和还原的过程我都需要进行矩阵运算。所以想加速压缩/还原速度我需要保证挑选出来的新基组成的<span\r\nclass=\"math inline\">\\(B\\)</span>的逆好求。</p>\r\n<p>同时，为了尽可能压缩空间，我要使得挑选出来的新基的观测状态<span\r\nclass=\"math inline\">\\((d_1, d_2, \\cdots, d_n)\\)</span>尽可能多的使<span\r\nclass=\"math inline\">\\(d_i &lt;\r\n\\text{阈值}\\)</span>。这样我就可能少保存系数，从而达到压缩存储空间的效果。</p>\r\n<p>注意，为啥我新基的个数要和旧基保持一样（即都有<span\r\nclass=\"math inline\">\\(n\\)</span>个基向量）？因为图片大小为<span\r\nclass=\"math inline\">\\(512 \\times\r\n512\\)</span>，你不能直接把人家图片大小给改了啊，直接通过砍图片大小来达到的压缩不叫压缩。</p>\r\n<hr />\r\n<p>多说一嘴，基的选择要结合实际情况分析，例如这张图片色彩很单调，且一大片区域都是同一种颜色的情况。那么基向量里必有<span\r\nclass=\"math inline\">\\(\\begin{bmatrix}1 \\\\ 1 \\\\ \\vdots \\\\ 1\r\n\\end{bmatrix}\\)</span>。因为这个基向量表达的图片状态就是纯单色图片。当然了，我意思是这个基向量肯定起着主导作用（也就是系数<span\r\nclass=\"math inline\">\\(d_i\\)</span>大），但是仍要结合使用别的基向量，要不你还原出来的图片就是纯单色图片。</p>\r\n<h3 id=\"八.-左右逆-伪逆\">八. 左右逆, 伪逆</h3>\r\n<p>对于矩阵<span class=\"math inline\">\\(A \\in \\mathbb{R}^{m \\times\r\nn}\\)</span>，若<span\r\nclass=\"math inline\">\\(A\\)</span>的各列线性无关。则<span\r\nclass=\"math inline\">\\(A\\)</span>存在左逆：<span\r\nclass=\"math inline\">\\((A^\\mathrm{T}A)^{-1}A^\\mathrm{T}\\)</span>。</p>\r\n<p>拿这玩意左乘<span class=\"math inline\">\\(A\\)</span>可得到<span\r\nclass=\"math inline\">\\(I\\)</span>，所以叫左逆。</p>\r\n<p>为啥条件是各列线性无关呢？因为我们知道<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}A\\)</span>一定是半正定矩阵。且当<span\r\nclass=\"math inline\">\\(N(A) =\r\n{\\textbf{0}}\\)</span>时，升级为正定矩阵，而正定矩阵一定可逆。所以才能有<span\r\nclass=\"math inline\">\\((A^\\mathrm{T}A)^{-1}\\)</span>。</p>\r\n<hr />\r\n<p>对应的，我可以得到右逆的定义，若<span\r\nclass=\"math inline\">\\(A\\)</span>的各行线性无关，则<span\r\nclass=\"math inline\">\\(A\\)</span>存在右逆：<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}(AA^\\mathrm{T})^{-1}\\)</span>。</p>\r\n<hr />\r\n<p>下面来讨论一下伪逆。</p>\r\n<p>我们知道，如果矩阵<span class=\"math inline\">\\(r(A) &lt; \\min(m, n), A\r\n\\in \\mathbb{R}^{m \\times n}\\)</span>，那么对于无解的最小二乘方程：<span\r\nclass=\"math inline\">\\(Ax = b\\)</span>是求不出最优近似解的。但是伪逆<span\r\nclass=\"math inline\">\\(A^+\\)</span>却可以求到\"最优稳定解\"<span\r\nclass=\"math inline\">\\(\\hat{x}\\)</span>，满足：<span\r\nclass=\"math inline\">\\(\\| A\\hat{x}-b \\| \\le \\| Ax - b \\|\\)</span>。</p>\r\n<p>ok，那如何求伪逆呢？用SVD。这里我直接给出公式：</p>\r\n<p><span class=\"math inline\">\\(A^+ = V\\Sigma^+\r\nU^\\mathrm{T}\\)</span>，<span\r\nclass=\"math inline\">\\(\\Sigma^+\\)</span>就是<span\r\nclass=\"math inline\">\\(\\Sigma\\)</span>的每一个奇异值取倒数。</p>\r\n<p>（伪逆这里讲的很浅，因为目前还不怎么用得着，等以后需要学习原理的时候再补充）</p>\r\n","categories":["4. 大学","数学","线性代数"]},{"title":"线性代数4","url":"/2024/09/15/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/","content":"<p>总结、知识易混点整理、补充知识</p>\r\n<span id=\"more\"></span>\r\n<hr />\r\n<h3 id=\"总结\">总结</h3>\r\n<p>前前后后花了一个月左右把mit 18.06学完了，收获颇丰，感谢教授。</p>\r\n<p>这门课第一章从（方程组 + 矩阵 +\r\n四个基本子空间）出发，讨论了线性代数的基本元素：向量、矩阵、空间。最后用所学知识对电势差问题建模，得到了许多优美的结论。</p>\r\n<p>第二章开始研究矩阵各种性质，例如正交、投影、行列式、特征值、对角化。并在结尾用马尔可夫矩阵寻找稳态，用正交性对傅里叶级数建模。</p>\r\n<p>第三章仍然是研究矩阵的各种性质，例如对称、正定、相似、SVD分解。以及将线性变换和矩阵统一起来。利用基变换实现图像压缩展示了线性变换的优美之处。</p>\r\n<p>总之，这门课不仅帮我扎实的打好了线代基础，而且给了我理解线代的上层视角。以及：马尔可夫矩阵、对角化、SVD分解、基变换压缩这三个知识点也给了我科研上的启发，说不定哪天就可以作为trick来优化我的算法。</p>\r\n<h3 id=\"section\"></h3>\r\n<h3 id=\"知识点易混点整理\">知识点易混点整理</h3>\r\n<ol type=\"1\">\r\n<li>如何理解矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>可对角化的条件是：“有n个线性无关的特征向量”?\r\n<ul>\r\n<li>因为我们在推对角化公式的时候，用的是<span class=\"math inline\">\\(AS =\r\nS\\Lambda\\)</span>。<span\r\nclass=\"math inline\">\\(S\\)</span>是n个特征向量排成的方阵</li>\r\n<li>因为要右乘<span\r\nclass=\"math inline\">\\(S^{-1}\\)</span>，所以就要保证<span\r\nclass=\"math inline\">\\(S\\)</span>的n个列向量线性无关，即<span\r\nclass=\"math inline\">\\(A\\)</span>有n个线性无关的特征向量</li>\r\n<li>这样才能推出：<span class=\"math inline\">\\(A = S\\Lambda\r\nS^{-1}\\)</span></li>\r\n</ul></li>\r\n<li>上面那个判据太困难了，有什么等价判据？\r\n<ul>\r\n<li>若<span\r\nclass=\"math inline\">\\(A\\)</span>有n个互不相同的特征值，则<span\r\nclass=\"math inline\">\\(A\\)</span>有n个线性无关的特征向量</li>\r\n<li>但若没有，则不能说<span\r\nclass=\"math inline\">\\(A\\)</span>一定没有n个线性无关的特征向量</li>\r\n<li>所以我们判断一个矩阵是否可对角化，可转换为求其特征值的问题。</li>\r\n</ul></li>\r\n<li><span class=\"math inline\">\\(A\\)</span>有n个线性无关的特征向量 和\r\n<span class=\"math inline\">\\(A\\)</span>的各列线性无关有什么关系？\r\n<ul>\r\n<li>前者可推后者，后者不可推前者</li>\r\n<li>我来证一下前者可推后者，因为对于特征向量x，有<span\r\nclass=\"math inline\">\\(Ax = \\lambda x\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\lambda x\\)</span>是通过<span\r\nclass=\"math inline\">\\(A\\)</span>进行列变换得到的，那仅仅通过列变换就可以得到一组线性无关的向量，相当于变换后的列空间就是<span\r\nclass=\"math inline\">\\(\\mathrm{R}^n\\)</span>。而列变换不改变列空间，所以<span\r\nclass=\"math inline\">\\(C(A) = \\mathrm{R}^n\\)</span>，所以<span\r\nclass=\"math inline\">\\(A\\)</span>的各列线性无关。</li>\r\n</ul></li>\r\n<li>对称矩阵一定可以对角化吗？若可以，它的对角化有什么特别之处？\r\n<ul>\r\n<li>是的一定可以。</li>\r\n<li>对称矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>可以对角化。那么可写为：<span\r\nclass=\"math inline\">\\(A = S\\Lambda S^{-1}\\)</span></li>\r\n<li>因为对称矩阵有个很好的性质就是：可选出一组正交特征向量。所以<span\r\nclass=\"math inline\">\\(S\\)</span>可以是完全正交的，再将其标准化一下，即可得到正交阵<span\r\nclass=\"math inline\">\\(Q\\)</span>。</li>\r\n<li>正交阵有一个很好的性质：<span class=\"math inline\">\\(Q^{-1} =\r\nQ^T\\)</span></li>\r\n<li>所以可对角化的对称矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>可对角化为：<span\r\nclass=\"math inline\">\\(A = Q\\Lambda Q^\\mathrm{T}\\)</span></li>\r\n</ul></li>\r\n<li>正定矩阵有什么好处吗？\r\n<ul>\r\n<li>首先正定矩阵是对称矩阵的一个子集，对称矩阵已经有一些很好的性质了，正定矩阵除了有对称矩阵的性质，还有其余很好的性质。比如一定可逆而且<span\r\nclass=\"math inline\">\\(x^\\mathrm{T}Ax &gt; 0\\)</span>。</li>\r\n<li>如果快速获得一个对称矩阵？<span\r\nclass=\"math inline\">\\(A^\\mathrm{T}A\\)</span>，<span\r\nclass=\"math inline\">\\(xx^\\mathrm{T} / AA^\\mathrm{T}\\)</span></li>\r\n<li>如果快速获得一个正定矩阵？<span class=\"math inline\">\\(A^\\mathrm{T}A,\r\nr(A) = n\\)</span></li>\r\n</ul></li>\r\n<li></li>\r\n</ol>\r\n<h3 id=\"补充知识\">补充知识</h3>\r\n","categories":["4. 大学","数学","线性代数"]},{"title":"计算机组成原理实验笔记","url":"/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/","content":"<p>用Verilog实现一个简易RISC-V指令集CPU软核。</p>\r\n<p>本次实验是重庆大学2022级弘深计算机拔尖班计算机组成原理的实验项目。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"一.-想说的话\">一. 想说的话</h3>\r\n<p>在开始做实验之前，首先要对CPU的物理结构和数据是如何在regfile,\r\ndata_memory, instr_memory、alu中传输的有比较清晰的认知。建议观看视频: <a\r\nhref=\"https://www.bilibili.com/video/BV1wi4y157D3?p=1\">从0到1设计一台计算机</a>，掌握理论知识。</p>\r\n<p>在看完视频后，可以先跟着这个<a\r\nhref=\"https://www.bilibili.com/video/BV1pK4y1C7es?p=1&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0\">教你写一个简单的CPU</a>视频，实现一个简单的MIPS指令集CPU软核，掌握实践知识。不用完全写对，跟着写一遍知道各个模块是如何互相运作的即可。因为视频中没有测试文件测试各个模块，都是一口气写下来的。所以最终版仿真是跑不起来的，因为存在诸多bug。</p>\r\n<p>然后，最好在系统学习完一遍计组的理论知识（尤其是流水线冒险）后，再去写RISC-V指令集的软核。或者边学边做也行。我就是在全部写完后，才去学的计组理论知识，所以写出来的软核在冒险那一块是存在几个bug的，已经懒得调了。到时候下半年参加龙芯杯的时候反正也要再一个cpu，把这个遗憾留到龙芯杯解决就是了。</p>\r\n<h3 id=\"二.-思路\">二. 思路</h3>\r\n<p>有啥思路？拿到设计图干就完事了，把线连好就行了，没啥难度。</p>\r\n<p>代码已开源：<a\r\nhref=\"https://github.com/potatoQi/RISCV_CPU_Chongqing-University-Computer-Organization-Principles-Course-Project\">RISCV_CPU(Chongqing\r\nUniversity Computer Organization Principles Course Project)</a></p>\r\n","categories":["4. 大学","计算机专业课"]},{"title":"计算机网络自学笔记","url":"/2024/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"<p>参考视频：<a\r\nhref=\"https://www.bilibili.com/video/BV1c4411d7jb?p=4&amp;spm_id_from=pageDriver&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0\">计算机网络微课堂-湖科大教书匠</a></p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"一.-导论\">一. 导论</h3>\r\n<ol type=\"1\">\r\n<li><p>网络、互联网、因特网</p>\r\n<p>网络由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。</p>\r\n<p>结点可以是手机/主机/打印机/交换机，链路可以是有线/无线。</p>\r\n<p>多个网络通过<strong>路由器</strong>连接起来，形成<strong>互联网(internet)</strong>。<strong>因特网(Internet)</strong>是最大的互联网。</p>\r\n<p>互联网的通信协议可以是任意的，因特网的通信协议是TCP/IP协议。</p></li>\r\n<li><p>因特网的组成</p>\r\n<p>由边缘部分和核心部分组成。边缘部分就是所有连接在因特网的主机，核心部分就是大量网络和连接这些网路的路由器组成。为连入核心部分的边缘部分提供数据交换服务。</p></li>\r\n<li><p>三种交换方式</p>\r\n<ol type=\"1\">\r\n<li><p>电路交换</p>\r\n<ul>\r\n<li><p>定义：就是很多设备连接到交换机上，交换机感性理解就是有许多入口和出口，它可以指定某个入口的信号发送到某个出口，这样，多个设备就可以同时互不干扰的发送信号了。交换机又可以与交换机相连，扩大网络范围。</p></li>\r\n<li><p>电路交换的步骤：</p>\r\n<ol type=\"1\">\r\n<li>建立连接（给通信俩主机分配一条物理通信线路）</li>\r\n<li>传输信号（这条物理通信线路一直被占用）</li>\r\n<li>释放连接（归还通信资源）</li>\r\n</ol></li>\r\n<li><p>电路交换的优缺点</p>\r\n<ul>\r\n<li>优点\r\n：延迟小，通信线路都双方专属了，能不小吗。而且数据是有序的。</li>\r\n<li>缺点：建立连接时间长；无法做到很多台主机之间同时相互通信（因为俩俩主机通信时就会占用一条通信线路，但是没有那么多通信线路）</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>报文交换</p>\r\n<ol type=\"1\">\r\n<li>定义：就是不建立连接了，也就是不锁死一条通信线路了。而是直接把<strong>报文(发送的数据)</strong>发送到交换机上，然后交换机存储转发给下一个交换机，一直到接收方收到报文为止。</li>\r\n<li>报文交换的优缺点\r\n<ol type=\"1\">\r\n<li>优点：无需建立连接；动态分配线路</li>\r\n<li>缺点：引入了转发时延；需要较大的缓存空间(报文可能很大)</li>\r\n</ol></li>\r\n</ol></li>\r\n<li><p>分组交换</p>\r\n<ol type=\"1\">\r\n<li><p>定义：就是所谓的边缘部分和核心部分，发送方将报文发送到其所连网络中，通过路由器不断的转发，最终转发到接收方中。</p></li>\r\n<li><p>分组交换步骤</p>\r\n<ol type=\"1\">\r\n<li>构造分组：先讲报文划分成若干个等长的数据段，在每个数据段前加上元数据，这些元数据叫首部。</li>\r\n<li>存储转发：路由器在拿到分组后，根据首部进行查表转发，找到合适的转发接口，然后转发给下一个路由器</li>\r\n<li>还原报文：接收方在收到分组后，去掉首部，将数据段组合还原出报文</li>\r\n</ol>\r\n<ul>\r\n<li>Note：对于同一报文的不同分组，分组的路由路径不一定相同，而且分组到达接收者的顺序不一定与发送时的顺序相同。</li>\r\n</ul></li>\r\n<li><p>分组交换的优缺点</p>\r\n<ol type=\"1\">\r\n<li>优点：无需建立连接；简化了存储管理（因为对报文进行了切片，所以路由器的缓存区只需固定即可，不论报文多大都可以切片为分组后转发出去）；减小重发数据量（假设传输过程中出错了，报文交换就要重新发送整个报文，但分组交换只需重发出错的那个分组即可）</li>\r\n<li>缺点：引入了转发时延；更多的元数据信息（切完片后每个分组都有首部）；还原报文时复杂</li>\r\n</ol></li>\r\n</ol></li>\r\n</ol></li>\r\n<li><p>计算机网络的性能指标</p>\r\n<ol type=\"1\">\r\n<li><p>速率</p>\r\n<ol type=\"1\">\r\n<li>8bit = 1B(byte)，kb = <span\r\nclass=\"math inline\">\\(2^{10}\\)</span>B</li>\r\n<li>bit/s (b/s, bps)\r\n（速率的单位都是bit，其余的速率单位也要换算为bit来求解）</li>\r\n<li>kb/s = <span class=\"math inline\">\\(10^3\\)</span> b/s</li>\r\n<li>mb/s = <span class=\"math inline\">\\(10^6\\)</span> b/s</li>\r\n<li>Gb/s = <span class=\"math inline\">\\(10^9\\)</span> b/s</li>\r\n<li>Tb/s = <span class=\"math inline\">\\(10^{12}\\)</span> b/s</li>\r\n</ol>\r\n<ul>\r\n<li>例题：有一个待发送的数据块，大小为100 MB，网卡的发送速率为100\r\nMbps，则网卡发送完该数据块需要多长时间?</li>\r\n<li>100 mbps =<span class=\"math inline\">\\(100 * 10^6\\)</span> b/s</li>\r\n<li>100MB = <span class=\"math inline\">\\(100 * 2^{20} \\cdot 2^3\\)</span>\r\n= <span class=\"math inline\">\\(100 * 2^{23}\\)</span> b</li>\r\n<li>所以t = <span class=\"math inline\">\\(\\frac{2^{23}}{10^6} =\r\n8.388608\\)</span> s</li>\r\n</ul></li>\r\n<li><p>带宽</p>\r\n<ol type=\"1\">\r\n<li>带宽在模电里的定义：即某段频率区间的宽度</li>\r\n<li>带宽在计网中的定义：即最大传输速率，基本单位为b/s，与速率的单位一样</li>\r\n</ol></li>\r\n<li><p>吞吐量</p>\r\n<ol type=\"1\">\r\n<li>定义：表示单位时间内通过某个网络（或信道、接口）的数据量</li>\r\n<li>吞吐量的上限就是带宽。</li>\r\n</ol></li>\r\n<li><p>时延</p>\r\n<ol type=\"1\">\r\n<li>定义：时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</li>\r\n<li>Note：写这类题最好的方法是画图分析！</li>\r\n<li>其中，发送时延是计算机将信息发送到网络中的时延，传播时延是网络的信息传播到路由器的时延，处理时延是路由器存储转发的时延</li>\r\n</ol>\r\n<ul>\r\n<li>例题：<img src=\"1.png\" /></li>\r\n<li>发送时延 = <span class=\"math inline\">\\(\\frac{100MB}{1Mb / s} =\r\n\\frac{100 * 2^{30} * 8}{10^6 b/s} = 838.8608s\\)</span></li>\r\n<li>传播时延 = <span class=\"math inline\">\\(\\frac{1000 * 1000m}{2 * 10^8\r\nm/s} = 0.005s\\)</span></li>\r\n<li><span class=\"math inline\">\\(2.0 \\times\r\n10^8\\)</span>是光纤传播速度</li>\r\n<li><span class=\"math inline\">\\(2.3 \\times\r\n10^8\\)</span>是铜线传播速度</li>\r\n</ul></li>\r\n<li><p>时延带宽积</p>\r\n<ol type=\"1\">\r\n<li>定义：时延带宽积 = 传播时延 * 带宽</li>\r\n<li>把带宽想象成横截面积，传播时延想象为长度，则乘积就是管道的长度。也就是若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个bit。</li>\r\n</ol></li>\r\n<li><p>往返时间</p>\r\n<ol type=\"1\">\r\n<li>定义：双向交互一次所需的时间</li>\r\n</ol></li>\r\n<li><p>利用率</p>\r\n<ol type=\"1\">\r\n<li>信道利用率：表示信道有百分之几的时间是被利用的（有数据通过）</li>\r\n<li>网络利用率：全网络的信道利用率的加权平均</li>\r\n</ol>\r\n<ul>\r\n<li>Note：信道利用率并非越高越好，因为利用率越高，传播时延就越高。</li>\r\n<li>如果令<span\r\nclass=\"math inline\">\\(D_0\\)</span>为网络空闲时的时延，<span\r\nclass=\"math inline\">\\(D\\)</span>为当前的时延，利用率为<span\r\nclass=\"math inline\">\\(U\\)</span>。则有公式：<span\r\nclass=\"math inline\">\\(D = \\frac{D_0}{1 - U}\\)</span></li>\r\n</ul></li>\r\n<li><p>丢包率</p>\r\n<ol type=\"1\">\r\n<li>定义：在一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率</li>\r\n<li>分组丢失的主要两种情况\r\n<ol type=\"1\">\r\n<li>分组在传输过程中出现误码，被结点丢弃</li>\r\n<li>分组在到达分组交换机被丢弃，因为其缓存容量满了</li>\r\n</ol></li>\r\n</ol></li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"二.-计算机网络体系结构总览\">二. 计算机网络体系结构总览</h3>\r\n<ol type=\"1\">\r\n<li><p>计网体系结构的分类</p>\r\n<ol type=\"1\">\r\n<li>OSI体系结构（法律上的国际标准，但没商用）</li>\r\n<li>TCP/IP体系结构（事实上的国际标准，已商用）</li>\r\n<li>原理体系结构（用来教学用的体系结构，是在TCP/IP体系结构上的展开）\r\n<ul>\r\n<li>物理层、数据链路层、网络层、运输层、应用层</li>\r\n</ul></li>\r\n</ol></li>\r\n<li><p>分层的必要性</p>\r\n<ol type=\"1\">\r\n<li>物理层：你需要考虑用什么线(光纤/双绞线)去传输信号，用怎样的物理接口、使用什么信号表示0和1，这些都是物理层要考虑的问题。当把物理层解决的时候，我们就可以实现把信号从本机上发射出去了。</li>\r\n<li>数据链路层：考虑下面这个场景，一条总线，然后连出很多分线到各个主机上。那么，假设其中一台主机向总线发送了数据，那么他的目标主机咋知道流过的bit流是否是发送给自己的？以及，如果协调各个主机发送的信号争用总线的问题？这些都是数据链路层要解决的问题（提前剧透一下，数据链路层引入了MAC的概念，用于区别网络中的主机）。当解决了数据链路层，我们用可以实现一个网络中的信号传输了。</li>\r\n<li>网络层：此时视角来到了很很多路由器、网络、主机的大网络。此时，我们面临着如何标识各网络中各主机的问题（剧透：引入IP地址），以及分组如何选择从源点到目的地的路径。这些问题都划分到网络层去解决。解决了网络层，那么数据就可以在大网络里相互传递了。</li>\r\n<li>运输层：在解决网络层的基础上，假设出现了丢包，或者主机接收到分组后，它咋知道是给QQ？还是给微信？所以，这些都是运输层要考虑的问题。当解决了运输层的时候，就已经可以实现进程之间网络的通信了。</li>\r\n<li>应用层：这一层就是各种应用的协议，比如万维网的http协议，电子邮件的smtp协议，文件传输的ftp协议，通过各种协议+进程间的交互来完成特定的网络应用。</li>\r\n</ol></li>\r\n<li><p>分层思想举例</p>\r\n<p><img src=\"2.png\" /></p>\r\n<ul>\r\n<li>首先，你打开浏览器进程，然后发送一个访问请求，应用层按照http协议构建一个http请求报文，然后丢给运输层。</li>\r\n<li>运输层在http报文的首部添加一个tcp首部，为了区分应用进程和可靠传输，此时成为tcp数据报。</li>\r\n<li>网络层在tcp数据报添加一个ip首部，为了使ip数据报在互联网上运行，此时成为ip数据报。</li>\r\n<li>数据链路层在ip数据报添加一个首部和尾部ETH，为了让其在一个网络/链路上传输，此时成为帧。</li>\r\n<li>物理层在帧前加前导码，然后传输</li>\r\n</ul></li>\r\n<li><p>计网体系结构专用术语</p>\r\n<ul>\r\n<li>专业术语来源于OSI的七层协议体系结构，但也适用于TCP/IP的四层体系结构和五层协议原理体系结构。</li>\r\n</ul>\r\n<p><img src=\"4.png\" /></p>\r\n<ol type=\"1\">\r\n<li><p>实体</p>\r\n<ol type=\"1\">\r\n<li>实体定义：任何可发送或接收信息的硬件或软件进程</li>\r\n<li>对等实体定义：收发双方相同层次中的实体</li>\r\n</ol></li>\r\n<li><p>协议</p>\r\n<ol type=\"1\">\r\n<li><p>定义：控制两个对等实体进行<strong>逻辑通信</strong>的规则的集合。</p>\r\n<ul>\r\n<li>比如http协议是控制在应用层的俩对等实体进行通信的规则。tcp/udp协议就是运输层的协议，ip就是网络层的协议</li>\r\n</ul></li>\r\n<li><p>协议的三要素</p>\r\n<ol type=\"1\">\r\n<li><p>语法：定义所交换信息的格式，例如IP协议所添加的ip数据报格式如下：</p>\r\n<p><img src=\"3.png\" /></p></li>\r\n<li><p>语义：定义收发双方所要完成的操作</p>\r\n<ul>\r\n<li>就是收到报文后双方要做的动作。以http协议为例，接收方收到http请求报文后，先查找，然后返回一个响应报文。</li>\r\n</ul></li>\r\n<li><p>同步：定义收发双方的时序关系</p></li>\r\n</ol></li>\r\n</ol></li>\r\n<li><p>服务</p>\r\n<ol type=\"1\">\r\n<li>定义：在协议的控制下，两个对等实体间的逻辑通信使得本层能向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</li>\r\n</ol>\r\n<ul>\r\n<li>Note：协议是“水平”的，服务是“垂直”的</li>\r\n</ul></li>\r\n<li><p>服务访问点</p>\r\n<ul>\r\n<li>定义：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区别不同的服务类型。</li>\r\n<li>数据链路层的服务访问点为帧的“类型”字段</li>\r\n<li>网络层的服务访问点为IP数据报首部中的“协议字段”</li>\r\n<li>运输层的服务访问点为“端口号”</li>\r\n</ul></li>\r\n<li><p>服务原语</p>\r\n<ol type=\"1\">\r\n<li>定义：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。（没搞懂，以后来填坑）</li>\r\n</ol></li>\r\n<li><p>协议数据单元PDU</p>\r\n<ol type=\"1\">\r\n<li>定义：对等层次之间的数据包称为该层的协议数据单元</li>\r\n</ol>\r\n<ul>\r\n<li>物理层的PDU：比特流</li>\r\n<li>数据链路层的PDU：帧</li>\r\n<li>网络层的PDU：IP数据报</li>\r\n<li>运输层的PDU：TCP报文段</li>\r\n<li>应用层的PDU：报文</li>\r\n</ul></li>\r\n<li><p>服务数据单元SDU</p>\r\n<ol type=\"1\">\r\n<li>定义：同一系统内，层与层之间交换的数据包称为服务数据单元</li>\r\n</ol>\r\n<ul>\r\n<li>Note：多个SDU可以合成为一个PDU，一个SDU也可以划分为几个PDU</li>\r\n</ul></li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"三.-物理层\">三. 物理层</h3>\r\n<ol type=\"1\">\r\n<li><p>物理层的基本概念</p>\r\n<ul>\r\n<li>在计网中，用来连接各种网络设备的传输媒体种类众多，大致可分为两类，一类是导引型传输媒体（双绞线、同轴电缆），一类是非导引型传输媒体（微波通信）。</li>\r\n<li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li>\r\n<li>物理层位数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么</li>\r\n<li>物理层协议的主要任务\r\n<ol type=\"1\">\r\n<li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置</li>\r\n<li>电气特性：指明在接口电缆的各条线上出现的电压的范围</li>\r\n<li>功能特性：指明某条线上出现的某一电平的电压表示何种意义</li>\r\n<li>过程特性：指明对于不同功能的各种可能事件的出现顺序</li>\r\n</ol></li>\r\n</ul></li>\r\n<li><p>物理层下面的传输媒体</p>\r\n<ul>\r\n<li>引导型传输媒体：同轴电缆、双绞线、光纤、电力线</li>\r\n<li>非引导型传输媒体：无线电波、微波、红外线、可见光</li>\r\n</ul></li>\r\n<li><p>传输方式</p>\r\n<ul>\r\n<li>串行/并行传输：\r\n<ul>\r\n<li>串行传输：只需一条线，一个一个bit的传输</li>\r\n<li>并行传输：n条先，n个n个bit的传输，速率位串行传输的n倍</li>\r\n<li>计算机之间的传输通常为串行传输，计算机内部（如果CPU与内存之间的传输通常为并行）</li>\r\n</ul></li>\r\n<li>同步传输/异步传输：\r\n<ul>\r\n<li>同步传输：数据块以bit流传输过去，字节之间没有间隔\r\n<ul>\r\n<li>因为没有间隔，所以必须保证收发双方的时钟频率同步\r\n<ul>\r\n<li>外同步：在收发双方之间添加一条单独的时钟信号线</li>\r\n<li>内同步：发送端将时钟同步信号编码到发送数据中一起传输（例如曼彻斯特编码）</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>异步传输：字节之间有间隙，且间隙时间不固定\r\n<ul>\r\n<li>因为间隙时间不固定，所以叫异步。所以发送端要在每个字节前后加上起始位和结束位</li>\r\n</ul></li>\r\n</ul></li>\r\n<li>单工/半双工/全双工通信：\r\n<ul>\r\n<li>单工(向)通信：通信双方只有一个数据传输方向（例如广播）</li>\r\n<li>半双工通信：通信双方可以互相传数据，但是不能同时进行（例如对讲机）</li>\r\n<li>双工通信：通信双方可以互相传数据，且可以同时进行（例如电话）</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>编码与调制</p>\r\n<ul>\r\n<li><p>信号都是发到信道中，信道不等于传输媒体。如果是单工传输，那么传输媒体中只有一个信道。而对于半双工和全双工传输，传输媒体中就有两个信道。</p></li>\r\n<li><p>以下是几种常用编码技术：</p>\r\n<ol type=\"1\">\r\n<li>不归零编码：就是010101直接传，缺点就是接受双方时钟频率必须一样</li>\r\n<li>归零编码：就是10(-1)(0)1010(01)0这样传，接收方只需在信号归零时进行采样即可，无需保证双方时钟频率必须一样。但是缺点就是一般的编码内容都给归零了，浪费资源</li>\r\n<li>曼彻斯特编码：每个码元的中间时刻都会发生信号跳变，跳变既表示了时钟也表示了数据</li>\r\n<li>差分曼彻斯特编码：一样是用跳变，但是跳变仅表示时钟，数据要看每个码元开始处的电平与上一个码元结束处电平是否变化，来表示数据</li>\r\n</ol></li>\r\n<li><p>调制是指把数字信号调制为可以发出去的信号。</p></li>\r\n<li><p>以下是一个基本调制方法：</p>\r\n<ul>\r\n<li>正交振幅调制QAM，例如QAM16，它调制出的波形可以有12种相位，每种相位有1或2种振幅可选。故可调制出16种码元（看图）</li>\r\n</ul>\r\n<p><img src=\"5.png\" /></p>\r\n<ul>\r\n<li>每个码元可以表示4个bit信息。码元与4位bit信息之间的对应关系采用格雷码。</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>信道的极限容量</p>\r\n<ul>\r\n<li>奈氏准则（没考虑噪声）：\r\n<ul>\r\n<li>理想低通信道的最高码元传输速率：2 * W(信道带宽，单位Hz) (码元 /\r\n秒)</li>\r\n<li>理想带通信道的最高码元传输速率：W (码元 / 秒)</li>\r\n<li>码元 / 秒与bit / s的换算，若一个码元携带n个比特，则码元 / 秒 = n\r\nbit/s</li>\r\n</ul></li>\r\n<li>香农公式：\r\n<ul>\r\n<li><span class=\"math inline\">\\(c = W \\times\r\n\\log_2(1+\\frac{S}{N})\\)</span></li>\r\n<li>c：信道的极限信息传输速率(bit/s)</li>\r\n<li>W：信道带宽（Hz）</li>\r\n<li>S：信道内所传信号的平均功率</li>\r\n<li>N：信道内的高斯噪声功率</li>\r\n<li>S/N：信噪比（dB）</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p>信道复用技术</p>\r\n<ul>\r\n<li>频分复用(FDM)、时分复用(TDM)、统计时分复用\r\n<ul>\r\n<li>略</li>\r\n</ul></li>\r\n<li>波分复用\r\n<ul>\r\n<li>略</li>\r\n</ul></li>\r\n<li>码分复用\r\n<ul>\r\n<li>打个比方，FDM是不同的组在不同的房间里说话，TDM是不同的人在不同的时刻说话，CDMA是不同的人使用不同的语言说话</li>\r\n<li>CDMA技术可以让不同用户在同样的时间使用同样的频率进行通信。为什么能做到呢？因为每个用户有一个唯一标识符——码型(芯片序列)</li>\r\n<li>码型有m位，用1代表1，-1代表0。且要保证不同用户的码型俩俩正交，这样才可以互不干扰同时发送。</li>\r\n<li>用<span class=\"math inline\">\\(S,\r\nT\\)</span>表示俩用户的码型，那么有<span\r\nclass=\"math inline\">\\(S^\\mathrm{T}T=0\\)</span>，说明对应位相等的个数与对应位不等的个数一样。那么可推导出<span\r\nclass=\"math inline\">\\(S^\\mathrm{T}\\overline{T} =\r\n0\\)</span>。取反后对应位原本相等的就变不等了，原本不等的就变相等了，但个数还是一样的。</li>\r\n<li>OK，然后如果一个用户要发送一个1，那么就把自己的码型发出去(1\r\nbit时)，如果发送0，就把自己的反码发出去(1 bit时)。</li>\r\n<li>如果n个用户同时发送一个bit信息，那么n个码型线性叠加在一起记为W，然后丢给接收站点。</li>\r\n<li>如果想得到用户1，也就是码型为S的那个人在这一时刻发送的bit信号时什么，就拿它的码型S与叠加后码型W做点乘。即<span\r\nclass=\"math inline\">\\(S \\cdot\r\nW\\)</span>。若结果为1，则这一时刻用户1发了一个1；如果结果为-1，则它发了一个0；如果结果为0，则它在这一时刻啥都没发。</li>\r\n<li>原理非常好理解，把W展开，除了自身码型，其余码型相乘后因为正交都为0了。只剩自己了（若这一时刻没发就连自己都没有），然后自己与自己相乘就是1。</li>\r\n</ul></li>\r\n</ul></li>\r\n</ol>\r\n","categories":["4. 大学","计算机专业课"]},{"title":"算法刷题笔记","url":"/2024/02/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","content":"<p>信息学竞赛刷题笔记</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"思维题\">思维题</h3>\r\n<ul>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/97/\">95.\r\n费解的开关 - AcWing题库</a></p>\r\n<ul>\r\n<li>经过思考后，发现一个开关按2次与没按没差别。所以对于每个开关，要不就按，要不就不按。继续思考，对于一个开关，它的状态取决于它自己以及上下左右共5个开关按or不按，而且跟顺序无关。</li>\r\n<li>接着往下想，既然与顺序无关，那我就可以从第一个开始按。假设（1，1）按了，那么...\r\n...感觉还是不好想。</li>\r\n<li>这时要学会给自己增加已知信息。假设我第一行开关按or不按已经知道。那么我就可以推出第二行的按法。因为当第一行按完之后，能改变第一行状态的只有第二行（不能再按第一行了，因为按两次等于没按）。所以如果（1，j）是0，那么（2，j）就要按。</li>\r\n<li>思路就出来了，枚举第一行的按法，然后推出第二行按法，继续推出第三行按法，直至推出第五行按法。此时1-4行都是1了，最后检查第5行是否全是1即可。</li>\r\n</ul></li>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/107/\">105. 七夕祭\r\n- AcWing题库</a></p>\r\n<ul>\r\n<li><p>首先很容易看出行和列是独立的问题，而且本质是一样的。所以接下来都讨论列。</p></li>\r\n<li><p>然后略加思考也可以发现最终每列的数量就是全部列加起来取平均，取不了平均就没解。</p></li>\r\n<li><p>假设a1, a2, ...,\r\nan平均值为avg，假设1号给2号b1个，2号给3号b2个，n号给1号bn个。则所求可表达为：<span\r\nclass=\"math inline\">\\(|b_1|+|b_2|+...+|b_n|\\)</span>。且有下列方程组成立：\r\n<span class=\"math display\">\\[\r\na1 - b1 + bn = avg \\\\\r\na2 - b2 + b1 = avg \\\\\r\na3 - b3 + b2 = avg \\\\\r\n... \\\\\r\nan - bn + b_{n-1} = avg\r\n\\]</span></p></li>\r\n<li><p>整理可得</p></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n-b_1+b_n = avg - a_1 \\\\\r\n-b_2+b_n = 2avg - (a_1+a_2) \\\\\r\n-b_3+b_n = 3avg - (a_1+a_2+a_3) \\\\\r\n...\r\n-b_{n-1}+b_n = (n-1)avg - (a_1+a_2+...+a_{n-1})\r\n\\]</span></p>\r\n<ul>\r\n<li>继续整理</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nb_1 = -avg + a_1 + b_n \\\\\r\nb_2 = -2avg + (a_1 + a_2) + b_n \\\\\r\n... \\\\\r\nb_{n-1} = -(n-1)avg + (a_1+a_2+...+a_{n-1})\r\n\\]</span></p>\r\n<ul>\r\n<li>继续整理</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nb_1 = b_n - avg + a_1 \\\\\r\nb_2 = b_n - 2avg + (a_1+a_2) \\\\\r\n...\\\\\r\nb_{n-1} = b_n - (n-1)avg + (a_1+a_2+...+a_{n-1})\r\n\\]</span></p>\r\n<ul>\r\n<li>令x = bn，则所求为：<span\r\nclass=\"math inline\">\\(|x-c1|+|x-c2|+...+|x-c_{n-1}|+|x - c_n|,\r\nc_n=0\\)</span></li>\r\n<li>一目了然，x取c的中位数时，所求最小。</li>\r\n</ul></li>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/1535/\">1533. 1\r\n的个数 - AcWing题库</a></p>\r\n<ul>\r\n<li>考虑每一位能出现多少次1。</li>\r\n</ul>\r\n<p><img src=\"2.png\" /></p>\r\n<ul>\r\n<li>如上图，考虑d，如果d是0。那么当d这一位取1的话，左边只能是000 ~\r\n(abc-1)，右边可以是000 ~ 999。上图都清晰明了了，分情况讨论即可。</li>\r\n</ul></li>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/1643/\">1641.\r\n狼人杀-简单版 - AcWing题库</a></p>\r\n<ul>\r\n<li>枚举哪两个人是狼人，那么此时所有人的身份就确定了。然后检查两个条件。(1):\r\n是否有且仅有两个人在说谎；(2):\r\n俩狼人中是否有且仅有一个人在说谎。若俩条件满足则是一组解。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"基础算法\">基础算法</h3>\r\n<h4 id=\"位运算\">位运算</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/92/\">90.\r\n64位整数乘法 - AcWing题库</a>\r\n<ul>\r\n<li>计算a * b %\r\np的结果。O(1)即可得出结果，但是a和b的范围很大会爆longlong。所以要用时间换空间。考虑a\r\n* b = a * (b的二进制表示)，例如a * 5 = a * (101) = a * (4 + 0 +\r\n1)。于是很容易的想到用logn的时间去分解b，用个中间变量sum对自己做累加（sum初始值为a），这样sum就会等于a\r\n，然后等于2a，然后等于4a...\r\n...。分解b的过程中如果最后一位二进制是1，就ans +=\r\nsum即可。这种用加法代替乘法的方法，叫做龟速乘。</li>\r\n<li>注意，%的优先级比+高。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/877/\">875. 快速幂 -\r\nAcWing题库</a>\r\n<ul>\r\n<li>计算<span class=\"math inline\">\\(a^b %\r\np\\)</span>的结果。思路跟龟速乘一样，都是分解b。考虑<span\r\nclass=\"math inline\">\\(a^b = a^{b的二进制形式}\\)</span>，例如<span\r\nclass=\"math inline\">\\(a^5 = a^{101} = a^{4 + 0 + 1} = a^4 *\r\na^1\\)</span>。用while去分解b的二进制，用个中间变量sum对自己做累乘（sum初始值为b），如果分解过程中b的最后一位二进制是1，就ans\r\n*= sum即可。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"递归分治\">递归/分治</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/description/99/\">97.\r\n约数之和 - AcWing题库</a>\r\n<ul>\r\n<li>求<span\r\nclass=\"math inline\">\\(a^b\\)</span>的所有约数之和。不难想到分解质因数。假设数num分解为<span\r\nclass=\"math inline\">\\(p_1^{k1} \\cdot p_2^{k2} \\cdot ... \\cdot\r\np_n^{kn}\\)</span>，那么数num的约数的个数就是(k1 + 1) * (k2 + 1) * ... *\r\n(kn +\r\n1)（相当于每个质数是材料，可以拿0/1/2/...个）。数num的约数之和就是<span\r\nclass=\"math inline\">\\((1+p_1+p_1^2+...+p_1^{k1}) \\cdot\r\n(1+p_2+p_2^2+...+p_2^{k2}) \\cdot ... \\cdot\r\n(1+p_n+p_n^2+...+p_n^{kn})\\)</span>。</li>\r\n<li>上面的数学推导作为一个大学生不难想出。那么这题思路就是先将a分解质因数，然后将每个质数的次数乘b。然后求<span\r\nclass=\"math inline\">\\((1+p_1+p_1^2+...+p_1^{k1}) \\cdot\r\n(1+p_2+p_2^2+...+p_2^{k2}) \\cdot ... \\cdot\r\n(1+p_n+p_n^2+...+p_n^{kn})\\)</span>即可。</li>\r\n<li>关键<span\r\nclass=\"math inline\">\\((1+p_1+p_1^2+...+p_1^{k1})\\)</span>怎么求，其实这种看起来有规律的东西都是用递归去加速，根据直觉尝试一下，假设sum\r\n= 1, mul = p1，然后while( sum += mul, mul *= mul )。第一次：sum=1+p1,\r\nmul=p1<sup>2；第二次：sum=1+p1+p1</sup>2+p1^3, mul = p1^4...\r\n...你看，这不就出来了。</li>\r\n<li>递归是俩倍俩倍去递归的，所以最后可能剩一点边角料。假设<span\r\nclass=\"math inline\">\\(p_1^{cnt}\\)</span>到<span\r\nclass=\"math inline\">\\(p_1^{k1}\\)</span>还没求，很简单，直接递归调用函数cal(p1,\r\nk1-cnt) * ksm(p1, cnt)</li>\r\n<li>这题坑点较多，注意b有可能为0。注意a可能为0/1。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/100/\">98. 分形之城 -\r\nAcWing题库</a>\r\n<ul>\r\n<li>一道找规律模拟题，挺恶心的。本质上就是给一个数num，找出其对应的坐标（x,\r\ny）。观察后不难发现，num会落到4个区，其中2、3区的区内坐标就等于上一个等级的对应数的坐标。1区的区内坐标等于上一个等级的对应数的坐标沿[左上到右下对角线]对称的坐标。4区的区内坐标等于上一个等级的对应数的坐标沿[右上到左下对角线]对称的坐标。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"前缀和差分\">前缀和/差分</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/101/\">99. 激光炸弹 -\r\nAcWing题库</a>\r\n<ul>\r\n<li>简单二维前缀和</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/102/\">100. 增减序列\r\n- AcWing题库</a>\r\n<ul>\r\n<li>差分题。最关键的一步是要联想到看一看差分数组。做题多就有经验了，这种区间操作问题一般要想到转换为差分数组，然后区间操作问题就转为端点修改问题。</li>\r\n<li>将a转化为差分数组b后，这题就变成了，将b2~bn全部变为0的最少次数是多少？在最少次数的前提下，b1有多少种取值方式？每一次区间操作等价于将<span\r\nclass=\"math inline\">\\(b_i\\)</span>加或减1，<span\r\nclass=\"math inline\">\\(b_j\\)</span>加或减1（i &lt; j &amp;&amp; 1 &lt;= i\r\n&lt;= n &amp;&amp; 2 &lt;= j &lt;= n + 1）</li>\r\n<li>然后由于贪心思想，尽可能将b2~bn中的正负数抵消掉。剩下抵消不掉的数的绝对值+1其实就是b1的不同取值个数。因为剩下不能凑对抵消的只能通过和b1或者<span\r\nclass=\"math inline\">\\(b_{n+1}\\)</span>凑对来抵消。选择用b1凑对多少次，b1就有多少种取值方式。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"二分\">二分</h4>\r\n<ul>\r\n<li><a\r\nhref=\"https://www.acwing.com/problem/content/description/104/\">102.\r\n最佳牛围栏 - AcWing题库</a>\r\n<ul>\r\n<li>看到平均数就想到整体减平均数，假设答案是一个数，然后每个数减掉这个数，那么只要找出一段区间长度&gt;=f的区间和&gt;=0就可以了。只要找出这样的区间。说明答案还可以更大，如果找不出，答案就要减小。所以二分答案即可。</li>\r\n<li>关键是如何找到“一段区间长度&gt;=f的区间和&gt;=0”，如果没有区间长度限制O(n)扫一遍用最大连续子段和即可。主要有区间限制，那么就多开一个数组minn[i]表示截止到0\r\n~\r\ni位置中sum[i]中的最小值即可。（其实这也是最大连续子段和的另一种做法）</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1484/\">1482. 进制 -\r\nAcWing题库</a>\r\n<ul>\r\n<li>首先将已知进制的数转为十进制。然后枚举另一个数的进制即可。但是另一个数的进制可能非常大。而且满足进制数越大，转换后的数就越大。所以可以二分。二分右边界是多少呢？极端一点，假设第二个数是10，第一个数是target进制。那么右端点至少要到（第一个数拉满的target进制转为的十进制）才行。</li>\r\n<li>坑点：如果当前数为tar进制，那么当前数的每一位数都要在[0,\r\ntar)中。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"排序\">排序</h4>\r\n<ul>\r\n<li><a\r\nhref=\"https://www.acwing.com/problem/content/description/115/\">113.\r\n特殊排序 - AcWing题库</a>\r\n<ul>\r\n<li>本质上就是裸排序题，用归并或者快排把&lt;号换成题中的compare即可。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"贪心\">贪心</h3>\r\n<ul>\r\n<li><a\r\nhref=\"https://www.acwing.com/problem/content/description/1519/\">1517.\r\n是否加满油 - AcWing题库</a>\r\n<ul>\r\n<li>很多细节的贪心模拟题。</li>\r\n<li>思路就是在当前加油站，在最远能行驶的距离之内找到第一个价钱比当前加油站低的加油站，然后开过去。如果找不到，就找价钱最少的，然后在当前加油站加满油开过去。如果一个加油站都找不到，就输出无解。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"数学\">数学</h3>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/1588/\">1586.\r\n连续因子 - AcWing题库</a>\r\n<ul>\r\n<li>用分解因数的方法去枚举连续因子的开头，然后对于每个开头，看看最多能连多少个，取个max即可。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"数据结构\">数据结构</h3>\r\n<h4 id=\"链表\">链表</h4>\r\n<ul>\r\n<li><a\r\nhref=\"https://www.acwing.com/problem/content/description/828/\">826.\r\n单链表 - AcWing题库</a>\r\n<ul>\r\n<li>其实上链表的模拟题几乎都可以用数组去做。</li>\r\n<li>其实用数组模拟的思路很暴力，假设有N次操作，那么就实例化N个结构体对象。给每次操作分配一个node，每个node里有l,\r\nr,\r\nx。然后按照题目要求改变node的l、r即可。（l、r初始为-1，a[0]为虚拟头节点）</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"并查集\">并查集</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/1252/\">1250.\r\n格子游戏 - AcWing题库</a>\r\n<ul>\r\n<li>乍一看题目觉得很复杂，但实际上想到把二维转为一维就简单了。给每一个二维坐标赋予一个独一的一维坐标。每次一条边就是将两个点merge起来。如果一条边的两个点已经在一个集合里面了，说明产生了环。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1254/\">1252.\r\n搭配购买 - AcWing题库</a>\r\n<ul>\r\n<li>将所有捆绑在一起的东西看作一个物品，然后01背包即可。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/239/\">237.\r\n程序自动分析 - AcWing题库</a>\r\n<ul>\r\n<li>对于一组约束，将相等条件都用并查集并起来。然后依次检查不相等条件的两个点是否在同一集合中，如果在就是NO。全部检查完没问题就是YES。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/241/\">239. 奇偶游戏\r\n- AcWing题库</a>\r\n<ul>\r\n<li>这题涉及到区间问题，都应该往是否可以转换成“前缀和数组和差分数组上的区间俩端点“问题这个方向思考。这题考虑前缀和数组sum，区间[l,\r\nr]有偶数个1说明sum[r]与sum[l - 1]的奇偶性相同，区间[l,\r\nr]有奇数个1说明sum[r]与sum[l - 1]的奇偶性不同。</li>\r\n<li>看出这个后这题就好做了，二分M，每次检查前mid个条件是否满足。显然满足当且仅当是一个二分图，那么用染色法就检查前mid个条件形成的图是不是一个二分图即可。</li>\r\n<li>这题其实我还这样想过，就是用的[程序自动分析]这题的思路：二分M，每次检查前mid个条件是否满足。检查方法使用并查集，先将前mid个条件中相同条件的俩元素并起来，再检查前mid个条件中不相同条件的俩元素是否在同一集合，在就return\r\n0。都检查完了没问题就return 1。</li>\r\n<li>但上面这样想是错的，因为这题是有个隐藏条件的，任意一个元素，它不是奇数，就是偶数。所以上面并查集的做法是无法做到保证只有两个集合的。例如下面这个例子：</li>\r\n<li><img src=\"1.png\" /></li>\r\n<li>通过三句红话其实可以推出这些条件无法共存（不是二分图）。但是上面的并查集做法是检查不出来的。</li>\r\n<li>如果要用并查集的话要用这种思路：维护d[x]，表示x与父亲的奇偶性（如果俩点奇偶性相同则为0，不相同则为1）。在更新fat[x]的时候顺便更新一下d[x]，那么更新完后d[x]就成为了x与祖先的奇偶性。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/240/\">238.\r\n银河英雄传说 - AcWing题库</a>\r\n<ul>\r\n<li>跟上一题一样维护d[x]，表示x到父亲的距离。也是在更新fat[x]时顺便更新一下d[x]即可，更新完后d[x]就成为了x到祖先的距离。</li>\r\n<li>这题在merge时会用到并查集大小信息，所以还要多维护一个siz[x]。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1555/\">1553. 用\r\nSwap(0, i) 操作进行排序 - AcWing题库</a>\r\n<ul>\r\n<li>很巧妙的解法，没做过很难想出来。</li>\r\n<li>如果当前位置i上的数是x，那么x向i连一条边。最终形成的图是一个个环。最终想到达到的目的就是n个自环。考虑交换操作会对这个图产生什么影响。如果0跟不在一个环的数交换，那么两个环会合并。如果0跟在一个环的数交换，那么环会分裂成两个。贪心的想，先把所有跟0不在一个环的环合并到0这个环上，然后再一个一个元素分裂出去形成自环即可。那么用并查集维护一下就好了。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"对顶堆\">对顶堆</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/108/\">106.\r\n动态中位数 - AcWing题库</a>\r\n<ul>\r\n<li>将数分为较大的一部分和较小的一部分。而且保证较大一部分的数的数量在偶数时与较小一部分的数的数量相等，在奇数时较大一部分的数的数量比较小一部分数的数量大1。</li>\r\n<li>用小根堆b维护较大的一部分，大根堆a维护较小的一部分。每次一进来一个数t，先与b.top()（也就是较大一部分中的最小的数）比较，如果比b.top()小，则把t插入a中。反之，把t插入b中。</li>\r\n<li>然后就要保证两个堆之间的数量关系。维护一下即可。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1545/\">1543. 栈 -\r\nAcWing题库</a>\r\n<ul>\r\n<li>相对于上面一题，就多了一个删除操作。</li>\r\n<li>使用multiset，这玩意内部是自动从小到大排序的。支持插入、删除、用迭代器访问，两个堆分别用俩multiset代替就行了。</li>\r\n<li>删除要a.erase(a.find(x))，而不是a.erase(x)，后者会把所有x全删掉。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"优先双端队列\">优先/双端队列</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/1543/\">1541.\r\n世界首富 - AcWing题库</a>\r\n<ul>\r\n<li>把每个人的信息都用结构体记录下来，然后对于每个查询，二分找到左右端点，然后对区间内的点重新sort一遍。这种做法时间过不去，因为n有1e5。极端情况每次查询都要对1e5个元素重新sort。</li>\r\n<li>看题目年龄最多200，所以考虑以年龄作为索引。相当于每个年龄开一条链，然后把对应年龄人的信息链上去。</li>\r\n<li>输出规定年龄区间内前m个人的信息，其实就是一个多路合并问题。用一个优先队列解决。</li>\r\n<li>（P.S.\r\nvector类型可以定义为pair/struct，写一个排序函数cmp即可。但是priority_queue里若想实现自己定义的规则，不要用pair最好用struct，而且不是写排序函数，而是写一个重载&lt;的规则，注意规则内部大于要变小于，小于要变大于）</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"线段树\">线段树</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/1275/\">1273.\r\n天才的记忆 - AcWing题库</a>\r\n<ul>\r\n<li>区间查询最大值。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/248/\">242.\r\n一个简单的整数问题 - AcWing题库</a>\r\n<ul>\r\n<li>区间修改，单点查询。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/244/\">243.\r\n一个简单的整数问题2 - AcWing题库</a>\r\n<ul>\r\n<li>区间修改，区间查询。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1279/\">1277.\r\n维护序列 - AcWing题库</a>\r\n<ul>\r\n<li>区间修改（乘法加法），区间查询。</li>\r\n<li>假设sum' = sum * a + b，那么加一个数sum' + c = sum * a + (b +\r\nc)，相当于加法标记加了个c；乘一个数sum' * c = sum * ac +\r\n(bc)，相当于加法和乘法标记都自乘了个c。所以就这样维护俩标记即可，然后按照sum\r\n= sum * mul + add的规则去更新sum即可。</li>\r\n<li>但如果假设sum' = (sum + a) * b，那么加一个数sum' + c = sum * b + ab\r\n+ c，你看，就不好可持续性维护了。</li>\r\n<li>这题注意build初始化时每个t[p]的mul标记都要初始化为1。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1277/\">1275. 最大数\r\n- AcWing题库</a>\r\n<ul>\r\n<li>动态维护后L个数中的最大值，可以发现数组的数量是只会增加不会减少的，而且数组元素数量最多增长到2e5。所以对数组下标建一颗线段树维护区间最大值即可。单点修改\r\n+ 区间查询。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/246/\">245.\r\n你能回答这些问题吗 - AcWing题库</a>\r\n<ul>\r\n<li>考虑t[p]的最大子段和sm如何转移：max(t[p1].sm, t[p2].sm,\r\n跨过mid的最大子段和)。跨过mid的最大子段和 = t[p1]的最大后缀和 +\r\nt[p2]的最大前缀和。</li>\r\n<li>所以t[p]需要维护最大子段和sm，最大前缀和lm，最大后缀和rm，在维护lm,\r\nrm时还会用到区间和sum。</li>\r\n<li>查询区间[l, r]时，ask函数应返回一个Tree类型，当l &lt;= mid &lt;=\r\nr（mid = (t[p].l + t[p].r) / 2）时，可以通过子树t1,\r\nt2表示出状态。如果不返回Tree类型的话，就没有子树t1,\r\nt2的信息，状态不好表示出来。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/247/\">246.\r\n区间最大公约数 - AcWing题库</a>\r\n<ul>\r\n<li>由更相减损术可知gcd(a, b) = gcd(a, b -\r\na)。次公式可扩展到多个变量：gcd(a, b, c, d) = gcd(a, b - a, c - b, d -\r\nc)，这其实就是差分形式。所以可以线段树维护原数组的差分数组的区间gcd和区间和，那么操作1就是单点修改（单点修改那可以完全不用考虑懒标记问题了很舒服），操作2求gcd(A[l],\r\nA[l + 1], A[l + 2], ..., A[r]) = gcd(A[l], A[l + 1] - A[l], A[l + 2] -\r\nA[l + 1], ..., A[r] - A[r - 1]) = gcd(差分数组[1 ~ l]之和，差分数组[l +\r\n1到r]的gcd)。</li>\r\n<li>这题有俩小细节，第一差分单点修改r +\r\n1有可能到n外边去，第二查询时如果l = r则要特判下。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/249/\">247.\r\n亚特兰蒂斯 - AcWing题库</a>\r\n<ul>\r\n<li>扫描线算法，扫描线算法是个比较死的算法，因为其有一个特殊性质：线段是成对出现的。</li>\r\n<li>做法两种，我喜欢这种：维护区间最小值min和区间最小值的长度minlen。这样，如果t[1].min\r\n= 0，则被覆盖的长度 = 全部长度 - t[1].minlen。如果t[1].min !=\r\n0，则被覆盖的长度 =\r\n全部长度。区间最小值和区间最小值长度都非常好维护，区间修改就是给最小值打个懒标记即可，不用管minlen，因为最小值加一个数减一个数仍然是最小值，minlen不会变。</li>\r\n<li>上面就是扫描线的做法。所以扫描线很简单，关键这题的细节处理有点点小麻烦。</li>\r\n<li>一，坐标都是小数，所以需要离散化处理成整数才能建线段树。二，t[p]管理的实际区间为getVal(t[p].r\r\n+ 1) -\r\ngetVal(t[p].l)，因为只有这样，线段树的子节点才可以初始化minlen，不然minlen不好初始化。三，离散化的俩函数getRank,\r\ngetVal的参数类型要注意。</li>\r\n</ul></li>\r\n<li><a href=\"https://ac.nowcoder.com/acm/contest/67742/H\">H-Tokitsukaze\r\nand Power Battle (hard)_2024牛客寒假算法基础集训营2</a>\r\n<ul>\r\n<li>是“最大区间和”的变形题。</li>\r\n<li>考虑i，j的位置，如果i，j都在mid左边是一种情况，即t[p].ans =\r\nt[p1].ans。如果i，j都在mid右边是一种情况，即t[p].ans =\r\nt[p2].ans。如果i，j分布在mid两边，则需要考虑x(即中间砍的那一刀)的位置。</li>\r\n<li>如果砍的一刀在mid, mid + 1之间，则t[p].ans =\r\nt[p1].包含右端点的最大后缀和 - t[p2].包含左端点的最小前缀和。</li>\r\n<li>如果砍的一刀在左半边，则t[p].ans = t[p1].包含右端点的答案 -\r\nt[p2].包含左端点的最小前缀和。</li>\r\n<li>如果砍的一刀在右半边，则t[p].ans = t[p1].包含右端点的最大后缀和 +\r\nt[p2].包含左端点的答案。</li>\r\n<li>所以t[p].ans就是在上面几种情况取max。发现用到了“包含右端点的最大后缀和rmax”，“包含左端点的最小前缀和lmin”，“包含右端点的答案rans”，“包含左端点的答案lans”，rmax和lmin很好维护，现在来看lans和rans如何维护。</li>\r\n<li>先考虑t[p].lans。此时i是卡死的就在l上，考虑j的位置。如果j左半边，则t[p].lans\r\n= t[p1].lans。如果j在右半边，则考虑砍的一刀位置，如果砍在mid,\r\nmid+1中间，则t[p].lans = t[p1].sum -\r\nt[p2].lmin；如果砍在左半边，则t[p].lans = t[p1].包含左右端点的答案 -\r\nt[p2].lmin；如果砍在右半边，则t[p].lans = t[p1].sum + t[p2].lans。</li>\r\n<li>t[p].rans同理。发现在维护这俩的时候还用到了\"包含左右端点的答案lrans\"。</li>\r\n<li>现在考虑t[p].lrans。因为i，j都定死了，所以只需考虑砍的一刀的位置。如果砍在mid,mid+1中间，则t[p].lrans\r\n= t[p1].sum - t[p2].sum。如果砍在左半边，则t[p].lrans = t[p1].lrans -\r\nt[p2].sum。如果砍在右半边，则t[p].lrans = t[p1].sum + t[p2].lrans。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"树状数组\">树状数组</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/109/\">107.\r\n超快速排序 - AcWing题库</a>\r\n<ul>\r\n<li>求逆序对。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/243/\">241. 楼兰图腾\r\n- AcWing题库</a>\r\n<ul>\r\n<li>简单的求每个数之前比它大的数的个数。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/245/\">244.\r\n谜一样的牛 - AcWing题库</a>\r\n<ul>\r\n<li>最后一头牛的高度是确定的，在确定最后一头牛高度后，倒数第二头牛的高度也确定了，依次类推。假设现在要求第i头牛的高度，则若数组c的区间和[1,\r\nk] = 比第i头牛矮的牛数量 + 1，则第i头牛的高度为k（最开始每个位置的c[i] =\r\n1）。</li>\r\n<li>区间和查询用树状数组，找高度时配合二分。找到该牛高度k后，upd(x,\r\n-1)。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"字典树\">字典树</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/837/\">835.\r\nTrie字符串统计 - AcWing题库</a>\r\n<ul>\r\n<li>板子题，字典树空间一般不知道开多少合适，建议用vector。就比如这题，开个vector&lt;Node&gt;\r\na。Node结构体里放指向信息，这题的指向信息有26个，就在Node里开一个alpha[26]。</li>\r\n<li>从根节点编号0出发，若a[0].alpha[k] =\r\n0，那就新开一个点，a[0].alpha[k] = ++dex,\r\na.push_back(tmp)即可。然后编号跳到a[0].alpha[k]，继续依次类推。</li>\r\n<li>通过这种方法，就不需要考虑空间应该开多大了。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/145/\">143.\r\n最大异或对 - AcWing题库</a>\r\n<ul>\r\n<li>思考每个数的二进制形式，将每个数的二进制形式insert到字典树中（字典树就两个指向信息p[0/1]），然后对于每个数，依次扫二进制的每一位数k，在字典树里找a[p].nxt[k\r\n^\r\n1]是否存在，存在p就指向它，不存在就指向a[p].nxt[k]。在过程中统计答案求最大值即可。</li>\r\n</ul></li>\r\n<li><a\r\nhref=\"https://www.acwing.com/problem/content/description/258/\">256.\r\n最大异或和 - AcWing题库</a>\r\n<ul>\r\n<li>涉及到区间异或运算，所以尝试是否可以前缀和/差分转化为单点运算，发现是可以的。考虑维护前缀异或数组，s[i]\r\n= a[1] ^ a[2] ... ^ a[i]，这样a[p] ^ a[p + 1] ^ a[p + 2] ^ ... ^ a[n] =\r\ns[n] ^ s[l - 1]。所以所求为x ^ s[n] ^ s[p - 1]。(x ^\r\ns[n])是一个定值C，所以就是在[l - 1, r - 1]内找一个数s[i]，使得s[i] ^\r\nC最大。所以就是可持久化Trie树。</li>\r\n<li>可持久化Trie树就是每次添加一条链，具体算法是p = root[now], q =\r\nroot[now - 1]。然后p的所有子节点除了新链上的点，复制q的节点，然后p =\r\nt[p][k] = ++dex, q = t[q][k]。再递归进行直至把这条链添加进Trie树。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"模拟\">模拟</h3>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/1496/\">1494.\r\n银行排队 - AcWing题库</a>\r\n<ul>\r\n<li>还行的一道模拟题，考虑时间轴，每个人要等的时间 = 到他的时间 -\r\n他到的时间。用一个优先队列维护正在办理业务的人，按照谁先结束排序。</li>\r\n<li>通过这题可以学到priority_queue是可以自定义排序规则的，只需要重载&lt;号（类型一定要是结构体不能是pair）</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1559/\">1557.\r\n说话方式 - AcWing题库</a>\r\n<ul>\r\n<li>坑点比较多，有可能有ab:cc/a:::bcc/a:aa:b...的情况。</li>\r\n<li>通过这题可以学到map也是可以排序的。只需要vector&lt;PAIR&gt;\r\nvec(mp.begin(),\r\nmp.end())，即可把mp转换成一个vector。然后用sort对vector排序即可。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1488/\">1486.\r\n排队等候 - AcWing题库</a>\r\n<ul>\r\n<li>跟“银行排队”那题比较像，这题多了一个“等待区”的概念，而且没有了具体的时间。所以不像上一题好写。所以学会自己给自己增加条件，用一个循环模拟时间线（因为17点下班所以复杂度不会很高）。然后对于当前第T秒，先把每个窗口办理完手续的人赶出去，然后再依次把人放进等待区，分配到对应的窗口。</li>\r\n<li>这题坑点是即使一个人它开始办理业务的时间超过了17点，它也要分配到对应的窗口，因为对于他自己，是不知道前面的人需要多久的，所以他肯定会排进某个窗口的队里。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"dp\">DP</h3>\r\n<h4 id=\"背包\">背包</h4>\r\n<ul>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/2/\">2. 01背包问题\r\n- AcWing题库</a></p>\r\n<ul>\r\n<li>01背包，复杂度O(n * m)，一维倒序</li>\r\n</ul></li>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/3/\">3.\r\n完全背包问题 - AcWing题库</a></p>\r\n<ul>\r\n<li>完全背包，复杂度O(n * m)，一维正序</li>\r\n</ul></li>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/4/\">4.\r\n多重背包问题 I - AcWing题库</a></p>\r\n<ul>\r\n<li>朴素多重背包，复杂度O(n * m * s)，当成01背包做</li>\r\n</ul></li>\r\n<li><p><a\r\nhref=\"https://www.acwing.com/problem/content/description/5/\">5.\r\n多重背包问题 II - AcWing题库</a></p>\r\n<ul>\r\n<li>二进制优化多重背包，复杂度O(n * m * logs)</li>\r\n<li>原理即用1、2、...、exp、s - exp凑出[1, s]总中任意一个数</li>\r\n</ul></li>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/6/\">6.\r\n多重背包问题 III - AcWing题库</a></p>\r\n<ul>\r\n<li>单调队列优化多重背包，复杂度O(n * v_max),\r\nv_max为物品中最大的体积</li>\r\n<li>先列出递推表达式，然后把j - v, j - 2v, ...\r\nr的表达式也一起列出来。然后画个数轴，发现是个滑动区间。</li>\r\n</ul>\r\n<p><img src=\"3.png\" /></p>\r\n<ul>\r\n<li>那么三重循环，第一枚举物品，第二枚举余数（从0到v-1），第三从r枚举到m，每次+=v，同时开始滑动。</li>\r\n<li>更新的时候注意w的数量，假设更新f[j]用到了f[k]，那么f[k]的w的数量就是(j\r\n- k) / v * w。</li>\r\n</ul></li>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/9/\">9.\r\n分组背包问题 - AcWing题库</a></p>\r\n<ul>\r\n<li>多重背包是看选0个、还是1个、2个。分组背包就是看选第1个、还是第2个。第一重枚举组，第二重枚举体积，第三重枚举组内物品。</li>\r\n</ul></li>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/11/\">11.\r\n背包问题求方案数 - AcWing题库</a></p>\r\n<ul>\r\n<li>这题不是求“恰好装满某容量的方案数”，如果是求前面这个问题的话用一个计数数组跑一遍01背包即可，g[0]\r\n= 1。</li>\r\n<li>这题是求最优选法的方案，所以计数数组含义仍然不变，g[i]表示恰好装好容量为i的方案数，把f数组含义变一下，f[i]表示<strong>恰好</strong>用容量i的包装出的最优价值。这样的话，就需要memset(f,\r\n-0x3f, sizeof f), f[0] = 0。然后跑一遍01即可。最后统计的时候在f[1 ~\r\nm]中找出最优价值，然后再在g[1 ~ m]中统计最优价值的方案数之和。</li>\r\n</ul></li>\r\n<li><p><a\r\nhref=\"https://www.acwing.com/problem/content/description/12/\">12.\r\n背包问题求具体方案 - AcWing题库</a></p>\r\n<ul>\r\n<li>求具体方案。用二维背包去求，先跑一遍二维01。再去逆推出方案。</li>\r\n<li>注意因为字典序从小到大，所以做01时要倒着做，这样最后选的最后字典序最小的，逆推的时候就可以从最小的开始。</li>\r\n</ul></li>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/1595/\">1593.\r\n整数分解 - AcWing题库</a></p>\r\n<ul>\r\n<li>很巧的一道题。对于样例，背包体积容量169(m)，重量容量5(k)。物品个数是其约数个数n，每个物品的价值是约数的p次方，体积是约数的p次方，重量是1。按字典序大输出，即做完全背包时按约数从小到大，这样倒序找方案的时候就是从大到小。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"树形dp\">树形dp</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/10/\">10.\r\n有依赖的背包问题 - AcWing题库</a>\r\n<ul>\r\n<li>f(i,\r\nj)：i为根节点，容量为j时所能装出的最大方案。考虑如何划分，如果x是根节点，如果考虑x儿子节点内部的选择方式的话，方案太多，不好划分。所以考虑按照容量划分，即枚举给每个儿子节点分配多少的容量。</li>\r\n<li>坑点1：俩重循环，第一重j从m -\r\nv[x]到0倒序，之所以倒序是因为对某儿子，容量只会分配给它一次。</li>\r\n<li>坑点2：自己是必选的，而且只能选1次，所以要倒序枚举：<code>for (int i = m; i &gt;= v[x]; i--) f[x][i] = f[x][i - v[x]] + w[x];</code></li>\r\n<li>坑点3：因为自己是必选的，如果自己不选，儿子选了也没用，所以要：<code>for (int i = 0; i &lt; v[x]; i++) f[x][i] = 0;</code></li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"图论\">图论</h3>\r\n<h4 id=\"最短路\">最短路</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/1497/\">1495.\r\n公共自行车管理 - AcWing题库</a>\r\n<ul>\r\n<li>题意稍长但不难懂，看完之后第一反应是多关键字最短路。但是除了距离可以在做dij时维护，“发送的自行车最小数量”和“带回车辆最小数量”是无法在dij的时候维护的。因为这两个量需要知道整段路径的信息后才可求出来，不具有最优子结构。</li>\r\n<li>所以这题思路就是先dij，然后枚举所有最短路，找出符合条件最优的一条。</li>\r\n<li>dfs过程中维护参数sum表示从起点走到x时路上所有站点需求变化量之和，这样直到到达终点前，每一步若<code>sum &lt; 0，min_carry = max(min_carry, -sum)</code>，到达终点即可求出“发送的自行车最小数量”。“带回车辆最小数量”\r\n= sum + 发送的自行车最小数量。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"树\">树</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/1499/\">1497.\r\n树的遍历 - AcWing题库</a>\r\n<ul>\r\n<li>经典题。给出中序和后序，后序的最后一个点肯定是root，所以在中序里找到root的位置，然后中序的左半边就是左子树，右半边就是右子树。（从而可算出左右子树节点数量）因为后序是左右根，所以后序序列的[起始,\r\n起始 + 左子树数量 - 1]是左子树，[起始 + 左子树数量 - 1 + 1,\r\n结束]是右子树。这样就分别在中序和后序序列中得到了左右字数，然后递归即可。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1529/\">1527.\r\n判断二叉搜索树 - AcWing题库</a>\r\n<ul>\r\n<li>经典题。本质上和上一题一样，因为这题的树是二叉搜索树。而BST的中序遍历就是元素从小到大排序。所以它的中序遍历相当于已经告诉你了。然后它又告诉了你前序遍历。那么根据这俩序列，按照上一题的方法，就可以构造出树了。</li>\r\n<li>跟上一题不同的是，这里的元素可能会重复。其实问题不大，因为题目中说“左子树上所有结点的值均小于它的根结点的值”，所以若x在中序遍历中出现多次，找最左边的即可。</li>\r\n<li>然后这题让我们输出后序遍历，其实在构造的时候，在dfs的return前加一句ans[++dex]\r\n= root，即可得到后序遍历。</li>\r\n<li>最后这题还有个翻转机制，翻转其实就是中序遍历reverse一下即可，然后找最左边的变成找最右边的，其余都一样。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1602/\">1600.\r\n完全二叉树 - AcWing题库</a>\r\n<ul>\r\n<li>要求判断一棵树是否是完全二叉树。完全二叉树有一个很好的性质，就是可以存到一个长度为n的序列中。假设当前节点编号是x，则父节点编号为x/2，左儿子编号为x\r\n* 2，右儿子编号为x * 2 +\r\n1，所以检测一棵树是不是完全二叉树，只需按照上述方法把树编号建到序列中。最后检查1\r\n~ n序列中有无空的位置即可。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1552/\">1550.\r\n完全二叉搜索树 - AcWing题库</a>\r\n<ul>\r\n<li>这题很好的结合了完全二叉树和二叉搜索树的特点。前者特点是可用一个数组来存，后者特点是中序遍历为有序。所以以1作为根节点，然后用<em>2,\r\n</em>2+1的方式，对树作中序遍历，然后将递增的数字填进相应的位置即可。</li>\r\n</ul></li>\r\n</ul>\r\n","categories":["3. 竞赛"]},{"title":"计算机组成原理自学笔记","url":"/2024/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"<p>资料来源：课件、黑书</p>\r\n<p>upd：满绩了，题目讲实话不算容易，幸好做了比较充分的复习。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"一.-alu算术逻辑单元\">一. ALU算术逻辑单元</h3>\r\n<ol type=\"1\">\r\n<li>基础知识\r\n<ol type=\"1\">\r\n<li>对于无符号数，那么每一位都是可以用来表示数据的。比如64的无符号数max值为2\r\n^ 64 - 1</li>\r\n<li>对于有符号数，<strong>统一采用补码形式存储在计算机中。</strong>\r\n<ol type=\"1\">\r\n<li>原因如下：\r\n<ol type=\"1\">\r\n<li>如果最高位为符号位，其余位采用原码表示，那么0就有0 000...00和1\r\n000...00两种表示方法，不能唯一确定，不好</li>\r\n<li>那么取个反呢？也就是最高位仍是符号位，如果想表示一个正数x的相反数，就直接把x的二进制全部取反即可。\r\n<ol type=\"1\">\r\n<li>取反本质上就相当于INT_MAX - x，那么正数范围x是0 ~\r\nINT_MAX，则取反也是一一对应的，所以可以用x取反的方式得到x的相反数，也就得到了-0\r\n~ -INT_MAX的负数表示。</li>\r\n<li>但是老问题仍然存在，对于+0，其二进制全部取反后得到1\r\n111...11。所以0仍然存在两种表示方法，这不好</li>\r\n</ol></li>\r\n<li>为了解决这个问题，取反后加1就好了。本质上就是-(INT_MAX - x +\r\n1)。对于+0，是0 000...00，对于-0，仍然是0 000...00。此时，正数范围x是0 ~\r\nINT_MAX。当x取0的时候，-0表示为0 000.00，当x取INT_MAX时，-x表示为1\r\n000...01。你会发现1\r\n000...00这个数没被用到。所以多出来的这个二进制数，我们用它来表示-(INT_MAX+1)</li>\r\n</ol></li>\r\n<li>对于正数，符号位为0，其余位该咋样咋样，跟原码一样。所以64位的最大值为2\r\n^ 63 - 1</li>\r\n<li>对于负数，其二进制是其相反数全部取反+1。64位的负数范围本应是[-INT_MAX,\r\n-0]，但因为1\r\n000...00这个数没人对应。所以用它来对应-(INT_MAX+1)。所以负数范围是[-(INT_MAX+1),\r\n-0]</li>\r\n</ol></li>\r\n</ol></li>\r\n<li>加法溢出（减法溢出同理）\r\n<ol type=\"1\">\r\n<li>正数 + 负数，不会溢出</li>\r\n<li>正数 + 正数，符号位为1，溢出</li>\r\n<li>负数 + 负数，符号位为0，溢出</li>\r\n</ol></li>\r\n<li>乘法\r\n<ol type=\"1\">\r\n<li>朴素法：本质就是二进制分解，将乘数二进制分解，每次看最后一位是不是1，若是，往结果里加上一个被乘数（注意，每分解一次被乘数就要左移一位）</li>\r\n<li>优化法：本质还是二进制分解，但聪明的就是把结果和乘数写一起，初始化的时候在乘数(结果)的前面预留x位（x为被乘数的位数），然后每次检查结果最后一位，若是1，从最高位开始加上一个被乘数，然后结果右移一位，被乘数x2；若是0，则结果直接右移一位，被乘数x2</li>\r\n</ol></li>\r\n<li>除法（建议多练几个样例练练手）\r\n<ol type=\"1\">\r\n<li>恢复除数法朴素法\r\n<ol type=\"1\">\r\n<li>除数低位补0，然后被除数对着除数减，减成功就在结果顶一个1出去，没成功就顶一个0出去。直到除数变为1时结束</li>\r\n</ol></li>\r\n<li>恢复除数法优化法\r\n<ol type=\"1\">\r\n<li>除数不动，然后被除数高位补0，然后高位对着除数减，减成功了就往被除数屁股后塞个1进来，没成功就往被除数屁股后塞个0进来。直到原本的被除数都被减过一遍后（最后一次比较完后高位<strong>减完后，低位左移，塞屁股</strong>然后走人）</li>\r\n</ol></li>\r\n<li>加减交替法\r\n<ol type=\"1\">\r\n<li>初始化是被除数高位补0，然后高四位直接减除数</li>\r\n<li>之后的每一步，直接看被除数符号位是不是1，是1直接屁股塞个0然后高四位加余数。不是的话屁股塞个1然后高四位减余数。直到原本的被除数都被减过一遍后（最后一次判断完屁股塞什么后，直接<strong>低位左移然后</strong>塞完屁股走人）</li>\r\n</ol></li>\r\n</ol></li>\r\n<li>IEEE754\r\n<ol type=\"1\">\r\n<li>S是阶符、E是阶码、M是尾数</li>\r\n<li>单精度\r\n<ol type=\"1\">\r\n<li>E = e + 127，e是真实指数</li>\r\n<li><span class=\"math inline\">\\(1 \\le E \\le 254(127 * 2)\\)</span></li>\r\n<li>8位阶码，共32位</li>\r\n</ol></li>\r\n<li>双精度\r\n<ol type=\"1\">\r\n<li>E = e + 1023</li>\r\n<li><span class=\"math inline\">\\(1 \\le E \\le 2046(1023 * 2)\\)</span></li>\r\n<li>11位阶码，共64位</li>\r\n</ol></li>\r\n<li><img src=\"8.png\" /></li>\r\n<li><img src=\"9.png\" /></li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"二.-指令集isa\">二. 指令集ISA</h3>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 28%\" />\r\n<col style=\"width: 37%\" />\r\n<col style=\"width: 33%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>R型指令</th>\r\n<th>I型指令</th>\r\n<th>S型指令</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>add rd rs1 rs2</td>\r\n<td>addi rd rs1 imm</td>\r\n<td>sw rs2 imm(rs1)（将rs2里的东西赋值到rs1 + imm里）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>sub rd rs1 rs2</td>\r\n<td>subi rd rs1 imm</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>and rd rs1 rs2</td>\r\n<td>andi rd rs1 imm</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>or rd rs1 rs2</td>\r\n<td>ori rd rs1 imm</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>xor rd rs1 rs2</td>\r\n<td>xori rd rs1 imm</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>sll rd rs1 rs2</td>\r\n<td>slli rd rs1 imm (左移imm位，zero-extend)</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>srl rd rs1 rs2 （左移rs2位，zero-extend）</td>\r\n<td>srli rd rs1 imm（右移imm位，zero-extend）</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>sra rd rs1 rs2 （右移rs2位，sign-extend）</td>\r\n<td>srai rd rs1 imm（右移imm位，sign-extend）</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>slt rd rs1 rs2 （rs1小于rs2吗，带sign）</td>\r\n<td>slti rd rs1 imm（rs1小于imm吗，带sign）</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>sltu rd rs1 rs2（rs1小于rs2吗，不带sign）</td>\r\n<td>sltiu rd rs1 imm（rs1小于imm吗，不带sign）</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td></td>\r\n<td>lw rd imm(rs1)（将rs1 + imm的数据加载到rd里）</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td></td>\r\n<td>jalr rd imm(rs1)（将pc + 4赋值给rd，pc赋值为rs1 + imm）</td>\r\n<td></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 39%\" />\r\n<col style=\"width: 29%\" />\r\n<col style=\"width: 31%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>B型指令</th>\r\n<th>U型指令</th>\r\n<th>J型指令</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>beq rs1 rs2 label（若rs1 == rs2，PC被赋值为label）</td>\r\n<td>lui rd imm（rd = imm &lt;&lt; 12）</td>\r\n<td>jal rd imm（rd = PC + 4, PC = PC + imm）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>bne （not equal）</td>\r\n<td>auipc rd imm（rd = (imm &lt;&lt; 12) + PC）</td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>bge （greater or equal）signed</td>\r\n<td></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>bgeu （greater or equal）nosigned</td>\r\n<td></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>blt （less than）signed</td>\r\n<td></td>\r\n<td></td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>bltu （less than）nosigned</td>\r\n<td></td>\r\n<td></td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>I、S、B、U、J，除了I是有/无符号扩展，其余都是有符号扩展，U是先左移12位再有符号扩展</p>\r\n<ul>\r\n<li>C转汇编练习\r\n<ul>\r\n<li>x0：固定为0，可写可读但是始终为0</li>\r\n<li>x1：返回地址寄存器，调用函数的时候自动更新为调用语句的地址</li>\r\n<li>x10/x11：返回结果寄存器，用来保存函数里计算的值</li>\r\n<li>x5-7/x28-31：临时寄存器，随便用</li>\r\n<li>x8-9/x18-27：保存寄存器，在函数调用中需要保存恢复（入栈）</li>\r\n<li>读取字符是lbu，存储字符是sb</li>\r\n<li>函数中return的固定格式：jalr x0, 0(x1)</li>\r\n<li><img src=\"10.png\" /> ppt4(15)</li>\r\n<li><img src=\"24.png\" /> ppt4(16)</li>\r\n<li><img src=\"11.png\" /> ppt4(25)</li>\r\n<li><img src=\"12.png\" /> ppt4(38)</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"三.-单周期数据通路\">三. 单周期数据通路</h3>\r\n<ol type=\"1\">\r\n<li><p>CI：指令数 CPI：每条指令所需的周期数 f：时钟频率 T = <span\r\nclass=\"math inline\">\\(\\frac{1}{f} \\cdot (CI \\cdot\r\nCPI)\\)</span>：时间</p></li>\r\n<li><p>1GHz = 10^3MHz = 10^9Hz；1ns = 10^3ps = 10^9s</p></li>\r\n<li><p>1ns = (1 / 1GHz)</p></li>\r\n<li><p>系统加速比 = <span\r\nclass=\"math inline\">\\(\\frac{改进前的总时间}{改进后的总时间}\\)</span> =\r\n<span class=\"math inline\">\\(\\frac{改进前的总时间}{改进前的总时间 \\cdot\r\n不可改进部分的占比 + \\frac{改进前的总时间 \\cdot\r\n可改进部分的占比}{改进部分的加速比}}\\)</span>，若用吞吐量计算的话就是分子分母反过来-&gt;<span\r\nclass=\"math inline\">\\(\\frac{改进后的吞吐量}{改进前的吞吐量}\\)</span></p></li>\r\n<li><p>关键路径分析</p>\r\n<ol type=\"1\">\r\n<li><p><img src=\"13.png\" /></p>\r\n<p>俩寄存器从readdata1/2出来然后进alu运算，得到结果直接传回registers</p></li>\r\n<li><p><img src=\"14.png\" /></p>\r\n<p>readdata1是首地址，immgen是偏移量，经alu运算后得到地址，然后ram的readdata读到数据后传回registers，赋值给rd</p></li>\r\n<li><p><img src=\"15.png\" /></p>\r\n<p>readdata2是要写入ram的数据，直接流入ram的writedata，readdata1是首地址，immgen是偏移量，经alu运算后得到地址</p></li>\r\n<li><p><img src=\"16.png\" /></p>\r\n<p>readdata1/2分别是rs1,\r\nrs2，经alu判断是否相等后zero信号给到pc那边的mux。label通过immgen传到mux</p></li>\r\n</ol></li>\r\n<li><p>对于寄存器（pc、InstrMem、Registers、DataMem），如果走完全程就加整个的延迟，如果只是往里写东西就只加一个Set\r\nup，如果只是读东西就只加一个read。</p>\r\n<ol type=\"1\">\r\n<li>sw的关键路径：pc_read + InstrMem + Registers + ALU + Setup</li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"四.-流水线数据通路\">四. 流水线数据通路</h3>\r\n<ol type=\"1\">\r\n<li><p>流水线的五个阶段</p>\r\n<ol type=\"1\">\r\n<li><p>IF：从内存中获取指令</p></li>\r\n<li><p>ID：指令解码和寄存器读取</p></li>\r\n<li><p>EX：执行操作或计算地址</p></li>\r\n<li><p>MEM：访问内存操作数</p></li>\r\n<li><p>WB：将结果写回寄存器</p>\r\n<p><img src=\"17.png\" /></p></li>\r\n</ol></li>\r\n<li><p>流水线数据通路的延迟</p>\r\n<ol type=\"1\">\r\n<li><p>时钟周期(每个cycle的时间) = max{ lat(IF), lat(ID), lat(EX),\r\nlat(MEM), lat(WB) }</p></li>\r\n<li><p>忽略了流水线的装载和排空</p></li>\r\n<li><p>忽略了寄存器的建立时间</p>\r\n<blockquote>\r\n<p>这里要注意区分时钟周期、延迟的概念：</p>\r\n<p>对于单周期数据通路，其时钟周期就是它的延迟</p>\r\n<p>对于流水线数据通路，其时钟周期是max{ 五个阶段的延迟 }，其延迟是sum{\r\n五个阶段的延迟 }</p>\r\n</blockquote></li>\r\n</ol></li>\r\n<li><p>画流水线图</p>\r\n<ol type=\"1\">\r\n<li><p>传统流水线图</p>\r\n<p><img src=\"18.png\" /></p>\r\n<p>直接IF、ID、EX、MEM、WB五个阶段哐哐往上写就好了</p></li>\r\n<li><p>资源调度流水线图</p>\r\n<p><img src=\"19.png\" /></p>\r\n<p>固定的五套件是IM（instr_memory）、Reg、ALU、DM（data_memory）、Reg。如果写就前半部分标黑，如果读就后半部分标黑，如果都用到了就都标黑。没用到就标白（例如sub、add没用到DM）</p></li>\r\n<li><p>插气泡的写法</p>\r\n<p><img src=\"20.png\" /></p></li>\r\n</ol></li>\r\n<li><p>冒险</p>\r\n<ol type=\"1\">\r\n<li>结构冒险：就是抢硬件资源，比如若将指令和数据放在一个存储器，那么IF阶段和MEM阶段就会同时用存储器，产生结构冒险</li>\r\n<li>数据冒险：\r\n<ol type=\"1\">\r\n<li>产生数据依赖就会产生数据冒险</li>\r\n<li>三种数据依赖\r\n<ol type=\"1\">\r\n<li>写后读（RAW）\r\n<ol type=\"1\">\r\n<li>即前面写的还没更新，后面就读了，结果读出来不符合原本预期</li>\r\n<li>无lw/sw语句\r\n<ol type=\"1\">\r\n<li>也就是对于同一个寄存器，WB的CC必须在ID的CC之前，之后就会存在RAW依赖。WB和ID的CC相同是否可行呢？其实是可以的。因为通常默认一个CC内先下降沿再上升沿，下降写，上升读，所以同一个CC内，先写后读，数据是可以正确传递的，所以同一个CC也可以。</li>\r\n<li>总结解决办法就是写读之间间隔的语句要&gt;=2（不包括它俩），或者插bubble，或者前推</li>\r\n</ol></li>\r\n</ol></li>\r\n<li>读后写（WAR）\r\n<ol type=\"1\">\r\n<li>即前面还没读到，后面就写进去了，结果读出来不符合原本预期</li>\r\n<li>因为五级流水读取ID在第二阶段，写WB是第五阶段，所以不会发现读后写的冒险。只有在乱序执行的时候才会出现</li>\r\n</ol></li>\r\n<li>写后写（WAW）\r\n<ol type=\"1\">\r\n<li>假设三条指令前两条写，后一条读，按理说读出来的是最后一条写后的结果，但如果第一个写最后才执行，那么就读出来一个错误的值。</li>\r\n<li>五级流水仍是顺序执行的，所以不会有WAW冒险。只有在乱序执行的时候才会出现</li>\r\n</ol></li>\r\n</ol></li>\r\n<li>前推MUX控制\r\n<ul>\r\n<li>alu那，俩操作数，有不同的选择</li>\r\n<li>F0 = (EX/MEM.RegWrite &amp;&amp; EX/MEM.Rd != 0 &amp;&amp; ID/EX.Rs\r\n== EX/MEM.Rd) EX/MEM前推到ID/EX.Rs</li>\r\n<li>F1 = (MEM/WB.RegWrite &amp;&amp; MEM/WB.Rd != 0 &amp;&amp; ID/Ex.Rs\r\n== MEM/WB.Rd) MEM/WB前推到ID/EX.Rs</li>\r\n<li>如果F0=0，F1=0就不前推，不可能俩都为1，其中一个为1就前推对应的阶段到ID/EX.Rs</li>\r\n</ul></li>\r\n<li>Load-Use冒险检测\r\n<ol type=\"1\">\r\n<li>Hazard = (ID/EX.MemRead &amp;&amp; ID/EX.Rd == IF/ID.Rs)</li>\r\n<li>要从datamemory读东西并且最终要写入的寄存器会被下面的语句用到，那么就存在load-use冒险。</li>\r\n<li>隔一条的load-use冒险可以前推解决，不间隔的load-use冒险前推解决不了</li>\r\n</ol></li>\r\n</ol></li>\r\n<li>控制冒险：\r\n<ol type=\"1\">\r\n<li>就是beq指令没执行完前后面的指令不给执行，但是beq到EX/MEM阶段才知道是否执行，而此时后面的三条指令已经塞进来了，所以就会发生控制冒险</li>\r\n<li>解决方案一：插三条bubble</li>\r\n<li>解决方案二：如果发现要执行跳转则flush\r\nID/IF/EX阶段（因为后面的指令最多执行了ID/IF/EX三个阶段，所以刷新掉即可）\r\n<ol type=\"1\">\r\n<li>If (EX/MEM.branch &amp; EX/MEM.Zero) IF.Flush=True; ID.Flush=True;\r\nEX.Flush=True;</li>\r\n</ol></li>\r\n<li>当然，其实beq的俩数比较不需要放在alu后比较，其实readdata刚出来，也就是在ID的结尾就可以比较了。所以我们可以把比较前移至ID阶段\r\n<ol type=\"1\">\r\n<li>if (IF/ID.IR == beq &amp;&amp; Reg[Rs1] == Reg[Rs2]) IF.Flush =\r\nTrue;</li>\r\n<li>此时仍会出现冒险，解决方案如下</li>\r\n<li>解决方案一：插一条bubble</li>\r\n<li>解决方案二：若发现要执行跳转，则flush掉IF/ID寄存器即可</li>\r\n</ol></li>\r\n<li>还有另一种控制冒险，就是jal指令，跟前移后的beq一样，也是到ID阶段就知道跳转地址了，所以也是flush一下ID/EX寄存器即可\r\n<ol type=\"1\">\r\n<li>if (IF/ID.IR == jal[R]) IF.Flush = True;</li>\r\n</ol></li>\r\n<li>在学了flush技巧后，前面我们没解决的load-use冒险也可以用flush技巧来解决了，具体来说如下：\r\n<ol type=\"1\">\r\n<li>在检测上发生load-use冒险时：Hazard = (ID/EX.MemRead &amp;&amp;\r\nID/EX.Rd == IF/ID.Rs)</li>\r\n<li>将ID/EX寄存器控制字段flush掉</li>\r\n<li>阻止PC寄存器更新</li>\r\n<li>阻止IF/ID寄存器指令字段更新</li>\r\n</ol></li>\r\n</ol></li>\r\n</ol></li>\r\n<li><p>流水线性能分析</p>\r\n<ol type=\"1\">\r\n<li><p><img src=\"21.png\" /></p></li>\r\n<li><p>可以发现，多插一个bubble就会多一个时间周期才能完成</p></li>\r\n<li><p>而且可以发现一个规律，插入bubble后的<span\r\nclass=\"math inline\">\\(CPI = 1 +\r\n\\frac{bubble数}{指令数}\\)</span></p></li>\r\n<li><p>那么下面这题就可以理解了</p>\r\n<p><img src=\"22.png\" /></p>\r\n<p>只有beq、jal、ld会产生惩罚，题目说了没有结构冒险，所以只考虑ld。只有40%load，一个load指令会bubble一个周期，所以假设指令数是x，那么bubble数就是0.4x，代入公式：CPI\r\n= 1 + 0.4x / x = 1.4，然后T = CPI * 时钟周期 = 1.4 * 1.1 = 1.54</p></li>\r\n<li><p><img src=\"23.png\" /></p>\r\n<ul>\r\n<li>条件分支beq 20%，无条件跳转jal\r\n5%。跳转地址在ID阶段解决意味着会延迟一个周期跳转，跳转条件在EX解决意思是到EX/MEM才知道是否要跳转，也就是延迟3个周期跳转。</li>\r\n<li>那么假设静态预测不跳转，CPI = 1 + 0.05 * 1 + 0.2 * 3 = 1.65</li>\r\n<li>如果假设静态预测跳转，CPI = 1 + 0.05 * 1 + 0.2 * 1 = 1.25</li>\r\n</ul></li>\r\n</ol></li>\r\n</ol>\r\n<p>‍</p>\r\n<h3 id=\"五.-动态分支预测\">五. 动态分支预测</h3>\r\n<p>考点：根据双模的计数器的状态跳转图、或者历史的预测情况、历史的跳转情况，分析出最近的十次他能预测成果的次数</p>\r\n<h3 id=\"六.-cache\">六. Cache</h3>\r\n<ol type=\"1\">\r\n<li>AMAT（平均访问时间）\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(T = p * T_c + (1 - p) * (T_c +\r\nT_m)\\)</span></li>\r\n<li>p是命中率，<span class=\"math inline\">\\(T_c\\)</span>\r\n是访问时间，<span\r\nclass=\"math inline\">\\(T_m\\)</span>是缺失代价访问时间</li>\r\n</ol></li>\r\n<li>主存与cache\r\n<ol type=\"1\">\r\n<li>对于主存地址，俩部分，主存块号m位，块内地址b位。这个地址可以定位到一个存储单元</li>\r\n<li>对于cache行的内容，tag位 + 有效位 + 脏位 + LRU位 + 数据。</li>\r\n<li>若想在cache中定位到一个存储单元，需要从主存地址中解析出cache行号和块内地址</li>\r\n<li>地址映射表 = 标记阵列 = (tag位 + 有效位 + 脏位 + LRU位)</li>\r\n</ol></li>\r\n<li>映射方式\r\n<ol type=\"1\">\r\n<li>直接映射\r\n<ol type=\"1\">\r\n<li>cache行号 = 主存块号 % cache行数</li>\r\n<li>其实主存块号对应的cache行号，就是m位主存块号的低c位。高m -\r\nc位就作为tag位</li>\r\n<li>技巧：tag位 = log2(主存容量 / cache容量)</li>\r\n</ol></li>\r\n<li>全相联映射\r\n<ol type=\"1\">\r\n<li>因为全相联是随便放，所以给你一个主存地址，是无法定位到放到cache中的哪一行的</li>\r\n<li>所以我们将主存地址的m位全部作为tag位</li>\r\n</ol></li>\r\n<li>组相联映射\r\n<ol type=\"1\">\r\n<li>主存m位块号里的低c位就是对应的组号，高m - c位就作为tag位</li>\r\n<li>可以发现组相联也是无法定位到具体某一行的</li>\r\n</ol></li>\r\n</ol></li>\r\n<li>关联度\r\n<ol type=\"1\">\r\n<li>定义：一个主存地址可能被存放到cache中的可能位置个数</li>\r\n<li>关联度越低，命中率越低，判断是否命中的开销越小</li>\r\n<li>直接映射：1</li>\r\n<li>全相联映射：cache行数</li>\r\n<li>组相联映射：组路数</li>\r\n</ol></li>\r\n<li>替换算法\r\n<ol type=\"1\">\r\n<li>LRU：选择近期最久没被实用的块被替换</li>\r\n<li>算法实现：通过LRU位实现（计数器）</li>\r\n</ol></li>\r\n<li>一致性问题\r\n<ol type=\"1\">\r\n<li>写命中（要修改的存储单元在cache中）\r\n<ol type=\"1\">\r\n<li>写直达（同时更新cache和主存）</li>\r\n<li>写返回（更新cache和脏位，当被替换出去的时候再更新主存）</li>\r\n</ol></li>\r\n<li>写不命中（要修改的存储单元不在cache中）\r\n<ol type=\"1\">\r\n<li>写分配法（在主存里更新完后copy一份到cache中）</li>\r\n<li>写不分配法（在主存里更新完后就结束）</li>\r\n</ol></li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"六.-汇编补充\">六. 汇编补充</h3>\r\n<ul>\r\n<li><p>在线RISC-V汇编编写网站：<a\r\nhref=\"https://venus.kvakil.me/\">venus</a></p></li>\r\n<li><p>RISC-V汇编转机器码网站：<a\r\nhref=\"https://riscvasm.lucasteske.dev/#\">Online RISC-V\r\nAssembler</a></p></li>\r\n<li><p>更多指令细节请参考：<a\r\nhref=\"https://inst.eecs.berkeley.edu/~cs61c/fa23/pdfs/resources/reference-card.pdf\">CS\r\n61C Reference Card</a></p></li>\r\n<li><p>RISC-V的大部分指令长度固定，为32位。每条指令都是由32个0/1序列组成。</p></li>\r\n<li><p>寄存器：RISC-V中，寄存器是处理器内部用于存储数据的小存储单元。它们可以非常快速地被访问和写入，比起访问主内存来说速度要快得多。</p></li>\r\n<li><p>RISC-V定义了一组32个通用寄存器，编号从0到31。在代码中就是x0, x1,\r\nx2, ..., x31。</p>\r\n<p><img src=\"1.png\" /></p></li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li><p>R(register)型指令：操作寄存器操作的指令</p>\r\n<ul>\r\n<li>格式：<img src=\"2.png\" /></li>\r\n<li>opcode操作码，rd目标寄存器号，rs1/rs2第一/二个源寄存器号，funct3附加操作码，funct7附加操作码。</li>\r\n<li>add x3, x1, x2（+）</li>\r\n<li>sub x3, x1, x2（-）</li>\r\n<li>and x3, x1, x2（&amp;）</li>\r\n<li>or x3, x1, x2（|）</li>\r\n<li>xor x3, x1, x2（^）</li>\r\n</ul></li>\r\n<li><p>I(immediate)型指令：寄存器与常数操作的指令</p>\r\n<ul>\r\n<li>格式：<img src=\"3.png\" /></li>\r\n<li>immediate立即数。</li>\r\n<li>addi x1, x2, 10</li>\r\n<li>slti x1, x2, 15：如果x2小于15，将x1设置位1。否则设置为0</li>\r\n<li>andi x1, x2, 0xFF：寄存器与常数进行&amp;操作</li>\r\n<li>ori x1, x2, 0xFF</li>\r\n<li>xori x1, x2, 0xFF</li>\r\n<li>slli x1, x2, 2（将x2左移2位结果存到x1中）</li>\r\n<li>ld x1, 0(x5)：从内存地址 x5+0 处加载 64 位的值到 x10</li>\r\n</ul></li>\r\n<li><p>S(store)型指令：寄存器与内存操作的指令</p>\r\n<ul>\r\n<li>格式：<img src=\"4.png\" /></li>\r\n<li>rs1访存基址寄存器编号，r2源操作数寄存器编号，imm立即数（表示从基址开始的偏移量。</li>\r\n<li>sw x1, 10(x2)：将x1内容存储到x2为基址，偏移量为10的内存地址中</li>\r\n</ul></li>\r\n<li><p>B(branch)型指令：程序的有条件跳转指令</p>\r\n<ul>\r\n<li>格式：<img src=\"5.png\" /></li>\r\n<li>imm立即数：表示要跳转的语句的地址。</li>\r\n<li>beq x1, x2, label：如果x1==x2，程序跳转到label处</li>\r\n<li>blt(Branch less than) x1, x2, label：如果x1 &lt;\r\nx2，程序跳转到label处</li>\r\n<li>bgt(Branch greater than) x1, x2, label：如果x1 &gt;\r\nx2，程序跳转到label处</li>\r\n<li>bgtz(Branch greater than zero) x1\r\nlabel：如果x1大于0，程序跳转到label处</li>\r\n<li>bgez(Branch greater or equal to zero) x1\r\nlabel：如果x1大于等于0，程序跳转到label处</li>\r\n</ul></li>\r\n<li><p>J(jump)型指令：程序的无条件跳转指令</p>\r\n<ul>\r\n<li>格式：<img src=\"6.png\" /></li>\r\n<li>也可以叫UJ(Unconditional Jump)指令。</li>\r\n<li>jr rd：跳转到rd寄存器存的地址那里</li>\r\n<li>jal x1,\r\noffset：跳转到当前指令地址加上offset的位置，并将下一条指令的地址存入x1中</li>\r\n</ul></li>\r\n<li><p>U(upper immediate)型指令：将20位立即数加载到寄存器的高位<br />\r\n</p>\r\n<ul>\r\n<li>格式：<img src=\"7.png\" /></li>\r\n<li>lui x1 imm：将20位立即数imm加载到x1的高20位，低12位清零</li>\r\n</ul></li>\r\n</ol>\r\n<ul>\r\n<li>练习题：写一个斐波那契数列程序</li>\r\n</ul>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fib</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n==<span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> fib(n<span class=\"number\">-1</span>)+fib(n<span class=\"number\">-2</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight mathematica\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">fib</span><span class=\"operator\">:</span></span><br><span class=\"line\">    <span class=\"variable\">addi</span> <span class=\"variable\">sp</span><span class=\"operator\">,</span> <span class=\"variable\">sp</span><span class=\"operator\">,</span> <span class=\"operator\">-</span><span class=\"number\">16</span>\t<span class=\"type\">#</span> 开辟<span class=\"number\">16</span>字节的栈空间</span><br><span class=\"line\">    <span class=\"variable\">sw</span> <span class=\"variable\">ra</span><span class=\"operator\">,</span> <span class=\"number\">0</span><span class=\"punctuation\">(</span><span class=\"variable\">sp</span><span class=\"punctuation\">)</span>        <span class=\"type\">#</span> 保存函数地址</span><br><span class=\"line\">    <span class=\"variable\">sw</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"number\">4</span><span class=\"punctuation\">(</span><span class=\"variable\">sp</span><span class=\"punctuation\">)</span>        <span class=\"type\">#</span> 保存参数<span class=\"variable\">n</span><span class=\"operator\">,</span> <span class=\"variable\">a0</span> <span class=\"operator\">=</span> <span class=\"variable\">n</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"variable\">addi</span> <span class=\"variable\">t0</span><span class=\"operator\">,</span> <span class=\"variable\">x0</span><span class=\"operator\">,</span> <span class=\"number\">2</span>        <span class=\"type\">#</span> <span class=\"variable\">t0</span> <span class=\"operator\">=</span> <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"variable\">blt</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"variable\">t0</span><span class=\"operator\">,</span> <span class=\"type\">less_or</span><span class=\"type\">_equal</span><span class=\"type\">_than</span><span class=\"type\">_one</span>    <span class=\"type\">#</span> 如果<span class=\"variable\">n</span> <span class=\"operator\">&lt;=</span> <span class=\"number\">1</span>，直接返回<span class=\"variable\">n</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"variable\">addi</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"operator\">-</span><span class=\"number\">1</span>        <span class=\"type\">#</span> <span class=\"variable\">a0</span> <span class=\"operator\">=</span> <span class=\"variable\">n</span> <span class=\"operator\">-</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"variable\">jal</span> <span class=\"variable\">ra</span><span class=\"operator\">,</span> <span class=\"variable\">fib</span>            <span class=\"type\">#</span> 执行<span class=\"variable\">fib</span><span class=\"punctuation\">(</span><span class=\"variable\">n</span> <span class=\"operator\">-</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">    <span class=\"variable\">add</span> <span class=\"variable\">t1</span><span class=\"operator\">,</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"variable\">x0</span>        <span class=\"type\">#</span> 将<span class=\"variable\">fib</span><span class=\"punctuation\">(</span><span class=\"variable\">n</span> <span class=\"operator\">-</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span>的结果存到<span class=\"variable\">t1</span>中</span><br><span class=\"line\">    <span class=\"variable\">sw</span> <span class=\"variable\">t1</span><span class=\"operator\">,</span> <span class=\"number\">8</span><span class=\"punctuation\">(</span><span class=\"variable\">sp</span><span class=\"punctuation\">)</span>        <span class=\"type\">#</span> 将结果存到栈中</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"variable\">lw</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"number\">4</span><span class=\"punctuation\">(</span><span class=\"variable\">sp</span><span class=\"punctuation\">)</span>        <span class=\"type\">#</span> 恢复参数<span class=\"variable\">n</span><span class=\"operator\">,</span> <span class=\"variable\">a0</span> <span class=\"operator\">=</span> <span class=\"variable\">n</span></span><br><span class=\"line\">    <span class=\"variable\">addi</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"operator\">-</span><span class=\"number\">2</span>        <span class=\"type\">#</span> <span class=\"variable\">a0</span> <span class=\"operator\">=</span> <span class=\"variable\">n</span> <span class=\"operator\">-</span> <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"variable\">jal</span> <span class=\"variable\">ra</span><span class=\"operator\">,</span> <span class=\"variable\">fib</span>            <span class=\"type\">#</span> 执行<span class=\"variable\">fib</span><span class=\"punctuation\">(</span><span class=\"variable\">n</span> <span class=\"operator\">-</span> <span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">    <span class=\"variable\">add</span> <span class=\"variable\">t2</span><span class=\"operator\">,</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"variable\">x0</span>        <span class=\"type\">#</span> 将<span class=\"variable\">fib</span><span class=\"punctuation\">(</span><span class=\"variable\">n</span> <span class=\"operator\">-</span> <span class=\"number\">2</span><span class=\"punctuation\">)</span>的结果存到<span class=\"variable\">t2</span>中</span><br><span class=\"line\">    <span class=\"variable\">sw</span> <span class=\"variable\">t2</span><span class=\"operator\">,</span> <span class=\"number\">12</span><span class=\"punctuation\">(</span><span class=\"variable\">sp</span><span class=\"punctuation\">)</span>        <span class=\"type\">#</span> 将结果存到栈中</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"variable\">lw</span> <span class=\"variable\">t1</span><span class=\"operator\">,</span> <span class=\"number\">8</span><span class=\"punctuation\">(</span><span class=\"variable\">sp</span><span class=\"punctuation\">)</span>        <span class=\"type\">#</span> 重新把结果读到<span class=\"variable\">t1</span>中</span><br><span class=\"line\">    <span class=\"variable\">lw</span> <span class=\"variable\">t2</span><span class=\"operator\">,</span> <span class=\"number\">12</span><span class=\"punctuation\">(</span><span class=\"variable\">sp</span><span class=\"punctuation\">)</span>        <span class=\"type\">#</span> 重新把结果读到<span class=\"variable\">t2</span>中</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"variable\">add</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"variable\">t1</span><span class=\"operator\">,</span> <span class=\"variable\">t2</span>        <span class=\"type\">#</span> <span class=\"variable\">a1</span> <span class=\"operator\">=</span> <span class=\"variable\">fib</span><span class=\"punctuation\">(</span><span class=\"variable\">n</span> <span class=\"operator\">-</span> <span class=\"number\">1</span><span class=\"punctuation\">)</span> <span class=\"operator\">+</span> <span class=\"variable\">fib</span><span class=\"punctuation\">(</span><span class=\"variable\">n</span> <span class=\"operator\">-</span> <span class=\"number\">2</span><span class=\"punctuation\">)</span></span><br><span class=\"line\">    <span class=\"variable\">lw</span> <span class=\"variable\">ra</span><span class=\"operator\">,</span> <span class=\"number\">0</span><span class=\"punctuation\">(</span><span class=\"variable\">sp</span><span class=\"punctuation\">)</span>        <span class=\"type\">#</span> 恢复当前<span class=\"variable\">fib</span>的返回地址</span><br><span class=\"line\">    <span class=\"variable\">addi</span> <span class=\"variable\">sp</span><span class=\"operator\">,</span> <span class=\"variable\">sp</span><span class=\"operator\">,</span> <span class=\"number\">16</span>        <span class=\"type\">#</span> 恢复栈空间</span><br><span class=\"line\">    <span class=\"variable\">jr</span> <span class=\"variable\">ra</span>                <span class=\"type\">#</span> 返回到调用<span class=\"variable\">fib</span>函数的地方</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"type\">less_or</span><span class=\"type\">_equal</span><span class=\"type\">_than</span><span class=\"type\">_one</span><span class=\"operator\">:</span></span><br><span class=\"line\">    <span class=\"variable\">addi</span> <span class=\"variable\">sp</span><span class=\"operator\">,</span> <span class=\"variable\">sp</span><span class=\"operator\">,</span> <span class=\"number\">16</span>\t<span class=\"type\">#</span> 栈空间恢复</span><br><span class=\"line\">    <span class=\"variable\">add</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"variable\">a0</span><span class=\"operator\">,</span> <span class=\"variable\">x0</span>    <span class=\"type\">#</span> <span class=\"variable\">a1</span> <span class=\"operator\">=</span> <span class=\"variable\">n</span></span><br><span class=\"line\">    <span class=\"variable\">jr</span> <span class=\"variable\">ra</span>            <span class=\"type\">#</span> 返回</span><br></pre></td></tr></table></figure>\r\n","categories":["4. 大学","计算机专业课"]}]