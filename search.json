[{"title":"0. 从博弈论到多智能体强化学习","url":"/2023/10/15/0-%E4%BB%8E%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%88%B0%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/","content":"<p>什么是多智能体强化学习？比如快递工厂里的一个个快递机器，或者王者荣耀人机模式里的每个小兵，异或是现在自动驾驶中的每一辆车，都可以定义为智能体。让智能体进行强化学习是为了他们做出更好的决策。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"博弈论基本概念\">博弈论基本概念</h3>\r\n<ul>\r\n<li>玩家集合：\r\n<ul>\r\n<li><span class=\"math inline\">\\(N = \\{1, 2, ..., n\\}\\)</span></li>\r\n</ul></li>\r\n<li>策略集合\r\n<ul>\r\n<li><span class=\"math inline\">\\(A_1, A_2, A_3, ..., A_n\\)</span></li>\r\n</ul></li>\r\n<li>收益函数\r\n<ul>\r\n<li><span class=\"math inline\">\\(r_1=f_1(A_1, A_2, ...,\r\nA_n)\\)</span></li>\r\n<li><span class=\"math inline\">\\(r_2=f_2(A_1, A_2, ...,\r\nA_n)\\)</span></li>\r\n<li>... ...</li>\r\n<li><span class=\"math inline\">\\(r_n=f_n(A_1, A_2, ...,\r\nA_n)\\)</span></li>\r\n</ul></li>\r\n</ul>\r\n<p>用“囚徒困境”这个例子来进一步理解：</p>\r\n<p><img src=\"1.png\" /></p>\r\n<p>如图是两个玩家，玩家一是绿色的，玩家二是红色的。每个人选择坦白 /\r\n抵赖所获得的分数如图。</p>\r\n<p>若玩家1选择坦白\r\n，则玩家2必然选择坦白，因为比起0分1，1分显然更好。</p>\r\n<p>若玩家1选择抵赖，则玩家2也是选择坦白。</p>\r\n<p>所以不管玩家1选什么，玩家2都会选择坦白，坦白是玩家2的<strong>占优策略</strong>。</p>\r\n<p>同样的，不管玩家2选什么，玩家1也都会选择坦白\r\n，坦白也是玩家1的<strong>占优策略</strong>。</p>\r\n<p>所以博弈结果必然就是俩人都选择坦白。</p>\r\n<p>假如修改一下游戏规则呢？</p>\r\n<p><img src=\"2.png\" /></p>\r\n<p>此时若玩家2的占优策略仍然是坦白。</p>\r\n<p>但是若玩家2选择坦白，则玩家1会选择坦白。若玩家2选择坦白，则玩家1会选择抵赖。此时坦白就不是玩家1的占优策略了。</p>\r\n<p>那么玩家1应该如何做决策呢？</p>\r\n<p>因为俩玩家都是绝顶聪明，所以玩家1肯定知道玩家2做出了它的占优策略——坦白。所以玩家1既然知道玩家2选坦白，他也就只能选坦白。此时坦白是玩家1的<strong>最佳应对</strong>。</p>\r\n<p>通过这个例子，我们感受了一下博弈论，还学到俩新名词，<strong>占优策略</strong>和<strong>最佳应对</strong>。</p>\r\n<p>下面我们来看博弈论的解：</p>\r\n<p>正如同上面的囚徒困境，一些博弈问题是存在解的：解 =\r\n即任何玩家都不能通过独自改变策略而获益时的策略组合，换句话说，解 =\r\n所有玩家处于最佳应对时的策略组合。</p>\r\n<p>数学定义如下：</p>\r\n<ul>\r\n<li><p>给定一个策略组合 <span\r\nclass=\"math inline\">\\(a=(a_1,a_2,...,a_n)\\in A_1\\times\r\nA_2\\times...\\times A_n,\\)</span></p></li>\r\n<li><p>若 <span class=\"math display\">\\[\r\nr_1(a_1,a_2,...,a_n)\\geq r_1(a_1^{\\prime},a_2,...,a_n), \\forall\r\na_1^{\\prime}\\in A_1 \\\\\r\nr_2(a_1,a_2,...,a_n)\\geq r_{1}(a_{1},a_{2}^{\\prime},...,a_{n}),\\forall\r\na_{2}^{\\prime}\\in A_{2} \\\\\r\n... ... \\\\\r\nr_n(a_1,a_2,...,a_n)\\geq r_n(a_1,a_2,...,a_n^{\\prime}),\\forall\r\na_n^{\\prime}\\in A_n\r\n\\]</span></p></li>\r\n<li><p>那么策略组合<span\r\nclass=\"math inline\">\\(a\\)</span>是一个纳什均衡。</p></li>\r\n<li><p>下面介绍另一种博弈情况（混合策略）下的解——混合纳什均衡。</p>\r\n<ul>\r\n<li>混合策略：每个玩家都有一个概率分布<span class=\"math inline\">\\((p_1,\r\np_2, ..., p_n), p_i\\)</span>为玩家选择动作i的概率。</li>\r\n<li>混合纳什均衡：等于一个混合策略组合。s.t.\r\n任何玩家都不能通过独自改变自身混合策略来提高自己的期望收益。</li>\r\n<li>定理：任意一个博弈，必然存在一个混合策略纳什均衡。</li>\r\n</ul></li>\r\n<li><p>例如下面这个例子，此博弈的混合策略纳什均衡就是每个人的混合策略都为<span\r\nclass=\"math inline\">\\(\\frac{1}{3}, \\frac{1}{3},\r\n\\frac{1}{3}\\)</span>。</p></li>\r\n</ul>\r\n<p><img src=\"3.png\" /></p>\r\n<ul>\r\n<li>当然博弈还有许多种均衡，上面只是介绍了最基础的纳什均衡和混合策略纳什均衡。博弈也有很多种博弈（只要加上不同的限定条件），比如所有人收益都是一样的就叫合作博弈，所有人收益之和是一个定值就叫竞争博弈。</li>\r\n</ul>\r\n<h3 id=\"从博弈论走到多智能体强化学习\">从博弈论走到多智能体强化学习</h3>\r\n<p>现实中，博弈玩家、玩家策略的数量都很大很大，而且玩家自身的收益函数可能并不知道，需要一点一点与环境交互才知道。所以用简单的博弈论模型去描述现实问题会比较困难。</p>\r\n<p>所以下面引入一个新的博弈模型——马尔科夫博弈</p>\r\n<ul>\r\n<li><p>玩家集合</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(N = \\{1, 2, ..., n\\}\\)</span></li>\r\n</ul></li>\r\n<li><p>策略集合</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(A_1, A_2, A_3, ..., A_n \\\\ A = A_1\r\n\\times A_2 \\times ... \\times A_n\\)</span></li>\r\n</ul></li>\r\n<li><p>状态集合</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(S = \\{s_1, s_2, ..., s_n\\}\\)</span></li>\r\n</ul></li>\r\n<li><p>转移函数</p>\r\n<ul>\r\n<li>如果已知当前状态<span class=\"math inline\">\\(s_i\\)</span>,\r\n和当前策略<span class=\"math inline\">\\(a_i\\)</span>,\r\n有概率得到下一个状态<span class=\"math inline\">\\(s_i&#39;\\)</span>。</li>\r\n<li>概率函数就是描述上面这个过程的概率是多少。</li>\r\n<li><span class=\"math inline\">\\(f(s_i, a_i, s_i&#39;)\\)</span></li>\r\n</ul></li>\r\n<li><p>收益函数</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(r_i\\)</span>由S和A确定</li>\r\n</ul></li>\r\n</ul>\r\n<p>上面这个博弈模型就可以描述现实生活中绝大多数博弈模型。</p>\r\n<p>那强化学习跟博弈论又有什么学习呢？</p>\r\n<p>强化学习也分好几种，第一种叫状态价值学习，即有一个状态价值函数<span\r\nclass=\"math inline\">\\(Q(s,\r\na)\\)</span>，表示在s状态下采取a动作所能获得的期望累积收益。通过神经网络拟合Q函数，不断学习来使得它收敛。这是状态价值学习。</p>\r\n<p>那放到多智能体中，在当前状态S下，每个玩家都可以通过强化学习得出自己的<span\r\nclass=\"math inline\">\\(Q_{max}(s_i, a_i), a_i∈A_i\\)</span>\r\n，拿前面囚徒困境去类比的话，就是<span\r\nclass=\"math inline\">\\(a_1\\)</span>为坦白，<span\r\nclass=\"math inline\">\\(a_2\\)</span>为抵赖。也就是此时就可以建模出一个简单的博弈论模型。</p>\r\n<p>当多智能体们通过博弈后，又得到了下一个状态S'。于是再用强化学习算出在状态S'下，每个玩家的<span\r\nclass=\"math inline\">\\(Q_{max}\\)</span>，循环往复以此类推。最后就可以收敛于最优解。</p>\r\n<h3 id=\"总结\">总结</h3>\r\n<p>上面所讲的知识的目的皆在引入博弈论和多智能体强化学习两个概念。所以许多地方为了方便理解没有很严谨，有许多漏洞之处。但作为一个刚入门的小白（比如我），已经可以给我一个大概的理解和感受了，这就是此篇blog的目的。</p>\r\n","categories":["2. 技能栈","多智能体强化学习"]},{"title":"0. 引言","url":"/2023/10/05/0-%E5%BC%95%E8%A8%80/","content":"<p>在阅读一篇关于多智能体强化学习的论文时，发现涉及到凸优化的知识我不会。于是打算自学，参考的教程是<a\r\nhref=\"https://www.bilibili.com/video/BV19M411T7S7?p=1&amp;vd_source=2501060da9b4bef86e2b8ec8a8d880b5\">中科大凌青老师的教学视频</a>。</p>\r\n<p>文中的笔记是我看完课程后的思考与总结，可能有错误还请指出！我速速修改=w=</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n","categories":["4. 大学","凸优化"]},{"title":"1. 仿射集/凸集/凸锥","url":"/2023/10/05/1-%E4%BB%BF%E5%B0%84%E9%9B%86-%E5%87%B8%E9%9B%86-%E5%87%B8%E9%94%A5/","content":"<p>介绍了仿射集、凸集、凸锥的概念，以及三者之间的联系。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n<p><img src=\"2.jpg\" /></p>\r\n","categories":["4. 大学","凸优化"]},{"title":"1. 深度强化学习导论","url":"/2023/10/15/1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/","content":"<p>以下面这张图和一个例子来说明RL的基本逻辑</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.png\" /></p>\r\n<p>假设智能体是一个刚出生的机器人，我们的目的是想训练它学会站起来行走。</p>\r\n<p>那么它的动作有很多，比如脚摆动10°/20°，手摆动5°/2°，balablabla。</p>\r\n<p>环境就是一个简单的笔直的通道，从机器人出生点到终点，只不过这条直道上有许多很矮的障碍。</p>\r\n<p>奖励就是机器人离终点越近，它每走一个单位距离所能获得的奖励值就增加。并且规定如果机器人长时间没有前进，将会扣除奖励值。并且规定如果机器人被绊倒了，将会大大扣除奖励值。</p>\r\n<p>状态就是智能体通过与环境交互后每一时刻的状态。比如时刻1它到达了某个点是一个状态，时刻2它在某个点被绊倒了也是一个状态。</p>\r\n<p>通过设计这么一个机制，机器人为了得到最大奖励值，他就会逐渐学会站起来，并且走到终点。这就是深度强化学习（RL）。</p>\r\n<blockquote>\r\n<p>强化学习与监督学习的区别</p>\r\n<p>监督学习里，都是有标签的，网络可以通过正确的标签来修正自己的预测。但是强化学习里没有，它只能通过与环境不断交互来优化自己的策略。</p>\r\n</blockquote>\r\n<p>下面通过一个实验，通过实际写代码，来加深对RL的理解：</p>\r\n<p><img src=\"2.png\" /></p>\r\n<p>首先对问题进行建模，动作就是每个拉杆选择拉 /\r\n不拉。奖励就是拉下每个拉杆所获得奖励（中了得1分，没中得0分）。玩家就是我们自己。目标是在T次拉杆后，使得获得的奖励最大。</p>\r\n<p>作为一个没头脑的人，我们可能随便拉，这样子显然不会使最大奖励收敛。</p>\r\n<p>作为一个有一点头脑的人，他会这样做：拿出10%的机会去“冒险”，即随机拉一个杆，剩下90%机会去拉已经拉过的杆中获益估值最高的杆。</p>\r\n<p>作为一个更聪明的人，他随着拉杆次数的增加，拿去“冒险”的机会比例会逐渐降低。因为他知道，随着拉杆次数的增加，他对每根杆的获益估值越来越准确，所以此时更优的方法是去拉已知估值最高的，而不是拿去随机冒险浪费次数。</p>\r\n<p>通过上面这3个人的想法，我们其实已经可以有点感觉到本质了。“冒险”其实就是去探测每个拉杆的获奖概率值，“冒险”次数越多，拟合出来的每个拉杆的获奖概率值就越准。“不冒险”就是在自己拟合出来的每个拉杆概率下，选最优的。</p>\r\n<p>好的，思路知道了，代码开搞。文中附有注释：</p>\r\n<p>代码中有一点要解释一下，就是代码中的“懊悔”和“获益函数”。作为上帝视角的我们，肯定要评测不同策略（普通人、聪明人、更聪明的人）的表现。所以我们需要衡量标准。所以用“累计懊悔”来充当这个衡量标准。每次懊悔的计算公式很简单，即是(拉杆中最大获奖概率\r\n- 当前拉杆的获奖概率)。</p>\r\n<p>然后是“获益函数”，获益函数就是上面所说的我们拟合的每个拉杆的获奖概率值\r\n的平均值。他的计算公式为：<span class=\"math inline\">\\(E_k = E_k +\r\n\\frac{r_t - E_k}{N_k}\\)</span>，k是第k个拉杆，<span\r\nclass=\"math inline\">\\(r_t\\)</span>是在时刻t时拉下拉杆k所获得的收益，<span\r\nclass=\"math inline\">\\(N_k\\)</span>是第k根拉杆被拉下的次数。</p>\r\n<p>上面这个公式其实是这样推导的： <span class=\"math display\">\\[\r\nE_k = \\frac{\\sum_{t=1}^{N_t}r_t}{N_k} = \\frac{\\sum_{t=1}^{N_k-1}r_t +\r\nr_{N_k}}{N_k} = \\frac{(N_k-1)E_{k-1}+r_{N_k}}{N_k} = E_{k-1} +\r\n\\frac{r_{N_k}-E_{k-1}}{N_k}\r\n\\]</span> 这样就得到了<span\r\nclass=\"math inline\">\\(E_k\\)</span>的递推公式，需要注意的是，代码中给<span\r\nclass=\"math inline\">\\(E_k, k∈[1,\r\nK]\\)</span>赋了初值1。因为这样能保证至少先把每个拉杆都拉一遍。</p>\r\n<p>如果赋初值为0的话，那么真正只有“冒险”的时候才有几率去拉新杆了。这样的话新杆很难有机会拉到。</p>\r\n<p>所以我们希望先把全部杆至少拉一遍。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>: <span class=\"comment\"># 老虎机类</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, K</span>):</span><br><span class=\"line\">        self.K = K <span class=\"comment\"># 拉杆数量</span></span><br><span class=\"line\">        self.probs = np.random.uniform(low=<span class=\"number\">0</span>, high=<span class=\"number\">1</span>, size=K) <span class=\"comment\"># 生成K个0~1的值作为每根拉杆的获奖概率</span></span><br><span class=\"line\">        self.best_id = np.argmax(self.probs) <span class=\"comment\"># 返回self.probs最大元素的下标值</span></span><br><span class=\"line\">        self.best_prob = self.probs[self.best_id] <span class=\"comment\"># 最大获奖概率</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">play</span>(<span class=\"params\">self, k</span>): <span class=\"comment\"># 模拟拉杆</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> np.random.random() &lt; self.probs[k]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># np.random.seed(1) # 设定随机种子，不然每次的随机数值都不一样</span></span><br><span class=\"line\">K = <span class=\"number\">10</span></span><br><span class=\"line\">a = A(K) <span class=\"comment\"># 实例化老虎机</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;生成了一个拉杆为%d个的老虎机&#x27;</span> % K)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;%d号拉杆的获奖概率最大，是%.4f&#x27;</span> % (a.best_id, a.best_prob))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solver</span>: <span class=\"comment\"># 主实现函数</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, a</span>):</span><br><span class=\"line\">        self.a = a <span class=\"comment\"># self.a就是老虎机实例化的一个对象</span></span><br><span class=\"line\">        self.counts = np.zeros(a.K) <span class=\"comment\"># 用来计算每根拉杆的尝试次数</span></span><br><span class=\"line\">        self.regret = <span class=\"number\">0</span> <span class=\"comment\"># 当前步的累计懊悔</span></span><br><span class=\"line\">        self.actions = [] <span class=\"comment\"># 记录每一步的动作</span></span><br><span class=\"line\">        self.regrets = [] <span class=\"comment\"># 记录每一步的累计懊悔</span></span><br><span class=\"line\">        self.T = <span class=\"number\">0</span> <span class=\"comment\"># 记录run的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run_one_step</span>(<span class=\"params\">self</span>): <span class=\"comment\"># 返回当前这一步应该拉哪一根拉杆，具体由不同策略实现</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> NotImplementedError</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run</span>(<span class=\"params\">self, num_steps</span>):</span><br><span class=\"line\">        self.T = num_steps</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(num_steps):</span><br><span class=\"line\">            k = self.run_one_step()</span><br><span class=\"line\">            <span class=\"comment\"># 更新第k根杆的拉动次数</span></span><br><span class=\"line\">            self.counts[k] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\"># 更新动作</span></span><br><span class=\"line\">            self.actions.append(k)</span><br><span class=\"line\">            <span class=\"comment\"># 更新懊悔</span></span><br><span class=\"line\">            self.regret += self.a.best_prob - self.a.probs[k]</span><br><span class=\"line\">            self.regrets.append(self.regret)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EpsilonGreedy</span>(<span class=\"title class_ inherited__\">Solver</span>): <span class=\"comment\"># epsilon贪心算法，继承Solver类（聪明人的策略）</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, a, epsilon=<span class=\"number\">0.01</span></span>): <span class=\"comment\"># 构造函数</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>(EpsilonGreedy, self).__init__(a) <span class=\"comment\"># 先对它的父类做一遍构造</span></span><br><span class=\"line\">        <span class=\"comment\"># 初始化探索率</span></span><br><span class=\"line\">        self.epsilon = epsilon</span><br><span class=\"line\">        <span class=\"comment\"># 初始化所有拉杆的预期估值</span></span><br><span class=\"line\">        self.estimates = np.array([<span class=\"number\">1.0</span>] * a.K)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run_one_step</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> np.random.random() &lt; self.epsilon:</span><br><span class=\"line\">            k = np.random.randint(<span class=\"number\">0</span>, a.K) <span class=\"comment\"># 随机选择一根拉杆</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            k = np.argmax(self.estimates) <span class=\"comment\"># 选择期望估值最高的拉杆</span></span><br><span class=\"line\">        r = self.a.play(k) <span class=\"comment\"># 拉动</span></span><br><span class=\"line\">        <span class=\"comment\"># 更新预期估值</span></span><br><span class=\"line\">        self.estimates[k] += <span class=\"number\">1</span> / (self.counts[k] + <span class=\"number\">1</span>) * (r - self.estimates[k])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> k</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot_results</span>(<span class=\"params\">solvers, solver_name</span>): <span class=\"comment\"># 画图函数，solvers是策略列表，solver_name是策略的名字</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx, solver <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(solvers):</span><br><span class=\"line\">        x = <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(solver.actions))</span><br><span class=\"line\">        plt.plot(x, solver.regrets, label=solver_name[idx])</span><br><span class=\"line\">        plt.xlabel(<span class=\"string\">&#x27;Time steps&#x27;</span>)</span><br><span class=\"line\">        plt.ylabel(<span class=\"string\">&#x27;Cumulative regrets&#x27;</span>)</span><br><span class=\"line\">        plt.title(<span class=\"string\">&#x27;%d-bandit / Use method %s&#x27;</span> % (solver.a.K, solver_name[idx]))</span><br><span class=\"line\">        plt.legend()</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建不同的epsilon值</span></span><br><span class=\"line\">epsilons = [<span class=\"number\">1e-4</span>, <span class=\"number\">0.01</span>, <span class=\"number\">0.1</span>, <span class=\"number\">0.25</span>, <span class=\"number\">0.5</span>]</span><br><span class=\"line\"><span class=\"comment\"># 实例化EpsilonGreedy对象</span></span><br><span class=\"line\">epsilon_greedy_solvers = [EpsilonGreedy(a, epsilon=e) <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> epsilons]</span><br><span class=\"line\">epsilon_greedy_solvers_name = [<span class=\"string\">&#x27;EpsilonGreedy(epsilon=&#123;&#125;)&#x27;</span>.<span class=\"built_in\">format</span>(e) <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> epsilons]</span><br><span class=\"line\"><span class=\"comment\"># 开始run</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> idx, solver <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(epsilon_greedy_solvers):</span><br><span class=\"line\">    solver.run(<span class=\"number\">5000</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;The cumulative regrets of %s is %.4lf&#x27;</span> % (epsilon_greedy_solvers_name[idx], solver.regret))</span><br><span class=\"line\"><span class=\"comment\"># 画图</span></span><br><span class=\"line\">plot_results(epsilon_greedy_solvers, epsilon_greedy_solvers_name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DecayingEpsilonGreedy</span>(<span class=\"title class_ inherited__\">EpsilonGreedy</span>): <span class=\"comment\"># 更聪明的人的策略</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, a, epsilon=<span class=\"number\">0.1</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(DecayingEpsilonGreedy, self).__init__(a, epsilon=epsilon)</span><br><span class=\"line\">        self.count = -<span class=\"number\">1</span></span><br><span class=\"line\">        self.epsilon2 = self.epsilon</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run_one_step</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 让epsilon随着拉杆次数增加线性递减到0</span></span><br><span class=\"line\">        self.count += <span class=\"number\">1</span></span><br><span class=\"line\">        self.epsilon =(-<span class=\"number\">1</span> * self.epsilon2 / self.T) * self.count + self.epsilon2</span><br><span class=\"line\">        <span class=\"keyword\">if</span> np.random.random() &lt; self.epsilon:</span><br><span class=\"line\">            k = np.random.randint(<span class=\"number\">0</span>, a.K) <span class=\"comment\"># 随机选择一根拉杆</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            k = np.argmax(self.estimates) <span class=\"comment\"># 选择期望估值最高的拉杆</span></span><br><span class=\"line\">        r = self.a.play(k) <span class=\"comment\"># 拉动</span></span><br><span class=\"line\">        <span class=\"comment\"># 更新预期估值</span></span><br><span class=\"line\">        self.estimates[k] += <span class=\"number\">1</span> / (self.counts[k] + <span class=\"number\">1</span>) * (r - self.estimates[k])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> k</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>()</span><br><span class=\"line\">epsilons = [<span class=\"number\">1e-4</span>, <span class=\"number\">0.01</span>, <span class=\"number\">0.1</span>, <span class=\"number\">0.25</span>, <span class=\"number\">0.5</span>]</span><br><span class=\"line\"><span class=\"comment\"># 实例化DecayingEpsilonGreedy对象</span></span><br><span class=\"line\">decaying_epsilon_greedy_solvers = [DecayingEpsilonGreedy(a, epsilon=e) <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> epsilons]</span><br><span class=\"line\">decaying_epsilon_greedy_solvers_name = [<span class=\"string\">&#x27;DecayingEpsilonGreedy(epsilon=&#123;&#125;)&#x27;</span>.<span class=\"built_in\">format</span>(e) <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> epsilons]</span><br><span class=\"line\"><span class=\"comment\"># 开始run</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> idx, solver <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(decaying_epsilon_greedy_solvers):</span><br><span class=\"line\">    solver.run(<span class=\"number\">5000</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span> (<span class=\"string\">&#x27;The cumulative regrets of %s is %.4lf&#x27;</span> % (decaying_epsilon_greedy_solvers_name[idx], solver.regret))</span><br><span class=\"line\"><span class=\"comment\"># 画图</span></span><br><span class=\"line\">plot_results(decaying_epsilon_greedy_solvers, decaying_epsilon_greedy_solvers_name)</span><br></pre></td></tr></table></figure>\r\n<p>让我们来看一下代码的运行结果：</p>\r\n<p><img src=\"3.png\" /></p>\r\n<p><img src=\"4.png\" /></p>\r\n<p><img src=\"5.png\" /></p>\r\n<p><img src=\"6.png\" /></p>\r\n<p><img src=\"7.png\" /></p>\r\n<p>（俩图的标题的epsilon那错了懒得改了不影响）</p>\r\n<p>对于图中这次生成的数据来说，“冒险”概率越低效果越好（曲线几乎不增长）。当然我自己在本地测试各种生成数据后总结发现冒险概率=0.01/0.1时表现最优。</p>\r\n<p>然后使用DecayingEpsilonGreedy策略后表现更优了一些，对那些初始冒险率越大的优化效果越好。</p>\r\n<p>通过这个案例，已经可以对RL有一个初步理解了。老虎机这个案例除了用Epsilon-Greedy，还可以用<strong>上置信界算法</strong>、<strong>汤普森采样算法</strong>方法去解决。这三种方法是解决绝大多数RL的基本思想。</p>\r\n<p>但是老虎机这个案例是<strong>无状态强化学习</strong>，因为每一次与老虎机交互的结果和以往的动作无关。那有状态的强化学习怎么办呢？下一节将会对马尔可夫决策过程进行讲解。</p>\r\n","categories":["2. 技能栈","多智能体强化学习"]},{"title":"2. 几种重要的凸集-上","url":"/2023/10/05/2-%E5%87%A0%E7%A7%8D%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%B8%E9%9B%86-%E4%B8%8A/","content":"<p>介绍了一个点、空集、超平面、半空间、球、椭球。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n<p><img src=\"2.jpg\" /></p>\r\n","categories":["4. 大学","凸优化"]},{"title":"2. python急救包","url":"/2023/10/16/2-python%E6%80%A5%E6%95%91%E5%8C%85/","content":"<p>许多代码都是用python实现的，我的python基础一般，所以在实践中学咯。下面记录一些\r\npython常用的基础语法。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"numpy相关\">numpy相关</h3>\r\n<h4 id=\"随机数\">随机数</h4>\r\n<p>np.random.random()：生成一个[0, 1)的随机数</p>\r\n<p>np.random.uniform(low=, high=, size=)：生成size个[low,\r\nhigh)的随机数</p>\r\n<p>np.random.randint(x, y)：生成一个[x, y]的整数</p>\r\n<p>np.random.seed(可填数字)：不填就是随机数。填不同的数字就代表不同的世界线。处于同一个世界线的随机数们都是固定的</p>\r\n<h4 id=\"创建数组\">创建数组</h4>\r\n<p>np.zeros(k)：生成一个有k个元素，初始值为0的数组</p>\r\n<p>np.array(val * num)：生成一个有num个元素，初始值为val的数组</p>\r\n<h4 id=\"数组操作\">数组操作</h4>\r\n<p>np.argmax(数组)：返回数组中最大值的下标</p>\r\n<h3 id=\"python基本语法相关\">python基本语法相关</h3>\r\n<ul>\r\n<li>a.append()：列表追加元素</li>\r\n<li>for idx, x in\r\nenumerate(solvers)：使用enumerate方法可以下标和元素本身表示出来很方便</li>\r\n<li>a = range(num)：产生一个[0, 1, 2, ..., num]的数组</li>\r\n<li>epsilons = [1, 2, 3, 4], a = [fun(e) for e in\r\nepsilons]：很方便的定义一个列表，列表里的元素就是拿每个epsilons的元素丢进fun里返回来的东西</li>\r\n<li>print (\"啦啦啦%d，噜噜噜%s，嘻嘻嘻%.4lf\" % (a, b,\r\nc))：格式化输出</li>\r\n<li>‘啦啦啦{0}噜噜噜{1}’.format(a, b)：也是格式化输出，可以这样使用a =\r\n['abc is {}'.format(e) for e in epsilons]</li>\r\n<li>Python写一个类记得要写构造函数def __init__(self):\r\n若需参数自己加</li>\r\n<li>Python也可以写类，继承很简单，比如类A继承B，就写class A(B):\r\n即可</li>\r\n<li>class A继承B的话，记得在A的构造函数里第一句加一个super(A,\r\nself).__init__(B的构造函数的参数)。这一步就是在填父类的构造函数</li>\r\n</ul>\r\n<h3 id=\"matplotlib.pyplot相关\">matplotlib.pyplot相关</h3>\r\n<p>plt.plot(x, y,\r\nlabel=)：x是一个列表，代表x轴的数据；y是一个列表，代表y轴的数据；label也是一个列表，代表不同线的名字（绘制多条线时使用）</p>\r\n<p>plt.xlabel('xxx')：给x轴起名字</p>\r\n<p>plt.ylabel('xxx')：给y轴起名字</p>\r\n<p>plt.title('xxx')：起标题</p>\r\n<p>plt.legend()：显示图例，要配合plt.plot中的label使用</p>\r\n<p>plt.show()：把图画出来</p>\r\n","categories":["2. 技能栈","多智能体强化学习"]},{"title":"4. 保凸运算","url":"/2023/11/19/4-%E4%BF%9D%E5%87%B8%E8%BF%90%E7%AE%97/","content":"<p>介绍了4种不改变集合凸性的运算：集合交、仿射函数、透视函数、线性分数函数。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.png\" /></p>\r\n<p><img src=\"2.png\" /></p>\r\n<p><img src=\"3.png\" /></p>\r\n<p><img src=\"4.png\" /></p>\r\n","categories":["4. 大学","凸优化"]},{"title":"5. 凸函数的定义","url":"/2023/11/19/5-%E5%87%B8%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89/","content":"<p>介绍了凸函数的四种定义：直接定义、降维定义、一阶可微下的定义、二阶可微下的定义。以及补充了若A为对称矩阵条件下，<span\r\nclass=\"math inline\">\\(x^TAx \\ge 0 \\iff A \\succeq 0\\)</span>的证明。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.png\" /></p>\r\n<p><img src=\"2.png\" /></p>\r\n<p><img src=\"3.png\" /></p>\r\n<p><img src=\"4.png\" /></p>\r\n","categories":["4. 大学","凸优化"]},{"title":"3. 几种重要的凸集-下","url":"/2023/10/05/3-%E5%87%A0%E7%A7%8D%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%B8%E9%9B%86-%E4%B8%8B/","content":"<p>介绍了多面体、单纯形、多面体与单纯形的关系、对称矩阵集合、对称半正定矩阵集合、对称正定矩阵集合。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n<p><img src=\"2.jpg\" /></p>\r\n","categories":["4. 大学","凸优化"]},{"title":"ChatGPT4使用","url":"/2023/11/12/ChatGPT4%E4%BD%BF%E7%94%A8/","content":"<p>最近OpenAI开了发布会，ChatGPT4更新为GPT-4\r\nTurbo，还推出了一个GPTs功能，这使得人们可以自己定制化GPT，还可以使用人家的GPTs。</p>\r\n<p>我猜未来GPTs应该跟国内小程序一样，将一定程度上改变app/网站的生态。</p>\r\n<p>所以为了体验一下GPT-4\r\nTurbo，我去官网注册了OpenAI的账号并且购买了GPT4（一个月）。这篇博客内容是订阅方法以及基本使用GPT4的方法。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"如何订阅gpt4-plus\">如何订阅GPT4 PLUS？</h3>\r\n<ol type=\"1\">\r\n<li>去<a href=\"https://chat.openai.com/\">官网链接\r\n(openai.com)</a>注册一个OpenAI账号并登录（建议通过Google邮箱注册）</li>\r\n<li>注册过程中，需要用到手机号验证，使用<a\r\nhref=\"https://sms-activate.org/cn\">SMS-Activate</a>解决</li>\r\n<li>1、2步完成后，就可以使用ChatGPT服务了，但是只能使用3.5而且有次数限制。点击升级，会看到一个支付界面，界面里要填银行卡相关信息。银行卡只能使用美国的。所以在<a\r\nhref=\"https://www.fomepay.com/\">FOMEPay</a>上购买一张虚拟美国银行卡，往里充钱。然后将卡号信息填到刚才的界面中即可。</li>\r\n<li>充值成功，可正常使用ChatGPT4</li>\r\n</ol>\r\n<p>（注意，充值过程一定要全程使用美国IP的梯子！）</p>\r\n<h3 id=\"如何使用\">如何使用？</h3>\r\n<p>想怎么用怎么用，推荐几个插件：</p>\r\n<ol type=\"1\">\r\n<li>WebPilot：帮助ChatGPT联网搜索信息</li>\r\n<li>Wolfram：科学计算，图标绘制</li>\r\n<li>Tutory：可以帮你制定任意领域的学习路线</li>\r\n<li>Ai Tool Hunt：找插件的插件</li>\r\n<li>MixerBox Scholar：可以访问一些学术资源</li>\r\n</ol>\r\n","categories":["杂项"]},{"title":"FROST—Fast row-stochastic optimization with uncoordinated step-sizes","url":"/2023/12/04/FROST%E2%80%94Fast-row-stochastic-optimization-with-uncoordinated-step-sizes/","content":"<p>中文翻译是：非协调步长行随机优化</p>\r\n<p>个人认为在仔细研读了Distributed那篇文章后，再看这篇文章时，会对双随机、列随机、行随机的算法分别有哪些有一个很好的认识。</p>\r\n<span id=\"more\"></span>\r\n<hr />\r\n<h3 id=\"abstract\">Abstract</h3>\r\n<p>本文讨论了构造不出双随机权值的有向图上的分布优化问题。</p>\r\n<p>现有算法大多采用推和共识算法，利用列随机权值来克服这一问题。列随机权值的形成要求每个代理(至少)知道其输出度，这在诸如基于广播的通信协议中可能是不切实际的。</p>\r\n<p>与此相反，我们描述了一种适用于不要求出度知识的有向图的快速行随机优化算法。</p>\r\n<p>该方法的实现很简单，因为每个代理在本地为传入的信息分配权重，并在本地选择合适的步长。我们证明了对于光滑且强凸函数，在最大步长为正且足够小的前提下，算法线性收敛到最优解。</p>\r\n<hr />\r\n<h3 id=\"introduction\">1. Introduction</h3>\r\n<p>第2节阐述了问题和假设。第3节回顾了使用双随机或列随机权值的相关算法，并展示了这些类型算法分析背后的直觉。在第4节中，我们提供了本文提出的主要算法FROST。在第5节中，我们发展了FROST的收敛性质。第6节给出了仿真结果，第7节总结了本文。</p>\r\n<p>下面是Notation：</p>\r\n<p>对于行随机矩阵<span\r\nclass=\"math inline\">\\(\\underline{A}\\)</span>，<span\r\nclass=\"math inline\">\\(\\pi_r,\r\n1_n\\)</span>分别是其左右Perron特征向量，满足<span\r\nclass=\"math inline\">\\(\\pi_r^T1_n = 1\\)</span></p>\r\n<p>对于列随机矩阵<span class=\"math inline\">\\(\\underline{B}\\)</span>\r\n，<span class=\"math inline\">\\(1_n,\r\n\\pi_c\\)</span>分别是其左右Perron特征向量，满足<span\r\nclass=\"math inline\">\\(1_n^T\\pi_c = 1\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\|\\|_F\\)</span>是Frobenius范数，<span\r\nclass=\"math inline\">\\(\\|\\|_2\\)</span>是欧几里得范数，<span\r\nclass=\"math inline\">\\(\\|\\|\\)</span>也是一个范数，具体含义看具体那部分的文章</p>\r\n<p><span class=\"math inline\">\\({\\otimes}\\)</span>表示Kronecker积。</p>\r\n<hr />\r\n<h3 id=\"problem-formulation\">2. Problem formulation</h3>\r\n<p>如果 j 连向 i ，则<span class=\"math inline\">\\((i, j) \\in\r\n\\mathcal{E}\\)</span> 另外，目标是最小化总花费，即： <span\r\nclass=\"math display\">\\[\r\n\\min_{\\mathbf{x}}F(\\mathbf{x})\\triangleq\\frac{1}{n}\\sum_{i=1}^{n}f_{i}(\\mathbf{x})\r\n\\]</span></p>\r\n<h4 id=\"assumption-1\">Assumption 1</h4>\r\n<p>图G是无向联通图。</p>\r\n<h4 id=\"assumption-2\">Assumption 2</h4>\r\n<p>图G是有向强连通图。</p>\r\n<h4 id=\"assumption-3\">Assumption 3</h4>\r\n<p><span\r\nclass=\"math inline\">\\(f_i\\)</span>是凸函数，且具有有界次梯度。</p>\r\n<h4 id=\"assumption-4\">Assumption 4</h4>\r\n<p><span\r\nclass=\"math inline\">\\(f_i\\)</span>是光滑，且强凸的。（光滑定义：具有连续的导数）</p>\r\n<p>即满足以下式子： <span class=\"math display\">\\[\r\n\\left\\|\\nabla f_i(\\mathbf{x})-\\nabla f_i(\\mathbf{y})\\right\\|_2\\leq\r\nl\\|\\mathbf{x}-\\mathbf{y}\\|_2 \\\\\r\nf_i(\\mathbf{y})\\geq f_i(\\mathbf{x})+\\nabla\r\nf_i(\\mathbf{x})^\\top(\\mathbf{y}-\\mathbf{x})+\\frac{\\mu}{2}\\|\\mathbf{x}-\\mathbf{y}\\|_2^2\r\n\\]</span> 第一个就是导数满足Lipschitz连续，所以<span\r\nclass=\"math inline\">\\(f_i\\)</span>肯定光滑。</p>\r\n<p>第二个就是凸函数的定义，因为有不等号右边最后一项的存在，所以<span\r\nclass=\"math inline\">\\(f_i\\)</span>是个强凸函数。</p>\r\n<h4 id=\"assumption-5\">Assumption 5</h4>\r\n<p>网络中的每个玩家都知道自己的编号。</p>\r\n<h4 id=\"assumption-6\">Assumption 6</h4>\r\n<p>每个玩家知道它的出度。</p>\r\n<hr />\r\n<h3 id=\"补充\">补充</h3>\r\n<p>看到这里。我想先停一下。来看一道题：假设每个玩家有一个初始值xi。如果他们都想知道所有玩家初始值的平均值是多少，应该怎么做？</p>\r\n<p>如果图是平衡的，则用平均一致性算法即可。即类似于：<span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_i^{k+1}=\\sum_{j=1}^Na_{ij}\\tilde{\\sigma}_j^k\\)</span>。</p>\r\n<p>如果图不平衡，则采用推和算法。 <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;\\nu_{k+1}^{i} =\\sum_{j=1}^nb_{ij}\\nu_k^j,  \\\\\r\n&amp;\\mathbf{x}_{k+1}^{i} =\\sum_{j=1}^nb_{ij}\\mathbf{x}_k^j  \\\\\r\n&amp;\\mathbf{z}_{k+1}^{i} =\\frac{\\mathbf{x}_{k+1}^i}{\\nu_{k+1}^i},\r\n\\end{aligned}\r\n\\]</span> 每一个点维护两个值：x、v（都是一维的）。所谓推，就是点 j\r\n把值xj / 出度推给邻居，把权重vj / 出度推给邻居。所谓和，就是点 i\r\n把所有邻居 j 推来的值加一起得到vi，把所有邻居 j\r\n推来的权重加一起得到xi。</p>\r\n<p>注意到，对于任意时刻k，有：<span\r\nclass=\"math inline\">\\(\\frac{\\sum{x_i}}{\\sum{v_i}} = \\frac{x1 + x2 + ...\r\n+ xn}{n} = avg\\)</span></p>\r\n<p>当迭代的次数足够大时，信息已经在网络中充分流转。第 i 个点的<span\r\nclass=\"math inline\">\\(x_i\\)</span>会收敛到<span\r\nclass=\"math inline\">\\(n[\\boldsymbol{\\pi}_c]_i * avg\\)</span>，<span\r\nclass=\"math inline\">\\(v_i\\)</span>会收敛到<span\r\nclass=\"math inline\">\\(n[\\pi_c]_i\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\frac{x_i}{v_i} = avg\\)</span>。（<span\r\nclass=\"math inline\">\\(\\pi_c\\)</span>是列随机矩阵的右Perron特征向量）</p>\r\n<p>即每个点的xi / vi都收敛到全局平均值。</p>\r\n<p>这是一维的情况。</p>\r\n<p>如果每个玩家的初始值是一个向量xi（权重vi仍然不变初始值为1），则一样的，经过推和算法后，每个玩家的zi都收敛到avg（此时avg就是一个向量）。</p>\r\n<p>在推和共识上稍加改动，就可以得到下面这个算法： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;\\nu_{k+1}^{i} =\\sum_{j=1}^nb_{ij}\\nu_k^j,  \\\\\r\n&amp;\\mathbf{x}_{k+1}^{i}\r\n=\\sum_{j=1}^nb_{ij}\\mathbf{x}_k^j-\\alpha_k\\nabla\r\nf_i\\left(\\mathbf{z}_k^i\\right),  \\\\\r\n&amp;\\mathbf{z}_{k+1} =\\frac{\\mathbf{x}_{k+1}^i}{\\nu_{k+1}^i},\r\n\\end{aligned}\r\n\\]</span> 下面这个算法只在更新x时加了一个梯度项。</p>\r\n<p>这样的话，当迭代次数足够多时，第 i 个点的<span\r\nclass=\"math inline\">\\(x_i\\)</span>会收敛到<span\r\nclass=\"math inline\">\\([\\boldsymbol{\\pi}_c]_i * x^*\\)</span>，<span\r\nclass=\"math inline\">\\(v_i\\)</span>会收敛到<span\r\nclass=\"math inline\">\\(n[\\pi_c]_i\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\frac{x_i}{v_i} = x^*\\)</span>。</p>\r\n<h3 id=\"personal-summary\">Personal Summary</h3>\r\n<p>首先是由推和协议衍生出来的算法，推和协议用列随机矩阵可以求出全局平均值（如果玩家动作是动态更新的话，更新sigma时记得+x[i]\r\n- xx[i]）。</p>\r\n<p>因此套一个梯度下降就可以解决聚合游戏问题。</p>\r\n<p>如果已知最优解都会收敛到一个值的话，可以直接在推和协议中修改加一个梯度项，使得收敛到最优解。为了加快速度，还可以将普通的梯度项改为考虑全局的梯度项。</p>\r\n","categories":["1. 论文"]},{"title":"Linear convergence in optimization over directed graphs with row-stochastic matrices","url":"/2023/10/31/Linear-convergence-in-optimization-over-directed-graphs-with-row-stochastic-matrices/","content":"<p>标题：Linear convergence in optimization over directed graphs with\r\nrow-stochastic matrices</p>\r\n<p>中文翻译：行随机矩阵有向图优化的线性收敛性</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"abstract\">Abstract</h3>\r\n<p>本文研究的是一个多智能体网络（有向图）上的分布式优化问题，其中目标函数是每个玩家成本函数的总和。</p>\r\n<p>现存的在有向图上的分布式优化算法都至少需要每个玩家知道其邻居的出度。但本文不需要。而且最佳收敛速度为<span\r\nclass=\"math inline\">\\(O(\\mu^{k}), 0 &lt; \\mu &lt; 1, k\\)</span> is the\r\nnumber of 迭代。</p>\r\n<p>前提是目标函数为强凸函数，且具有Lipschitz连续梯度。</p>\r\n<h3 id=\"introduction\">1. Introduction</h3>\r\n<p>近年来出现了许多分布式优化方法，最初的方法是基于梯度下降，这种方法直观且计算简单，但由于算法使用的步长逐渐减小，通常速度较慢。证明了任意凸函数的收敛速度为<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln\r\nk}{\\sqrt{k}})\\)</span>，强凸函数的收敛速度为<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln k}k)\\)</span>。</p>\r\n<p>后来，发展出基于拉格朗日对偶变量的方法，例如分布式对偶分解[15]、分布式实现交替方向乘法器[16\r\n- 18]。对于强凸函数收敛速度将达到<span\r\nclass=\"math inline\">\\(O(\\mu^k)\\)</span>，缺点是计算代价比较高。</p>\r\n<p>再后来，为了兼顾收敛速度和计算简易性，一些分布式算法在保持步长不变的前提下，不使用对偶变量。例如分布式Nesterov-based方法，对于任意满足有界和Lipschitz梯度的凸函数，收敛速度达到<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln k}{k^2})\\)</span>。还例如[20],\r\n[21]中的方法，用固定步长和历史梯度信息实现了对一般凸函数<span\r\nclass=\"math inline\">\\(O(\\frac{1}{k})\\)</span>，强凸函数<span\r\nclass=\"math inline\">\\(O(\\mu^k)\\)</span>的收敛速度。</p>\r\n<p>但是上面这些方法都是在基于无向图或者权重平衡图上考虑的。但是实际中更多的是权重不平衡有向图的情况，所以这篇论文就是来解决这个问题的。</p>\r\n<p>怎么解决呢？一般分布式优化中通常需要双随机矩阵，可是有向图中得不到双随机矩阵，只能得到行随机矩阵或者列随机矩阵。本文提出的算法参考了[36]。</p>\r\n<p>Notation：</p>\r\n<ul>\r\n<li><p>小写字母是标量，小写粗体是向量，大写字母是矩阵</p></li>\r\n<li><p>The spectral radius of a matrix A is <span\r\nclass=\"math inline\">\\(\\rho(A)\\)</span>。谱半径就是A的特征值绝对值的最大值</p></li>\r\n<li><p><span class=\"math inline\">\\(\\lambda_{i}(A)\\)</span> denotes the\r\n<span class=\"math inline\">\\(i-th\\)</span> largest eigenvalue of\r\nA.</p></li>\r\n<li><p>对于一个最简的行随机矩阵A，将其特征值1的右特征向量记为<span\r\nclass=\"math inline\">\\(1_n\\)</span>，左特征向量记为<span\r\nclass=\"math inline\">\\(\\pi ^T\\)</span>，使得<span\r\nclass=\"math inline\">\\(\\pi ^T \\cdot 1_n = 1\\)</span>。</p></li>\r\n<li><p><span\r\nclass=\"math inline\">\\(\\|\\cdot\\|\\)</span>被定义为一个特殊的矩阵范数，在Lemma2中会讲到</p></li>\r\n<li><p><span\r\nclass=\"math inline\">\\(\\|\\cdot\\|_2\\)</span>就是普通的向量或者矩阵的二范数</p></li>\r\n<li><p>有性质： <span class=\"math display\">\\[\r\n\\begin{aligned}c&#39;\\|\\cdot\\|\\leq\\|\\cdot\\|_2\\leq c\\|\\cdot\\|\r\n\\\\d&#39;\\|\\cdot\\|_2\\leq\\|\\cdot\\|\\leq d\\|\\cdot\\|_2\\end{aligned} \\\\\r\nc&#39;, c, d&#39;, d\\,are\\,some\\,positive\\,constants\r\n\\]</span></p></li>\r\n<li><p>更多关于向量和矩阵范数的知识，参考[37]</p></li>\r\n</ul>\r\n<h3 id=\"problem-assumptions-algorithm\">2. Problem, Assumptions,\r\nAlgorithm</h3>\r\n<p>Problem：</p>\r\n<p>把问题描述为一个强连通有n个玩家的有向图：<span\r\nclass=\"math inline\">\\(\\mathcal{G}=(\\mathcal{V},\\mathcal{E})\\)</span>。注意若<span\r\nclass=\"math inline\">\\((i, j) \\in \\mathcal{E}\\)</span>，则<span\r\nclass=\"math inline\">\\(j\\)</span>可以发信息给<span\r\nclass=\"math inline\">\\(i\\)</span>。定义<span\r\nclass=\"math inline\">\\(\\mathcal{N}_i^{in}\\)</span>为<span\r\nclass=\"math inline\">\\(i\\)</span>自己加上<span\r\nclass=\"math inline\">\\(i\\)</span>的邻居，这个集合也就是能发信息给<span\r\nclass=\"math inline\">\\(i\\)</span>的玩家集合。</p>\r\n<p>我们要的目标函数是这个：<span\r\nclass=\"math inline\">\\(min\\,f(\\mathbf{x})=\\sum_{i=1}^nf_i(\\mathbf{x})\\)</span></p>\r\n<p>需要注意<span\r\nclass=\"math inline\">\\(f_i\\)</span>是凸且可微的，并且只有玩家<span\r\nclass=\"math inline\">\\(i\\)</span>知道。</p>\r\n<p>Assumption 1：有向图是强连通的。</p>\r\n<p>Assumption 2：每个<span\r\nclass=\"math inline\">\\(f_i\\)</span>是可微且强凸的。且对x导数（梯度）具有Lipschitz连续。具体来说，<span\r\nclass=\"math inline\">\\(f_i\\)</span>满足如下两个定义：</p>\r\n<blockquote>\r\n<p><span\r\nclass=\"math inline\">\\(f_i(\\mathbf{x}_1)-f_i(\\mathbf{x}_2)\\leq\\nabla\r\nf_i(\\mathbf{x}_1)^\\top(\\mathbf{x}_1-\\mathbf{x}_2)-\\frac{s}{2}\\|\\mathbf{x}_1-\\mathbf{x}_2\\|_2^2\\)</span>，s是正整数</p>\r\n<p><span class=\"math inline\">\\(\\|\\nabla f_i(\\mathbf{x}_1)-\\nabla\r\nf_i(\\mathbf{x}_2)\\|_2\\leq\r\nl\\|\\mathbf{x}_1-\\mathbf{x}_2\\|_2\\)</span>，l是正整数</p>\r\n</blockquote>\r\n<p>因为<span class=\"math inline\">\\(f\\)</span>是所有<span\r\nclass=\"math inline\">\\(f_i\\)</span>之和，所以<span\r\nclass=\"math inline\">\\(f\\)</span>也是满足强凸和Lipschitz梯度连续的，也就是满足上面那俩式子。显然常数分别为<span\r\nclass=\"math inline\">\\(ns, nl\\)</span>。</p>\r\n<p>Algorithm： <span class=\"math display\">\\[\r\n\\begin{gathered}\r\n\\mathbf{x}_{k+1,i}\r\n=\\sum_{j=1}^{n}a_{ij}\\mathbf{x}_{k,j}-\\alpha\\mathbf{z}_{k,i},\r\n\\left.\\left(\\begin{matrix}{1}{\\mathrm{a}}\\\\\\end{matrix}\\right.\\right) \\\\\r\n\\mathbf{y}_{k+1,i} =\\sum_{j=1}^{n}a_{ij}\\mathbf{y}_{k,j}, (1\\mathrm{b})\r\n\\\\\r\n\\mathbf{z}_{k+1,i} =\\sum_{j=1}^{n}a_{ij}\\mathbf{z}_{k,j}+{\\frac{\\nabla\r\nf_{i}(\\mathbf{x}_{k+1,i})}{[\\mathbf{y}_{k+1,i}]_{i}}}-{\\frac{\\nabla\r\nf_{i}(\\mathbf{x}_{k,i})}{[\\mathbf{y}_{k,i}]_{i}}}\r\n\\left.\\left(\\begin{matrix}{1}{\\mathrm{c}}\\\\\\end{matrix}\\right.\\right)\r\n\\end{gathered}\r\n\\]</span> <span class=\"math inline\">\\(a_{ij}\\)</span> 满足下面这个条件：\r\n<span class=\"math display\">\\[\r\na_{ij}=\\begin{cases}&amp;&gt;0,&amp;j\\in\\mathcal{N}_i^\\mathrm{in},\\\\&amp;0,&amp;\\mathrm{otw.},\\end{cases}\\quad\\sum_{j=1}^na_{ij}=1,\\forall\r\ni\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(\\alpha &gt; 0\\)</span> is a constant\r\nstep-size</p>\r\n<p><span class=\"math inline\">\\(\\nabla\r\nf_{i}(\\mathbf{x}_{k,i})\\in\\mathbb{R}^{p}\\)</span> is the gradient of\r\n<span class=\"math inline\">\\(f_i\\)</span> at <span\r\nclass=\"math inline\">\\(x_{k, i}\\)</span></p>\r\n<p><span class=\"math inline\">\\(x_0\\)</span> is arbitrary, <span\r\nclass=\"math inline\">\\(\\mathbf{y}_{0,i}=\\mathbf{e}_i, \\quad\r\n\\mathbf{z}_{0,i}=\\nabla f_i(\\mathbf{x}_{0,i})\\)</span></p>\r\n<p>上面的算法中</p>\r\n<p>根据[38]中的Perron-Frobenius定理，(1b)将收敛到矩阵A的左特征向量<span\r\nclass=\"math inline\">\\(\\pi ^T\\)</span>。</p>\r\n<p>(1c)使用(1b)来缩放梯度，从而消除了行随机矩阵引起的不平衡。</p>\r\n<p>而且，为了简化证明，其实可以把<span class=\"math inline\">\\(x_{k, i},\r\nz_{k, i}, \\nabla\r\nf_i(x_{k,i})\\)</span>,$看成一维的。只要一维的得证了，后续套一个Kronecker\r\nproduction notation就可以把p维的证出来了。</p>\r\n<p>为了简化表达，我们定义下面式子： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\mathbf{x}_{k}&amp; =[x_{k,1},\\cdots,x_{k,n}]^{\\top},  \\\\\r\n\\mathbf{Z}_{k}&amp; =[z_{k,1},\\cdots,z_{k,n}]^{\\top},  \\\\\r\n\\nabla\\mathbf{f}_{k}&amp; =\\left[\\nabla f_1(x_{k,1}),\\cdots,\\nabla\r\nf_n(x_{k,n})\\right]^\\top,  \\\\\r\nY_{k}&amp; =[\\mathbf{y}_{k,1},\\cdots,\\mathbf{y}_{k,n}]^\\top,  \\\\\r\n\\widetilde{Y}_{k}&amp; =\\operatorname{diag}(Y_k).\r\n\\end{aligned}\r\n\\]</span> 则algorithm 1可以写成以下形式： <span class=\"math display\">\\[\r\n\\begin{gathered}\r\n\\mathbf{x}_{k+1}= A\\mathbf{x}_{k}-\\alpha\\mathbf{z}_{k}, (2\\mathrm{a}) \\\\\r\nY_{k+1}= AY_{k}, (2\\mathrm{b}) \\\\\r\n\\mathbf{z}_{k+1}= A\\mathbf{z}_{k}+\\widetilde\r\nY_{k+1}^{-1}\\nabla\\mathbf{f}_{k+1}-\\widetilde\r\nY_{k}^{-1}\\nabla\\mathbf{f}_{k}, \\text{(2c)}\r\n\\end{gathered}\r\n\\]</span></p>\r\n<h3 id=\"main-results\">3. Main results</h3>\r\n<p>定义：<span\r\nclass=\"math inline\">\\(Y_\\infty=\\lim_{k\\to\\infty}Y_k\\)</span></p>\r\n<p>因为<span class=\"math inline\">\\(Y_k = AY_{k-1} = A^2Y_{k-2} =\r\n...\\)</span></p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\operatorname*{lim}_{k\\to\\infty}Y_{k}=\\operatorname*{lim}_{k\\to\\infty}A^{k}\\)</span>（<span\r\nclass=\"math inline\">\\(Y_1=I_n\\)</span>）</p>\r\n<p>又由[38]中的Perron-Frobenius定理，<span\r\nclass=\"math inline\">\\(Y_k\\)</span>将收敛到<span\r\nclass=\"math inline\">\\(1_n\\pi ^ T\\)</span></p>\r\n<p>即<span\r\nclass=\"math inline\">\\(Y_\\infty=\\lim\\limits_{k\\to\\infty}Y_k=\\operatorname*{lim}\\limits_{k\\to\\infty}A^k=1_n\\pi^T\\)</span>\r\n继续定义： <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\mathbf{x}^{*}&amp; =x^{*}\\mathbf{1}_{n},  \\\\\r\n\\widehat{\\mathbf{x}}_{k}&amp; =Y_{\\infty}\\mathbf{x}_{k},  \\\\\r\n\\widehat{z}_{k}&amp; =Y_{\\infty}\\mathbf{z}_{k},  \\\\\r\n\\nabla\\mathbf{f}^{*}&amp; =[\\nabla f_{1}(x^{*}),\\cdots,\\nabla\r\nf_{n}(x^{*})]^{\\top},  \\\\\r\n\\nabla\\widehat{\\mathbf{f}}_{k}&amp;\r\n=\\frac{1}{n}\\mathbf{1}_{n}\\mathbf{1}_{n}^{\\top}\\left[\\nabla\r\nf_{1}(\\widehat{x}_{k}),...,\\nabla f_{n}(\\widehat{x}_{k})\\right]^{\\top},\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;\\tau=\\left\\|A-I_{n}\\right\\|_{2}, \\\\\r\n&amp;\\epsilon=\\left\\|I_{n}-Y_{\\infty}\\right\\|_{2}, \\\\\r\n&amp;\\eta=\\operatorname*{max}\\left(\\left|1-\\alpha\r\nnl\\right|,\\left|1-\\alpha ns\\right|\\right)\r\n\\end{aligned}\r\n\\]</span></p>\r\n<p><span class=\"math inline\">\\(l, s\\)</span>出自这： $$\r\nf_i(_1)-f_i(_2)f_i(_1)^(_1-_2)-|_1-_2|_2^2$，s是正整数 \\</p>\r\n|f_i(_1)-f_i(_2)|_2l|_1-_2|_2$，l是正整数 <span class=\"math display\">\\[\r\n继续定义：\r\n\\]</span>\r\n<span class=\"math display\">\\[\\begin{aligned}\r\n&amp;y=\\operatorname*{sup}_{k}\\left\\|Y_{k}\\right\\|_{2}, \\\\\r\n&amp;\\widetilde{y}=\\operatorname*{sup}_{k}\\left\\|\\widetilde{Y}_{k}^{-1}\\right\\|_{2}.\r\n\\end{aligned}\\]</span>\r\n<p>$$</p>\r\n<h4 id=\"lemma-1\">Lemma 1</h4>\r\n<p><span class=\"math inline\">\\(\\left\\|Y_k-Y_\\infty\\right\\|_2\\leq\r\nT\\gamma_1^k,\\quad\\forall k.\\quad(3) \\\\ 0 &lt; \\gamma &lt; 1 \\, and \\, 0\r\n&lt; T &lt; \\infty\\)</span></p>\r\n<p>推导参考[22]</p>\r\n<h4 id=\"lemma-2\">Lemma 2</h4>\r\n<p>For any <span class=\"math inline\">\\(a \\in \\mathbb{R^n}\\)</span>,\r\ndefine <span\r\nclass=\"math inline\">\\(\\widehat{\\mathbf{a}}=Y_{\\infty}\\mathbf{a}\\)</span>.\r\nThen there exists <span class=\"math inline\">\\(0&lt;\\sigma&lt;1\\)</span>\r\nsuch that <span class=\"math display\">\\[\r\n\\left\\|A\\mathbf{a}-\\widehat{\\mathbf{a}}\\right\\|\\leq\\sigma\\left\\|\\mathbf{a}-\\widehat{\\mathbf{a}}\\right\\|\r\n\\qquad (4)\r\n\\]</span> Proof:</p>\r\n<p>由[38]中的Perron-Frobenius定理，得<span\r\nclass=\"math inline\">\\(\\rho(A)=1\\)</span> and every eigenvalue of A other\r\nthan 1 is strictly less than <span\r\nclass=\"math inline\">\\(\\rho(A)\\)</span>。</p>\r\n<p>We now have： <span class=\"math display\">\\[\r\n\\begin{array}{rcl}AY_\\infty&amp;=&amp;A\\mathbf{1}_n\\pi^\\top&amp;=&amp;\\mathbf{1}_n\\pi^\\top&amp;=&amp;Y_\\infty,\\\\Y_\\infty\r\nY_\\infty&amp;=&amp;\\mathbf{1}_n\\pi^\\top\\mathbf{1}_n\\pi^\\top&amp;=&amp;\\mathbf{1}_n\\pi^\\top&amp;=&amp;Y_\\infty,\\end{array}\r\n\\]</span> and thus <span\r\nclass=\"math inline\">\\(AY_{\\infty}-Y_{\\infty}Y_{\\infty}\\)</span> is a\r\nzero matrix. Therefore, <span class=\"math display\">\\[\r\nA\\mathbf{a}-Y_\\infty\\mathbf{a}\\quad=\\quad(A-Y_\\infty)(\\mathbf{a}-Y_\\infty\\mathbf{a}).\r\n\\]</span></p>\r\n<blockquote>\r\n<p>右边打开：Aa - AYa - Ya + Y^2a = Aa - AYa - Ya + Ya = Aa - AYa = Aa -\r\nYa = 左边</p>\r\n</blockquote>\r\n<p>所以 <span class=\"math display\">\\[\r\n\\left\\|A\\mathbf{a}-Y_\\infty\\mathbf{a}\\right\\|\\quad\\leq\\quad\\left\\|A-Y_\\infty\\right\\|\\left\\|\\mathbf{a}-Y_\\infty\\mathbf{a}\\right\\|,\\quad\\left(5\\right)\r\n\\]</span> 又<span class=\"math inline\">\\(\\|A - Y_\\infty\\| &lt; 1\\)</span>\r\n<strong><u>为啥</u></strong></p>\r\n<p>所以</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\left\\|A\\mathbf{a}-\\widehat{\\mathbf{a}}\\right\\|\\leq\\sigma\\left\\|\\mathbf{a}-\\widehat{\\mathbf{a}}\\right\\|\\)</span>，<span\r\nclass=\"math inline\">\\(\\sigma=\\left\\|A-Y_{\\infty}\\right\\|\\)</span>，且<span\r\nclass=\"math inline\">\\(0 &lt; \\sigma &lt; 1\\)</span></p>\r\n<h4 id=\"lemma-3\">Lemma 3</h4>\r\n<p>There exists some constant <span\r\nclass=\"math inline\">\\(\\widetilde{T}\\)</span> such that the following\r\ninequalities hold for all k &gt;= 1 <span class=\"math display\">\\[\r\n(a)\\left\\|\\widetilde{Y}_k^{-1}-\\widetilde{Y}_\\infty^{-1}\\right\\|_2\\leq\\widetilde{y}^2\\widetilde{T}\\gamma_1^k\r\n\\\\\r\n(b)\\left\\|\\widetilde{Y}_{k+1}^{-1}-\\widetilde{Y}_{k}^{-1}\\right\\|_{2}\\leq2\\widetilde{y}^{2}\\widetilde{T}\\gamma_{1}^{k}\r\n\\]</span> Proof:</p>\r\n<p>先推(a) <span class=\"math display\">\\[\r\n\\begin{aligned}\r\n\\left\\|\\tilde{Y}_{k}^{-1}-\\tilde{Y}_{\\infty}^{-1}\\right\\|_{2}&amp;\r\n\\leq\\left\\|\\tilde{Y}_{k}^{-1}\\right\\|_{2}\\left\\|\\tilde{Y}_{k}-\\tilde{Y}_{\\infty}\\right\\|_{2}\\left\\|\\tilde{Y}_{\\infty}^{-1}\\right\\|_{2},  \\\\\r\n&amp;\\leq\\tilde{y}^{2}\\widetilde{T}\\gamma_{1}^{k},\r\n\\end{aligned}\r\n\\]</span> 第一个不等号推导见“Distributed Nash Equilibrium Seeking\r\nfor...”的Lemma 1证明</p>\r\n<p>第二个不等号用了<span\r\nclass=\"math inline\">\\(\\widetilde{y}\\)</span>的定义和Lemma 1</p>\r\n<p>再推(b)，用推(a)一样的方法，先推出：</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\left\\|\\widetilde{Y}_{k+1}^{-1}-\\widetilde{Y}_{k}^{-1}\\right\\|_2\r\n\\le \\|\\widetilde{Y}_{k+1}\\| \\cdot \\|\\widetilde{Y}_{k}^{-1}\\| \\cdot\r\n\\|\\widetilde{Y}_{k+1} - \\widetilde{Y}_k\\| \\le \\widetilde{y}^2 \\cdot\r\n\\|\\widetilde{Y}_{k+1} - \\widetilde{Y}_k\\|\\)</span></p>\r\n<p>又<span class=\"math inline\">\\(\\|\\widetilde{Y}_{k+1} -\r\n\\widetilde{Y}_k\\| = \\|\\widetilde{Y}_{k+1} - \\widetilde{Y}_{\\infty}\\ -\r\n(\\widetilde{Y}_{k} - \\widetilde{Y}_{\\infty})\\| \\le \\|\\widetilde{Y}_{k+1}\r\n- \\widetilde{Y}_{\\infty}\\| + \\|\\widetilde{Y}_{k} -\r\n\\widetilde{Y}_{\\infty}\\| \\le 2\\widetilde{T}\\gamma_{1}^{k}\\)</span></p>\r\n<p>所以</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\left\\|\\widetilde{Y}_{k+1}^{-1}-\\widetilde{Y}_{k}^{-1}\\right\\|_2\r\n\\le 2\\widetilde{y}^2\\widetilde{T}\\gamma_{1}^{k}\\)</span>，得证。</p>\r\n<p>剩下来的内容不继续看了，因为需要的知识已经找到了，就是Lemma 3</p>\r\n","categories":["1. 论文"]},{"title":"Distributed Nash Equilibrium Seeking for...","url":"/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/","content":"<p>标题全称为：Distributed Nash Equilibrium Seeking for Aggregative\r\nGames With Directed Communication Graphs</p>\r\n<p>中文翻译为：在使用有向图结构的聚合博弈中寻找离散式纳什均衡</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"abstract\">Abstract</h3>\r\n<p>在聚合博弈中寻找分布式纳什均衡的关键点就是聚合博弈采取什么样的图结构。</p>\r\n<p>若采取无向图或者权衡平衡图结构，则这个问题已经被前人解决。</p>\r\n<p>如果采取有向图，则这仍然是个无人解决的问题。</p>\r\n<p>本文解决的是当图结构采取“固定有向图”或者“时变有向图”时的分布式NE寻找问题。</p>\r\n<p>使用了两种算法来分别解决上面所提到的两种图结构时的分布式NE寻找问题。</p>\r\n<p>创新点是受凸优化中重球法的启发，向玩家策略的更新规范中引入了“动量项”，使得加速了算法寻找NE的收敛速度。</p>\r\n<p>对于强连通固定图和b强连通时变图，从理论上证明，如果代价函数和参与人的集合满足一定条件，在步长减小的情况下，参与人的行动将收敛到集合博弈的NE上。</p>\r\n<p>本文最后将该算法运用于插电式混合动力汽车的能耗控制，检验了算法的正确性。</p>\r\n<hr />\r\n<h3 id=\"section-1-introduction\">Section 1: Introduction</h3>\r\n<h4 id=\"研究背景\">1-1: 研究背景</h4>\r\n<ul>\r\n<li><p>本文研究的是聚合游戏，也就是每个玩家的花费除了依赖自身动作还依赖所有玩家的聚合行为。在聚合游戏中寻找NE是个有挑战性的问题，因为每个玩家只能与自己的邻居通信。</p></li>\r\n<li><p>在分布式通信计算领域，一些解决聚合游戏中NE寻找问题的分布式算法已经被提出。具体分为“分布式离散时间算法”[6],\r\n[7]和“分布式连续时间算法”[8]-[15]</p></li>\r\n</ul>\r\n<p>[6]：在这篇文章中，作者专注于研究有向图中的两种特殊的聚合游戏，分别叫做“network\r\naggregative games” 和 \"average aggregative games\"。使用\"optimal response\r\nstrategy\"方法去研究的。而且，在图的加权邻接矩阵为双随机矩阵的条件下，<span\r\nclass=\"math inline\">\\(\\varepsilon-NE\\)</span>在average aggregative\r\ngames的寻找得以被解决。</p>\r\n<p>[7]：在这篇文章中，作者专注于研究无向图中的聚合游戏。并相应提出了几种分布式同步和异步算法。</p>\r\n<p>[8]：在这篇文章中，作者专注于研究权重平衡有向图中的聚合游戏，其中玩家的dynamics\r\nwere described by disturbed first-order systems.\r\n为了寻找寻找外部干扰下具有coupled equality\r\nconstraint的聚合游戏的NE，作者在文中提出了一种利用内部模型排斥外部干扰来找NE的分布式算法。同时利用dynamic\r\naverage consensus来估计所有玩家的总和。</p>\r\n<p>[9]：在这篇文章中，研究了玩家成本函数非光滑，同时玩家动作受到局部可行性约束和线性耦合约束时的情况。具体来说，作者利用微分包含和微分投影算子，提出了一种基于连续时间分布投影的算法来找权重平衡有向图上的非光滑聚合游戏的NE。</p>\r\n<p>[10]：在这篇文章中，作者研究了无向连通图上具有耦合约束的聚合游戏。</p>\r\n<p>[11]：结合projected gradient dynamics 和 consensus tracking\r\ndynamics，本文讨论了无向连通图上的聚合游戏。</p>\r\n<p>[12]：结合projected gradient dynamics 和 consensus tracking\r\ndynamics，本文讨论了权重平衡有向图上的聚合游戏。</p>\r\n<p>[13]：研究了存在对通信链路持续攻击的网络上的聚合游戏。其中玩家的动态是受未知时变干扰和未建模项影响的双积分器。</p>\r\n<p>[14]：研究了聚合游戏在智能电网能耗控制中的运用。其中玩家采用平均共识协议来估计总能耗，并且表明玩家的行为以指数形式收敛于NE。</p>\r\n<p>[15]：将PHEVs建模成一个无向连通图上的聚合游戏，并对NE的稳定性进行了分析。</p>\r\n<ul>\r\n<li>可以发现上面的文章大多都是在无向图或者权重平衡有向图上的工作。在一般有向图上利用分布式离散时间算法来寻找NE仍然是一个未解决的问题。因为难点就在于玩家之间的通信结构不平衡。</li>\r\n<li>但是到目前为止，关于在不平衡有向图上的分布式优化问题已经被广泛研究。例如下面几篇文章：</li>\r\n</ul>\r\n<p>[16]：提出了一种连续时间算法来解决权重不平衡图上的聚合游戏的NE寻找问题。</p>\r\n<p>[17]：通过结合(子)梯度下降和推和共识协议开发了分布式(子)梯度推算法，其中双随机矩阵的要求可被推广到列随机矩阵。</p>\r\n<p>[18]：为了不需要提前知道列-随机矩阵的出度，这篇文章仅使用行-随机矩阵，通过估计行-随机矩阵的左Perron特征向量来求解具有不平衡有向图的分布无约束优化问题。</p>\r\n<p>[19],\r\n[20]：通过估计行随机矩阵的左Perron特征向量，研究有向图的分布式约束优化问题。</p>\r\n<ul>\r\n<li>所以本文受到上述文章中处理不平衡有向图的方法启发，分别运用行随机矩阵（algorithm\r\n1）和列随机矩阵（algorithm\r\n2）来研究不平衡有向图上（两种算法分别对应fixed digraph和time-varying\r\ndigraph）的聚合游戏。</li>\r\n<li>具体来说，通过估计与拓扑相关的行随机矩阵的左特征向量，成功消除了这种拓扑相关行随机矩阵对所有玩家聚合行为估计的不平衡影响。此外，针对时变有向图下的聚集博弈，提出了一种基于推和协议的分布式算法来寻找NE。而且由于玩家的动作受到设定的约束，因此采用投影梯度法根据聚集的局部估计更新玩家的动作。</li>\r\n<li>另一方面，考虑到步长恒定的投影梯度法只能在存在集合约束的情况下使玩家的动作收敛到NE的一个邻域，所以本文采用步长递减的方法来保证收敛到准确的NE，并且允许参与者采用不协调的步长。</li>\r\n<li>然而，步长递减也带来了另一个挑战，即收敛速度慢。受到[21]中重球法的启发下，本文在玩家行为更新规律中引入动量项，以加快算法的收敛速度。证明了所提出的步长递减离散NE搜索算法能够保证收敛到精确NE。</li>\r\n<li>此外，还分析了在步长递减时所提出的NE搜索算法的收敛速度。最后，将所提出的算法应用于有向图上的插电式混合动力汽车系统能耗博弈的求解，数值结果表明，动量项加速了算法的收敛速度。</li>\r\n</ul>\r\n<blockquote>\r\n<p>看了上面的introduction，个人感觉其实就是说：</p>\r\n<p>不平衡有向图上的聚合问题没人解决，因为玩家之间通信结构不平衡。</p>\r\n<p>然后本文用[18] ~\r\n[20]“估计行随机矩阵左特征向量”的方法解决上面这个难点。</p>\r\n<p>另外，本文还讨论了时变有向图下的聚集博弈，用的是[17]的方法，但是在他基础上把步长固定改为步长递减从而使NE收敛更精确。另外还加了一个[21]里的重球法中的动量项来加快收敛速度。</p>\r\n</blockquote>\r\n<h4 id=\"大致目录-基础公式\">1-2: 大致目录 &amp; 基础公式</h4>\r\n<p>Section 2：图论的基础结论、问题建模、算法引入</p>\r\n<p>Section 3、4：算法的收敛性证明</p>\r\n<p>Section 5：验证算法在插电式混合动力汽车能耗控制的正确性</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(\\mathbb{R,\r\nN_+}\\)</span>：分别是实数集和正整数集</li>\r\n<li><span class=\"math inline\">\\(e_i ∈ \\mathbb{R^n}\\)</span>\r\n：n维列向量，其中第i项为1，其余项为0</li>\r\n<li><span class=\"math inline\">\\(1_n ∈ \\mathbb{R^n}\\)</span>\r\n：n维列向量，每一项都是1</li>\r\n<li><span class=\"math inline\">\\(I_n\\)</span>：n维单位矩阵</li>\r\n<li><span class=\"math inline\">\\(\\|\\cdot\\|\\)</span>：欧几里得范式</li>\r\n<li><span class=\"math inline\">\\(\\|x\\|_H, H \\in \\mathbb{R^{n \\times\r\nn}}\\)</span>：加权范数（weighed norm）（结果为一个常数），定义为：<span\r\nclass=\"math inline\">\\(\\|x\\|_H = \\sqrt{x^THx}\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\Omega \\in\r\n\\mathbb{R^n}\\)</span>：n维的非空闭凸集，里面每个元素都是n维列向量</li>\r\n<li><span class=\"math inline\">\\(P_{\\Omega}[x]\\)</span>: x(<span\r\nclass=\"math inline\">\\(\\Omega\\)</span>外一点)在<span\r\nclass=\"math inline\">\\(\\Omega\\)</span>上的投影点(结果为一个n维列向量),\r\n定义为: <span class=\"math inline\">\\(P_{\\Omega}[x] = argmin_{y \\in\r\n\\Omega}\\|x - y\\| = y^*, y^* \\in \\Omega\\)</span>\r\n<ul>\r\n<li>具有非扩张性，即：<span\r\nclass=\"math inline\">\\(\\|P_{\\Omega}[x]-P_{\\Omega}[z]\\| \\le\r\n\\|x-z\\|\\)</span></li>\r\n</ul></li>\r\n<li><span\r\nclass=\"math inline\">\\([x]_i\\)</span>：x这个n维向量中的第i项</li>\r\n<li><span\r\nclass=\"math inline\">\\(H_{ij}\\)</span>：矩阵H的i行j列那个元素</li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"section-2-preliminary-knowledge\">Section 2: Preliminary\r\nknowledge</h3>\r\n<h4 id=\"图理论\">2-1: 图理论</h4>\r\n<p><span class=\"math inline\">\\(\\mathcal{N}=\\{1, 2, ...,\r\nN\\}\\)</span>：玩家集合</p>\r\n<p><span class=\"math inline\">\\(\\varepsilon(k) \\subseteq \\{(i, j), i, j\r\n\\in \\mathcal{N}\\}\\)</span>：时刻为k时的边集 <span\r\nclass=\"math inline\">\\((i, j) \\in \\varepsilon(k)\\)</span> means that\r\nplayer i can receive information from player j at time j.</p>\r\n<p><span class=\"math inline\">\\(\\mathcal{G}(k) = \\{\\mathcal{N},\r\n\\varepsilon(k)\\}\\)</span>：时刻为k时的图</p>\r\n<p><span class=\"math inline\">\\(N^{in}_{i}(k) = \\{i\\} \\cup \\{j | (j, i)\r\n\\in \\varepsilon(k)\\}\\)</span>：时刻为k时，点i的入点集合</p>\r\n<p><span class=\"math inline\">\\(N^{out}_{i}(k) = \\{i\\} \\cup \\{j | (i, j)\r\n\\in \\varepsilon(k)\\}\\)</span>：时刻为k时，点i的出点集合</p>\r\n<p><span\r\nclass=\"math inline\">\\(d_i^k=|N^{out}_{i}(k)|\\)</span>：时刻为k时，点i的出度</p>\r\n<p>strongly connected fixed digraph：强连通有向图。即任意俩点可通</p>\r\n<p>For the time-varying digraph <span\r\nclass=\"math inline\">\\(\\mathcal{G}(k), \\{\\mathcal{G}(k)\\}\\)</span> is\r\nsaid to be B-strongly connected if there exists a <span\r\nclass=\"math inline\">\\(B \\in \\mathbb{N_+}\\)</span> such that the union\r\ndigraph <span\r\nclass=\"math inline\">\\(\\cup_{t=kB}^{(k+1)B}\\mathcal{G}(t)\\)</span> is\r\nstrongly connected for any <span class=\"math inline\">\\(k \\in\r\n\\mathbb{N_+}\\)</span>\r\n换句话说，如果一定时间段内的所有时变图的并（边并起来，边权不相加）为强连通，则这些时变图的集合是B-连通的。</p>\r\n<p>后面依次类推。</p>\r\n<h4 id=\"问题建模\">2-2: 问题建模</h4>\r\n<p>每个玩家的动作集合定义为<span\r\nclass=\"math inline\">\\(\\Omega_i\\)</span>，动作定义为<span\r\nclass=\"math inline\">\\(x_i\\)</span>。每个玩家的花费函数定义为<span\r\nclass=\"math inline\">\\(J_i(x), x = [x_1, x_2, ...,\r\nx_n]^T\\)</span>，通过这个表达式可以看出来，每个玩家的花费函数跟所有玩家的动作相关。</p>\r\n<p><span class=\"math inline\">\\(J_i(x)\\)</span>还有几种等价的定义：</p>\r\n<p>定义1：<span class=\"math display\">\\[J_i(x) = f_i(x_i, \\sigma(x)), \\\\\r\n\\sigma(x)=\\sum_{j=1}^{N}\\phi_{j}(x_j) \\qquad (1)\\]</span></p>\r\n<p>定义2：<span class=\"math inline\">\\(J_i(x)=J_i(x_i, x_{-i}),\r\nx_{-i}=[x_1, ..., x_{i-1}, x_{i+1}, ..., x_n]\\)</span></p>\r\n<p>要解决的问题是最小化每一个玩家的花费函数，即：</p>\r\n<p><span class=\"math inline\">\\(min \\, f_i(x_i, \\sigma(x)), \\forall{i}\r\n\\in \\mathcal{N} \\qquad (2)\\)</span></p>\r\n<p>实际上就是求一个纳什均衡问题，因为纳什均衡就是任何一个玩家改变它的动作都不能使得它的花费函数更小。如果纳什均衡的观点表达上面的式子，就是：</p>\r\n<p>假如<span class=\"math inline\">\\(x^*\\)</span>是NE，当且仅当<span\r\nclass=\"math inline\">\\(J_i(x_i^*, x_{-i}^*) \\le J_i(x_i, x_{-i}^*),\r\n\\forall{x_i} \\in \\Omega_i, \\forall{i} \\in \\mathcal{N}\\)</span></p>\r\n<blockquote>\r\n<p>Note that the players in the considered game have no knowledge of the\r\naggregation <span class=\"math inline\">\\(\\sigma(x)\\)</span> due to the\r\nprivacy of <span class=\"math inline\">\\(\\phi_j(x_j), j \\in\r\n\\mathcal{N}\\)</span>。</p>\r\n<p>也就是说，<span\r\nclass=\"math inline\">\\(\\phi_i(x_i)\\)</span>函数是每个人特有的，只有自己知道，别人不知道。但是可以通过有向图与邻居交换信息。</p>\r\n</blockquote>\r\n<p>下面是论文的几个假设，论文解决的问题都是基于这几个假设作为前提的。</p>\r\n<h5 id=\"assumption-1\">Assumption 1</h5>\r\n<ul>\r\n<li>论文讨论的图不是一般有向图，而是两类。分别是固定有向图（fixed\r\ndigraph）和时变有向图（time-varying digraph）。</li>\r\n<li>而且fixed digraph一定满足强连通，time-varying\r\ndigraph一定满足B-强连通。</li>\r\n</ul>\r\n<h5 id=\"assumption-2\">Assumption 2</h5>\r\n<ul>\r\n<li><p>对于所有玩家的动作集合<span\r\nclass=\"math inline\">\\(\\Omega_{i}\\)</span>，都是非空、紧致、凸的。</p></li>\r\n<li><p>定义<span class=\"math inline\">\\(\\Omega_{-i}=\\Omega_{1} \\times\r\n\\Omega_{2} \\times ... \\times \\Omega_{i-1} \\times \\Omega_{i+1} \\times ...\r\n\\times \\Omega_{N}\\)</span>。More over, for given <span\r\nclass=\"math inline\">\\(x_{-i} \\in \\Omega_{-i}, J_i(x_i, x_{-i})\\)</span>\r\nis convex about <span class=\"math inline\">\\(x_i\\)</span> on <span\r\nclass=\"math inline\">\\(\\Omega_{i}\\)</span></p></li>\r\n<li><p><span class=\"math inline\">\\(J_i(x_i, x_{-i})\\)</span>对<span\r\nclass=\"math inline\">\\(x\\)</span>连续可微，<span\r\nclass=\"math inline\">\\(\\phi_i(x_i)\\)</span>对<span\r\nclass=\"math inline\">\\(x_i\\)</span>连续可微。</p>\r\n<ul>\r\n<li>定义<span class=\"math inline\">\\(\\nabla_z{f(z,\r\ny)}\\)</span>为对z求一阶偏导</li>\r\n<li>按照此定义，将<span class=\"math inline\">\\(J_i(x_i,\r\nx_{-i})\\)</span>对<span\r\nclass=\"math inline\">\\(x_i\\)</span>求导，将得到<span\r\nclass=\"math inline\">\\(\\nabla_{x_i}J_i(x_i, x_{-i}) =\\nabla_{x_i}f_i(x_i,\r\n\\sigma(x)) + \\nabla_{\\sigma}f_i(x_i, \\sigma(x)) \\,\r\n\\nabla_{x_i}\\phi_i(x_i)\\)</span>。这里实际上是有点歧义的，作者想表达的意思就是关注玩家i的动作对其花费函数的影响。</li>\r\n<li>定义<span class=\"math inline\">\\(\\Gamma(x)=[\\nabla_{x_1}J_1(x_1,\r\nx_{-1}), ..., \\nabla_{x_N}J_N(x_N,\r\nx_{-N})]^T\\)</span>，即每个玩家花费函数对自身动作求导组成的一个列向量</li>\r\n<li>定义<span class=\"math inline\">\\(G_i(x_i, \\tilde{\\sigma_i}) =\r\n\\nabla_{x_i}f_i(x_i, \\sigma(x))|_{\\sigma(x)=\\tilde{\\sigma_i}} +\r\n\\nabla_{\\sigma}f_i(x_i, \\sigma(x)) \\,\r\n\\nabla_{x_i}\\phi_i(x_i)|_{\\sigma(x)=\\tilde{\\sigma_i}}\\)</span>。不是把每个花费函数对动作求导嘛，这里就是把求导结果里的<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>赋值为<span\r\nclass=\"math inline\">\\(\\tilde{\\sigma_i}\\)</span>了。</li>\r\n</ul></li>\r\n</ul>\r\n<h5 id=\"assumption-3\">Assumption 3</h5>\r\n<ul>\r\n<li><span\r\nclass=\"math inline\">\\(\\Gamma(x)\\)</span>满足下列俩条件之一：</li>\r\n<li><span class=\"math inline\">\\(\\Gamma(x)\\)</span>在<span\r\nclass=\"math inline\">\\(\\Omega\\)</span>上是严格单调的，也就是说，<span\r\nclass=\"math inline\">\\((\\Gamma(x)-\\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,\r\n\\forall{x, x&#39;} \\in \\Omega, x \\ne x&#39;\\)</span></li>\r\n<li><span class=\"math inline\">\\(\\Gamma(x)\\)</span>在<span\r\nclass=\"math inline\">\\(\\Omega\\)</span>上是强单调的，也就是说，存在一个常数<span\r\nclass=\"math inline\">\\(\\mu &gt; 0\\)</span>使得<span\r\nclass=\"math inline\">\\((\\Gamma(x)-\\Gamma(x&#39;))^T(x-x&#39;) \\ge\r\n\\mu\\|x-x&#39;\\|^2, \\forall{x, x&#39;} \\in \\Omega, x \\ne\r\nx&#39;\\)</span></li>\r\n</ul>\r\n<h5 id=\"assumption-4\">Assumption 4</h5>\r\n<ul>\r\n<li><p>The mapping <span class=\"math inline\">\\(G_i(x_i, \\sigma) is\r\nL_1-Lipschitz\\)</span> continuous with repect to <span\r\nclass=\"math inline\">\\(\\sigma \\in \\mathbb{R}\\)</span> and <span\r\nclass=\"math inline\">\\(\\phi_i(x_i)\\)</span> is <span\r\nclass=\"math inline\">\\(L_2-Lipschitz\\)</span> continuous with repect to\r\n<span class=\"math inline\">\\(x_i \\in \\Omega_i\\)</span> for all <span\r\nclass=\"math inline\">\\(i \\in \\mathcal{N}\\)</span>, i.e.,</p></li>\r\n<li><p>(<span class=\"math inline\">\\(L_1, L_2\\)</span> are two positive\r\nconstants) <span class=\"math display\">\\[\r\n\\begin{aligned}\\|G_i(x_i,\\sigma_1)-G_i(x_i,\\sigma_2)\\|_2&amp;\\le\r\nL_1\\left\\|\\sigma_1-\\sigma_2\\right\\|,&amp;\\forall\\sigma_1,\\sigma_2\\in\\mathbb{R},\\\\\\|\\phi_i(z_1)-\\phi_i(z_2)\\|&amp;\\le\r\nL_2\\left\\|z_1-z_2\\right\\|,&amp;\\forall z_1,z_2\\in\\Omega_i,\\end{aligned}\r\n\\]</span></p></li>\r\n</ul>\r\n<h4 id=\"算法引入\">2-3: 算法引入</h4>\r\n<h5\r\nid=\"algorithm-1-ne-seeking-with-row-stochastic-adjacency-matrix\">Algorithm\r\n1 NE Seeking With Row-Stochastic Adjacency Matrix</h5>\r\n<ul>\r\n<li>Initialization: <span class=\"math inline\">\\(x_i^0=x_i^1 \\in\r\n\\Omega_i, v_i^1=e_i, \\tilde\\sigma_i^1=\\phi_i(x_i^1)\\)</span></li>\r\n<li>for <span class=\"math inline\">\\(k \\in \\mathbb{N}_+\\)</span> do\r\n<ul>\r\n<li>for each player <span class=\"math inline\">\\(i \\in\r\n\\mathcal{N}\\)</span> do\r\n<ul>\r\n<li><span class=\"math inline\">\\(x_i^{k+1}=P_{\\Omega_i}[x_i^k -\r\n\\alpha_i^kG_i(x_i^k, \\tilde\\sigma_i^k) + \\lambda_i(x_i^k-x_i^{k-1})]\r\n\\qquad (3a)\\)</span></li>\r\n<li><span class=\"math inline\">\\(v_i^{k+1}=\\sum_{j=1}^Na_{ij}v_j^k \\qquad\r\n(3b)\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{i}^{k+1}=\\sum_{j=1}^{N}a_{ij}\\tilde{\\sigma}_{j}^{k}+\\frac{\\phi_{i}\\left(x_{i}^{k+1}\\right)}{\\left[v_{i}^{k+1}\\right]_{i}}-\\frac{\\phi_{i}\\left(x_{i}^{k}\\right)}{\\left[v_{i}^{k}\\right]_{i}}\r\n\\qquad (3c)\\)</span></li>\r\n</ul></li>\r\n<li>end for</li>\r\n</ul></li>\r\n<li>end for</li>\r\n</ul>\r\n<p>行随机邻接矩阵记为<span\r\nclass=\"math inline\">\\(A=[a_{ij}]\\)</span>，其中<span\r\nclass=\"math inline\">\\(a_{ii}&gt;0\\)</span>，且若<span\r\nclass=\"math inline\">\\((j, i) \\in \\varepsilon\\)</span>则<span\r\nclass=\"math inline\">\\(a_{ij}&gt;0\\)</span>, 否则<span\r\nclass=\"math inline\">\\(a_{ij}=0\\)</span>。另外，行随机矩阵的特征就是每一行元素和为1。</p>\r\n<p><span\r\nclass=\"math inline\">\\(x_i^k\\)</span>表示第i个玩家在时刻k的动作</p>\r\n<p><span class=\"math inline\">\\(v_i^k \\in\r\n\\mathbb{R}^N\\)</span>用来estimate the left eigenvector <span\r\nclass=\"math inline\">\\(v\\)</span> associated with eigenvalue <span\r\nclass=\"math inline\">\\(1\\)</span> of the matrix A.</p>\r\n<p><span class=\"math inline\">\\(\\tilde\\sigma_i^k\\)</span> be the player\r\ni's estimate on the aggregation <span\r\nclass=\"math inline\">\\(\\sigma(x_k)\\)</span> at iteration <span\r\nclass=\"math inline\">\\(k\\)</span>, <span\r\nclass=\"math inline\">\\(x_k=[x_1^k, ..., x_N^k]^T\\)</span></p>\r\n<p><span\r\nclass=\"math inline\">\\(\\alpha_i^k\\)</span>表示步长，它遵循下面三个限制：</p>\r\n<ol type=\"1\">\r\n<li>每个玩家在任意时刻的步长都是大于0的，且对于每个玩家，其<span\r\nclass=\"math inline\">\\(\\{\\alpha_i^k\\}\\)</span>单调不增加</li>\r\n<li><span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\alpha_{i}^{k}=\\infty,\\sum_{k=1}^{\\infty}(\\alpha_{i}^{k})^{2}&lt;\\infty\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\sum\\limits_{k=1}^{\\infty}(\\overline{\\alpha}_{k}-\\underline{\\alpha}_{k})&lt;\\infty,\\text{\r\nwhere\r\n}\\overline{\\alpha}_{k}=\\max\\limits_{j\\in\\mathcal{N}}\\{\\alpha_{j}^{k}\\}\\text{\r\nand\r\n}\\underline{\\alpha}_{k}=\\min\\limits_{j\\in\\mathcal{N}}\\{\\alpha_{j}^{k}\\}.\\)</span></li>\r\n</ol>\r\n<p>在algorithm 1中，玩家使用非精确梯度<span\r\nclass=\"math inline\">\\(G_i(x_i^k,\r\n\\tilde\\sigma_i^k)\\)</span>来更新自身动作。为了消除不精确梯度带来的误差，引入递减的步长而不是固定的步长，从而保证精确收敛到NE。另外，动量项<span\r\nclass=\"math inline\">\\(\\lambda_i(x_i^k-x_i^{k-1})]\\)</span>可以加速算法的收敛，<span\r\nclass=\"math inline\">\\(0&lt;\\lambda_i&lt;1\\)</span>是动量参数。以上就是对于(3a)的解释。</p>\r\n<p>在(3c)中的第二项和第三项，其存在的目的是为了解决矩阵<span\r\nclass=\"math inline\">\\(A\\)</span>可能不是列随机的问题。</p>\r\n<p>可以看出，(3b)和(3c)都用到了<span\r\nclass=\"math inline\">\\(a_{ij}\\)</span>，所以algorithm 1只适用于fixed\r\ndigraph。</p>\r\n<h5\r\nid=\"algorithm-2-ne-seeking-with-column-stochastic-adjacency-matrix\">Algorithm\r\n2 NE Seeking With Column-Stochastic Adjacency Matrix</h5>\r\n<p>这个算法是针对time-varying\r\ndigraph的。在算法2中，每个玩家需要知道自己在每次交流中的出度，因为不同时刻每个点的出度会变化。</p>\r\n<ul>\r\n<li>Initialization: <span\r\nclass=\"math inline\">\\(x_{i}^{0}=x_{i}^{1}\\in\\Omega_{i},y_{i}^{1}=1,\\tilde{\\sigma}_{i}^{1}=\\phi_{i}(x_{i}^{1})\\)</span></li>\r\n<li>for <span class=\"math inline\">\\(k \\in \\mathbb{N}_+\\)</span> do\r\n<ul>\r\n<li>for each player <span class=\"math inline\">\\(i \\in\r\n\\mathcal{N}\\)</span> do\r\n<ul>\r\n<li><span class=\"math inline\">\\(w_i^{k+1}=\\sum_{j\\in\r\nN_i^{in}(k)}\\frac{\\tilde{\\sigma}_j^k}{d_j^k} \\qquad (4a)\\)</span></li>\r\n<li><span class=\"math inline\">\\(y_i^{k+1}=\\sum_{j\\in\r\nN_i^{in}(k)}\\frac{y_j^k}{d_j^k} \\qquad (4b)\\)</span></li>\r\n<li><span class=\"math inline\">\\(z_i^{k+1}=\\frac{w_i^{k+1}}{y_i^{k+1}}\r\n\\qquad (4c)\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(x_i^{k+1}=P_{\\Omega_i}\\left[x_i^k-\\alpha_i^kG_i(x_i^k,Nz_i^{k+1})+\\lambda_i(x_i^k-x_i^{k-1})\\right]\r\n\\qquad (4d)\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_i^{k+1}=w_i^{k+1}+\\phi_i\\left(x_i^{k+1}\\right)-\\phi_i\\left(x_i^k\\right)\r\n\\qquad (4e)\\)</span></li>\r\n</ul></li>\r\n<li>end for</li>\r\n</ul></li>\r\n<li>end for</li>\r\n</ul>\r\n<p>可以发现，这里求<span\r\nclass=\"math inline\">\\(x_i^{k+1}\\)</span>第二项<span\r\nclass=\"math inline\">\\(G_i\\)</span>中并没用<span\r\nclass=\"math inline\">\\(\\tilde\\sigma_i^k\\)</span>，而是用的<span\r\nclass=\"math inline\">\\(Nz_i^{k+1}\\)</span>。z是w跟y的比值，w与y又与点的入点和(入点的出度)有关。</p>\r\n<blockquote>\r\n<p>Note: 在algorithm 1中，若把\"若<span class=\"math inline\">\\((j, i) \\in\r\n\\varepsilon\\)</span>则<span\r\nclass=\"math inline\">\\(a_{ij}&gt;0\\)</span>\"改为“若<span\r\nclass=\"math inline\">\\((j, i) \\in \\varepsilon\\)</span>则<span\r\nclass=\"math inline\">\\(a_{ij}=\\frac{1}{d_j^k}\\)</span>”，则(3c)与(4e)等价</p>\r\n</blockquote>\r\n<hr />\r\n<h3 id=\"section-3-convergence-analysis-of-algorithm-1\">Section 3:\r\nConvergence analysis of algorithm 1</h3>\r\n<h4 id=\"theorem-1\">3-1: Theorem 1</h4>\r\n<p>条件：</p>\r\n<ol type=\"1\">\r\n<li><p>采用固定有向图结构</p></li>\r\n<li><p><span class=\"math inline\">\\(\\nabla_{x_i}J_i(x_i, x_{-i})\r\n=\\nabla_{x_i}f_i(x_i, \\sigma(x)) + \\nabla_{\\sigma}f_i(x_i, \\sigma(x)) \\,\r\n\\nabla_{x_i}\\phi_i(x_i)\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\Gamma(x)=[\\nabla_{x_1}J_1(x_1, x_{-1}),\r\n..., \\nabla_{x_N}J_N(x_N, x_{-N})]^T\\)</span></p>\r\n<p><span class=\"math inline\">\\(G_i(x_i, \\tilde{\\sigma_i}) =\r\n\\nabla_{x_i}f_i(x_i, \\sigma(x))|_{\\sigma(x)=\\tilde{\\sigma_i}} +\r\n\\nabla_{\\sigma}f_i(x_i, \\sigma(x)) \\,\r\n\\nabla_{x_i}\\phi_i(x_i)|_{\\sigma(x)=\\tilde{\\sigma_i}}\\)</span></p></li>\r\n<li><p><span\r\nclass=\"math inline\">\\((\\Gamma(x)-\\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,\r\n\\forall{x, x&#39;} \\in \\Omega, x \\ne x&#39;\\)</span></p></li>\r\n<li><p><span class=\"math display\">\\[\r\n\\begin{aligned}\\|G_i(x_i,\\sigma_1)-G_i(x_i,\\sigma_2)\\|_2&amp;\\le\r\nL_1\\left\\|\\sigma_1-\\sigma_2\\right\\|,&amp;\\forall\\sigma_1,\\sigma_2\\in\\mathbb{R},\\\\\\|\\phi_i(z_1)-\\phi_i(z_2)\\|&amp;\\le\r\nL_2\\left\\|z_1-z_2\\right\\|,&amp;\\forall z_1,z_2\\in\\Omega_i,\\end{aligned}\r\n\\]</span></p></li>\r\n<li><p>对于<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>步长，满足下面三条性质(C1-C3)</p>\r\n<ol type=\"1\">\r\n<li><span\r\nclass=\"math inline\">\\(\\{\\alpha_i^k\\}\\)</span>不严格递减，且<span\r\nclass=\"math inline\">\\(\\alpha_i^k&gt;0\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\alpha_{i}^{k}=\\infty,\\sum_{k=1}^{\\infty}(\\alpha_{i}^{k})^{2}&lt;\\infty\\)</span></li>\r\n<li><span\r\nclass=\"math inline\">\\(\\sum\\limits_{k=1}^{\\infty}(\\overline{\\alpha}_{k}-\\underline{\\alpha}_{k})&lt;\\infty,\\text{\r\nwhere\r\n}\\overline{\\alpha}_{k}=\\max\\limits_{j\\in\\mathcal{N}}\\{\\alpha_{j}^{k}\\}\\text{\r\nand\r\n}\\underline{\\alpha}_{k}=\\min\\limits_{j\\in\\mathcal{N}}\\{\\alpha_{j}^{k}\\}.\\)</span></li>\r\n</ol></li>\r\n<li><p><span\r\nclass=\"math inline\">\\(\\begin{matrix}0&amp;&lt;&amp;\\lambda_i&amp;&lt;&amp;\\frac{\\sqrt{2}}{2}\\end{matrix}\\)</span></p></li>\r\n</ol>\r\n<p>结论：all players' actions converge to the unique NE <span\r\nclass=\"math inline\">\\(x^*\\)</span> under algorithm 1.</p>\r\n<h4 id=\"preliminary-analysis-about-algorithm-1\">3-2: Preliminary\r\nanalysis about algorithm 1</h4>\r\n<p>先来求一下algorithm 1里的<span\r\nclass=\"math inline\">\\(v_i^k\\)</span></p>\r\n<p>定义：<span\r\nclass=\"math inline\">\\(\\left.V_{k}=\\left[\\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\\ldots,v_{N}^{k}}\\end{array}\\right.\\right]^{T}\\)</span></p>\r\n<p>所以<span class=\"math inline\">\\(v_i^{k+1}=\\sum_{j=1}^Na_{ij}v_j^k\r\n\\qquad (3b)\\)</span>等价于<span\r\nclass=\"math inline\">\\(V_{k+1}=AV_{k}\\qquad (5)\\)</span></p>\r\n<p>因为<span class=\"math inline\">\\(V_1 = [v_1, v_2, ..., v_N]^T =\r\nI_N\\)</span>，即<span class=\"math inline\">\\(v_i =\r\ne_i\\)</span>（条件）</p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}V_k=\\operatorname*{lim}_{k\\to\\infty}A^{k-1}V_1=\\operatorname*{lim}_{k\\to\\infty}A^{k}\\)</span></p>\r\n<p>因为A是行随机矩阵，所以显然<span\r\nclass=\"math inline\">\\(1_n\\)</span>是特征值为1时的一个特征向量。</p>\r\n<p>所以得出<span\r\nclass=\"math inline\">\\(\\operatorname*{lim}_{k\\to\\infty}A^{k}=1_Nv^T\\)</span>\r\n（根据Perron-Frobenius定理）, where <span\r\nclass=\"math inline\">\\(v\\)</span> 是A关于特征值1的左特征向量且<span\r\nclass=\"math inline\">\\(v\\)</span>每一项大于0，且<span\r\nclass=\"math inline\">\\(v^T1_N=1\\)</span>。</p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}\\left.V_{k}=\\left[\\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\\ldots,v_{N}^{k}}\\end{array}\\right.\\right]^{T}\r\n= 1_Nv^T\\)</span>。又<span class=\"math inline\">\\(1_Nv^T=[v, v, ...,\r\nv]^T\\)</span>。</p>\r\n<p>也就是说，当k趋近于无穷大时，每个玩家的<span\r\nclass=\"math inline\">\\(v_i\\)</span>都收敛于<span\r\nclass=\"math inline\">\\(v\\)</span>。</p>\r\n<p>再来求一下algorithm 1里的<span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{i}^{k}\\)</span></p>\r\n<p>首先<span\r\nclass=\"math inline\">\\(V_k\\)</span>对角线上的元素都是正的，通过<span\r\nclass=\"math inline\">\\(V_{k+1}=AV_{k}\\)</span>可看出。首先<span\r\nclass=\"math inline\">\\(V_1\\)</span>是单位阵肯定对角线为正，然后A的对角线元素都是正的（这是algorithm\r\n1引入时提到的条件）。所以他俩乘出来的对角线也是正的。不断递推，对角线上都是正的。</p>\r\n<p>所以现在我定义一个<span\r\nclass=\"math inline\">\\(\\left.\\hat{V}_k=\\operatorname{diag}\\left(\\begin{bmatrix}v_1^k\\end{bmatrix}\\right._1,\\begin{bmatrix}v_2^k\\end{bmatrix}_2,\\ldots,\\begin{bmatrix}v_N^k\\end{bmatrix}_N\\right)\\)</span></p>\r\n<p>上面这个<span\r\nclass=\"math inline\">\\(\\hat{V}_k\\)</span>其实就是取了<span\r\nclass=\"math inline\">\\(V_k\\)</span>的对角线，其余地方都是0。</p>\r\n<p>因为前面说了对角线都是正的嘛，所以<span\r\nclass=\"math inline\">\\(\\hat{V_k}\\)</span>是满秩可逆的。而且我们知道最终<span\r\nclass=\"math inline\">\\(V_k\\)</span>是收敛的，所以<span\r\nclass=\"math inline\">\\(\\hat{V_k}\\)</span>最终也是收敛的。</p>\r\n<p>最后我再定义<span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{k}=\\left[\\tilde{\\sigma}_{1}^{k},\\tilde{\\sigma}_{2}^{k},\\ldots,\\tilde{\\sigma}_{N}^{k}\\right]^{T}\\)</span>和<span\r\nclass=\"math inline\">\\(\\phi_k =\r\n\\left[\\phi_{1}(x_{1}^{k}),\\phi_{2}(x_{2}^{k}),\\ldots,\\phi_{N}(x_{N}^{k})\\right]^{T}\\)</span></p>\r\n<p>则<span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{i}^{k+1}=\\sum_{j=1}^{N}a_{ij}\\tilde{\\sigma}_{j}^{k}+\\frac{\\phi_{i}\\left(x_{i}^{k+1}\\right)}{\\left[v_{i}^{k+1}\\right]_{i}}-\\frac{\\phi_{i}\\left(x_{i}^{k}\\right)}{\\left[v_{i}^{k}\\right]_{i}}\r\n\\qquad (3c)\\)</span>可改写为：</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{k+1}=A\\tilde{\\sigma}_k+\\hat{V}_{k+1}^{-1}\\Phi_{k+1}-\\hat{V}_k^{-1}\\Phi_k\r\n\\qquad (6)\\)</span></p>\r\n<h4 id=\"lemmas\">3-3: Lemmas</h4>\r\n<p>为了接下来的叙述方便，定义<span\r\nclass=\"math inline\">\\(V_{\\infty}=\\lim\\limits_{k\\to\\infty}V_{k}=1_{N}v^{T}\\)</span>和<span\r\nclass=\"math inline\">\\(\\hat{V}_{\\infty}=\\operatorname{diag}([v]_1,\\ldots,[v]_N)\\)</span></p>\r\n<h5 id=\"lemma-1\">Lemma 1</h5>\r\n<p>因为<span\r\nclass=\"math inline\">\\(\\hat{V}_{k}\\)</span>是收敛的，所以会有<span\r\nclass=\"math inline\">\\(\\|\\hat{V}_{k}^{-1}\\|\\leq \\varrho, \\varrho &gt;\r\n0\\)</span></p>\r\n<blockquote>\r\n<p>矩阵的二范式从几何意义上来说就是单位圆在经过矩阵变换后离原点最远的距离。假设要求<span\r\nclass=\"math inline\">\\(\\|A\\|\\)</span>，则先求<span\r\nclass=\"math inline\">\\(A^TA\\)</span>，然后再求<span\r\nclass=\"math inline\">\\(A^TA\\)</span>的特征值，取最大的特征值开方就是矩阵A的二范数</p>\r\n</blockquote>\r\n<p>引理1：<span\r\nclass=\"math inline\">\\(\\|\\hat{V}_{k}^{-1}-\\hat{V}_{\\infty}^{-1}\\|\\leq\\varrho^{2}\\gamma\\theta^{k},\r\nk \\in \\mathbb{N_+}, \\gamma &gt; 0, 0 &lt; \\theta &lt; 1, \\varrho &gt;\r\n0\\)</span></p>\r\n<p>证明：</p>\r\n<p>因为<span class=\"math inline\">\\((\\hat{V_k}^{-1})(\\hat{V_k} -\r\n\\hat{V}_\\infty)(\\hat{V}_\\infty^{-1}) =\r\n(\\hat{V}_{k}^{-1}-\\hat{V}_{\\infty}^{-1})\\)</span></p>\r\n<p>两边取范数，得：<span\r\nclass=\"math inline\">\\(\\|\\hat{V}_{k}^{-1}-\\hat{V}_{\\infty}^{-1}\\| =\r\n\\|(\\hat{V_k}^{-1})(\\hat{V_k} - \\hat{V}_\\infty)(\\hat{V}_\\infty^{-1})\\|\r\n\\le \\|\\hat{V_k}^{-1}\\|\\|\\hat{V_k} -\r\n\\hat{V}_\\infty\\|\\|\\hat{V}_\\infty^{-1}\\|\\)</span></p>\r\n<p>定义<span class=\"math inline\">\\(\\varrho =\r\n{sup}_{k}\\left\\|\\widetilde{V}_{k}^{-1}\\right\\|_{2}\\)</span>，则<span\r\nclass=\"math inline\">\\(\\|\\hat{V_k}^{-1}\\|\\|\\hat{V}_\\infty^{-1}\\| \\le\r\n\\varrho^2\\)</span></p>\r\n<p>又<span class=\"math inline\">\\(\\|\\hat{V}_k - \\hat{V}_\\infty\\| \\le\r\n\\gamma\\theta^{k}\\)</span>, [17]。</p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\|\\hat{V}_{k}^{-1}-\\hat{V}_{\\infty}^{-1}\\| \\le\r\n\\varrho^{2}\\gamma\\theta^{k}\\)</span>，得证。</p>\r\n<h5 id=\"lemma-2\">Lemma 2</h5>\r\n<p>引理2：<span\r\nclass=\"math inline\">\\(V_{\\infty}\\tilde{\\sigma}_{k}=V_{\\infty}\\hat{V}_{k}^{-1}\\Phi_{k},\r\nk \\in \\mathbb{N_+}\\)</span></p>\r\n<p>证明如下：</p>\r\n<p><img src=\"1.png\" /></p>\r\n<h5 id=\"lemma-3\">Lemma 3</h5>\r\n<p>先来点前置知识</p>\r\n<p>因为<span\r\nclass=\"math inline\">\\(\\operatorname*{lim}_{k\\to\\infty}\\left(A-1_{N}v^{T}\\right)^{k}=\\operatorname*{lim}_{k\\to\\infty}A^{k}-1_{N}v^{T}=0\\)</span>（这个极限推导可以先放着不管），所以根据谱半径的知识，可以知道<span\r\nclass=\"math inline\">\\(\\rho(A-1_Nv^T)~&lt;~1\\)</span></p>\r\n<p>又因为<span class=\"math inline\">\\(\\rho(A-1_Nv^T) \\le \\|A -\r\n1_Nv^T\\|\\)</span></p>\r\n<p>所以必然存在一个矩阵范数<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|_\\epsilon\\)</span>，使得<span\r\nclass=\"math inline\">\\(\\rho(A-1_{N}v^{T})\\leq\\|A-1_{N}v^{T}\\|_{\\epsilon}\\leq\r\n\\rho(A-1_{N}v^{T})+\\epsilon&lt;1\\)</span></p>\r\n<p>另外，又因为所有的矩阵范式都是等价的，所以有：</p>\r\n<p><span class=\"math inline\">\\(\\|\\cdot\\|_{\\epsilon}\\leq\r\nc\\|\\cdot\\|\\)</span> and <span class=\"math inline\">\\(\\|\\cdot\\|\\leq\r\nd\\|\\cdot\\|_{\\epsilon}\\)</span></p>\r\n<p>接下来再定义两个东西</p>\r\n<p><span class=\"math inline\">\\(\\rho_1=\\left\\|A-1_Nv^T\\right\\|_\\epsilon,\r\n\\rho_1 &lt; 1 \\qquad (7)\\)</span></p>\r\n<p><span class=\"math inline\">\\(\\rho_2=\\left\\|I_N-1_Nv^T\\right\\| \\qquad\r\n(8)\\)</span></p>\r\n<p>引理3：Under Assumption 1(a), 2 and 4, <span\r\nclass=\"math inline\">\\(\\|\\tilde{\\sigma}_i^k-v^T\\tilde{\\sigma}_k\\|\\)</span>\r\nis bounded, i.e., there exists a constant <span\r\nclass=\"math inline\">\\(\\hat{C} &gt; 0\\)</span> such that <span\r\nclass=\"math inline\">\\(\\|\\tilde{\\sigma}_{i}^{k}-v^{T}\\tilde{\\sigma}_{k}\\|\\leq\\hat{C}\\)</span></p>\r\n<p>证明如下：</p>\r\n<p><img src=\"5.png\" /></p>\r\n<p><img src=\"6.png\" /></p>\r\n<h5 id=\"lemma-4\">Lemma 4</h5>\r\n<p>引理4：<span\r\nclass=\"math inline\">\\(\\|G_i\\left(x_i^k,\\sigma(x_k)\\right)\\|\\le M,\r\n\\|G_i(x_i^k, \\tilde{\\sigma}_i^k) \\| \\le M, M &gt; 0\\)</span></p>\r\n<p>证明如下：</p>\r\n<p><img src=\"2.png\" /></p>\r\n<h5 id=\"lemma-5\">Lemma 5</h5>\r\n<p>定义<span\r\nclass=\"math inline\">\\(\\overline{\\lambda}=\\max_{j\\in\\mathcal{N}}\\{\\lambda_j\\}\\)</span>，若<span\r\nclass=\"math inline\">\\(0&lt;\\overline{\\lambda}&lt;\\frac{\\sqrt{2}}2\\)</span>，则下面三条性质将会满足：</p>\r\n<ol type=\"a\">\r\n<li><p><span\r\nclass=\"math inline\">\\(\\left\\|x_{i}^{k+1}-x_{i}^{k}\\right\\|\\leq\r\nM\\sum_{s=1}^{k}\\overline{\\lambda}^{k-s}\\overline{\\alpha}_{s},\\forall\r\nk\\in\\mathbb{N}_{+}\\)</span></p></li>\r\n<li><p><span\r\nclass=\"math inline\">\\(\\lim\\limits_{k\\to\\infty}\\left\\|x_{i}^{k+1}-x_{i}^{k}\\right\\|=0\\)</span></p></li>\r\n<li><p><span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\|x_{i}^{k+1}-x_{i}^{k}\\|^{2}&lt;\\infty\\)</span></p></li>\r\n</ol>\r\n<p>where <span class=\"math inline\">\\(M\\)</span> is given in Lemma 4, and\r\n<span\r\nclass=\"math inline\">\\(\\overline{\\alpha}_{k}=\\max_{j\\in\\mathcal{N}}\\{\\alpha_{j}^{k}\\}\\)</span></p>\r\n<p>证明如下：</p>\r\n<p><img src=\"3.png\" /></p>\r\n<p><img src=\"4.png\" /></p>\r\n<p>补充：因为所有动作<span\r\nclass=\"math inline\">\\(x_i^k\\)</span>都属于compact的<span\r\nclass=\"math inline\">\\(\\Omega_i\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\{x_k\\}\\)</span>是有界的，又由Lemma\r\n5(b)和柯西收敛准测可容易推出<span\r\nclass=\"math inline\">\\(\\{x_k\\}​\\)</span>是收敛的。</p>\r\n<h5 id=\"lemma-6\">Lemma 6</h5>\r\n<ol type=\"a\">\r\n<li><p>For any <span class=\"math inline\">\\(k \\geq 2\\)</span>, one has\r\n<span\r\nclass=\"math display\">\\[\\left\\|\\tilde{\\sigma}_{k}-V_{\\infty}\\tilde{\\sigma}_{k}\\right\\|\\leq\r\ndc\\rho_{1}^{k-1}\\left\\|\\tilde{\\sigma}_{1}-1_{N}v^{T}\\tilde{\\sigma}_{1}\\right\\|\r\n+\r\nD_1\\sum_{l=1}^{k-1}\\rho_1^{k-l-1}\\beta_l+D_2\\sum_{l=1}^{k-1}\\rho_1^{k-l-1}\\theta^l\r\n\\qquad (9)\\]</span>where <span\r\nclass=\"math inline\">\\(D_{1}=dc\\rho_{2}\\varrho\r\nL_{2}\\sqrt{N}M,D_{2}=2dc\\rho_{2}C\\varrho^{2}\\gamma,\r\n\\beta_l=\\sum_{s=1}^{l}\\overline{\\lambda}^{l-s}\\overline{\\alpha}_{s}\\)</span>and<span\r\nclass=\"math inline\">\\(0&lt;\\theta&lt;1\\)</span> is given in Lemma\r\n1.</p></li>\r\n<li><p>For step-size sequence <span\r\nclass=\"math inline\">\\(\\{\\alpha_i^k\\}\\)</span> satisfying conditions\r\nC1-C3, one has <span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\overline{\\alpha}_{k}\\left\\|\\tilde{\\sigma}_{k}-V_{\\infty}\\tilde{\\sigma}_{k}\\right\\|&lt;\\infty\\)</span></p></li>\r\n</ol>\r\n<p>证明如下：</p>\r\n<p><img src=\"7.png\" /></p>\r\n<p><img src=\"8.png\" /></p>\r\n<h4 id=\"proof-of-theorem-1\">3-4: Proof of theorem 1</h4>\r\n<p><img src=\"9.png\" /></p>\r\n<p><img src=\"10.png\" /></p>\r\n<p><img src=\"11.png\" /></p>\r\n<p><img src=\"12.png\" /></p>\r\n<p><img src=\"13.png\" /></p>\r\n<p><img src=\"14.png\" /></p>\r\n<p><img src=\"15.png\" /></p>\r\n<p><img src=\"16.png\" /></p>\r\n<h4 id=\"theorem-2\">3-5: Theorem 2</h4>\r\n<p>在满足Assumption 1(a), 2, 3(b) and 4的前提下。令<span\r\nclass=\"math inline\">\\(\\alpha_{i}^{k}=\\frac{1}{\\sqrt{k}}=\\alpha_{k}\\)</span>。且<span\r\nclass=\"math inline\">\\(0&lt;\\lambda_i&lt;\\frac{\\sqrt{2}}{2}\\)</span>，则<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速率为<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln t}{\\sqrt{t}})\\)</span>。 <span\r\nclass=\"math display\">\\[\r\nq_t=\\frac{\\sum\\limits_{k=1}^t\\alpha_k\\|x_k-x^*\\|^2}{\\sum\\limits_{k=1}^t\\alpha_k}\r\n\\]</span> 证明：暂略</p>\r\n<h4 id=\"convergence-rate-analysis-of-algorithm-1\">3-6: Convergence rate\r\nanalysis of algorithm 1</h4>\r\n<p>如果<span\r\nclass=\"math inline\">\\(\\Gamma(x)\\)</span>是强单调，且步长满足<span\r\nclass=\"math inline\">\\(\\alpha_{i}^{k}=\\frac{1}{\\sqrt{k}}\\)</span>。则可以分析algorithm\r\n1的收敛速率。</p>\r\n<p>结论就是<span class=\"math inline\">\\(x_k\\)</span>收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span>的速率与<span\r\nclass=\"math inline\">\\(q_t\\)</span>收敛到0的速率相同。证明如下：</p>\r\n<p><img src=\"17.png\" /></p>\r\n<hr />\r\n<h3 id=\"section-4-convergence-analysis-of-algorithm-2\">Section 4:\r\nConvergence analysis of algorithm 2</h3>\r\n<p>对于之前的algorithm 2中的公式(4a) - (4c)，用矩阵表示如下： <span\r\nclass=\"math display\">\\[\r\n\\begin{aligned}\r\n&amp;w_{k+1} =A\\left(k\\right)\\tilde{\\sigma}_{k},  \\\\\r\n&amp;y_{k+1} =A\\left(k\\right)y_{k},  \\\\\r\n&amp;z_{i}^{k+1} =\\frac{w_{i}^{k+1}}{y_{i}^{k+1}},\\quad i=1,\\ldots,N,\r\n&amp; (24)\r\n\\end{aligned}\r\n\\]</span> (4e)则可以表达为以下形式：</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\tilde{\\sigma}_{k+1}=A\\left(k\\right)\\tilde{\\sigma}_{k}+\\Phi_{k+1}-\\Phi_{k},\\quad(25)\\)</span></p>\r\n<p>其中A矩阵是一个列随机矩阵，如果点j连向i，则A(i, j) = 1 /\r\n(点j的出度)。如果j不连向i，则A(i, j) = 0。</p>\r\n<p>定义<span\r\nclass=\"math inline\">\\(\\epsilon_{k}=[\\epsilon_{1}^{k},\\ldots,\\epsilon_{N}^{k}]^{T}=\\Phi_{k+1}-\\Phi_{k}\\)</span>，这个是。再定义<span\r\nclass=\"math inline\">\\(\\epsilon_{i}^{k}=\\phi_{i}(x_{i}^{k+1})-\\phi_{i}(x_{i}^{k})\\)</span>。</p>\r\n<p>因为A是列随机矩阵，所以<span\r\nclass=\"math inline\">\\(1_{N}^{T}A({k})=1_{N}^{T}\\)</span>。所以(25)左右同乘一个<span\r\nclass=\"math inline\">\\(1_N^T\\)</span>，然后移项得到递推式，通过递推式可得<span\r\nclass=\"math inline\">\\(1_{N}^{T}\\tilde{\\sigma}_{k} - 1_N^T\\phi_k =\r\n1_N^T\\tilde{\\sigma}_1 - 1_N^T\\phi_1 = 0\\)</span></p>\r\n<p>所以<span class=\"math inline\">\\(1_N^T\\tilde{\\sigma}_k = 1_N^T\\phi_k =\r\n\\phi_1(x_1^k) + \\phi_2(x_2^k) + ... + \\phi_n(x_n^k) =\r\n\\sigma(x_k)\\)</span></p>\r\n<h4 id=\"lemmas-1\">4-1: Lemmas</h4>\r\n<h5 id=\"lemma-7\">Lemma 7</h5>\r\n<p>定理：在满足Assumptions 1(b), 2, 4的前提下，there exists a constant\r\n<span class=\"math inline\">\\(\\tilde{M} &gt; 0\\)</span>, s.t, <span\r\nclass=\"math inline\">\\(\\|G_{i}(x_{i}^{k},\\sigma(x_{k}))\\|\\leq\\tilde{M}\\)</span>\r\nand <span\r\nclass=\"math inline\">\\(\\|G_{i}(x_{i}^{k},Nz_{i}^{k+1})\\|\\leq\\tilde{M}\\)</span></p>\r\n<p>证明：</p>\r\n<p>Lemma 4已经证出了<span\r\nclass=\"math inline\">\\(\\left\\|G_i\\left(x_i^k,\\sigma(x_k)\\right)\\right\\|\\leq\r\nM_1\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\|G_{i}(x_{i}^{k},\\sigma(x_{k}))\\|\\leq\\tilde{M}\\)</span>就不用证了。主要证后面那个。</p>\r\n<p><span\r\nclass=\"math display\">\\[\\begin{Vmatrix}G_i(x_i^k,Nz_i^{k+1})\\end{Vmatrix}\\le\\begin{Vmatrix}G_i(x_i^k,Nz_i^{k+1})-G_i(x_i^k,1_N^T\\tilde{\\sigma}_k)\\end{Vmatrix}+\\left\\|G_{i}(x_{i}^{k},1_{N}^{T}\\tilde{\\sigma}_{k})\\right\\|\r\n\\\\ \\qquad \\le L_{1}\\left\\Vert\r\nNz_{i}^{k+1}-1_{N}^{T}\\tilde{\\sigma}_{k}\\right\\Vert+\\left\\Vert\r\nG_{i}(x_{i}^{k},1_{N}^{T}\\tilde{\\sigma}_{k})\\right\\Vert \\]</span></p>\r\n<p>显然，<span\r\nclass=\"math inline\">\\(\\|G_{i}(x_{i}^{k},1_{N}^{T}\\tilde{\\sigma}_{k})\\|\\)</span>就是<span\r\nclass=\"math inline\">\\(\\|G_i(x_i^k,\\sigma(x_k))\\|\\)</span>，所以其有界。</p>\r\n<p>由[17, lemma 1(a)]可知，k &gt;=2 时，有：</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\left|z_{i}^{k+1}-\\frac{1_{N}^{T}\\tilde{\\sigma}_{k}}{N}\\right|\\le\\frac{8}{\\delta}\\Bigg(\\iota^{k-1}\\|\\tilde{\\sigma}_{1}\\|_{1}+\\sum_{s=1}^{k-1}\\iota^{k-s-1}\\|\\epsilon_{s}\\|_{1}\\Bigg)\r\n\\quad (26)\\)</span></p>\r\n<p>with <span class=\"math inline\">\\(\\delta &gt; 0, 0 &lt; \\iota &lt;\r\n1\\)</span></p>\r\n<p>因为<span class=\"math inline\">\\(\\|\\epsilon_{s}\\|_{1}\\le\r\nN\\|\\epsilon_{s}\\|=N\\|\\Phi_{s+1}-\\Phi_{s}\\|\\leq2NC\\)</span></p>\r\n<p>所以不难证出：<span\r\nclass=\"math inline\">\\(L_{1}\\left\\|Nz_{i}^{k+1}-1_{N}^{T}\\tilde{\\sigma}_{k}\\right\\|\\)</span>有界</p>\r\n<p>所以<span class=\"math inline\">\\(\\|\r\nG_i(x_i^k,Nz_i^{k+1})\\|\\)</span>有界，即<span\r\nclass=\"math inline\">\\(\\parallel G_i(x_i^k,Nz_i^{k+1})\\parallel \\le\r\n\\tilde{M}_2\\)</span></p>\r\n<p>令<span class=\"math inline\">\\(\\tilde{M} = max (M_1,\r\n\\tilde{M}_2)\\)</span>，得证。</p>\r\n<blockquote>\r\n<p>Note: 如果<span\r\nclass=\"math inline\">\\(\\overline{\\lambda}=\\operatorname*{max}_{j\\in\\mathcal{N}}\\{\\lambda_{j}\\}\\)</span>\r\nsatisfies <span class=\"math inline\">\\(0 &lt; \\overline{\\lambda} &lt;\r\n\\frac{\\sqrt{2}}{2}\\)</span>，则Lemma\r\n5中的结论和证明过程仍然成立，只需要将其中涉及到的M换成<span\r\nclass=\"math inline\">\\(\\tilde{M}\\)</span></p>\r\n</blockquote>\r\n<h5 id=\"lemma-8\">Lemma 8</h5>\r\n<p>定理：如果<span\r\nclass=\"math inline\">\\(\\overline{\\lambda}=\\max_{j\\in\\mathcal{N}}\\{\\lambda_{j}\\}\\)</span>\r\nsatisfies <span class=\"math inline\">\\(0 &lt; \\overline{\\lambda} &lt;\r\n\\frac{\\sqrt{2}}{2}\\)</span>，且<span\r\nclass=\"math inline\">\\(\\alpha_i^k\\)</span> satisfies conditions\r\nC1-C3。则<span\r\nclass=\"math inline\">\\(\\lim_{k\\rightarrow\\infty}\\epsilon_{i}^{k}=0\\)</span>，且\r\n<span\r\nclass=\"math inline\">\\(\\sum_{k=1}^\\infty\\overline{\\alpha}_k\\|\\epsilon_i^k\\|&lt;\\infty\\)</span></p>\r\n<p>证明：</p>\r\n<p>由于上面的Note存在，所以Lemma 5的结论可以直接用于Lemma 8的证明。</p>\r\n<p>先证第一个：</p>\r\n<p>因为<span class=\"math inline\">\\(\\phi_i(x_i)\\)</span>是L2-Lipschitz\r\ncontinuous，所以<span class=\"math inline\">\\(\\|\\epsilon_{i}^{k}\\|\\le\r\nL_{2}\\|x_{i}^{k+1}-x_{i}^{k}\\|\\)</span></p>\r\n<p>而且由Lemma 5(b)知：<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}\\|x_{i}^{k+1}-x_{i}^{k}\\|=0\\)</span></p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}\\epsilon_{i}^{k}=0\\)</span></p>\r\n<p>再证第二个：</p>\r\n<p>由Lemma 5(a)知：<span\r\nclass=\"math inline\">\\(\\left\\|x_i^{k+1}-x_i^k\\right\\|\\leq\r\nM\\sum_{s=1}^k\\overline{\\lambda}^{k-s}\\overline{\\alpha}_s\\)</span></p>\r\n<p>所以：<span class=\"math inline\">\\(\\overline{\\alpha}_k||\\epsilon_i^k||\r\n\\le\r\n\\overline{\\alpha}_{k}L_{2}\\tilde{M}\\sum_{s=1}^{k}\\overline{\\lambda}^{k-s}\\overline{\\alpha}_{s}\r\n\\le\r\nL_{2}\\tilde{M}\\sum_{s=1}^{k}\\overline{\\lambda}^{k-s}\\overline{\\alpha}_{s}^{2}\\)</span></p>\r\n<p>又根据[31 Lemma 3.1(b)]，可得到：<span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\overline{\\alpha}_{k}||\\epsilon_{i}^{k}||\\leq\r\nL_{2}\\tilde{M}\\sum_{k=1}^{\\infty}\\sum_{s=1}^{k}\\overline{\\lambda}^{k-s}\\overline{\\alpha}_{s}^{2}&lt;\\infty\\)</span></p>\r\n<blockquote>\r\n<p>Note：通过Lemma 8证明的这两个结论，通过[17 Lemma\r\n1]，可以进一步证明出：</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\lim\\limits_{k\\to\\infty}\\left\\|z_i^{k+1}-\\frac{1_N^T\\tilde{\\sigma}_k}{N}\\right\\|=0,\\sum\\limits_{k=1}^{\\infty}\\overline{\\alpha}_k\\left\\|z_i^{k+1}-\\frac{1_N^T\\tilde{\\sigma}_k}{N}\\right\\|&lt;\\infty\\)</span></p>\r\n<p>因为<span\r\nclass=\"math inline\">\\(1_{N}^{T}\\tilde{\\sigma}_{k}\\)</span>就是<span\r\nclass=\"math inline\">\\(\\sigma\\left(x_{k}\\right)\\)</span></p>\r\n<p>所以<span\r\nclass=\"math inline\">\\(\\sum_{k=1}^{\\infty}\\overline{\\alpha}_{k}\\left\\Vert\r\nNz_{i}^{k+1}-\\sigma(x_{k})\\right\\Vert &lt; \\infty\\)</span></p>\r\n<p>上面这个公式在algorithm 2的收敛分析中有作用。</p>\r\n</blockquote>\r\n<h4 id=\"theorem-3\">4-2: Theorem 3</h4>\r\n<p>定理：在满足Assumptions 1(b), 2, 3(a), 4，以及<span\r\nclass=\"math inline\">\\(0 &lt; \\lambda_i &lt;\r\n\\frac{\\sqrt{2}}{2}\\)</span>，以及C1-C3的条件下。所有玩家的动作最终会收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span></p>\r\n<p>证明：</p>\r\n<p><img src=\"18.png\" /></p>\r\n<p><img src=\"19.png\" /></p>\r\n<h4 id=\"theorem-4\">4-3: Theorem 4</h4>\r\n<p>定理：在Assumptions 1(b), 2, 3(b), 4 are satisfied 的前提下，令<span\r\nclass=\"math inline\">\\(\\alpha_{i}^{k}=\\frac{1}{\\sqrt{k}}=\\alpha_{k}\\)</span>，且<span\r\nclass=\"math inline\">\\(0 &lt; \\lambda_i &lt;\r\n\\frac{\\sqrt{2}}{2}\\)</span>。则<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速率为<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln t}{\\sqrt{t}})\\)</span> <span\r\nclass=\"math display\">\\[\r\nq_t=\\frac{\\sum\\limits_{k=1}^t\\alpha_k\\|x_k-x^*\\|^2}{\\sum\\limits_{k=1}^t\\alpha_k}\r\n\\]</span> 证明：需要参考[17 Corollary 3]和Theorem 2的证明。</p>\r\n<blockquote>\r\n<p>Note：如果<span\r\nclass=\"math inline\">\\(\\Gamma(x)\\)</span>是强单调且步长满足<span\r\nclass=\"math inline\">\\(\\alpha_i^k=\\frac1{\\sqrt{k}}\\)</span>，则可分析algorithm\r\n2的收敛速度。结论也是<span class=\"math inline\">\\(x_k\\)</span>收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span>的速率与<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速率相同。</p>\r\n</blockquote>\r\n<hr />\r\n<h3 id=\"section-5-energy-consumption-control-of-phevs\">Section 5: Energy\r\nconsumption control of PHEVs</h3>\r\n<p>每个PHEV就是一个玩家。第 i 个PHEV的电量消耗为<span\r\nclass=\"math inline\">\\(x_i, x_i \\in [x_i^{min},\r\nx_i^{max}]\\)</span>。每台车的成本函数<span\r\nclass=\"math inline\">\\(J_i\\)</span>定义为： <span class=\"math display\">\\[\r\nJ_i(x_i,x_{-i})=x_i\\left(a\\sigma(x)+b\\right)+p_o\\left(\\kappa_i\\left(1-\\frac{x_i}{x_i^{\\max}}\\right)^2+d_i\\right)\r\n\\qquad (30)\r\n\\]</span> a &gt; 0，<span\r\nclass=\"math inline\">\\(\\sigma(x)=\\sum_{i=1}^N{x_i}\\)</span>，<span\r\nclass=\"math inline\">\\(p_0\\)</span>是油价，<span\r\nclass=\"math inline\">\\(\\kappa_{i}\\)</span>是油价的换算系数，<span\r\nclass=\"math inline\">\\(d_i\\)</span>是第 i 台车所需的基本油量。</p>\r\n<p>总结一下，按照我的理解，上面那个式子就是每台车的花费函数嘛。花费分为俩部分：电费、油费。电费不仅跟自己的耗电量有关，也跟所有人的耗电量有关，所以是第\r\ni\r\n台车的电费是两者相乘。对于油费，首先一台车的油量分为两部分，第一是<span\r\nclass=\"math inline\">\\(x_i^{max} -\r\nx_i\\)</span>剩下的用油来跑，第二是一台车最起码要存储的油量<span\r\nclass=\"math inline\">\\(d_i\\)</span>。分别就对应着上面括号里的两项。乘个油价就为油费了。</p>\r\n<p>这个实际问题建模后显然满足Assumption 2,\r\n4。而且值得注意的是，其成本函数还具有一个势函数<span\r\nclass=\"math inline\">\\(F(x)\\)</span>： <span class=\"math display\">\\[\r\n\\begin{aligned}F(x)&amp;=\\frac12\\sum_{i=1}^Nax_i\\left(\\sigma(x)-x_i\\right)+\\sum_{i=1}^N\\left(ax_i^2+bx_i\\right)\\\\&amp;+\\sum_{i=1}^Np_o\\left(\\kappa_i\\left(1-\\frac{x_i}{x_i^{\\max}}\\right)^2+d_i\\right)\r\n\\qquad(31)\\end{aligned}\r\n\\]</span> （势函数就是指，对于所有i，有：<span\r\nclass=\"math inline\">\\(\\frac{\\partial{J}_{i}(x)}{\\partial\r\nx_{i}}=\\frac{\\partial{F}(x)}{\\partial x_{i}}\\)</span>）</p>\r\n<p>接下来，来验证这个建模满足Assumption 3(a)。即<span\r\nclass=\"math inline\">\\(\\Gamma(x)\\)</span>在<span\r\nclass=\"math inline\">\\(\\Omega\\)</span>上是严格单调的。</p>\r\n<h4 id=\"lemma-9\">Lemma 9</h4>\r\n<p>定理：如果<span class=\"math inline\">\\(N &gt; 3\\)</span>且a满足：\r\n<span class=\"math display\">\\[\r\na&lt;\\min_{i\\in\\mathcal{N}}\\frac{2p_{o}\\kappa_{i}}{\\left(N-3\\right)\\left(x_{i}^{\\max}\\right)^{2}}\r\n\\]</span> 则势函数<span\r\nclass=\"math inline\">\\(F(x)\\)</span>是严格凸的。</p>\r\n<p>证明：</p>\r\n<p>先求<span\r\nclass=\"math inline\">\\(\\nabla^2F(x)\\)</span>，不难求出，其对角元素为<span\r\nclass=\"math inline\">\\(2a+\\frac{2p_{o}\\kappa_{i}}{(x_{i}^{\\operatorname*{max}})^{2}}\\)</span>，非对角元素为<span\r\nclass=\"math inline\">\\(a\\)</span>。因为<span class=\"math inline\">\\(N &gt;\r\n3\\)</span>且a满足<span\r\nclass=\"math inline\">\\(a&lt;\\min_{i\\in\\mathcal{N}}\\frac{2p_{o}\\kappa_{i}}{\\left(N-3\\right)\\left(x_{i}^{\\max}\\right)^{2}}\\)</span>，所以<span\r\nclass=\"math inline\">\\(\\nabla^2F(x)\\)</span>是一个严格对角占优矩阵（严格对角占有矩阵就是对于每一行其对角线上元素的绝对值大于该行中其它所有元素绝对值之和）。所以由[30]中的Gershgorin’s\r\ndisctheorem可知<span\r\nclass=\"math inline\">\\(\\nabla^2F(x)\\)</span>是一个正定矩阵。那么凸函数的第四种定义即可知道<span\r\nclass=\"math inline\">\\(F(x)\\)</span>是一个严格凸函数。证毕。</p>\r\n<p>所以，这个建模在满足<span class=\"math inline\">\\(N &gt; 3,\r\na&lt;\\min_{i\\in\\mathcal{N}}\\frac{2p_{o}\\kappa_{i}}{\\left(N-3\\right)\\left(x_{i}^{\\max}\\right)^{2}}\\)</span>的时候，就满足<span\r\nclass=\"math inline\">\\(F(x)\\)</span>是个凸函数，即：<span\r\nclass=\"math inline\">\\((x-y)^{T}(\\nabla F(x)-{\\nabla F(y)})&gt;0, x \\ne\r\ny\\)</span> 。又因为<span\r\nclass=\"math inline\">\\(\\frac{\\partial{J}_{i}(x)}{\\partial\r\nx_{i}}=\\frac{\\partial{F}(x)}{\\partial x_{i}}\\)</span>，所以Assumption\r\n3(a)满足（这里的<span\r\nclass=\"math inline\">\\(F(x)\\)</span>其实就是Assumption 3中的<span\r\nclass=\"math inline\">\\(\\Gamma(x)\\)</span>）。</p>\r\n<p>至此，满足了Assumption 1, 2, 3(a), 4。只要控制好动量系数满足<span\r\nclass=\"math inline\">\\(0&lt;\\lambda_i&lt;\\frac{\\sqrt{2}}2\\)</span>，以及步长系数<span\r\nclass=\"math inline\">\\(\\lambda_i\\)</span>满足C1-C3，那么这个建模就满足Algorithm\r\n1、2的使用条件了。</p>\r\n<h4 id=\"numerical-simulations\">Numerical simulations</h4>\r\n<p>下面，分别通过两个实际的数值模拟来验证Algorithm 1、2。</p>\r\n<p>考虑有8台车，5种不同类型的车分别用不同颜色表示。每台车的具体参数见下表：</p>\r\n<p><img src=\"26.png\" /></p>\r\n<p>先来验证Algorithm 1。</p>\r\n<p><img src=\"20.png\" /></p>\r\n<p>可以看到，这个图是强连通的且不是一个权重平衡图。通过计算，<span\r\nclass=\"math inline\">\\(x^* =\r\n[17.6859,17.6859,15.5682,15.5682,12.5484,12.5484, 16.587,\r\n16.3481]\\)</span>。</p>\r\n<p>设置步长为<span\r\nclass=\"math inline\">\\(\\alpha_{i}^{k}=\\frac{1}{k^{0.6}}+\\frac{1}{k^{1.2}}\\)</span>。</p>\r\n<p>Fig 2是在不同<span\r\nclass=\"math inline\">\\(\\lambda_i\\)</span>下，使用Algorithm 1收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span>的迭代次数。</p>\r\n<p><img src=\"21.png\" /></p>\r\n<p>可以看到，加了动量项收敛速度确实会快一些。而且动量系数越大速度越快。而且虽然理论要求<span\r\nclass=\"math inline\">\\(0&lt;\\lambda_i&lt;\\frac{\\sqrt{2}}2\\)</span>，但是<span\r\nclass=\"math inline\">\\(\\frac{\\sqrt{2}}{2} &lt; \\lambda_i &lt;\r\n1\\)</span>时在数值仿真中仍然可以收敛。</p>\r\n<p>再来验证Algorithm 2。</p>\r\n<p><img src=\"22.png\" /></p>\r\n<p>如图Fig. 3，考虑车子的通信图周期性地在Fig. 3中的两个状态中切换。</p>\r\n<p>Fig. 4是在不同<span\r\nclass=\"math inline\">\\(\\lambda_i\\)</span>下，使用Algorithm 2收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span>的迭代次数。</p>\r\n<p><img src=\"23.png\" /></p>\r\n<p>可以发现，加了动量项收敛速度确实会快一些。而且动量系数越大速度越快。而且<span\r\nclass=\"math inline\">\\(\\lambda_i\\)</span>也是可以大于<span\r\nclass=\"math inline\">\\(\\frac{\\sqrt{2}}{2}\\)</span> ，小于1。</p>\r\n<p>最后通过数值模拟证明一下<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速率为<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln t}{\\sqrt{t}})\\)</span>。</p>\r\n<p>下面两幅图就是分别用了Algorithm 1和2（<span\r\nclass=\"math inline\">\\(\\alpha_{i}^{k}=\\frac{1}{\\sqrt{k}}, \\lambda_i =\r\n0.6\\)</span>）。其中<span class=\"math inline\">\\(c_t = \\frac{\\ln\r\nt}{\\sqrt{t}}\\)</span>。</p>\r\n<p><img src=\"24.png\" /></p>\r\n<p><img src=\"25.png\" /></p>\r\n<p>可以发现，迭代次数越多的时候，<span\r\nclass=\"math inline\">\\(q_t\\)</span>与<span\r\nclass=\"math inline\">\\(c_t\\)</span>的比值越接近1。也就通过数值模拟证明了在Algorithm1或2下，它俩收敛到0的速度是一样的。</p>\r\n<hr />\r\n<h3 id=\"section-6-conclusion\">Section 6: Conclusion</h3>\r\n<p>本文提出了两种算法分别解决固定有向图和时变有向图上的NE寻找问题（且图不需要权重平衡）。这俩算法分别是基于行随机矩阵左特征向量估计法、列随机矩阵推和法。</p>\r\n<p>而且为了加速算法收敛，算法1、2中均加入了动量项。</p>\r\n<p>但是算法中采用的是学习率递减到0的方式，这种方式会导致收敛速度较慢，这是本算法的不足。</p>\r\n<p>最后，本文作者认为，进一步研究“在聚合游戏中采用分布式算法加速寻找NE”将是一件很有趣的课题。</p>\r\n<hr />\r\n<h3 id=\"personal-summary\">Personal summary</h3>\r\n<h4 id=\"分布式发展历史\">分布式发展历史</h4>\r\n<p>这篇文章是我在分布式领域看的第一篇文章，所以在这里写点关于分布式算法优化领域的发展过程：</p>\r\n<blockquote>\r\n<p>1960s，Everett Dantzig, Wolfe and Benders\r\n思考了关于严格凸问题的拉格朗日松弛和线性规范的分解方法。（分解方法是为了将大型优化问题分解为小问题）</p>\r\n<p>后来，拉格朗日松弛和Hestenes, Powell and\r\nMiele发展的增广拉格朗日技术相结合，解决了一些凸但非严格凸的问题。可以理解为现代ADMM算法的前身。</p>\r\n<p>2000年初，出现了为了适应大规模数据的分布式算法，例如SGD（分布式随机梯度下降）。</p>\r\n<p>2010年初，为了解决大规模机器学习问题，出现了ADMM（交替方向乘子法）等算法。</p>\r\n<p>至今，分布式优化算法在算法效率、鲁棒性、以及适应动态和不确定环境方面取得了显著进展。出现了更加高效的分布式在线优化方法，以及能够适应网络拓扑变化和通信不确定性的算法。</p>\r\n</blockquote>\r\n<h4 id=\"文章总结\">文章总结</h4>\r\n<p>本文就是研究了一种特殊的博弈——聚合博弈。</p>\r\n<p>每个玩家的花费不仅跟自身动作有关，还跟其他人的动作有关。</p>\r\n<p>本论文设计了两种算法，在作者规定的特定条件下，可以使得每个人的花费尽可能低。分别用于固定有向图和时变有向图。</p>\r\n<p>文章内容为：算法介绍、算法的正确性证明、收敛速度分析、在PHEVs上的应用。</p>\r\n<h5 id=\"算法介绍\">算法介绍</h5>\r\n<p><strong>Algorithm 1</strong> <span class=\"math display\">\\[\r\n\\begin{gathered}\r\nx_i^0=x_i^1\\in\\Omega_i,v_i^1=e_i,\\tilde{\\sigma}_i^1=\\phi_i(x_i^1) \\\\\r\nx_{k+1}=P_{\\Omega_{i}}[x_{k}-\\alpha_{k}G_{i}(x_{k},\\tilde{\\sigma}_{k})+\\lambda_{i}(x_{k}-x_{k-1})]\r\n\\\\\r\nV_{k+1}=AV_k \\\\\r\n\\tilde{\\sigma}_{k+1}=A\\tilde{\\sigma}_k+\\hat{V}_{k+1}^{-1}\\Phi_{k+1}-\\hat{V}_{k}^{-1}\\Phi_{k}\r\n\\end{gathered}\r\n\\]</span> 目的就是为了把<span\r\nclass=\"math inline\">\\(x_k\\)</span>收敛到<span\r\nclass=\"math inline\">\\(x^*\\)</span>。使得玩家动作为<span\r\nclass=\"math inline\">\\(x^*\\)</span>时，每个玩家的花费最少。</p>\r\n<p>因为动作<span class=\"math inline\">\\(x_i\\)</span>会对花费<span\r\nclass=\"math inline\">\\(J_i\\)</span>产生影响，故定义<span\r\nclass=\"math inline\">\\(G_i\\)</span>为<span\r\nclass=\"math inline\">\\(J_i\\)</span>对<span\r\nclass=\"math inline\">\\(x_i\\)</span>求导，用来评估<span\r\nclass=\"math inline\">\\(x_i\\)</span>对<span\r\nclass=\"math inline\">\\(J_i\\)</span>产生的影响。</p>\r\n<p>那么<span class=\"math inline\">\\(x_i^{k+1}\\)</span>就可以通过<span\r\nclass=\"math inline\">\\(x_i^k\\)</span>和<span\r\nclass=\"math inline\">\\(G_i(x_i^k,\r\n\\tilde{\\sigma}_i^k)\\)</span>来更新。</p>\r\n<p><span class=\"math inline\">\\(\\tilde{\\sigma}_i^k\\)</span>是什么？</p>\r\n<p>需要注意的是，花费函数<span\r\nclass=\"math inline\">\\(J_i\\)</span>除了要知道<span\r\nclass=\"math inline\">\\(i\\)</span>玩家的动作<span\r\nclass=\"math inline\">\\(x_i\\)</span>，还需要知道所有玩家的输出函数<span\r\nclass=\"math inline\">\\(\\phi_i\\)</span>。所以定义<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>为所有玩家的输出函数之和。但是因为每个玩家没有上帝视角，所以<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>是未知的，所以我们可以用<span\r\nclass=\"math inline\">\\(\\tilde\\sigma_i\\)</span>来代替<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>。即每个玩家都有一个对<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>的评估函数<span\r\nclass=\"math inline\">\\(\\tilde\\sigma_i\\)</span>（这个评估函数也是需要迭代更新的，最终要收敛于<span\r\nclass=\"math inline\">\\(\\sigma(x)\\)</span>）</p>\r\n<p>至于<span\r\nclass=\"math inline\">\\(V_k\\)</span>，个人目前觉得是一个辅助矩阵，在迭代更新<span\r\nclass=\"math inline\">\\(\\tilde\\sigma_k\\)</span>时会用到。</p>\r\n<p>至于<span\r\nclass=\"math inline\">\\(\\lambda_i\\)</span>，是动量项，加速收敛用的。</p>\r\n<p><strong>Algorithm 2</strong> <span class=\"math display\">\\[\r\n\\begin{gathered}\r\n\\\\\r\nx_i^0=x_i^1\\in\\Omega_i,y_i^1=1,\\tilde{\\sigma}_i^1=\\phi_i(x_i^1) \\\\\r\nw_{k+1}=A\\left(k\\right)\\tilde{\\sigma}_{k} \\\\\r\ny_{k+1}=A\\left(k\\right)y_{k} \\\\\r\nz_i^{k+1}=\\frac{w_i^{k+1}}{y_i^{k+1}} \\\\\r\nx_{k+1}=P_{\\Omega_i}\\left[x_k-\\alpha_kG_i(x_k,Nz_{k+1})+\\lambda_i(x_k-x_{k-1})\\right]\r\n\\\\\r\n\\begin{aligned}\\tilde{\\sigma}_{k+1}=w_{k+1}+\\phi_i\\left(x_{k+1}\\right)-\\phi_i\\left(x_k\\right)\\end{aligned}\r\n\\end{gathered}\r\n\\]</span> w是多余的，可以把<span\r\nclass=\"math inline\">\\(w_{k+1}\\)</span>那里合并到最后一个公式。</p>\r\n<p>本质就是推和协议。y是权重，<span\r\nclass=\"math inline\">\\(\\sigma\\)</span>是基于权重的平均值。</p>\r\n<p>经过迭代后，<span class=\"math inline\">\\(z =\r\n\\frac{\\sigma}{y}\\)</span>就是<span\r\nclass=\"math inline\">\\(\\phi\\)</span>的平均值。</p>\r\n<p>但是因为<span\r\nclass=\"math inline\">\\(\\phi\\)</span>初值不是定值，所以最后公式倒数俩项就是动态更新<span\r\nclass=\"math inline\">\\(\\sigma\\)</span></p>\r\n<h5 id=\"算法正确性证明\">算法正确性证明</h5>\r\n<p>本文大篇幅都是在证这个。</p>\r\n<p>本质就是证<span class=\"math inline\">\\(x_k\\)</span>最终收敛于<span\r\nclass=\"math inline\">\\(x^*\\)</span>。即<span class=\"math inline\">\\(\\|x_k\r\n- x^*\\|^2 \\rightarrow 0\\)</span>。</p>\r\n<p>具体内容过多不好总结 ，具体看下文证明。</p>\r\n<p>证明过程主要用到了：矩阵范数性质、范数的放缩、Cauchy-Schwarz。</p>\r\n<h5 id=\"收敛速度分析\">收敛速度分析</h5>\r\n<p>在作者规定的更多特定条件下（条件比它提出的俩算法更严格），Algorithm\r\n1、2的收敛速度跟<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速度一样： <span\r\nclass=\"math display\">\\[\r\nq_t=\\frac{\\sum\\limits_{k=1}^t\\alpha_k\\|x_k-x^*\\|^2}{\\sum\\limits_{k=1}^t\\alpha_k}\r\n\\]</span> 而<span\r\nclass=\"math inline\">\\(\\{q_t\\}\\)</span>收敛到0的速度经证明为：<span\r\nclass=\"math inline\">\\(O(\\frac{\\ln t}{\\sqrt{t}})\\)</span></p>\r\n<h5 id=\"在phevs上的应用\">在PHEVs上的应用</h5>\r\n<p>这个部分论文中也没给出实现代码，只给出了数值模拟的结果和效果图。所以我自己复现了一遍论文的算法。</p>\r\n<p><strong>Algorithm 1的数值仿真</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Algorithm 1的数值仿真</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">8</span></span><br><span class=\"line\">x_best = [-<span class=\"number\">1</span>, <span class=\"number\">17.6859</span>, <span class=\"number\">17.6859</span>, <span class=\"number\">15.5682</span>, <span class=\"number\">15.5682</span>, <span class=\"number\">12.5484</span>, <span class=\"number\">12.5484</span>, <span class=\"number\">16.587</span>, <span class=\"number\">16.3481</span>]</span><br><span class=\"line\">x_min = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">x_max = [-<span class=\"number\">1</span>, <span class=\"number\">27.5</span>, <span class=\"number\">27.5</span>, <span class=\"number\">34.2</span>, <span class=\"number\">34.2</span>, <span class=\"number\">40.6</span>, <span class=\"number\">40.6</span>, <span class=\"number\">28.8</span>, <span class=\"number\">35.7</span>]</span><br><span class=\"line\">x = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">    x[i] = (x_min[i] + x_max[i]) / <span class=\"number\">2</span></span><br><span class=\"line\">p_0 = <span class=\"number\">5.6</span></span><br><span class=\"line\">a = <span class=\"number\">0.004</span></span><br><span class=\"line\">b = <span class=\"number\">0.1</span></span><br><span class=\"line\">k = [-<span class=\"number\">1</span>, <span class=\"number\">4.6</span>, <span class=\"number\">4.6</span>, <span class=\"number\">3.7</span>, <span class=\"number\">3.7</span>, <span class=\"number\">3.4</span>, <span class=\"number\">3.4</span>, <span class=\"number\">4.0</span>, <span class=\"number\">3.9</span>]</span><br><span class=\"line\">d = [-<span class=\"number\">1</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.8</span>]</span><br><span class=\"line\">alpha = <span class=\"number\">2</span></span><br><span class=\"line\">A = [</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>]</span><br><span class=\"line\">]   <span class=\"comment\"># 这里因为论文中没明确指定具体的值，只说是行随机，所以对于每行有值的位置我直接平均分了</span></span><br><span class=\"line\">v = [</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">]</span><br><span class=\"line\">sigma = [-<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">    sigma.append(x[i])</span><br><span class=\"line\"></span><br><span class=\"line\">xx = copy.deepcopy(x)</span><br><span class=\"line\">xxx = copy.deepcopy(x)</span><br><span class=\"line\">vv = copy.deepcopy(v)</span><br><span class=\"line\">ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#-----------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">G</span>(<span class=\"params\">i, x, sigma</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * (sigma + x) + b  - <span class=\"number\">2</span> * p_0 * k[i] / x_max[i] * (<span class=\"number\">1</span> - x / x_max[i])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_x</span>(<span class=\"params\">i, vec</span>):</span><br><span class=\"line\">    x[i] = xx[i] - alpha * G(i, xx[i], ssigma[i]) + vec * (xx[i] - xxx[i])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x[i] &lt; x_min[i]: x[i] = x_min[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x[i] &gt; x_max[i]: x[i] = x_max[i]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_v</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    vvv = copy.deepcopy(vv)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            vvv[j][l] *= A[i][j]</span><br><span class=\"line\">    res = [-<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> l <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"built_in\">sum</span> += vvv[l][j]</span><br><span class=\"line\">        res.append(<span class=\"built_in\">sum</span>)</span><br><span class=\"line\">    v[i] = res</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_sigma</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    add_1 = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        add_1 += ssigma[j] * A[i][j]</span><br><span class=\"line\">    add_2 = x[i] / v[i][i]</span><br><span class=\"line\">    add_3 = xx[i] / vv[i][i]</span><br><span class=\"line\">    sigma[i] = add_1 + add_2 - add_3</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">init</span>():</span><br><span class=\"line\">    <span class=\"keyword\">global</span> x, alpha, v, sigma, xx, xxx, vv, ssigma</span><br><span class=\"line\">    x = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        x[i] = (x_min[i] + x_max[i]) / <span class=\"number\">2</span></span><br><span class=\"line\">    alpha = <span class=\"number\">2</span></span><br><span class=\"line\">    v = [</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">        [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>],</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    sigma = [-<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        sigma.append(x[i])</span><br><span class=\"line\">    xx = copy.deepcopy(x)</span><br><span class=\"line\">    xxx = copy.deepcopy(x)</span><br><span class=\"line\">    vv = copy.deepcopy(v)</span><br><span class=\"line\">    ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">algorithm_1</span>(<span class=\"params\">iter_num, vec</span>):</span><br><span class=\"line\">    <span class=\"keyword\">global</span> xx, xxx, vv, ssigma, alpha</span><br><span class=\"line\">    init()</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    sum_1 = <span class=\"number\">0</span></span><br><span class=\"line\">    sum_2 = <span class=\"number\">0</span></span><br><span class=\"line\">    q = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 计算差距值</span></span><br><span class=\"line\">        <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"built_in\">sum</span> += (x[i] - x_best[i]) ** <span class=\"number\">2</span></span><br><span class=\"line\">        res.append(<span class=\"built_in\">sum</span> ** <span class=\"number\">0.5</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 计算qt的分子（这里的alpha注意步长设置为1/sqrt(j)）</span></span><br><span class=\"line\">        sum_1 += (<span class=\"number\">1</span> / j ** <span class=\"number\">0.5</span>) * <span class=\"built_in\">sum</span></span><br><span class=\"line\">        sum_2 += (<span class=\"number\">1</span> / j ** <span class=\"number\">0.5</span>)</span><br><span class=\"line\">        q.append(sum_1 / sum_2)</span><br><span class=\"line\">        <span class=\"comment\"># Algorithm 1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            upd_x(i, vec)</span><br><span class=\"line\">            upd_v(i)</span><br><span class=\"line\">            upd_sigma(i)</span><br><span class=\"line\">        xxx = copy.deepcopy(xx)</span><br><span class=\"line\">        xx = copy.deepcopy(x)</span><br><span class=\"line\">        vv = copy.deepcopy(v)</span><br><span class=\"line\">        ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\">        alpha = <span class=\"number\">1</span> / (j + <span class=\"number\">1</span>) ** <span class=\"number\">0.6</span> + <span class=\"number\">1</span> / (j + <span class=\"number\">1</span>) ** <span class=\"number\">1.2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res, q</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\">%matplotlib inline</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot_results</span>(<span class=\"params\">iter_num, vecs, vecs_name</span>):</span><br><span class=\"line\">    x = []</span><br><span class=\"line\">    y = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, iter_num):</span><br><span class=\"line\">        x.append(i)</span><br><span class=\"line\">        y.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> T <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(vecs)):</span><br><span class=\"line\">        y = algorithm_1(iter_num, vecs[T])[<span class=\"number\">0</span>]</span><br><span class=\"line\">        plt.plot(x, y, label=vecs_name[T])</span><br><span class=\"line\">        plt.xlabel(<span class=\"string\">&#x27;Iterations k&#x27;</span>)</span><br><span class=\"line\">        plt.ylabel(<span class=\"string\">&#x27;||xk - x*||&#x27;</span>)</span><br><span class=\"line\">        plt.legend()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(vecs_name[T], end=<span class=\"string\">&#x27;: &#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;%.2f&#x27;</span>%y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">vecs = [<span class=\"number\">0.0</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.8</span>]</span><br><span class=\"line\">vecs_name = [<span class=\"string\">&#x27;vec=0.0&#x27;</span>, <span class=\"string\">&#x27;vec=0.2&#x27;</span>, <span class=\"string\">&#x27;vec=0.4&#x27;</span>, <span class=\"string\">&#x27;vec=0.6&#x27;</span>, <span class=\"string\">&#x27;vec=0.8&#x27;</span>]</span><br><span class=\"line\">plot_results(<span class=\"number\">1000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">2000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">3000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">4000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">5000</span>, vecs, vecs_name)</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot_results_convergence_1</span>(<span class=\"params\">iter_num</span>):</span><br><span class=\"line\">    x = []</span><br><span class=\"line\">    y = []</span><br><span class=\"line\">    z = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>, iter_num + <span class=\"number\">1</span> + <span class=\"number\">1</span>): <span class=\"comment\"># 第一项ct是0，所以从第二项开始</span></span><br><span class=\"line\">        x.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num + <span class=\"number\">1</span>):</span><br><span class=\"line\">        z.append(math.log(i) / (i ** <span class=\"number\">0.5</span>))</span><br><span class=\"line\">    y = algorithm_1(iter_num, <span class=\"number\">0.6</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># qt的图像</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.plot(x, y)</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        经过调整参数为(x_min + x_max) / 2, 初始差距值已经比论文还低一些</span></span><br><span class=\"line\"><span class=\"string\">        但是qt始终无法收敛到0, 这是为什么呢?</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        当迭代次数很大时, 分子中的差距值已经很小, 所以导致分子比分母小许多, 所以假设论文中的迭代次数是8w次, 我比它多10倍,</span></span><br><span class=\"line\"><span class=\"string\">        比它多那么多后, 即使我刚开始迭代时的分子很大, 分子也会被后面10倍迭代次数的分母追上来。</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 这是用来画qt / ct的图像</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num):</span><br><span class=\"line\">        y[i] = y[i] / z[i]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.plot(x[<span class=\"number\">1</span>:], y[<span class=\"number\">1</span>:])</span><br><span class=\"line\">    plt.xlabel(<span class=\"string\">&#x27;t&#x27;</span>)</span><br><span class=\"line\">    plt.ylabel(<span class=\"string\">&#x27;qt / ct&#x27;</span>)</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">plot_results_convergence_1(<span class=\"number\">80000</span>)</span><br></pre></td></tr></table></figure>\r\n<p>效果图如下：（最后一张图，第一行数字是qt的收敛值，第二行数字是qt/ct的收敛值）</p>\r\n<p><img src=\"27.png\" /></p>\r\n<p><strong>Algorithm 2的数值仿真</strong></p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># Algorithm 2的数值仿真</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> copy</span><br><span class=\"line\"></span><br><span class=\"line\">n = <span class=\"number\">8</span></span><br><span class=\"line\">x_best = [-<span class=\"number\">1</span>, <span class=\"number\">17.68591179305579</span>, <span class=\"number\">17.68591178894396</span>, <span class=\"number\">15.568177079669734</span>, <span class=\"number\">15.568176869116588</span>,</span><br><span class=\"line\">            <span class=\"number\">12.54841009221712</span>, <span class=\"number\">12.548433755340588</span>, <span class=\"number\">16.50869895275612</span>, <span class=\"number\">16.348072510972873</span>]</span><br><span class=\"line\">x_min = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">x_max = [-<span class=\"number\">1</span>, <span class=\"number\">27.5</span>, <span class=\"number\">27.5</span>, <span class=\"number\">34.2</span>, <span class=\"number\">34.2</span>, <span class=\"number\">40.6</span>, <span class=\"number\">40.6</span>, <span class=\"number\">28.8</span>, <span class=\"number\">35.7</span>]</span><br><span class=\"line\">x = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">    x[i] = (x_min[i] + x_max[i]) / <span class=\"number\">2</span></span><br><span class=\"line\">p_0 = <span class=\"number\">5.6</span></span><br><span class=\"line\">a = <span class=\"number\">0.004</span></span><br><span class=\"line\">b = <span class=\"number\">0.1</span></span><br><span class=\"line\">k = [-<span class=\"number\">1</span>, <span class=\"number\">4.6</span>, <span class=\"number\">4.6</span>, <span class=\"number\">3.7</span>, <span class=\"number\">3.7</span>, <span class=\"number\">3.4</span>, <span class=\"number\">3.4</span>, <span class=\"number\">4.0</span>, <span class=\"number\">3.9</span>]</span><br><span class=\"line\">d = [-<span class=\"number\">1</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.8</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.7</span>, <span class=\"number\">0.8</span>]</span><br><span class=\"line\">alpha = <span class=\"number\">2</span></span><br><span class=\"line\">A_1 = [</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>],</span><br><span class=\"line\">]</span><br><span class=\"line\">A_2 = [</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>, -<span class=\"number\">1</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>],</span><br><span class=\"line\">    [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span> / <span class=\"number\">2</span>],</span><br><span class=\"line\">]</span><br><span class=\"line\">A = copy.deepcopy(A_1)</span><br><span class=\"line\">sigma = [-<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">    sigma.append(x[i])</span><br><span class=\"line\">w = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">y = [-<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">z = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">xx = copy.deepcopy(x)</span><br><span class=\"line\">xxx = copy.deepcopy(x)</span><br><span class=\"line\">ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\">yy = copy.deepcopy(y)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">init</span>():</span><br><span class=\"line\">    <span class=\"keyword\">global</span> x, alpha, sigma, w, y, z, xx, xxx, ssigma, yy</span><br><span class=\"line\">    x = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        x[i] = (x_min[i] + x_max[i]) / <span class=\"number\">2</span></span><br><span class=\"line\">    alpha = <span class=\"number\">2</span></span><br><span class=\"line\">    sigma = [-<span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        sigma.append(x[i])</span><br><span class=\"line\">    w = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\">    y = [-<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">    z = [-<span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    xx = copy.deepcopy(x)</span><br><span class=\"line\">    xxx = copy.deepcopy(x)</span><br><span class=\"line\">    ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\">    yy = copy.deepcopy(y)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#----------------------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_w</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"built_in\">sum</span> += A[i][j] * ssigma[j]</span><br><span class=\"line\">    w[i] = <span class=\"built_in\">sum</span>    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_y</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"built_in\">sum</span> += A[i][j] * yy[j]</span><br><span class=\"line\">    y[i] = <span class=\"built_in\">sum</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_z</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    z[i] = w[i] / y[i]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">G</span>(<span class=\"params\">i, x, sigma</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * (sigma + x) + b  - <span class=\"number\">2</span> * p_0 * k[i] / x_max[i] * (<span class=\"number\">1</span> - x / x_max[i])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_x</span>(<span class=\"params\">i, vec</span>):</span><br><span class=\"line\">    x[i] = xx[i] - alpha * G(i, xx[i], n * z[i]) + vec * (xx[i] - xxx[i])</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x[i] &lt; x_min[i]: x[i] = x_min[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x[i] &gt; x_max[i]: x[i] = x_max[i]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upd_sigma</span>(<span class=\"params\">i</span>):</span><br><span class=\"line\">    sigma[i] = w[i] + x[i] - xx[i]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">algorithm_2</span>(<span class=\"params\">iter_num, vec</span>):</span><br><span class=\"line\">    <span class=\"keyword\">global</span> A, A_1, A_2, w, ssigma, y, yy, z, x, xx, alpha, xxx, sigma</span><br><span class=\"line\">    init()</span><br><span class=\"line\">    res = []</span><br><span class=\"line\">    sum_1 = <span class=\"number\">0</span></span><br><span class=\"line\">    sum_2 = <span class=\"number\">0</span></span><br><span class=\"line\">    q = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num + <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 计算差距</span></span><br><span class=\"line\">        <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"built_in\">sum</span> += (x[i] - x_best[i]) ** <span class=\"number\">2</span></span><br><span class=\"line\">        <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span> ** (<span class=\"number\">0.5</span>)</span><br><span class=\"line\">        res.append(<span class=\"built_in\">sum</span>)</span><br><span class=\"line\">        <span class=\"comment\"># 计算qt的分子（这里的alpha注意步长设置为1/sqrt(j)）</span></span><br><span class=\"line\">        sum_1 += (<span class=\"number\">1</span> / j ** <span class=\"number\">0.5</span>) * <span class=\"built_in\">sum</span> * <span class=\"built_in\">sum</span></span><br><span class=\"line\">        sum_2 += (<span class=\"number\">1</span> / j ** <span class=\"number\">0.5</span>)</span><br><span class=\"line\">        q.append(sum_1 / sum_2)</span><br><span class=\"line\">        <span class=\"comment\"># 选择矩阵</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> j % <span class=\"number\">2</span>: A = copy.deepcopy(A_1)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>: A = copy.deepcopy(A_2)</span><br><span class=\"line\">        <span class=\"comment\"># Algorithm 2</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, n + <span class=\"number\">1</span>):</span><br><span class=\"line\">            upd_w(i)</span><br><span class=\"line\">            upd_y(i)</span><br><span class=\"line\">            upd_z(i)</span><br><span class=\"line\">            upd_x(i, vec)</span><br><span class=\"line\">            upd_sigma(i)</span><br><span class=\"line\">        <span class=\"comment\"># 更新状态</span></span><br><span class=\"line\">        xxx = copy.deepcopy(xx)</span><br><span class=\"line\">        xx = copy.deepcopy(x)</span><br><span class=\"line\">        yy = copy.deepcopy(y)</span><br><span class=\"line\">        ssigma = copy.deepcopy(sigma)</span><br><span class=\"line\">        alpha = <span class=\"number\">1</span> / (j + <span class=\"number\">1</span>) ** <span class=\"number\">0.6</span> + <span class=\"number\">1</span> / (j + <span class=\"number\">1</span>) ** <span class=\"number\">1.2</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> res, q</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\">%matplotlib inline</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot_results</span>(<span class=\"params\">iter_num, vecs, vecs_name</span>):</span><br><span class=\"line\">    x = []</span><br><span class=\"line\">    y = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, iter_num):</span><br><span class=\"line\">        x.append(i)</span><br><span class=\"line\">        y.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> T <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(vecs)):</span><br><span class=\"line\">        y = algorithm_2(iter_num, vecs[T])[<span class=\"number\">0</span>]</span><br><span class=\"line\">        plt.plot(x, y, label=vecs_name[T])</span><br><span class=\"line\">        plt.xlabel(<span class=\"string\">&#x27;Iterations k&#x27;</span>)</span><br><span class=\"line\">        plt.ylabel(<span class=\"string\">&#x27;||xk - x*||&#x27;</span>)</span><br><span class=\"line\">        plt.legend()</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(vecs_name[T], end=<span class=\"string\">&#x27;: &#x27;</span>)</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;%.2f&#x27;</span>%y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">vecs = [<span class=\"number\">0.0</span>, <span class=\"number\">0.2</span>, <span class=\"number\">0.4</span>, <span class=\"number\">0.6</span>, <span class=\"number\">0.8</span>]</span><br><span class=\"line\">vecs_name = [<span class=\"string\">&#x27;vec=0.0&#x27;</span>, <span class=\"string\">&#x27;vec=0.2&#x27;</span>, <span class=\"string\">&#x27;vec=0.4&#x27;</span>, <span class=\"string\">&#x27;vec=0.6&#x27;</span>, <span class=\"string\">&#x27;vec=0.8&#x27;</span>]</span><br><span class=\"line\">plot_results(<span class=\"number\">1000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">2000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">3000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">4000</span>, vecs, vecs_name)</span><br><span class=\"line\">plot_results(<span class=\"number\">5000</span>, vecs, vecs_name)</span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot_results_convergence_2</span>(<span class=\"params\">iter_num</span>):</span><br><span class=\"line\">    x = []</span><br><span class=\"line\">    y = []</span><br><span class=\"line\">    z = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">2</span>, iter_num + <span class=\"number\">1</span> + <span class=\"number\">1</span>): <span class=\"comment\"># 第一项ct是0，所以从第二项开始</span></span><br><span class=\"line\">        x.append(i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num + <span class=\"number\">1</span>):</span><br><span class=\"line\">        z.append(math.log(i) / (i ** <span class=\"number\">0.5</span>))</span><br><span class=\"line\">    y = algorithm_2(iter_num, <span class=\"number\">0.6</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># qt的图像</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.plot(x, y)</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        经过调整参数为(x_min + x_max) / 2, 初始差距值已经比论文还低一些</span></span><br><span class=\"line\"><span class=\"string\">        但是qt始终无法收敛到0, 这是为什么呢?</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">        当迭代次数很大时, 分子中的差距值已经很小, 所以导致分子比分母小许多, 所以假设论文中的迭代次数是8w次, 我比它多10倍,</span></span><br><span class=\"line\"><span class=\"string\">        比它多那么多后, 即使我刚开始迭代时的分子很大, 分子也会被后面10倍迭代次数的分母追上来。</span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 这是用来画qt / ct的图像</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, iter_num):</span><br><span class=\"line\">        y[i] = y[i] / z[i]</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(y[iter_num - <span class=\"number\">1</span>])</span><br><span class=\"line\">    plt.plot(x[<span class=\"number\">1</span>:], y[<span class=\"number\">1</span>:])</span><br><span class=\"line\">    plt.xlabel(<span class=\"string\">&#x27;t&#x27;</span>)</span><br><span class=\"line\">    plt.ylabel(<span class=\"string\">&#x27;qt / ct&#x27;</span>)</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">plot_results_convergence_2(<span class=\"number\">80000</span>)</span><br></pre></td></tr></table></figure>\r\n<p>效果图如下：（最后一张图，第一行数字是qt的收敛值，第二行数字是qt/ct的收敛值）</p>\r\n<p><img src=\"28.png\" /></p>\r\n<hr />\r\n<p>这篇blog发表于2023.10.16，现在是2023.12.4，看了2个月，目前算是告一段落了。</p>\r\n<p>分布式领域读的第一篇论文，挺有趣的，算是跨过了一道入门槛。</p>\r\n<p>接下来阅读论文的速度就要加快了。同时要去原理上去思考为什么这样做以及还可以怎样去优化。</p>\r\n<p>假如您正在阅读这篇blog，如发现错误，恳请在评论区中指出。</p>\r\n","categories":["1. 论文"]},{"title":"Linux基础","url":"/2023/10/14/Linux%E5%9F%BA%E7%A1%80/","content":"<ul>\r\n<li>这篇文章涉及到的都是本人用到的知识，没用到的我都没写。</li>\r\n<li>学会这些算是一个计算机学生的基本素养吧。</li>\r\n</ul>\r\n<span id=\"more\"></span>\r\n<ul>\r\n<li>比如以后进厂打工可嫩会接触到Linux环境，那么<strong>tmux、nano、Linux常用命令</strong>，总得会吧。</li>\r\n<li>然后工作或者租算力服务器或者连学校服务器，可能会用到<strong>SSH</strong>吧，所以ssh也总得会吧。</li>\r\n<li>然后因为自己平时也可能会写工程，所以<strong>Git、类github软件</strong>总得会用吧。</li>\r\n<li>然后可能偶尔在Linux或者Win下写点脚本来批处理文件，所以<strong>shell语法</strong>也得会一点吧。</li>\r\n<li>最后是docker，到时候别人传一个docker给你，你都不会配环境，这说不过去，所以<strong>docker</strong>也得会用吧。</li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"tmux\">tmux</h3>\r\n<p>学这个是为了可以在一个终端里开多个屏来工作，提高生产效率。</p>\r\n<ul>\r\n<li>tmux ls：显示所有session列表</li>\r\n<li>tmux attach -t [id]：进入到某个session中</li>\r\n<li>tmux：新建一个session并进入</li>\r\n<li>ctrl + b, s：显示session、window、pane树形结构</li>\r\n<li>ctrl + d：删除当前pane/window/session</li>\r\n<li>ctrl + b, d：在不删除session的前提下退出tmux</li>\r\n<li>ctrl + b, %：左右分屏</li>\r\n<li>ctrl + b, \"：上下分屏</li>\r\n<li>ctrl + b, ↑←↓→：在pane中切换</li>\r\n<li>ctrl + b不松开 + ↑←↓→：调整当前pane大小</li>\r\n<li>ctrl +\r\nb，[：进入复制模式，在此模式下按上下左右可控制光标移动。按q退出该模式</li>\r\n</ul>\r\n<h3 id=\"nanovim\">nano/vim</h3>\r\n<p>学这个是为了在Linux系统下处理文本。本质上就是学如何用记事本。</p>\r\n<p>关于vim我能不用尽量不用，但是迫不得已的时候使用的时候还是要会它的基本操作。按Esc回到命令模式，命令模式下dd删除本行，:wq保存退出，:q!强制退出，i进入编辑模式。下面是关于nano的操作</p>\r\n<p>另外，在/etc/nanorc里可以配置nano</p>\r\n<ul>\r\n<li>ctrl + x：退出</li>\r\n<li>ctrl + o：保存</li>\r\n<li>ctrl + k：剪切</li>\r\n<li>ctrl + u：粘贴</li>\r\n<li>alt +6：复制</li>\r\n<li>alt + u：撤销</li>\r\n<li>alt +\r\na：开启选中模式（注意这个快捷键与微信截图冲突了，记得把vx的改了）</li>\r\n<li>alt + m：开始鼠标模式</li>\r\n<li>alt + shift + 3：开启行号</li>\r\n<li>ctrl + a：回到行首；ctrl + e：回到行末；alt + /：跳转到文末；alt +\r\n：跳转到开头</li>\r\n<li>ctrl + shift + v：将windows文本复制到nano/vim/shell里</li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"linux常用命令\">Linux常用命令</h3>\r\n<h4 id=\"系统状况\">系统状况</h4>\r\n<ul>\r\n<li>top：查看所有进程的信息\r\n<ul>\r\n<li>输入M：按使用内存排序</li>\r\n<li>输入P：按使用CPU排序</li>\r\n<li>输入q：退出</li>\r\n</ul></li>\r\n<li>df -h：查看硬盘使用情况</li>\r\n<li>free -h：查看内存使用情况</li>\r\n<li>du -sh：查看当前目录所占硬盘空间\r\n<ul>\r\n<li>du -sh 文件名：查看当前目录下某文件所占硬盘空间</li>\r\n</ul></li>\r\n<li>ps aux：查看所有进程</li>\r\n<li>kill -9 pid：杀死编号为pid的进程</li>\r\n<li>ping www.baidu.com：检查是否联网</li>\r\n</ul>\r\n<h4 id=\"文件检索\">文件检索</h4>\r\n<ul>\r\n<li>find path -name \"filename\"：在某个路径下搜索目标文件</li>\r\n<li>grep\r\nxxx：从stdin中读入若干行参数，如果某行包括xxx，则输出该行，否则忽略该行</li>\r\n<li>xargs：从stdin接受数据，并以空格分割形式转换为命令行参数\r\n<ul>\r\n<li>例如，find . -name \"*.cpp\" | xargs\r\ncat，读取当前目录下所有.cpp文件的内容</li>\r\n<li>find . -name \"*.cp\" | xargs cat | grep\r\n\"cout\"：找出当前目录下的.cpp文件中所有包含cout的行</li>\r\n</ul></li>\r\n<li>wc -l filename：统计文件的行数\r\n<ul>\r\n<li>wc既可以接收文件名参数，也可以从stdin读入内容</li>\r\n<li>find . -name \"*.cpp\" | wc -l：统计当前目录下有多少个.cpp文件</li>\r\n<li>find . -name \"*.cpp\" | xargs wc\r\n-l：统计当前目录下每个.cpp文件有多少行</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"工具\">工具</h4>\r\n<ul>\r\n<li>|：管道符\r\n<ul>\r\n<li>将前一个command的<strong>stdout</strong>重定向到后一个command的<strong>stdin</strong></li>\r\n<li>在文件检索中经常用到</li>\r\n</ul></li>\r\n<li>history：展示历史操作\r\n<ul>\r\n<li>history 数字：展示最后num条操作</li>\r\n</ul></li>\r\n<li>tar -zcvf xxx.tar.gz 文件1 文件2：压缩</li>\r\n<li>tar -zxvf xxx.tar.gz：解压</li>\r\n<li>diff xxx yyy：比较xxx与yyy的不同点</li>\r\n<li>sudo apt update：更新可用软件包列表</li>\r\n<li>sudo apt install 包名：安装</li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"ssh\">ssh</h3>\r\n<p>这个ssh以后自己租服务器的时候用得上。就是学会如何登录，以及主机和服务器之间如何传文件即可。</p>\r\n<ul>\r\n<li><p>ssh user@hostname：登录</p></li>\r\n<li><p>在~/.ssh/config里写配置文件，格式如下</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Host name1</span><br><span class=\"line\">\tHostName IP地址</span><br><span class=\"line\">\tUser 用户名</span><br></pre></td></tr></table></figure>\r\n<p>那么在下次使用服务器时，就可以ssh name1来登录</p></li>\r\n<li><p>ssh-keygen：创建密钥（密钥文件存储在~/.ssh/下）</p></li>\r\n<li><p>ssh-copy-id\r\n服务器别名：向服务器添加自己的公钥，这样以后登录服务器可以免密登录</p></li>\r\n<li><p>scp source destinatino：跟cp一样，本机与服务器传文件</p>\r\n<ul>\r\n<li>例如scp /etc/nanorc 服务器别名:/etc/nanorc</li>\r\n<li>注意在传文件夹时要加-r，而且-r必须紧跟在scp后</li>\r\n</ul></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"git\">git</h3>\r\n<ul>\r\n<li>git config --global user.name xxx：设置全局用户名</li>\r\n<li>git config --global user.email xxx@xxx.com：设置全局邮箱地址</li>\r\n<li>上述信息都会记录在~/.gitconfig文件中</li>\r\n<li>git init：将当前目录配置成git仓库，信息记录在.git文件夹中</li>\r\n<li>git status：查看仓库状态</li>\r\n<li>git add xx：将xx文件添加到暂存区\r\n<ul>\r\n<li>git add .：将全部改动添加到暂存区</li>\r\n</ul></li>\r\n<li>git rm --cached xx：将xx改动从暂存区中移出</li>\r\n<li>git commit -m \"备注信息\"：将暂存区中的内容提交到当前分支</li>\r\n<li>git log：查看当前分支从根到HEAD指针的所有版本\r\n<ul>\r\n<li>git log --oneline：简洁显示</li>\r\n</ul></li>\r\n<li>git relog：查看HEAD指针的移动历史</li>\r\n<li>git reset --hard HEAD~：回滚到上一个版本\r\n<ul>\r\n<li>git reset --hard HEAD~~：回滚到上两个版本</li>\r\n<li>git reset --hard 版本号(7位hash值)：回滚到目标版本</li>\r\n</ul></li>\r\n<li>git remote add origin\r\ngit@git.acwing.com:Error666/test.git：将本地仓库与acgit绑定</li>\r\n<li>git push -u origin master：将本地仓库推送到acgit上\r\n<ul>\r\n<li>第一次需要向上面这么写，至于用master还是main，用git\r\nbranch查看本地分支。是什么就用什么。以后推送直接git push即可</li>\r\n</ul></li>\r\n<li>更多有关git的命令：<a\r\nhref=\"https://www.acwing.com/file_system/file/content/whole/index/content/2932078/\">传送门</a></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"shell\">shell</h3>\r\n<p>shell语言主要学来用来批处理文件的，比如建立多个文件夹，改名多个文件夹啥的。学完后在window里也用得上。比如打竞赛出题的数据的时候，就可以用shell写个脚本统一创建文件/改名。在windows里用git的git\r\nbash运行脚本即可。</p>\r\n<h4 id=\"基本\">基本</h4>\r\n<ul>\r\n<li>su - root/zhou：换用户</li>\r\n<li>mkdir/touch/cp/mv/rm/cat：基本操作</li>\r\n<li>chmod +x+x+x\r\n[filename]：给权限（3个x对应user,group,others，如果只给user写1个x即可）\r\n<ul>\r\n<li>chmod +x dirname -R：递归的给权限</li>\r\n</ul></li>\r\n<li>.sh为shell脚本后缀，在文件里第一行应为#!\r\n/bin/bash。执行方式有两种，bash filename.sh或者./filename.sh</li>\r\n<li>echo：输出\r\n<ul>\r\n<li>加参数-e：可在输出内容中识别转移字符，例如echo -e \"hello\"。</li>\r\n<li>加参数echo默认会输出换行，在结尾处加（要加-e）</li>\r\n<li>echo ${a[@]}：输出数组中的数，以一行形式</li>\r\n<li>echo ${a[@]:1:n}：输出数组下标为1 ~ n的数</li>\r\n</ul></li>\r\n<li>“”：可将有空格的名字看作一个整体</li>\r\n</ul>\r\n<h4 id=\"变量\">变量</h4>\r\n<ul>\r\n<li>变量=xxx：定义变量</li>\r\n<li>${变量}：使用变量</li>\r\n<li>$0, $1, $2, ...：为传入的参数（$0为文件名）</li>\r\n<li>$#：传入的参数个数</li>\r\n<li>$?：返回上一条command的exit code</li>\r\n<li>`command`：返回command的stdout（不支持嵌套）</li>\r\n<li>$(command)：作用同``，但是支持嵌套</li>\r\n</ul>\r\n<h4 id=\"运算\">运算</h4>\r\n<ul>\r\n<li>expr $a +/- $b：进行a±b的运算</li>\r\n<li>expr $a \\* $b：进行a*b的运算</li>\r\n<li>expr $a / $b：进行a/b的运算</li>\r\n<li>expr $a % $b：进行a%b的运算</li>\r\n<li>()可以改变优先级，但要加\\转义，同时记得打括号</li>\r\n</ul>\r\n<h4 id=\"循环\">循环</h4>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span>法一</span></span><br><span class=\"line\">for var in val1 val2 val3</span><br><span class=\"line\">do</span><br><span class=\"line\">  ....</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span>法二</span></span><br><span class=\"line\">for var in `seq 1 10`</span><br><span class=\"line\">do</span><br><span class=\"line\">  ...</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span>法三</span></span><br><span class=\"line\">for var in &#123;1..10&#125;/&#123;10..1&#125;/&#123;a..z&#125;/&#123;z..a&#125;\t# 这种写法&#123;&#125;里面只能是常量</span><br><span class=\"line\">do</span><br><span class=\"line\">  ...</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">for</span>法四（跟C++一样，只不过多了层括号）</span></span><br><span class=\"line\">for ((expreesion; condition; expression))</span><br><span class=\"line\">do</span><br><span class=\"line\">  ...</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">while</span></span></span><br><span class=\"line\">while condition</span><br><span class=\"line\">do</span><br><span class=\"line\">  ...</span><br><span class=\"line\">done</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"built_in\">break</span>/continue</span></span><br><span class=\"line\">跟C++一样</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"判断\">判断</h4>\r\n<ul>\r\n<li>shell里的if看的是exit code的状态。如果exit\r\ncode为0，则为真。否则为假</li>\r\n</ul>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\"><span class=\"keyword\">if</span></span></span><br><span class=\"line\">if condition</span><br><span class=\"line\">then</span><br><span class=\"line\">  ...</span><br><span class=\"line\">fi</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">if-else</span></span><br><span class=\"line\">if condition</span><br><span class=\"line\">then</span><br><span class=\"line\">  ...</span><br><span class=\"line\">else</span><br><span class=\"line\">  ...</span><br><span class=\"line\">fi</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">if-elif-else</span></span><br><span class=\"line\">if condition</span><br><span class=\"line\">then</span><br><span class=\"line\">  ...</span><br><span class=\"line\">elif</span><br><span class=\"line\">then</span><br><span class=\"line\">  ...</span><br><span class=\"line\">else</span><br><span class=\"line\">  ...</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\r\n<h4 id=\"test\">test/[ ]</h4>\r\n<ul>\r\n<li>[ $a -[参数] $b ]：整数a与b的比较\r\n<ul>\r\n<li>-eq：是否相等（equal）</li>\r\n<li>-ne：是否不相等（not equal）</li>\r\n<li>-gt：是否大于（greater than）</li>\r\n<li>-ge：是否大于等于（greater than or equal）</li>\r\n<li>-lt：是否小于（less than）</li>\r\n<li>-le：是否小于等于（less than or equal）</li>\r\n</ul></li>\r\n<li>[ -[参数] filename ]：文件类型判断\r\n<ul>\r\n<li>-e：文件是否存在</li>\r\n<li>-f：是否为文件</li>\r\n<li>-d：是否为目录</li>\r\n</ul></li>\r\n<li>[ -[参数] filename ]：文件权限判断\r\n<ul>\r\n<li>-r：是否可读</li>\r\n<li>-w：是否可写</li>\r\n<li>-x：是否可执行</li>\r\n<li>-s：是否为非空文件</li>\r\n</ul></li>\r\n<li>可用&amp;&amp;、||、!拼接</li>\r\n</ul>\r\n<h4 id=\"函数\">函数</h4>\r\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">fun_name() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>调用方式：fun_name val1 val2 val3</li>\r\n<li>函数内部默认参数从1开始，没有0，即$1</li>\r\n<li>在函数里面return的是exit code。echo的是stdout</li>\r\n<li>不管在函数还是函数外部直接使用的变量默认都是全局变量，所以若想使用局部变量，需要用local关键字声明</li>\r\n</ul>\r\n<h4 id=\"文件重定向\">文件重定向</h4>\r\n<ul>\r\n<li>&gt;：将原本输出到stdout的内容以覆盖形式输出到指定文件</li>\r\n<li>&lt;：原本从stdin读入数据，现在从指定文件中读入数据</li>\r\n<li>&gt;&gt;：将原本输出到stdout的内容以追加形式输出到指定文件</li>\r\n</ul>\r\n<h4 id=\"其它\">其它</h4>\r\n<ul>\r\n<li>导入外部脚本：source\r\nfilename（本质就是将外部脚本粘贴复制到本脚本中）</li>\r\n<li>更多shell语法：<a\r\nhref=\"https://www.acwing.com/file_system/file/content/whole/index/content/2855883/\">传送门</a></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"配docker环境-docker使用\">配docker环境 &amp; docker使用</h3>\r\n<p>首先要安装docker，搜docker ubuntu，进官网，按照官网指示装就行了。</p>\r\n<p>然后如果在用docker命令时发现每次都要加sudo权限，可以将当前用户加入到docker用户组中：sudo\r\nusermod -aG docker $USER。然后退出服务器，重进，即可解决这个问题</p>\r\n<p>记住，docker中区分image可以用id或者名字（image名字是name:版本号）。区分container可以用id或者name。</p>\r\n<h4 id=\"镜像\">镜像</h4>\r\n<ul>\r\n<li>docker pull 名称：拉取一个镜像</li>\r\n<li>docker images：列出本地所有镜像</li>\r\n<li>docker rmi id/名字：删除某个镜像</li>\r\n<li>docker save -o xxx.tar id/名字：把某个镜像导出</li>\r\n<li>docker load -i xxx.tar：导入某个镜像</li>\r\n</ul>\r\n<h4 id=\"容器\">容器</h4>\r\n<ul>\r\n<li>docker ps -a：查看本地的所有容器</li>\r\n<li>docker create -it 镜像id/名字：利用某镜像创建一个容器</li>\r\n<li>docker rm id/name：删除某容器</li>\r\n<li>docker rename name1 name2：重命名容器</li>\r\n<li>docker start id/name：启动某容器</li>\r\n<li>docker stop id/name：停止某容器</li>\r\n<li>docker attach id/name：进入某容器\r\n<ul>\r\n<li>ctrl + d：退出并停止该容器</li>\r\n<li>ctrl + p, ctrl + q：退出该容器但不停止它</li>\r\n</ul></li>\r\n</ul>\r\n","categories":["2. 技能栈","Linux"]},{"title":"SAI2的基本使用","url":"/2024/02/22/SAI2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"<p>SAI2的最最最基本使用（我不玩板绘）</p>\r\n<span id=\"more\"></span>\r\n<p>因为最近接了一个线上一对一的算法家教，所以买了一块数位板（高漫1060pro）方便授课，然后下了个SAI2。</p>\r\n<p>首先改板子的映射区，这个型号的板子对我来说太大了，手移动距离太多很累。所以把板子工作区域改小。</p>\r\n<p>然后是改板子的快捷键，我板子的快捷键从上到下分别是：（对应着SAI2里的功能）</p>\r\n<ul>\r\n<li>选中、剪切</li>\r\n<li>复制、粘贴</li>\r\n<li>画笔、橡皮</li>\r\n<li>ctrl、shift</li>\r\n<li>文字、ESC</li>\r\n<li>合并图层、画面居中</li>\r\n</ul>\r\n<p>所以设置好快捷键后，基本上只需要打开SAI2，然后在板子上操作就好了。不怎么需要去SAI2里操作了。</p>\r\n<hr />\r\n<p>说一下SAI2的操作逻辑，首先是文字，每次输入文字SAI2都会新建一个图层，所以在输入完文字后要按ESC\r\n+ 合并图层，才能将文字和原本内容合并到同一图层中。</p>\r\n<p>然后是粘贴，在你选中、复制、粘贴后，粘贴的内容会新开一个图层。所以需要按住ctrl移动到恰当位置后，按下合并图层，才能实现粘贴的内容和原内容在同一图层中。</p>\r\n<hr />\r\n<p>最后是操作时遇到的一些问题：</p>\r\n<ol type=\"1\">\r\n<li>为什么切换到画笔后，写不出东西？\r\n<ul>\r\n<li>可能是因为你选中了某个区域，没有取消就切换到画笔模式了。所以可以先按剪切后，再切换到画笔模式即可正常工作。</li>\r\n</ul></li>\r\n</ol>\r\n","categories":["杂项"]},{"title":"VS Code基本使用","url":"/2024/02/23/VS-Code%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","content":"<p>VS Code作为最常用的IDE，掌握其使用方法以及相关插件十分必要。</p>\r\n<p>而且这玩意还可以通过Github同步配置，所以配置一次，永久享用。</p>\r\n<p>而且VS Code里有终端，于是写项目配合git使用很方便。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"快捷键\">快捷键</h3>\r\n<ul>\r\n<li>ctrl + ,：设置</li>\r\n<li>ctrl + shift + p：命令面板</li>\r\n<li>ctrl + p：最近文件列表</li>\r\n<li>ctrl + j：切出下面板（用来在代码和终端输入间跳转）</li>\r\n</ul>\r\n<h3 id=\"插件\">插件</h3>\r\n<h4 id=\"code-runner\">code runner</h4>\r\n<ul>\r\n<li>ctrl + alt + n：编译运行程序</li>\r\n<li>ctrl + c：退出当前命令（死循环时退出运行）</li>\r\n</ul>\r\n<h4 id=\"wsl\">WSL</h4>\r\n<ul>\r\n<li>直接在本地vscode登入进wsl子系统中的vscode</li>\r\n<li>或者在wsl中输入code .进入vscode界面</li>\r\n</ul>\r\n<h4 id=\"git-graph\">Git Graph</h4>\r\n<ul>\r\n<li>装了之后，直接在vscode中就可以查看提交/分支状态</li>\r\n<li>可以查看每次commit的id/author/date/parents/与上一次commit的不同之处\r\n<ul>\r\n<li>查看与任意一次commit的不同之处：先点一个，再按住ctrl点另一个</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"todo-tree\">Todo Tree</h4>\r\n<ul>\r\n<li>TODO表示待办，FIXME表示写了一半还没写完，BUG表示这段程序有问题，HACK表示这段程序可以优化，NOTE表示想法</li>\r\n<li>这个插件除了方便写注释，还可以充当打标签的作用</li>\r\n</ul>\r\n<h4 id=\"jupyter\">Jupyter</h4>\r\n<ul>\r\n<li>无需安装jupyter notebook即可在vscode实现相同功能</li>\r\n<li>Esc + M：markdown模式</li>\r\n<li>Esc + Y：代码模式</li>\r\n<li>ctrl + enter：运行</li>\r\n<li>Esc + D, D：删除该单元</li>\r\n<li>Esc + B：在下方添加一个单元</li>\r\n<li>Esc + A：在上方添加一个单元</li>\r\n<li>Esc + L：显示行号</li>\r\n</ul>\r\n<h4 id=\"markdown-all-in-one-markdown-preview-enhanced\">Markdown All in\r\nOne &amp; Markdown Preview Enhanced</h4>\r\n<ul>\r\n<li>第一个插件就是markdown插件，第二个是增强功能插件</li>\r\n<li>第二个增强插件很强大，甚至可以渲染出matplotlib代码的图像。</li>\r\n<li>ctrl + k, v：打开预览面板</li>\r\n<li>``：行内代码</li>\r\n<li>- [x]：任务列表</li>\r\n<li>[^1]和[^1]: 配套使用 ：脚注</li>\r\n<li>==xxx==：高亮</li>\r\n<li>渲染plt代码图片：（只需将```python改为```python {cmd=true\r\nmatplotlib=true}）\r\n<ul>\r\n<li>这个功能只能在本地写markdo使用，hexo博客渲染不了</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"draw.io-integration\">Draw.io Integration</h4>\r\n<ul>\r\n<li>配合markdown使用，画流程图</li>\r\n</ul>\r\n<h4 id=\"markdown-table\">Markdown Table</h4>\r\n<ul>\r\n<li>配合markdown使用，快速生成表格</li>\r\n<li>选中一段文字，右键菜单中选择Markdown Table: Convert TSV to\r\ntable就能把这段文字变成表格。</li>\r\n<li>插入新的一行：当新行输入|，按tab补全</li>\r\n<li>在某列左/右插入新的一列：选中当前列，右键菜单插入即可</li>\r\n<li>当前列对齐方式：选中当前列，右键菜单选择即可</li>\r\n<li>交换相邻两列：选中当前列，右键菜单选择即可</li>\r\n</ul>\r\n","categories":["杂项"]},{"title":"个人博客搭建说明","url":"/2023/10/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%B4%E6%98%8E/","content":"<p>使用GitHub + Hexo搭建的本博客。</p>\r\n<p>教程参考<a\r\nhref=\"https://zhuanlan.zhihu.com/p/102592286\">从零开始搭建个人博客（超详细）\r\n- 知乎 (zhihu.com)</a>。</p>\r\n<p>上面这篇文章可以说是从0到1很详细的介绍了搭建个人博客的全流程，不过仍然有许多小错误，需要结合评论区和其它博文一起阅读才会避免踩坑。</p>\r\n<span id=\"more\"></span>\r\n<p>我大致总结一下流程：</p>\r\n<ol type=\"1\">\r\n<li>注册GitHub</li>\r\n<li>下载Git并将Git绑定到GitHub（使用token）</li>\r\n<li>购买域名</li>\r\n<li>安装node.js并配置环境变量（建议全程使用cmd管理员而不是git\r\nbash）</li>\r\n<li>安装hexo</li>\r\n<li>解析域名</li>\r\n<li>设置并美化主题</li>\r\n</ol>\r\n<p>另外，博客首页的头像是用的GitHub的头像链接，另外我不打算采用图床，因为怕翻车。所以文章里的全部图片都是存储在本地并push到GitHub中，若加载不出或速度慢可以尝试挂个梯子。</p>\r\n<p>域名第一年花了9块，之后续费好像是20多块一年。在阿里云买的。</p>\r\n<p>看板娘参考了两篇文章：<a\r\nhref=\"https://github.com/stevenjoezhang/live2d-widget\">设置看板娘</a>,\r\n<a\r\nhref=\"https://www.cnblogs.com/c10udlnk/p/14727173.html\">个性化配置看板娘</a>。</p>\r\n<p>但是live2d的模型默认的这几个我不是很熟悉，以后有空了想换成我自己喜欢的人物角色。</p>\r\n","categories":["杂项"]},{"title":"刷题笔记","url":"/2024/02/20/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","content":"<p>信息学竞赛刷题笔记</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"思维题\">思维题</h3>\r\n<ul>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/97/\">95.\r\n费解的开关 - AcWing题库</a></p>\r\n<ul>\r\n<li>经过思考后，发现一个开关按2次与没按没差别。所以对于每个开关，要不就按，要不就不按。继续思考，对于一个开关，它的状态取决于它自己以及上下左右共5个开关按or不按，而且跟顺序无关。</li>\r\n<li>接着往下想，既然与顺序无关，那我就可以从第一个开始按。假设（1，1）按了，那么...\r\n...感觉还是不好想。</li>\r\n<li>这时要学会给自己增加已知信息。假设我第一行开关按or不按已经知道。那么我就可以推出第二行的按法。因为当第一行按完之后，能改变第一行状态的只有第二行（不能再按第一行了，因为按两次等于没按）。所以如果（1，j）是0，那么（2，j）就要按。</li>\r\n<li>思路就出来了，枚举第一行的按法，然后推出第二行按法，继续推出第三行按法，直至推出第五行按法。此时1-4行都是1了，最后检查第5行是否全是1即可。</li>\r\n</ul></li>\r\n<li><p><a href=\"https://www.acwing.com/problem/content/107/\">105. 七夕祭\r\n- AcWing题库</a></p>\r\n<ul>\r\n<li><p>首先很容易看出行和列是独立的问题，而且本质是一样的。所以接下来都讨论列。</p></li>\r\n<li><p>然后略加思考也可以发现最终每列的数量就是全部列加起来取平均，取不了平均就没解。</p></li>\r\n<li><p>假设a1, a2, ...,\r\nan平均值为avg，假设1号给2号b1个，2号给3号b2个，n号给1号bn个。则所求可表达为：<span\r\nclass=\"math inline\">\\(|b_1|+|b_2|+...+|b_n|\\)</span>。且有下列方程组成立：\r\n<span class=\"math display\">\\[\r\na1 - b1 + bn = avg \\\\\r\na2 - b2 + b1 = avg \\\\\r\na3 - b3 + b2 = avg \\\\\r\n... \\\\\r\nan - bn + b_{n-1} = avg\r\n\\]</span></p></li>\r\n<li><p>整理可得</p></li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\n-b_1+b_n = avg - a_1 \\\\\r\n-b_2+b_n = 2avg - (a_1+a_2) \\\\\r\n-b_3+b_n = 3avg - (a_1+a_2+a_3) \\\\\r\n...\r\n-b_{n-1}+b_n = (n-1)avg - (a_1+a_2+...+a_{n-1})\r\n\\]</span></p>\r\n<ul>\r\n<li>继续整理</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nb_1 = -avg + a_1 + b_n \\\\\r\nb_2 = -2avg + (a_1 + a_2) + b_n \\\\\r\n... \\\\\r\nb_{n-1} = -(n-1)avg + (a_1+a_2+...+a_{n-1})\r\n\\]</span></p>\r\n<ul>\r\n<li>继续整理</li>\r\n</ul>\r\n<p><span class=\"math display\">\\[\r\nb_1 = b_n - avg + a_1 \\\\\r\nb_2 = b_n - 2avg + (a_1+a_2) \\\\\r\n...\\\\\r\nb_{n-1} = b_n - (n-1)avg + (a_1+a_2+...+a_{n-1})\r\n\\]</span></p>\r\n<ul>\r\n<li>令x = bn，则所求为：<span\r\nclass=\"math inline\">\\(|x-c1|+|x-c2|+...+|x-c_{n-1}|+|x - c_n|,\r\nc_n=0\\)</span></li>\r\n<li>一目了然，x取c的中位数时，所求最小。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"基础算法\">基础算法</h3>\r\n<h4 id=\"位运算\">位运算</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/92/\">90.\r\n64位整数乘法 - AcWing题库</a>\r\n<ul>\r\n<li>计算a * b %\r\np的结果。O(1)即可得出结果，但是a和b的范围很大会爆longlong。所以要用时间换空间。考虑a\r\n* b = a * (b的二进制表示)，例如a * 5 = a * (101) = a * (4 + 0 +\r\n1)。于是很容易的想到用logn的时间去分解b，用个中间变量sum对自己做累加（sum初始值为a），这样sum就会等于a\r\n，然后等于2a，然后等于4a...\r\n...。分解b的过程中如果最后一位二进制是1，就ans +=\r\nsum即可。这种用加法代替乘法的方法，叫做龟速乘。</li>\r\n<li>注意，%的优先级比+高。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/877/\">875. 快速幂 -\r\nAcWing题库</a>\r\n<ul>\r\n<li>计算<span class=\"math inline\">\\(a^b %\r\np\\)</span>的结果。思路跟龟速乘一样，都是分解b。考虑<span\r\nclass=\"math inline\">\\(a^b = a^{b的二进制形式}\\)</span>，例如<span\r\nclass=\"math inline\">\\(a^5 = a^{101} = a^{4 + 0 + 1} = a^4 *\r\na^1\\)</span>。用while去分解b的二进制，用个中间变量sum对自己做累乘（sum初始值为b），如果分解过程中b的最后一位二进制是1，就ans\r\n*= sum即可。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"递归分治\">递归/分治</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/description/99/\">97.\r\n约数之和 - AcWing题库</a>\r\n<ul>\r\n<li>求<span\r\nclass=\"math inline\">\\(a^b\\)</span>的所有约数之和。不难想到分解质因数。假设数num分解为<span\r\nclass=\"math inline\">\\(p_1^{k1} \\cdot p_2^{k2} \\cdot ... \\cdot\r\np_n^{kn}\\)</span>，那么数num的约数的个数就是(k1 + 1) * (k2 + 1) * ... *\r\n(kn +\r\n1)（相当于每个质数是材料，可以拿0/1/2/...个）。数num的约数之和就是<span\r\nclass=\"math inline\">\\((1+p_1+p_1^2+...+p_1^{k1}) \\cdot\r\n(1+p_2+p_2^2+...+p_2^{k2}) \\cdot ... \\cdot\r\n(1+p_n+p_n^2+...+p_n^{kn})\\)</span>。</li>\r\n<li>上面的数学推导作为一个大学生不难想出。那么这题思路就是先将a分解质因数，然后将每个质数的次数乘b。然后求<span\r\nclass=\"math inline\">\\((1+p_1+p_1^2+...+p_1^{k1}) \\cdot\r\n(1+p_2+p_2^2+...+p_2^{k2}) \\cdot ... \\cdot\r\n(1+p_n+p_n^2+...+p_n^{kn})\\)</span>即可。</li>\r\n<li>关键<span\r\nclass=\"math inline\">\\((1+p_1+p_1^2+...+p_1^{k1})\\)</span>怎么求，其实这种看起来有规律的东西都是用递归去加速，根据直觉尝试一下，假设sum\r\n= 1, mul = p1，然后while( sum += mul, mul *= mul )。第一次：sum=1+p1,\r\nmul=p1<sup>2；第二次：sum=1+p1+p1</sup>2+p1^3, mul = p1^4...\r\n...你看，这不就出来了。</li>\r\n<li>递归是俩倍俩倍去递归的，所以最后可能剩一点边角料。假设<span\r\nclass=\"math inline\">\\(p_1^{cnt}\\)</span>到<span\r\nclass=\"math inline\">\\(p_1^{k1}\\)</span>还没求，很简单，直接递归调用函数cal(p1,\r\nk1-cnt) * ksm(p1, cnt)</li>\r\n<li>这题坑点较多，注意b有可能为0。注意a可能为0/1。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/100/\">98. 分形之城 -\r\nAcWing题库</a>\r\n<ul>\r\n<li>一道找规律模拟题，挺恶心的。本质上就是给一个数num，找出其对应的坐标（x,\r\ny）。观察后不难发现，num会落到4个区，其中2、3区的区内坐标就等于上一个等级的对应数的坐标。1区的区内坐标等于上一个等级的对应数的坐标沿[左上到右下对角线]对称的坐标。4区的区内坐标等于上一个等级的对应数的坐标沿[右上到左下对角线]对称的坐标。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"前缀和差分\">前缀和/差分</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/101/\">99. 激光炸弹 -\r\nAcWing题库</a>\r\n<ul>\r\n<li>简单二维前缀和</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/102/\">100. 增减序列\r\n- AcWing题库</a>\r\n<ul>\r\n<li>差分题。最关键的一步是要联想到看一看差分数组。做题多就有经验了，这种区间操作问题一般要想到转换为差分数组，然后区间操作问题就转为端点修改问题。</li>\r\n<li>将a转化为差分数组b后，这题就变成了，将b2~bn全部变为0的最少次数是多少？在最少次数的前提下，b1有多少种取值方式？每一次区间操作等价于将<span\r\nclass=\"math inline\">\\(b_i\\)</span>加或减1，<span\r\nclass=\"math inline\">\\(b_j\\)</span>加或减1（i &lt; j &amp;&amp; 1 &lt;= i\r\n&lt;= n &amp;&amp; 2 &lt;= j &lt;= n + 1）</li>\r\n<li>然后由于贪心思想，尽可能将b2~bn中的正负数抵消掉。剩下抵消不掉的数的绝对值+1其实就是b1的不同取值个数。因为剩下不能凑对抵消的只能通过和b1或者<span\r\nclass=\"math inline\">\\(b_{n+1}\\)</span>凑对来抵消。选择用b1凑对多少次，b1就有多少种取值方式。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"二分\">二分</h4>\r\n<ul>\r\n<li><a\r\nhref=\"https://www.acwing.com/problem/content/description/104/\">102.\r\n最佳牛围栏 - AcWing题库</a>\r\n<ul>\r\n<li>看到平均数就想到整体减平均数，假设答案是一个数，然后每个数减掉这个数，那么只要找出一段区间长度&gt;=f的区间和&gt;=0就可以了。只要找出这样的区间。说明答案还可以更大，如果找不出，答案就要减小。所以二分答案即可。</li>\r\n<li>关键是如何找到“一段区间长度&gt;=f的区间和&gt;=0”，如果没有区间长度限制O(n)扫一遍用最大连续子段和即可。主要有区间限制，那么就多开一个数组minn[i]表示截止到0\r\n~\r\ni位置中sum[i]中的最小值即可。（其实这也是最大连续子段和的另一种做法）</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"排序\">排序</h4>\r\n<ul>\r\n<li><a\r\nhref=\"https://www.acwing.com/problem/content/description/115/\">113.\r\n特殊排序 - AcWing题库</a>\r\n<ul>\r\n<li>本质上就是裸排序题，用归并或者快排把&lt;号换成题中的compare即可。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"数据结构\">数据结构</h3>\r\n<h4 id=\"并查集\">并查集</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/1252/\">1250.\r\n格子游戏 - AcWing题库</a>\r\n<ul>\r\n<li>乍一看题目觉得很复杂，但实际上想到把二维转为一维就简单了。给每一个二维坐标赋予一个独一的一维坐标。每次一条边就是将两个点merge起来。如果一条边的两个点已经在一个集合里面了，说明产生了环。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1254/\">1252.\r\n搭配购买 - AcWing题库</a>\r\n<ul>\r\n<li>将所有捆绑在一起的东西看作一个物品，然后01背包即可。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/239/\">237.\r\n程序自动分析 - AcWing题库</a>\r\n<ul>\r\n<li>对于一组约束，将相等条件都用并查集并起来。然后依次检查不相等条件的两个点是否在同一集合中，如果在就是NO。全部检查完没问题就是YES。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/241/\">239. 奇偶游戏\r\n- AcWing题库</a>\r\n<ul>\r\n<li>这题涉及到区间问题，都应该往是否可以转换成“前缀和数组和差分数组上的区间俩端点“问题这个方向思考。这题考虑前缀和数组sum，区间[l,\r\nr]有偶数个1说明sum[r]与sum[l - 1]的奇偶性相同，区间[l,\r\nr]有奇数个1说明sum[r]与sum[l - 1]的奇偶性不同。</li>\r\n<li>看出这个后这题就好做了，二分M，每次检查前mid个条件是否满足。显然满足当且仅当是一个二分图，那么用染色法就检查前mid个条件形成的图是不是一个二分图即可。</li>\r\n<li>这题其实我还这样想过，就是用的[程序自动分析]这题的思路：二分M，每次检查前mid个条件是否满足。检查方法使用并查集，先将前mid个条件中相同条件的俩元素并起来，再检查前mid个条件中不相同条件的俩元素是否在同一集合，在就return\r\n0。都检查完了没问题就return 1。</li>\r\n<li>但上面这样想是错的，因为这题是有个隐藏条件的，任意一个元素，它不是奇数，就是偶数。所以上面并查集的做法是无法做到保证只有两个集合的。例如下面这个例子：</li>\r\n<li><img src=\"1.png\" /></li>\r\n<li>通过三句红话其实可以推出这些条件无法共存（不是二分图）。但是上面的并查集做法是检查不出来的。</li>\r\n<li>如果要用并查集的话要用这种思路：维护d[x]，表示x与父亲的奇偶性（如果俩点奇偶性相同则为0，不相同则为1）。在更新fat[x]的时候顺便更新一下d[x]，那么更新完后d[x]就成为了x与祖先的奇偶性。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/240/\">238.\r\n银河英雄传说 - AcWing题库</a>\r\n<ul>\r\n<li>跟上一题一样维护d[x]，表示x到父亲的距离。也是在更新fat[x]时顺便更新一下d[x]即可，更新完后d[x]就成为了x到祖先的距离。</li>\r\n<li>这题在merge时会用到并查集大小信息，所以还要多维护一个siz[x]。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"对顶堆\">对顶堆</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/108/\">106.\r\n动态中位数 - AcWing题库</a>\r\n<ul>\r\n<li>将数分为较大的一部分和较小的一部分。而且保证较大一部分的数的数量在偶数时与较小一部分的数的数量相等，在奇数时较大一部分的数的数量比较小一部分数的数量大1。</li>\r\n<li>用小根堆b维护较大的一部分，大根堆a维护较小的一部分。每次一进来一个数t，先与b.top()（也就是较大一部分中的最小的数）比较，如果比b.top()小，则把t插入a中。反之，把t插入b中。</li>\r\n<li>然后就要保证两个堆之间的数量关系。写俩if即可，if (a.size() &gt;\r\nb.size()) b.push(a.top()),\r\na.pop()。这句话保证了a的数量一旦超过b，就会被b反超。if (b.size() - 1\r\n&gt; a.size()) a.push(b.top()),\r\na.pop()。这句话保证了如果b的数量比a大2，则马上削弱它使得a、b数量相等。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"线段树\">线段树</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/1275/\">1273.\r\n天才的记忆 - AcWing题库</a>\r\n<ul>\r\n<li>区间查询最大值。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/248/\">242.\r\n一个简单的整数问题 - AcWing题库</a>\r\n<ul>\r\n<li>区间修改，单点查询。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/244/\">243.\r\n一个简单的整数问题2 - AcWing题库</a>\r\n<ul>\r\n<li>区间修改，区间查询。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1279/\">1277.\r\n维护序列 - AcWing题库</a>\r\n<ul>\r\n<li>区间修改（乘法加法），区间查询。</li>\r\n<li>假设sum' = sum * a + b，那么加一个数sum' + c = sum * a + (b +\r\nc)，相当于加法标记加了个c；乘一个数sum' * c = sum * ac +\r\n(bc)，相当于加法和乘法标记都自乘了个c。所以就这样维护俩标记即可，然后按照sum\r\n= sum * mul + add的规则去更新sum即可。</li>\r\n<li>但如果假设sum' = (sum + a) * b，那么加一个数sum' + c = sum * b + ab\r\n+ c，你看，就不好可持续性维护了。</li>\r\n<li>这题注意build初始化时每个t[p]的mul标记都要初始化为1。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/1277/\">1275. 最大数\r\n- AcWing题库</a>\r\n<ul>\r\n<li>动态维护后L个数中的最大值，可以发现数组的数量是只会增加不会减少的，而且数组元素数量最多增长到2e5。所以对数组下标建一颗线段树维护区间最大值即可。单点修改\r\n+ 区间查询。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/246/\">245.\r\n你能回答这些问题吗 - AcWing题库</a>\r\n<ul>\r\n<li>考虑t[p]的最大子段和sm如何转移：max(t[p1].sm, t[p2].sm,\r\n跨过mid的最大子段和)。跨过mid的最大子段和 = t[p1]的最大后缀和 +\r\nt[p2]的最大前缀和。</li>\r\n<li>所以t[p]需要维护最大子段和sm，最大前缀和lm，最大后缀和rm，在维护lm,\r\nrm时还会用到区间和sum。</li>\r\n<li>查询区间[l, r]时，ask函数应返回一个Tree类型，当l &lt;= mid &lt;=\r\nr（mid = (t[p].l + t[p].r) / 2）时，可以通过子树t1,\r\nt2表示出状态。如果不返回Tree类型的话，就没有子树t1,\r\nt2的信息，状态不好表示出来。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/247/\">246.\r\n区间最大公约数 - AcWing题库</a>\r\n<ul>\r\n<li>由更相减损术可知gcd(a, b) = gcd(a, b -\r\na)。次公式可扩展到多个变量：gcd(a, b, c, d) = gcd(a, b - a, c - b, d -\r\nc)，这其实就是差分形式。所以可以线段树维护原数组的差分数组的区间gcd和区间和，那么操作1就是单点修改（单点修改那可以完全不用考虑懒标记问题了很舒服），操作2求gcd(A[l],\r\nA[l + 1], A[l + 2], ..., A[r]) = gcd(A[l], A[l + 1] - A[l], A[l + 2] -\r\nA[l + 1], ..., A[r] - A[r - 1]) = gcd(差分数组[1 ~ l]之和，差分数组[l +\r\n1到r]的gcd)。</li>\r\n<li>这题有俩小细节，第一差分单点修改r +\r\n1有可能到n外边去，第二查询时如果l = r则要特判下。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/249/\">247.\r\n亚特兰蒂斯 - AcWing题库</a>\r\n<ul>\r\n<li>扫描线算法，扫描线算法是个比较死的算法，因为其有一个特殊性质：线段是成对出现的。</li>\r\n<li>做法两种，我喜欢这种：维护区间最小值min和区间最小值的长度minlen。这样，如果t[1].min\r\n= 0，则被覆盖的长度 = 全部长度 - t[1].minlen。如果t[1].min !=\r\n0，则被覆盖的长度 =\r\n全部长度。区间最小值和区间最小值长度都非常好维护，区间修改就是给最小值打个懒标记即可，不用管minlen，因为最小值加一个数减一个数仍然是最小值，minlen不会变。</li>\r\n<li>上面就是扫描线的做法。所以扫描线很简单，关键这题的细节处理有点点小麻烦。</li>\r\n<li>一，坐标都是小数，所以需要离散化处理成整数才能建线段树。二，t[p]管理的实际区间为getVal(t[p].r\r\n+ 1) -\r\ngetVal(t[p].l)，因为只有这样，线段树的子节点才可以初始化minlen，不然minlen不好初始化。三，离散化的俩函数getRank,\r\ngetVal的参数类型要注意。</li>\r\n</ul></li>\r\n<li><a href=\"https://ac.nowcoder.com/acm/contest/67742/H\">H-Tokitsukaze\r\nand Power Battle (hard)_2024牛客寒假算法基础集训营2</a>\r\n<ul>\r\n<li>是“最大区间和”的变形题。</li>\r\n<li>考虑i，j的位置，如果i，j都在mid左边是一种情况，即t[p].ans =\r\nt[p1].ans。如果i，j都在mid右边是一种情况，即t[p].ans =\r\nt[p2].ans。如果i，j分布在mid两边，则需要考虑x(即中间砍的那一刀)的位置。</li>\r\n<li>如果砍的一刀在mid, mid + 1之间，则t[p].ans =\r\nt[p1].包含右端点的最大后缀和 - t[p2].包含左端点的最小前缀和。</li>\r\n<li>如果砍的一刀在左半边，则t[p].ans = t[p1].包含右端点的答案 -\r\nt[p2].包含左端点的最小前缀和。</li>\r\n<li>如果砍的一刀在右半边，则t[p].ans = t[p1].包含右端点的最大后缀和 +\r\nt[p2].包含左端点的答案。</li>\r\n<li>所以t[p].ans就是在上面几种情况取max。发现用到了“包含右端点的最大后缀和rmax”，“包含左端点的最小前缀和lmin”，“包含右端点的答案rans”，“包含左端点的答案lans”，rmax和lmin很好维护，现在来看lans和rans如何维护。</li>\r\n<li>先考虑t[p].lans。此时i是卡死的就在l上，考虑j的位置。如果j左半边，则t[p].lans\r\n= t[p1].lans。如果j在右半边，则考虑砍的一刀位置，如果砍在mid,\r\nmid+1中间，则t[p].lans = t[p1].sum -\r\nt[p2].lmin；如果砍在左半边，则t[p].lans = t[p1].包含左右端点的答案 -\r\nt[p2].lmin；如果砍在右半边，则t[p].lans = t[p1].sum + t[p2].lans。</li>\r\n<li>t[p].rans同理。发现在维护这俩的时候还用到了\"包含左右端点的答案lrans\"。</li>\r\n<li>现在考虑t[p].lrans。因为i，j都定死了，所以只需考虑砍的一刀的位置。如果砍在mid,mid+1中间，则t[p].lrans\r\n= t[p1].sum - t[p2].sum。如果砍在左半边，则t[p].lrans = t[p1].lrans -\r\nt[p2].sum。如果砍在右半边，则t[p].lrans = t[p1].sum + t[p2].lrans。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"树状数组\">树状数组</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/109/\">107.\r\n超快速排序 - AcWing题库</a>\r\n<ul>\r\n<li>求逆序对。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/243/\">241. 楼兰图腾\r\n- AcWing题库</a>\r\n<ul>\r\n<li>简单的求每个数之前比它大的数的个数。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/245/\">244.\r\n谜一样的牛 - AcWing题库</a>\r\n<ul>\r\n<li>最后一头牛的高度是确定的，在确定最后一头牛高度后，倒数第二头牛的高度也确定了，依次类推。假设现在要求第i头牛的高度，则若数组c的区间和[1,\r\nk] = 比第i头牛矮的牛数量 + 1，则第i头牛的高度为k（最开始每个位置的c[i] =\r\n1）。</li>\r\n<li>区间和查询用树状数组，找高度时配合二分。找到该牛高度k后，upd(x,\r\n-1)。</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"字典树\">字典树</h4>\r\n<ul>\r\n<li><a href=\"https://www.acwing.com/problem/content/837/\">835.\r\nTrie字符串统计 - AcWing题库</a>\r\n<ul>\r\n<li>板子题，字典树空间一般不知道开多少合适，建议用vector。就比如这题，开个vector&lt;Node&gt;\r\na。Node结构体里放指向信息，这题的指向信息有26个，就在Node里开一个alpha[26]。</li>\r\n<li>从根节点编号0出发，若a[0].alpha[k] =\r\n0，那就新开一个点，a[0].alpha[k] = ++dex,\r\na.push_back(tmp)即可。然后编号跳到a[0].alpha[k]，继续依次类推。</li>\r\n<li>通过这种方法，就不需要考虑空间应该开多大了。</li>\r\n</ul></li>\r\n<li><a href=\"https://www.acwing.com/problem/content/145/\">143.\r\n最大异或对 - AcWing题库</a>\r\n<ul>\r\n<li>思考每个数的二进制形式，将每个数的二进制形式insert到字典树中（字典树就两个指向信息p[0/1]），然后对于每个数，依次扫二进制的每一位数k，在字典树里找a[p].nxt[k\r\n^\r\n1]是否存在，存在p就指向它，不存在就指向a[p].nxt[k]。在过程中统计答案求最大值即可。</li>\r\n</ul></li>\r\n<li><a\r\nhref=\"https://www.acwing.com/problem/content/description/258/\">256.\r\n最大异或和 - AcWing题库</a>\r\n<ul>\r\n<li>涉及到区间异或运算，所以尝试是否可以前缀和/差分转化为单点运算，发现是可以的。考虑维护前缀异或数组，s[i]\r\n= a[1] ^ a[2] ... ^ a[i]，这样a[p] ^ a[p + 1] ^ a[p + 2] ^ ... ^ a[n] =\r\ns[n] ^ s[l - 1]。所以所求为x ^ s[n] ^ s[p - 1]。(x ^\r\ns[n])是一个定值C，所以就是在[l - 1, r - 1]内找一个数s[i]，使得s[i] ^\r\nC最大。所以就是可持久化Trie树。</li>\r\n<li>可持久化Trie树就是每次添加一条链，具体算法是p = root[now], q =\r\nroot[now - 1]。然后p的所有子节点除了新链上的点，复制q的节点，然后p =\r\nt[p][k] = ++dex, q = t[q][k]。再递归进行直至把这条链添加进Trie树。</li>\r\n</ul></li>\r\n</ul>\r\n","categories":["3. 竞赛"]},{"title":"在VS Code中配置C/C++","url":"/2023/10/03/%E5%9C%A8VS-Code%E4%B8%AD%E9%85%8D%E7%BD%AEC-C/","content":"<p>之前因为学了一点html，所以下了一个VS Code来写html代码。</p>\r\n<p>今天要写C++的代码，以前都是用VS写的。但是突然想了一下既然都装了VS\r\nCode，为啥不配置一下。配置好了后以后写C/C++代码也不用打开繁重的VS了。而且VS\r\nCode还能加很多插件。</p>\r\n<span id=\"more\"></span>\r\n<p>说干就干，上网找了资料，终于配置好了。还是有蛮多坑的，主要是因为网上的教程大部分版本比较老了。所以我来写个教程，方便别人和以后自己在别的电脑上配置。我总结出以下几步：</p>\r\n<h3 id=\"下载mingw-w64并配置系统变量\">1. 下载MinGW-w64并配置系统变量</h3>\r\n<ul>\r\n<li><p>MinGW是是将经典的开源 C语言 编译器 GCC 移植到了 Windows\r\n平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows\r\n中运行的可执行程序。</p></li>\r\n<li><p>但是MinGW的很早就停止维护了，版本很老了。</p></li>\r\n<li><p>MinGW-w64相当于升级版的MinGW，是一个开源项目，不断在更新维护着。</p></li>\r\n<li><p><a\r\nhref=\"https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/\">下载链接</a>，划到最下面，选择“MinGW-W64\r\nGCC-8.1.0”下的“x86_64-win32-seh”进行下载。</p></li>\r\n<li><p>下载好后，解压到自己想要的位置。然后将其中的bin路径配置到系统变量中。</p></li>\r\n<li><p>打开cmd，输入gcc --version和gdb\r\n--version，弹出版本信息就说明这一步完成了。</p></li>\r\n</ul>\r\n<h3 id=\"下载插件cccode-runner\">2. 下载插件C/C++，Code Runner</h3>\r\n<ul>\r\n<li>在VS Code中下载即可。</li>\r\n</ul>\r\n<h3 id=\"配置文件\">3. 配置文件</h3>\r\n<ul>\r\n<li><p>新建一个项目文件夹，在下面建立一个.vscode文件夹，下面建立三个文件，launch.json，tasks.json，c_cpp_properties.json，然后依次把我的代码复制进去。注意代码中的“（改为自己的路径）”</p></li>\r\n<li><p>lauch.json</p></li>\r\n</ul>\r\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.2.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">\t<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;C++ Launch (GDB)&quot;</span><span class=\"punctuation\">,</span>                </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cppdbg&quot;</span><span class=\"punctuation\">,</span>                         </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;request&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;launch&quot;</span><span class=\"punctuation\">,</span>                        </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;targetArchitecture&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;x86&quot;</span><span class=\"punctuation\">,</span>                </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;program&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;workspaceRoot&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">,</span>                 </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;miDebuggerPath&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;D:\\\\app\\\\mingw64\\\\bin\\\\gdb.exe&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>     </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;stopAtEntry&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span>                  </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;cwd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class=\"punctuation\">,</span>                  </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;externalConsole&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                  </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;preLaunchTask&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:/app/mingw64/bin/g++.exe&quot;</span>  （改为自己的路径）          </span><br><span class=\"line\">\t\t<span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>tasks.json</li>\r\n</ul>\r\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:/app/mingw64/bin/g++.exe&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">    <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;-g&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;-std=c++11&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;$&#123;file&#125;&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;-o&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;$&#123;workspaceRoot&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;problemMatcher&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;owner&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cpp&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;fileLocation&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;relative&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;pattern&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;regexp&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;file&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;line&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;column&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;severity&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;message&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">5</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tasks&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;label&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:/app/mingw64/bin/g++.exe&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">            <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:/app/mingw64/bin/g++.exe&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-g&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-std=c++11&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;file&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-o&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;workspaceRoot&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;problemMatcher&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;owner&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cpp&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;fileLocation&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;relative&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;$&#123;workspaceRoot&#125;&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;pattern&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;regexp&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;file&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;line&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;column&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;severity&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;message&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">5</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;group&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;_id&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;build&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;isDefault&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>c_cpp_properties.json</li>\r\n</ul>\r\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Win32&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;includePath&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include//c++/tr1&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/x86_64-w64-mingw32/include&quot;</span>（改为自己的路径）</span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;defines&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;_DEBUG&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;UNICODE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;__GNUC__=6&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;__cdecl=__attribute__((__cdecl__))&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;intelliSenseMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;msvc-x64&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;browse&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;path&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include//c++/tr1&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/x86_64-w64-mingw32/include&quot;</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"punctuation\">]</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;compilerPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\VC\\\\Tools\\\\MSVC\\\\14.36.32532\\\\bin\\\\Hostx64\\\\x64\\\\cl.exe&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c17&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cppStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c++17&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li><p>在项目文件夹中新建cpp文件，随便写一个程序。然后F5调试。</p></li>\r\n<li><p>如果能输出正确结果就没问题。如果不能，比如std或者cout报错的话，就打开设置，在\"C/C++\"中找到C_Cpp:intelli\r\nSense Engine，将默认的“Default”改为“Tag Parser”。</p></li>\r\n<li><p>此时按F5就可以正常实现调试功能了。</p></li>\r\n<li><p>其实如果你不用调试的话，直接Ctrl + F5用Code\r\nRunner跑代码就行了。</p></li>\r\n</ul>\r\n","categories":["杂项"]},{"title":"数字逻辑实验笔记","url":"/2023/10/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/","content":"<p>这一部分主要是verilog语法，比较简单。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"两种声明方式\">两种声明方式</h3>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> AND4(a, b, out);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] a, b;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] out;</span><br><span class=\"line\">    <span class=\"keyword\">assign</span> out = a &amp; b;</span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> AND4(<span class=\"keyword\">input</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] a, <span class=\"keyword\">input</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] b, <span class=\"keyword\">output</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] out);</span><br><span class=\"line\">    <span class=\"keyword\">assign</span> out = a &amp; b;</span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"数据类型\">数据类型</h3>\r\n<p>掌握wire和reg即可。</p>\r\n<p>wire就是对应着电路里的线。reg就是对应着电路里的寄存器。</p>\r\n<p>常量用parameter定义，例如parameter width = 3;\r\n但是常量也可以重定义，例如下面这个例子：</p>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> adder(a, b, sum);</span><br><span class=\"line\">    <span class=\"keyword\">parameter</span> time_delay = <span class=\"number\">5</span>, time_count = <span class=\"number\">10</span>;</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">module</span> top;</span><br><span class=\"line\">    <span class=\"keyword\">wire</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] a1, b1;</span><br><span class=\"line\">    <span class=\"keyword\">wire</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] sum1;</span><br><span class=\"line\">    <span class=\"keyword\">wire</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] a2, b2;</span><br><span class=\"line\">    <span class=\"keyword\">wire</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] sum2;</span><br><span class=\"line\">    adder <span class=\"variable\">#(4, 8) AD1(a1, b1, sum1)</span>;\t<span class=\"comment\">//time_delay=4, time_count=8</span></span><br><span class=\"line\">    adder <span class=\"variable\">#(12) AD2(a2, b2, sum2)</span>;\t<span class=\"comment\">//time_delay=12, time_count=10</span></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"数据的表达方式\">数据的表达方式</h3>\r\n<p><位宽>'<进制><数字>：4'b0101 / 4‘h5</p>\r\n<p><进制><数字>：位宽一般默认是32位。h5</p>\r\n<p><数字>：位宽默认32位，进制默认为十进制。5</p>\r\n<h3 id=\"拼接运算符\">拼接运算符</h3>\r\n<p>{a, b[3:0], w, 3'b101} 等价于 {a, b[3], b[2], b[1], b[0], w, 1'b1,\r\n1'b0, 1'b1}</p>\r\n<p>{4{w}} 等价于 {w, w, w, w}</p>\r\n<p>{b, 3{a, b}} 等价于 {b, a, b, a, b, a, b}</p>\r\n<h3 id=\"赋值语句\">赋值语句</h3>\r\n<p>assign只能对wire类型赋值。assign的作用通常就是把reg的结果用一个wire接收。</p>\r\n<p>initial里对reg变量赋初值。</p>\r\n<p>always里的=(阻塞赋值)/&lt;=(非阻塞赋值)对always块里的reg类型赋值。</p>\r\n<p>always语句</p>\r\n<p>always @ (clk) //只要clk发生变化就触发 always @ (posedge clk)\r\n//clk上升沿触发（从0-&gt;1触发）</p>\r\n<p>always @ (negedge clk) //clk下降沿触发（从1-&gt;0触发）</p>\r\n<p>always @ (*) //always块内任何输入信号变化了就触发</p>\r\n<h3 id=\"条件语句\">条件语句</h3>\r\n<p>条件语句只能用于always或initial内部。只需要掌握if-else和case语句即可。</p>\r\n<p>if-else语句：跟C++一样，只不过多条语句时将{}换成begin-end</p>\r\n<p>case语句：有case/casex/casez可以选择。casex就是分支表达式中可以有?作为通配符。</p>\r\n<h3 id=\"循环语句\">循环语句</h3>\r\n<p>一般循环语句都是用来写仿真文件的。因为循环次数不确定的循环语句是不能被综合的！</p>\r\n<p>所以一般用循环语句来写源代码都是用for循环</p>\r\n<hr />\r\n<p>接下来的内容就是实验了，实验代码自己手撸的。而且只学了基本语法就开干了，所以代码自我感觉很丑不优美。</p>\r\n<h3 id=\"实验一\">实验一</h3>\r\n<p><img src=\"1.png\" /></p>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> demo02_verilog #(<span class=\"keyword\">parameter</span> W1 = <span class=\"number\">1</span>, W2 = <span class=\"number\">3</span>) (</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [(W1 - <span class=\"number\">1</span>) : <span class=\"number\">0</span>] sw15, sw14,</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [(W2 - <span class=\"number\">1</span>) : <span class=\"number\">0</span>] in1, in2, in3, in4,</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [(W2 - <span class=\"number\">1</span>) : <span class=\"number\">0</span>] ld</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"comment\">//错误代码：assign ld = (~sw15 &amp; ~sw14 &amp; in1) | (~sw15 &amp; sw14 &amp; in2) | (sw15 &amp; ~sw14 &amp; in3) | (sw15 &amp; sw14 &amp; in4);</span></span><br><span class=\"line\">    <span class=\"keyword\">assign</span> ld = sw15 ? (sw14 ? in4 : in3) : (sw14 ? in2 : in1);</span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"实验二\">实验二</h3>\r\n<p><img src=\"2.png\" /></p>\r\n<ul>\r\n<li>top.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> top(a, b, t, e, l1, l2, l3, clk, reset, an, led);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] a, b;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> t, e;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> l1, l2, l3;  <span class=\"comment\">//控制负数亮灯</span></span><br><span class=\"line\">    <span class=\"keyword\">wire</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] out;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk, reset;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] an;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">6</span>:<span class=\"number\">0</span>] led;</span><br><span class=\"line\">    </span><br><span class=\"line\">    add <span class=\"variable\">#(4) f1(.a(a), .b(b), .out(out), .t(t), .e(e))</span>;</span><br><span class=\"line\">    show(<span class=\"variable\">.clk</span>(clk), <span class=\"variable\">.reset</span>(reset),</span><br><span class=\"line\">         <span class=\"variable\">.hex0</span>(out), <span class=\"variable\">.hex2</span>(b), <span class=\"variable\">.hex3</span>(a),</span><br><span class=\"line\">         <span class=\"variable\">.an</span>(an), <span class=\"variable\">.sseg</span>(led), <span class=\"variable\">.l1</span>(l1), <span class=\"variable\">.l2</span>(l2), <span class=\"variable\">.l3</span>(l3));</span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>add.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//进位不影响补码运算的正确性，溢出影响正确性，溢出的本质就是超过了位宽能表达的范围</span></span><br><span class=\"line\"><span class=\"keyword\">module</span> add (a, b, out, t, e);</span><br><span class=\"line\">    <span class=\"keyword\">parameter</span> W = <span class=\"number\">32</span>;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [W-<span class=\"number\">1</span>:<span class=\"number\">0</span>] a, b;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> [W-<span class=\"number\">1</span>:<span class=\"number\">0</span>] out;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> t, e;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [W-<span class=\"number\">1</span>:<span class=\"number\">0</span>] a_, b_; <span class=\"comment\">//补码</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [W-<span class=\"number\">1</span>:<span class=\"number\">0</span>] out_;   <span class=\"comment\">//运算后的补码</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [W-<span class=\"number\">1</span>:<span class=\"number\">0</span>] out;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] i;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> t = <span class=\"number\">0</span>, e = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (*) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"comment\">//都转为补码</span></span><br><span class=\"line\">        a_ = a;</span><br><span class=\"line\">        b_ = b;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W - <span class=\"number\">1</span>; i = i + <span class=\"number\">1</span>) a_[i] = ~a[i];</span><br><span class=\"line\">            t = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    tt = a_[i];</span><br><span class=\"line\">                    a_[i] = a_[i] ^ <span class=\"number\">1</span> ^ t;</span><br><span class=\"line\">                    t = (tt &amp; <span class=\"number\">1</span>) | (t &amp; (tt | <span class=\"number\">1</span>));</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    tt = a_[i];</span><br><span class=\"line\">                    a_[i] = a_[i] ^ <span class=\"number\">0</span> ^ t;</span><br><span class=\"line\">                    t = (tt &amp; <span class=\"number\">0</span>) | (t &amp; (tt | <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (b_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W - <span class=\"number\">1</span>; i = i + <span class=\"number\">1</span>) b_[i] = ~b[i];</span><br><span class=\"line\">            t = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i == <span class=\"number\">0</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    tt = b_[i];</span><br><span class=\"line\">                    b_[i] = b_[i] ^ <span class=\"number\">1</span> ^ t;</span><br><span class=\"line\">                    t = (tt &amp; <span class=\"number\">1</span>) | (t &amp; (tt | <span class=\"number\">1</span>));</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    tt = b_[i];</span><br><span class=\"line\">                    b_[i] = b_[i] ^ <span class=\"number\">0</span> ^ t;</span><br><span class=\"line\">                    t = (tt &amp; <span class=\"number\">0</span>) | (t &amp; (tt | <span class=\"number\">0</span>));</span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"comment\">//俩补码运算</span></span><br><span class=\"line\">        t = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            out_[i] = a_[i] ^ b_[i] ^ t;</span><br><span class=\"line\">            t = (a_[i] &amp; b_[i]) | (t &amp; (a_[i] | b_[i]));</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"comment\">//检测是否溢出</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (a_[W-<span class=\"number\">1</span>] == <span class=\"number\">0</span> &amp;&amp; b_[W-<span class=\"number\">1</span>] == <span class=\"number\">0</span> &amp;&amp; out_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span>) e = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span> &amp;&amp; b_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span> &amp;&amp; out_[W-<span class=\"number\">1</span>] == <span class=\"number\">0</span>) e = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> e = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//将补码转为原码</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (out_[W-<span class=\"number\">1</span>] == <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"comment\">//变反码</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                a_[i] = out_[i];</span><br><span class=\"line\">                b_[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            tt = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                out_[i] = a_[i] ^ b_[i] ^ tt;</span><br><span class=\"line\">                tt = (a_[i] &amp; b_[i]) | (tt &amp; (a_[i] | b_[i]));</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"comment\">//变原码</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W - <span class=\"number\">1</span>; i = i + <span class=\"number\">1</span>) out_[i] = ~out_[i];</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"comment\">//赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; W; i = i + <span class=\"number\">1</span>) out[i] = out_[i];</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>show.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> show(clk, reset, hex0, hex1, hex2, hex3, an, sseg, l1, l2, l3);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk, reset;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] hex0, hex1, hex2, hex3; <span class=\"comment\">//分别存储4个灯要显示的数字（0-15）</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] an;                    <span class=\"comment\">//控制每个灯是否工作，0为工作</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">6</span>:<span class=\"number\">0</span>] sseg;                  <span class=\"comment\">//存储数字在数码管上的表示</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> l1, l2, l3;                  <span class=\"comment\">//控制负数亮灯</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">assign</span> l1 = hex3[<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">assign</span> l2 = hex2[<span class=\"number\">3</span>];</span><br><span class=\"line\">    <span class=\"keyword\">assign</span> l3 = hex0[<span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">localparam</span> N = <span class=\"number\">18</span>;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [N-<span class=\"number\">1</span>:<span class=\"number\">0</span>] regN;</span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk, <span class=\"keyword\">posedge</span> reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(reset) regN &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> regN &lt;= regN + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] an;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] hex_in;   <span class=\"comment\">//存储当前要展示的数字</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (*) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span>(regN[N-<span class=\"number\">1</span> : N-<span class=\"number\">2</span>])</span><br><span class=\"line\">            <span class=\"number\">2&#x27;b00</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                an = <span class=\"number\">4&#x27;b1110</span>; </span><br><span class=\"line\">                hex_in = hex0;  </span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"number\">2&#x27;b01</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                an = <span class=\"number\">4&#x27;b1101</span>; </span><br><span class=\"line\">                hex_in = hex1;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"number\">2&#x27;b10</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                an = <span class=\"number\">4&#x27;b1011</span>;</span><br><span class=\"line\">                hex_in = hex2;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">default</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                an = <span class=\"number\">4&#x27;b0111</span>;</span><br><span class=\"line\">                hex_in = hex3;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">6</span>:<span class=\"number\">0</span>] sseg;</span><br><span class=\"line\">    <span class=\"keyword\">always</span>@(<span class=\"keyword\">posedge</span> clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span>(hex_in[<span class=\"number\">2</span>:<span class=\"number\">0</span>])</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h0</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0000001</span>; </span><br><span class=\"line\">            <span class=\"number\">4&#x27;h1</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b1001111</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h2</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0010010</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h3</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0000110</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h4</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b1001100</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h5</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0100100</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h6</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0100000</span>;</span><br><span class=\"line\">            <span class=\"number\">4&#x27;h7</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0001111</span>;</span><br><span class=\"line\">        <span class=\"keyword\">endcase</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"实验三\">实验三</h3>\r\n<p><img src=\"3.png\" /></p>\r\n<ul>\r\n<li>top.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> top(clk, A, B, sum, t);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] A, B;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] sum;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> t;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] Lsm_d1;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">15</span>:<span class=\"number\">0</span>] Aup_d1, Bup_d1;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> Carry_d1;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        &#123;Carry_d1, Lsm_d1&#125; = A[<span class=\"number\">15</span>:<span class=\"number\">0</span>] + B[<span class=\"number\">15</span>:<span class=\"number\">0</span>];</span><br><span class=\"line\">        Aup_d1 = A[<span class=\"number\">31</span>:<span class=\"number\">16</span>];</span><br><span class=\"line\">        Bup_d1 = B[<span class=\"number\">31</span>:<span class=\"number\">16</span>];</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        sum[<span class=\"number\">15</span>:<span class=\"number\">0</span>] = Lsm_d1;</span><br><span class=\"line\">        &#123;t, sum[<span class=\"number\">31</span>:<span class=\"number\">16</span>]&#125; = Aup_d1 + Bup_d1 + Carry_d1;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"实验四\">实验四</h3>\r\n<p><img src=\"4.png\" /></p>\r\n<ul>\r\n<li>top.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// top 模块：整合时钟分频器和交通灯控制器</span></span><br><span class=\"line\"><span class=\"keyword\">module</span> top(</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk,        <span class=\"comment\">// 输入：主时钟信号</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> rst_n,      <span class=\"comment\">// 输入：复位信号</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] light_NS, <span class=\"comment\">// 输出：南北方向交通灯状态</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] light_EW  <span class=\"comment\">// 输出：东西方向交通灯状态</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">wire</span> clk_out;  <span class=\"comment\">// 内部线网：用于从时钟分频器传递分频后的时钟</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 实例化时钟分频器模块</span></span><br><span class=\"line\">    clockdivider u1(</span><br><span class=\"line\">        <span class=\"variable\">.clk</span>(clk),</span><br><span class=\"line\">        <span class=\"variable\">.rst_n</span>(rst_n),</span><br><span class=\"line\">        <span class=\"variable\">.clk_out</span>(clk_out)</span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"comment\">// 实例化交通灯控制模块</span></span><br><span class=\"line\">    traffic_light u2(</span><br><span class=\"line\">        <span class=\"variable\">.clk</span>(clk_out),  <span class=\"comment\">// 使用分频后的时钟</span></span><br><span class=\"line\">        <span class=\"variable\">.rst_n</span>(rst_n),</span><br><span class=\"line\">        <span class=\"variable\">.light_NS</span>(light_NS),  <span class=\"comment\">// 南北方向交通灯状态</span></span><br><span class=\"line\">        <span class=\"variable\">.light_EW</span>(light_EW)   <span class=\"comment\">// 东西方向交通灯状态</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>clockdivider.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// clockdivider 模块：用于将输入时钟分频</span></span><br><span class=\"line\"><span class=\"keyword\">module</span> clockdivider(</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk,           <span class=\"comment\">// 输入：原始的高频时钟信号</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> rst_n,         <span class=\"comment\">// 输入：复位信号</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> clk_out   <span class=\"comment\">// 输出：分频后的时钟信号</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">parameter</span> DIVISOR = <span class=\"number\">32&#x27;d1666_6667</span>; <span class=\"comment\">// 分频因子</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">31</span>:<span class=\"number\">0</span>] counter = <span class=\"number\">32&#x27;d0</span>;        <span class=\"comment\">// 计数器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 时钟分频逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">posedge</span> rst_n) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst_n) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"comment\">// 复位时，重置计数器和输出时钟</span></span><br><span class=\"line\">            counter &lt;= <span class=\"number\">32&#x27;d0</span>;</span><br><span class=\"line\">            clk_out &lt;= <span class=\"number\">1&#x27;b0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"comment\">// 计数器达到分频因子时，翻转输出时钟并重置计数器</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (counter == DIVISOR - <span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">                clk_out &lt;= ~clk_out;</span><br><span class=\"line\">                counter &lt;= <span class=\"number\">32&#x27;d0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">                <span class=\"comment\">// 否则，计数器递增</span></span><br><span class=\"line\">                counter &lt;= counter + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>traffic_light.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// traffic_light 模块：控制交通灯状态</span></span><br><span class=\"line\"><span class=\"keyword\">module</span> traffic_light(</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk,           <span class=\"comment\">// 输入：时钟信号</span></span><br><span class=\"line\">    <span class=\"keyword\">input</span> rst_n,         <span class=\"comment\">// 输入：复位信号</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] light_NS, <span class=\"comment\">// 输出：南北方向交通灯状态</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] light_EW  <span class=\"comment\">// 输出：东西方向交通灯状态</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 状态定义</span></span><br><span class=\"line\">    <span class=\"keyword\">parameter</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] GREEN_NS_RED_EW   = <span class=\"number\">3&#x27;b000</span>,</span><br><span class=\"line\">                     YELLOW_NS_RED_EW  = <span class=\"number\">3&#x27;b001</span>,</span><br><span class=\"line\">                     RED_NS_RED_EW_1   = <span class=\"number\">3&#x27;b010</span>,</span><br><span class=\"line\">                     RED_NS_GREEN_EW   = <span class=\"number\">3&#x27;b011</span>,</span><br><span class=\"line\">                     RED_NS_YELLOW_EW  = <span class=\"number\">3&#x27;b100</span>,</span><br><span class=\"line\">                     RED_NS_RED_EW_2   = <span class=\"number\">3&#x27;b101</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">2</span>:<span class=\"number\">0</span>] state = GREEN_NS_RED_EW; <span class=\"comment\">// 当前状态</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] counter = <span class=\"number\">4&#x27;b0000</span>;       <span class=\"comment\">// 计时器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 时钟边沿触发的逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @(<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">posedge</span> rst_n) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst_n) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"comment\">// 复位逻辑</span></span><br><span class=\"line\">            state &lt;= GREEN_NS_RED_EW;</span><br><span class=\"line\">            counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">        <span class=\"keyword\">end</span> <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"comment\">// 状态转换逻辑</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> (state)</span><br><span class=\"line\">                GREEN_NS_RED_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b1111</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 15时钟周期</span></span><br><span class=\"line\">                        state &lt;= YELLOW_NS_RED_EW;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                YELLOW_NS_RED_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b0011</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 3时钟周期</span></span><br><span class=\"line\">                        state &lt;= RED_NS_RED_EW_1;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_RED_EW_1: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b0011</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 3时钟周期，短暂的全红状态</span></span><br><span class=\"line\">                        state &lt;= RED_NS_GREEN_EW;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_GREEN_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b1111</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 15时钟周期</span></span><br><span class=\"line\">                        state &lt;= RED_NS_YELLOW_EW;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_YELLOW_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b0011</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 3时钟周期</span></span><br><span class=\"line\">                        state &lt;= RED_NS_RED_EW_2;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_RED_EW_2: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (counter == <span class=\"number\">4&#x27;b0011</span>) <span class=\"keyword\">begin</span> <span class=\"comment\">// 3时钟周期</span></span><br><span class=\"line\">                        state &lt;= GREEN_NS_RED_EW;</span><br><span class=\"line\">                        counter &lt;= <span class=\"number\">4&#x27;b0000</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">end</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">endcase</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 计数器递增</span></span><br><span class=\"line\">            counter &lt;= counter + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 根据当前状态更新交通灯输出</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> (state)</span><br><span class=\"line\">                GREEN_NS_RED_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b010</span>; <span class=\"comment\">// 南北绿灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 东西红灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                YELLOW_NS_RED_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b001</span>; <span class=\"comment\">// 南北黄灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 东西红灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_RED_EW_1: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 南北红灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 东西红灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_GREEN_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 南北红灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b010</span>; <span class=\"comment\">// 东西绿灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_YELLOW_EW: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 南北红灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b001</span>; <span class=\"comment\">// 东西黄灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">                RED_NS_RED_EW_2: <span class=\"keyword\">begin</span></span><br><span class=\"line\">                    light_NS &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 南北红灯</span></span><br><span class=\"line\">                    light_EW &lt;= <span class=\"number\">3&#x27;b100</span>; <span class=\"comment\">// 东西红灯</span></span><br><span class=\"line\">                <span class=\"keyword\">end</span></span><br><span class=\"line\">            <span class=\"keyword\">endcase</span></span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<h3 id=\"大作业\">大作业</h3>\r\n<p><img src=\"5.png\" /></p>\r\n<figure>\r\n<img src=\"6.png\" alt=\"1705202189606\" />\r\n<figcaption aria-hidden=\"true\">1705202189606</figcaption>\r\n</figure>\r\n<figure>\r\n<img src=\"7.png\" alt=\"1705202209567\" />\r\n<figcaption aria-hidden=\"true\">1705202209567</figcaption>\r\n</figure>\r\n<ul>\r\n<li>top.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> top(clk, reset, btn, an, sseg, current_floor, goal_floor);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> reset;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">3</span>:<span class=\"number\">0</span>] an;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">6</span>:<span class=\"number\">0</span>] sseg;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] hex_in;        <span class=\"comment\">//存储要显示的楼层数字</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] btn;                 <span class=\"comment\">// 按钮输入</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] current_floor;      <span class=\"comment\">// 当前楼层（例如01000）</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span>  [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] goal_floor;      <span class=\"comment\">// 呼叫的楼层（例如01000）</span></span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"keyword\">localparam</span> N = <span class=\"number\">18</span>;         <span class=\"comment\">//分频系数(50MHZ/2^16)</span></span><br><span class=\"line\">\t<span class=\"keyword\">reg</span> [N-<span class=\"number\">1</span>:<span class=\"number\">0</span>] regN;          <span class=\"comment\">//高两位作为控制信号，低16位为计数器，对时钟进行分频</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk, <span class=\"keyword\">posedge</span> reset) <span class=\"keyword\">begin</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(reset) regN &lt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span> regN &lt;= regN + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">    <span class=\"keyword\">solve</span> u1(<span class=\"variable\">.clk</span>(clk),</span><br><span class=\"line\">             <span class=\"variable\">.rst</span>(reset),</span><br><span class=\"line\">             <span class=\"variable\">.btn</span>(btn),</span><br><span class=\"line\">             <span class=\"variable\">.key_pulse</span>(),</span><br><span class=\"line\">             <span class=\"variable\">.current_floor</span>(current_floor),</span><br><span class=\"line\">             <span class=\"variable\">.goal_floor</span>(goal_floor)</span><br><span class=\"line\">             );</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">always</span> @ * <span class=\"keyword\">begin</span></span><br><span class=\"line\">\t   <span class=\"keyword\">case</span>(regN[N-<span class=\"number\">1</span> : N-<span class=\"number\">2</span>])</span><br><span class=\"line\">\t       <span class=\"number\">2&#x27;b00</span>: <span class=\"keyword\">begin</span></span><br><span class=\"line\">\t           an = <span class=\"number\">4&#x27;b0111</span>; <span class=\"comment\">//选中第1个数码管</span></span><br><span class=\"line\">\t           hex_in = current_floor;</span><br><span class=\"line\">\t       <span class=\"keyword\">end</span></span><br><span class=\"line\">\t       <span class=\"number\">2&#x27;b11</span>:<span class=\"keyword\">begin</span></span><br><span class=\"line\">\t           an = <span class=\"number\">4&#x27;b1110</span>;<span class=\"comment\">//选中第四个数码管</span></span><br><span class=\"line\">\t           hex_in =  goal_floor;</span><br><span class=\"line\">\t       <span class=\"keyword\">end</span></span><br><span class=\"line\">\t   <span class=\"keyword\">endcase</span></span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">always</span>@ * <span class=\"keyword\">begin</span></span><br><span class=\"line\">\t   <span class=\"keyword\">case</span>(hex_in)</span><br><span class=\"line\">\t       <span class=\"number\">5&#x27;b00000</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0000001</span>;</span><br><span class=\"line\">\t       <span class=\"number\">5&#x27;b00001</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b1001111</span>;</span><br><span class=\"line\">\t       <span class=\"number\">5&#x27;b00010</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0010010</span>;</span><br><span class=\"line\">\t       <span class=\"number\">5&#x27;b00100</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0000110</span>;</span><br><span class=\"line\">\t       <span class=\"number\">5&#x27;b01000</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b1001100</span>;</span><br><span class=\"line\">\t       <span class=\"number\">5&#x27;b10000</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b0100100</span>;</span><br><span class=\"line\">\t       <span class=\"keyword\">default</span>: sseg[<span class=\"number\">6</span>:<span class=\"number\">0</span>] = <span class=\"number\">7&#x27;b1111111</span>;</span><br><span class=\"line\">\t   <span class=\"keyword\">endcase</span></span><br><span class=\"line\">\t<span class=\"keyword\">end</span></span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>solve.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> <span class=\"keyword\">solve</span>(clk, rst, btn, key_pulse, current_floor, goal_floor);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> rst;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] btn;</span><br><span class=\"line\">\t<span class=\"keyword\">output</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] current_floor;</span><br><span class=\"line\">\t<span class=\"keyword\">output</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] goal_floor; </span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">wire</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] key_edge;         <span class=\"comment\">// 按键松开时，其为1，使得cnt清零，产生延时</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] key_lat;           <span class=\"comment\">// 存储上一个触发时的按键值</span></span><br><span class=\"line\">\t<span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] key_now;           <span class=\"comment\">// 存储当前时刻触发的按键值</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">negedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            key_now &lt;= &#123;<span class=\"number\">5</span>&#123;<span class=\"number\">1&#x27;b1</span>&#125;&#125;;</span><br><span class=\"line\">            key_lat &lt;= &#123;<span class=\"number\">5</span>&#123;<span class=\"number\">1&#x27;b1</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">            key_now &lt;= btn;</span><br><span class=\"line\">            key_lat &lt;= key_now;</span><br><span class=\"line\">        <span class=\"keyword\">end</span>    </span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">assign</span>  key_edge = key_lat &amp; (~key_now);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//产生20ms延时，当检测到key_edge有效是计数器清零开始计数</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span>\t[<span class=\"number\">17</span>:<span class=\"number\">0</span>] cnt;    </span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">negedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rst) cnt &lt;= <span class=\"number\">18&#x27;h0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(key_edge) cnt &lt;= <span class=\"number\">18&#x27;h0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> cnt &lt;= cnt + <span class=\"number\">1&#x27;h1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\">// 用f1、f2俩变量来控制实现&quot;只用按一次按钮就可以，不用一直按&quot;的效果</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] f1;</span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] f2;</span><br><span class=\"line\">    <span class=\"comment\">// 延时更新f1</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">negedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst) f1 &lt;= &#123;<span class=\"number\">5</span>&#123;<span class=\"number\">1&#x27;b0</span>&#125;&#125;;                </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (cnt==<span class=\"number\">18&#x27;h3ffff</span>) f1 &lt;= btn;  </span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"comment\">// f2随时保持f1的节奏</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">negedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst) f2 &lt;= &#123;<span class=\"number\">5</span>&#123;<span class=\"number\">1&#x27;b0</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> f2 &lt;= f1;             </span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 一开始俩都是0000，所以key_pulse不会改变</span></span><br><span class=\"line\">    <span class=\"comment\">// 一直按住某个按键的话，就会出现f2 = 0, f1 = 1的情况，此时key_pulse会翻转为1</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果按住某个按键，然后松开的话，那么会使得cnt重新为0。也就是f1 = 1的情况会延时一段时间，此时f2趁机更新为1。</span></span><br><span class=\"line\">    <span class=\"comment\">// 从而延时这段时间，不会使得key_pulse翻转</span></span><br><span class=\"line\">    <span class=\"comment\">// 当延时到了，就会出现，key_sec更新为0，f2 = 1的情况。此时也不会使得key_pulse翻转</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后重新回到俩都是0的情况</span></span><br><span class=\"line\">    <span class=\"comment\">// 当再按一次时，就会出现如上的情况，从而实现&quot;取消&quot;的功能</span></span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">5</span>-<span class=\"number\">1</span>:<span class=\"number\">0</span>] key_pulse;      <span class=\"comment\">// 处理后的按键状态</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk <span class=\"keyword\">or</span> <span class=\"keyword\">negedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rst) key_pulse &lt;= &#123;<span class=\"number\">5</span>&#123;<span class=\"number\">1&#x27;b0</span>&#125;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span>                                              </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~f2[<span class=\"number\">4</span>] &amp; f1[<span class=\"number\">4</span>]) key_pulse[<span class=\"number\">4</span>] &lt;= ~key_pulse[<span class=\"number\">4</span>];    </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~f2[<span class=\"number\">3</span>] &amp; f1[<span class=\"number\">3</span>]) key_pulse[<span class=\"number\">3</span>] &lt;= ~key_pulse[<span class=\"number\">3</span>];   </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~f2[<span class=\"number\">2</span>] &amp; f1[<span class=\"number\">2</span>]) key_pulse[<span class=\"number\">2</span>] &lt;= ~key_pulse[<span class=\"number\">2</span>];    </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~f2[<span class=\"number\">1</span>] &amp; f1[<span class=\"number\">1</span>]) key_pulse[<span class=\"number\">1</span>] &lt;= ~key_pulse[<span class=\"number\">1</span>];  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(~f2[<span class=\"number\">0</span>] &amp; f1[<span class=\"number\">0</span>]) key_pulse[<span class=\"number\">0</span>] &lt;= ~key_pulse[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">end</span>  </span><br><span class=\"line\">    <span class=\"keyword\">end</span>  </span><br><span class=\"line\">       </span><br><span class=\"line\"></span><br><span class=\"line\">    get_floor u2(<span class=\"variable\">.clk</span>(clk),</span><br><span class=\"line\">                 <span class=\"variable\">.rst</span>(rst),</span><br><span class=\"line\">                 <span class=\"variable\">.key_pulse</span>(key_pulse),</span><br><span class=\"line\">                 <span class=\"variable\">.current_floor</span>(current_floor),</span><br><span class=\"line\">                 <span class=\"variable\">.goal_floor</span>(goal_floor)</span><br><span class=\"line\">                 );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n<ul>\r\n<li>get_floor.v</li>\r\n</ul>\r\n<figure class=\"highlight verilog\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">module</span> get_floor(clk, rst, key_pulse, current_floor, goal_floor);</span><br><span class=\"line\">    <span class=\"keyword\">input</span> clk;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> rst;</span><br><span class=\"line\">    <span class=\"keyword\">input</span> [<span class=\"number\">4</span>:<span class=\"number\">0</span>] key_pulse;\t</span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">4</span>:<span class=\"number\">0</span>] current_floor;</span><br><span class=\"line\">    <span class=\"keyword\">output</span> <span class=\"keyword\">reg</span> [<span class=\"number\">4</span>:<span class=\"number\">0</span>] goal_floor; </span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"keyword\">initial</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">        goal_floor = <span class=\"number\">5&#x27;b00001</span>;</span><br><span class=\"line\">        current_floor = <span class=\"number\">5&#x27;b00001</span>;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    <span class=\"comment\">// 时钟分频器：每过1s，clk_out=~clk_out。实现&quot;每一秒钟，电梯移动一层&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> [<span class=\"number\">30</span>:<span class=\"number\">0</span>] cnt = <span class=\"number\">30&#x27;b0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">parameter</span> M = <span class=\"number\">100000000</span>;  <span class=\"comment\">//1s=1000000000ns</span></span><br><span class=\"line\">    <span class=\"keyword\">reg</span> clk_out = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rst) clk_out = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cnt == M-<span class=\"number\">1</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            clk_out = ~clk_out;</span><br><span class=\"line\">            cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">begin</span></span><br><span class=\"line\">            clk_out = <span class=\"number\">0</span>;</span><br><span class=\"line\">            cnt = cnt + <span class=\"number\">1&#x27;d1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">            </span><br><span class=\"line\">    <span class=\"comment\">// 更新goal_floor</span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (*) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rst) goal_floor = <span class=\"number\">5&#x27;b00001</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> goal_floor = key_pulse;</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"comment\">// 更新current_floor     </span></span><br><span class=\"line\">    <span class=\"keyword\">always</span> @ (<span class=\"keyword\">posedge</span> clk_out <span class=\"keyword\">or</span> <span class=\"keyword\">posedge</span> rst) <span class=\"keyword\">begin</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rst) current_floor = <span class=\"number\">5&#x27;b00001</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(goal_floor != <span class=\"number\">5&#x27;b00000</span>) <span class=\"keyword\">begin</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(current_floor &lt; goal_floor)               <span class=\"comment\">//电梯所在楼层低于目标楼层则上升</span></span><br><span class=\"line\">                current_floor = &#123;current_floor[<span class=\"number\">3</span>:<span class=\"number\">0</span>], current_floor[<span class=\"number\">4</span>]&#125;;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(current_floor &gt; goal_floor)         <span class=\"comment\">//电梯所在楼层高于目标楼层则下降</span></span><br><span class=\"line\">                current_floor = &#123;current_floor[<span class=\"number\">0</span>], current_floor[<span class=\"number\">4</span>:<span class=\"number\">1</span>]&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">end</span></span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">           </span><br><span class=\"line\"><span class=\"keyword\">endmodule</span></span><br></pre></td></tr></table></figure>\r\n","categories":["4. 大学","数字逻辑"]},{"title":"数学知识补充","url":"/2023/10/31/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/","content":"<p>论文中涉及到许多基础数学知识，但是在论文里单独展开篇幅太长了。所以统一在这篇blog里记录。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"lipschitz连续\">Lipschitz连续</h3>\r\n<p>先看连续的定义：函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>在点<span class=\"math inline\">\\(x =\r\nx_0\\)</span>连续<span class=\"math inline\">\\(\\iff\\)</span> <span\r\nclass=\"math inline\">\\(\\lim_{x \\rightarrow x_0}f(x) = f(x_0) \\iff \\forall\r\n\\varepsilon&gt;0, \\exists\\delta = \\delta(\\varepsilon)&gt;0\\)</span>,\r\n使得当<span class=\"math inline\">\\(|x - x_0| &lt;\r\n\\delta\\)</span>时，有<span class=\"math inline\">\\(|f(x) - f(x_0)| &lt;\r\n\\varepsilon\\)</span></p>\r\n<p>在此定义中，<span class=\"math inline\">\\(\\delta\\)</span>不仅与<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>有关，而且与<span\r\nclass=\"math inline\">\\(x_0\\)</span>有关，应记为<span\r\nclass=\"math inline\">\\(\\delta = \\delta(x_0,\r\n\\varepsilon)\\)</span>。也就是说，对于同一个<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>，在不同的<span\r\nclass=\"math inline\">\\(x_0\\)</span>处，使<span\r\nclass=\"math inline\">\\(|f(x) - f(x_0)| &lt;\r\n\\varepsilon\\)</span>的x取值范围可以差得很多。</p>\r\n<p>所以我们自然会问，对于<span class=\"math inline\">\\(\\forall \\varepsilon\r\n&gt; 0\\)</span>，是否存在只与<span\r\nclass=\"math inline\">\\(\\varepsilon\\)</span>有关的<span\r\nclass=\"math inline\">\\(\\delta\\)</span>，使得对于区间中任意两点<span\r\nclass=\"math inline\">\\(x_1, x_2\\)</span>，只要满足<span\r\nclass=\"math inline\">\\(|x_1 - x_2| &lt; \\delta\\)</span>，就成立<span\r\nclass=\"math inline\">\\(|f(x_1) - f(x_2)| &lt; \\varepsilon\\)</span>？</p>\r\n<p>这就引出了一致连续的定义：设函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>在区间X上有定义，若<span\r\nclass=\"math inline\">\\(\\forall \\varepsilon &gt; 0, \\exists\\delta =\r\n\\delta(\\varepsilon) &gt; 0\\)</span>，使得对于区间X中的任意两点<span\r\nclass=\"math inline\">\\(x_1, x_2\\)</span>，只要满足<span\r\nclass=\"math inline\">\\(|x_1 - x_2| &lt; \\delta\\)</span>，就成立<span\r\nclass=\"math inline\">\\(|f(x_1) - f(x_2)| &lt;\r\n\\varepsilon\\)</span>，则称函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>在区间X上一致连续。</p>\r\n<p>可以发现一致连续是比连续更强的一个条件。接下来要讲的Lipschitz连续，是比一致连续还要强的一个条件。</p>\r\n<p>先给出Lipschitz连续的定义：设函数<span\r\nclass=\"math inline\">\\(f(x)\\)</span>在区间X上有定义，若存在<span\r\nclass=\"math inline\">\\(L &gt; 0\\)</span>，使得对于区间X中的任意两点<span\r\nclass=\"math inline\">\\(x_1, x_2\\)</span>，都满足<span\r\nclass=\"math inline\">\\(|f(x_1) - f(x_2)| \\le L|x_1 -\r\nx_2|\\)</span>，则称<span\r\nclass=\"math inline\">\\(f(x)\\)</span>在区间X上是Lipschitz连续。</p>\r\n<blockquote>\r\n<p>下面证明Lipschitz连续是比一致连续更强的一个条件：</p>\r\n<p>证明：<span class=\"math inline\">\\(\\forall \\varepsilon &gt;\r\n0\\)</span>，取<span class=\"math inline\">\\(\\delta = \\frac{\\varepsilon}{L}\r\n&gt; 0\\)</span>，则<span class=\"math inline\">\\(\\forall x_1, x_2 \\in\r\nX\\)</span>，当<span class=\"math inline\">\\(|x_1 - x_2| &lt;\r\n\\delta\\)</span>时，<span class=\"math inline\">\\(|f(x1) - f(x_2)| \\le\r\nL|x_1 - x_2| &lt; L\\delta = L \\cdot \\frac{\\varepsilon}{L} =\r\n\\varepsilon\\)</span>，得证。</p>\r\n</blockquote>\r\n<h3 id=\"矩阵范数\">矩阵范数</h3>\r\n<h4 id=\"矩阵范数定义\">1. 矩阵范数定义</h4>\r\n<p>矩阵范数的定义如下：</p>\r\n<p>若函数<span class=\"math inline\">\\(f: R^{n \\times n} \\rightarrow\r\nR\\)</span>满足：</p>\r\n<ol type=\"1\">\r\n<li>正定性：<span class=\"math inline\">\\(f(A) \\ge 0, \\forall A \\in R^{n\r\n\\times n}\\)</span>，等号当且仅当<span class=\"math inline\">\\(A =\r\n0\\)</span>成立</li>\r\n<li>齐次性：<span class=\"math inline\">\\(f(\\alpha A) = |\\alpha| \\cdot\r\nf(A), \\forall A \\in R^{n \\times n}, \\alpha \\in R​\\)</span></li>\r\n<li>三角不等式：<span class=\"math inline\">\\(f(A \\pm B) \\le f(A) + f(B),\r\n\\forall A, B \\in R^{n \\times n}\\)</span></li>\r\n<li>相容性：<span class=\"math inline\">\\(f(AB) \\le f(A) \\cdot f(B),\r\n\\forall A, B \\in R^{n \\times n}\\)</span></li>\r\n</ol>\r\n<p>则将<span class=\"math inline\">\\(f(x)\\)</span>称为<span\r\nclass=\"math inline\">\\(R^{n \\times n}\\)</span>上的范数，记作<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|\\)</span></p>\r\n<p>还有一条性质，有些矩阵范数也是满足的，即与向量的相容性：</p>\r\n<p><span class=\"math inline\">\\(f(Ax) \\le f(A) \\cdot f(x), \\forall A \\in\r\nR^{n \\times n}, x \\in R^{n}\\)</span></p>\r\n<h4 id=\"算子从属范数\">2. 算子(从属)范数</h4>\r\n<p>矩阵范数跟向量范数一样，有很多种。但大多数情况都是用的算子(从属)范数中的二范数（谱范数）。</p>\r\n<p>先来介绍一下算子范数</p>\r\n<p>定义：设<span class=\"math inline\">\\(\\|\\cdot\\|\\)</span>是<span\r\nclass=\"math inline\">\\(R^n\\)</span>上的任意一个范数，若对<span\r\nclass=\"math inline\">\\(\\forall A \\in R^{n \\times n}\\)</span>满足 <span\r\nclass=\"math display\">\\[\r\n\\|A\\| = max_{x \\ne 0} \\frac{\\|Ax\\|}{\\|x\\|} = max_{\\|x\\| = 1} \\|Ax\\|\r\n\\]</span> 则矩阵范数<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|\\)</span>称为从属于向量范数的矩阵范数。也叫由向量范数诱导出来的算子范数。</p>\r\n<p>算子范数肯定是满足矩阵范数的四条定义的，而且它还满足与向量的相容性！（证明网上一大堆略）</p>\r\n<p>另外，对于所有的矩阵算子范数，它们都是等价的。俩矩阵范数等价的定义如下：</p>\r\n<p>俩矩阵范数<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|_\\alpha\\)</span>与<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|_\\beta\\)</span>等价，当且仅当存在两个正数<span\r\nclass=\"math inline\">\\(d_1, d_2\\)</span>，使得对于任意矩阵A，都有<span\r\nclass=\"math inline\">\\(d_1\\|A\\|_\\beta \\le \\|A\\|_\\alpha \\le\r\nd_2\\|A\\|_\\beta\\)</span></p>\r\n<p>一般我们推导不常用范数的有界性时，先推容易算的范数的有界性，再用所有范数等价这条性质来放缩。</p>\r\n<h4 id=\"矩阵二范数谱范数\">3. 矩阵二范数（谱范数）</h4>\r\n<p>如果算子范数角标取2，就变成了谱范数： <span class=\"math display\">\\[\r\n\\|A\\|_2 = max_{x \\ne 0} \\frac{\\|Ax\\|_2}{\\|x\\|_2} = max_{\\|x\\|_2 = 1}\r\n\\|Ax\\|_2\r\n\\]</span>\r\n矩阵A的谱范数的实际意义是”矩阵A能将向量放大的最大倍数“。在数值上为矩阵A的最大奇异值（<span\r\nclass=\"math inline\">\\(\\sqrt{\\lambda_{max}(A^TA)}\\)</span>）。</p>\r\n<p>那为啥要叫谱范数呢？它跟谱半径又有什么关系呢？</p>\r\n<p>先回忆一下矩阵谱半径的定义：<span\r\nclass=\"math inline\">\\(\\rho(A)=\\max\\{|\\lambda|:\\lambda\\in\\lambda(A)\\}\\)</span></p>\r\n<p>当<span\r\nclass=\"math inline\">\\(A\\)</span>为对称矩阵时，其特征值的绝对值就是它的奇异值。所以有<span\r\nclass=\"math inline\">\\(\\rho(A) = \\sqrt{\\lambda_{max}(A^TA)} =\r\n\\|A\\|_2\\)</span></p>\r\n<p>这就是为什么矩阵二范数别称叫谱范数的原因hhhh。</p>\r\n<h4 id=\"几个与谱半径有关的定理\">4. 几个与谱半径有关的定理</h4>\r\n<h5 id=\"section\">4.1</h5>\r\n<p>定理：谱半径小于等于任意一种范数</p>\r\n<p>证明：设<span\r\nclass=\"math inline\">\\(\\lambda\\)</span>为A的特征值，则<span\r\nclass=\"math inline\">\\(A\\alpha =\r\n\\lambda\\alpha\\)</span>，两边同时取范数得<span\r\nclass=\"math inline\">\\(\\|A\\alpha\\| = \\|\\lambda\\alpha\\|\\)</span>。</p>\r\n<p>由于算子范数满足与向量的相容性和齐次性，所以有：<span\r\nclass=\"math inline\">\\(\\|A\\alpha\\| = |\\lambda|\\|\\alpha\\| \\le\r\n\\|\\alpha\\|\\|A\\|\\)</span></p>\r\n<p>同除<span class=\"math inline\">\\(\\|\\alpha\\|\\)</span>，得：<span\r\nclass=\"math inline\">\\(|\\lambda| \\le \\|A\\|\\)</span></p>\r\n<p>所以<span class=\"math inline\">\\(\\rho(A) = |\\lambda|_{max} \\le\r\n\\|A\\|\\)</span>，得证。</p>\r\n<h5 id=\"section-1\">4.2</h5>\r\n<p>定理：<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}A^k=0\\Leftrightarrow\\rho(A)&lt;1\\)</span></p>\r\n<p>充分性：因为<span class=\"math inline\">\\(\\rho(A) &lt;\r\n1\\)</span>，所以必然可以找到一个矩阵范数，s.t. <span\r\nclass=\"math inline\">\\(\\|A\\| &lt; 1\\)</span>。</p>\r\n<p>所以<span class=\"math inline\">\\(\\|A^k\\| \\le \\|A\\|^k\\)</span>，当<span\r\nclass=\"math inline\">\\(k \\rightarrow \\infty\\)</span>时，<span\r\nclass=\"math inline\">\\(\\|A^k\\| \\le \\|A\\|^k \\rightarrow 0\\)</span>。</p>\r\n<p>又因为矩阵范数满足正定性，所以<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}A^k=0\\)</span></p>\r\n<p>必要性（反证法）：假设<span class=\"math inline\">\\(\\rho(A) \\ge\r\n1\\)</span>，设<span class=\"math inline\">\\(\\lambda\\)</span>为满足<span\r\nclass=\"math inline\">\\(|\\lambda| \\ge 1\\)</span>的特征值，假设<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>为对应的特征向量，则有<span\r\nclass=\"math inline\">\\(A^k\\alpha = \\lambda^k\\alpha\\)</span></p>\r\n<p>两边取范数，得：<span\r\nclass=\"math inline\">\\(\\left\\|A^k\\alpha\\right\\|=\\left\\|\\lambda^k\\alpha\\right\\|=\\left|\\lambda^k\\right|\\left\\|\\alpha\\right\\|\\geq\\left\\|\\alpha\\right\\|\\)</span></p>\r\n<p>又因为<span\r\nclass=\"math inline\">\\(\\|A^k\\alpha\\|\\leq\\|A^k\\|\\|\\alpha\\|\\)</span></p>\r\n<p>所以<span class=\"math inline\">\\(\\|A^k\\|\\|\\alpha\\| \\ge\r\n\\|\\alpha\\|\\)</span></p>\r\n<p>同除，得：<span class=\"math inline\">\\(\\|A^k\\| \\ge 1\\)</span></p>\r\n<p>与<span\r\nclass=\"math inline\">\\(\\lim_{k\\to\\infty}A^k=0\\)</span>矛盾，所以假设不成立，所以<span\r\nclass=\"math inline\">\\(\\rho(A) &lt; 1\\)</span>，得证。</p>\r\n<h5 id=\"section-2\">4.3</h5>\r\n<p>设<span class=\"math inline\">\\(A \\in R^{n \\times\r\nn}\\)</span>，则有：</p>\r\n<ol type=\"1\">\r\n<li><p><span class=\"math inline\">\\(\\sum_{k=0}^{\\infty}A^{k}\\)</span>收敛\r\n可推出 <span class=\"math inline\">\\(\\rho(A) &lt; 1\\)</span></p></li>\r\n<li><p>当<span\r\nclass=\"math inline\">\\(\\sum_{k=0}^{\\infty}A^{k}\\)</span>收敛时，它将收敛于：\r\n<span class=\"math display\">\\[\r\n\\sum_{k=0}^{\\infty}A^{k} = (I - A)^{-1}\r\n\\]</span> 而且存在一种算子范数<span\r\nclass=\"math inline\">\\(\\|\\cdot\\|\\)</span>，使得 <span\r\nclass=\"math display\">\\[\r\n\\|(I-A)^{-1}-\\sum_{k=0}^mA^k\\|\\leq\\frac{\\|A\\|^{m+1}}{1-\\|A\\|}, m \\in\r\n\\mathbb{N}\r\n\\]</span></p></li>\r\n</ol>\r\n<p>证明：第一条很容易证明，当收敛时它的第无穷项肯定是收敛于0的，然后由4.2即可推出。</p>\r\n<p>下面证明第二条：</p>\r\n<p>因为<span class=\"math inline\">\\(\\rho(A) &lt; 1\\)</span>，所以<span\r\nclass=\"math inline\">\\(I - A\\)</span>的特征值<span\r\nclass=\"math inline\">\\(1 - \\lambda \\ne 0\\)</span>，因此<span\r\nclass=\"math inline\">\\(|I - A| \\ne 0\\)</span>，所以<span\r\nclass=\"math inline\">\\(I - A\\)</span>可逆。</p>\r\n<p>又因为<span\r\nclass=\"math inline\">\\((I-A)(I+A+\\ldots+A^k)=I-A^{k+1}\\)</span></p>\r\n<p>所以<span\r\nclass=\"math inline\">\\((I+A+\\ldots+A^k)=(I-A)^{-1}(I-A^{k+1})\\)</span></p>\r\n<p>又因为<span class=\"math inline\">\\(k \\rightarrow 0\\)</span>时，<span\r\nclass=\"math inline\">\\(A^{k+1} \\rightarrow 0\\)</span></p>\r\n<p>所以<span\r\nclass=\"math inline\">\\((I+A+\\ldots+A^k)=(I-A)^{-1}\\)</span></p>\r\n<p>即<span\r\nclass=\"math inline\">\\(\\sum_{k=0}^{\\infty}A^k=(I-A)^{-1}\\)</span></p>\r\n<h4 id=\"总结\">5. 总结</h4>\r\n<p>介绍了矩阵范数。重点讲解了矩阵二范数（谱范数）。以及介绍了与谱半径相关的定理。</p>\r\n<ol type=\"1\">\r\n<li>定理1是将谱半径与矩阵范数联系起来</li>\r\n<li>定理2讨论了矩阵阶乘收敛问题</li>\r\n<li>定理3讨论了矩阵阶乘数列之和收敛问题</li>\r\n</ol>\r\n","categories":["1. 论文"]},{"title":"数字逻辑自学笔记","url":"/2023/10/06/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"<p>写于2023/10/6，这门课其实还是有点意思的。但是上个月身体原因一直在关心我自己的身体，所以这门课我全翘掉了，一点没听。现在马上就要实验课了，于是打算在国庆的末尾把这门课学了。目的是能做出几个组合逻辑电路的实验项目。</p>\r\n<span id=\"more\"></span>\r\n<p>upd: (2024/1/14)：这门课满绩了，考试很简单，都是笔记里的东西。</p>\r\n<hr />\r\n<p>自学参考的内容为老师ppt、各种网上博客。</p>\r\n<p>学完后打算去刷题巩固一下，刷题打算在一个up主视频里刷：<a\r\nhref=\"https://www.bilibili.com/video/BV1H54y1k7kM?p=1&amp;vd_source=2501060da9b4bef86e2b8ec8a8d880b5\">传送门</a></p>\r\n<p>最后，如果有朋友打算认真看这篇Blog进行学习的话，为了更好的阅读体验建议开梯子，因为本文有许多图片和一个视频。（存储在github中）</p>\r\n<p>先放一张各种门的符号图，后面忘了的话可以参考：</p>\r\n<p><img src=\"数字逻辑自学笔记/1.png\" /></p>\r\n<p><img src=\"2.png\" /></p>\r\n<h3 id=\"一.-组合逻辑电路1\">一. 组合逻辑电路(1)</h3>\r\n<h4 id=\"概述\">1.1. 概述</h4>\r\n<p>电路分为组合逻辑电路和时序逻辑电路。差别就是组合逻辑电路无记忆功能，时序逻辑电路有。</p>\r\n<p>描述电路的逻辑功能有以下几种形式：</p>\r\n<ol type=\"1\">\r\n<li>语言描述</li>\r\n<li>电路图</li>\r\n<li>逻辑表达式，即y = f(a1, a2, a3, ..., an)</li>\r\n<li>真值表</li>\r\n<li>卡诺图</li>\r\n<li>波形图</li>\r\n</ol>\r\n<h4 id=\"组合逻辑电路的分析-和-逻辑函数的设计方法\">1.2.\r\n组合逻辑电路的分析 和 逻辑函数的设计方法</h4>\r\n<ul>\r\n<li><p><strong>分析</strong>：</p>\r\n<ul>\r\n<li><p>即给你一个电路，让你告诉我这个电路是干啥用的。</p></li>\r\n<li><p>分析一个组合逻辑电路的固定套路很简单：</p>\r\n<ol type=\"1\">\r\n<li>一层一层写出逻辑表达式</li>\r\n<li>对最后得到的逻辑表达式进行化简\r\n<ul>\r\n<li>化简手段1：卡诺图</li>\r\n<li>化简手段2：<span class=\"math inline\">\\(A + A \\cdot B = A 或 A \\cdot\r\n(A + B) = A\\)</span></li>\r\n<li>化简手段3：<span class=\"math inline\">\\(A + \\overline{A}B = A + B 或\r\nA \\cdot (\\overline{A} + B) = A \\cdot B\\)</span></li>\r\n<li>化简手段4：<span class=\"math inline\">\\(\\overline{A}\\overline{C} +\r\nA\\overline{B} + \\overline{B}\\overline{C} = \\overline{A}\\overline{C} +\r\nA\\overline{B}\\)</span>（对于<span\r\nclass=\"math inline\">\\(\\overline{B}\\overline{C}\\)</span>添项即可证明）</li>\r\n<li>化简手段5：<span class=\"math inline\">\\(A \\oplus B = \\overline{A}B +\r\nA\\overline{B}\\)</span></li>\r\n<li>化简手段6：<span class=\"math inline\">\\(A \\odot B = (\\overline{A} +\r\nB)(A + \\overline{B})\\)</span></li>\r\n</ul></li>\r\n<li>对化简后的逻辑表达式列真值表，观察真值表，观察出此电路的功能</li>\r\n</ol></li>\r\n<li><p>例子：</p>\r\n<p><img src=\"3.png\" /></p>\r\n<ul>\r\n<li>T1是个与门，T2是个或门，第一层剩下都是与门，第二层一个或门，第三层一个非门，第四层一个与门，最后一层一个或门。最后通过真值表很容易看出ABC三个输入变量但有两个输出变量。不难想到是一个全加器。A、B是两个加数，C是上一位的进位，F1是当前位，F2是进位。</li>\r\n<li>还有许多功能电路啦...\r\n...比如半加器（2输入2输出）、投票表决器（多输入1输出）、奇校验电路（多输入1输出）、一致性电路（多输入1输出）</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p><strong>设计</strong>：</p>\r\n<ul>\r\n<li><p>告诉你一个功能，让你设计出一个电路来实现它。</p></li>\r\n<li><p>也是有固定套路的：</p>\r\n<ol type=\"1\">\r\n<li><p>分析功能，确定输入输出变量</p>\r\n<ul>\r\n<li>确定输入输出变量还是有点讲究的，有时候设计的好了可以大大减少运算量和电路的复杂程度。比如下面两个功能，换做是你，你会怎样设计？</li>\r\n</ul>\r\n<p><img src=\"4.png\" /> <img src=\"5.png\" /></p>\r\n<ul>\r\n<li>设计的关键其实是做到尽可能的<strong>复用</strong>，即对于不同对象的同一属性，尽量用一个变量表达出来。</li>\r\n</ul></li>\r\n<li><p>根据题意，直接构造出电路。或者写出真值表然后写出主析取范式然后再用卡诺图化简后得到最终逻辑表达式</p></li>\r\n<li><p>根据逻辑表达式，选取一种门电路，画出电路图</p></li>\r\n</ol></li>\r\n</ul></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"二.-组合逻辑电路2\">二. 组合逻辑电路(2)</h3>\r\n<p>上一节我们已经可以设计出逻辑表达式。但是具体选用哪一种门电路呢？每一种门电路应该如何设计呢？这一节我们就来学习。</p>\r\n<h4 id=\"单输出电路设计\">2.1. 单输出电路设计</h4>\r\n<h5 id=\"用与非门设计电路\">2.1.1. 用与非门设计电路</h5>\r\n<p>对于逻辑表达式F = ...中的 + 全部换成 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> 就好了，按照这个思路，只要在 +\r\n的头上画两根取反号就行了，最上面那根保留，下面那根负责把 + 换成 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> 。</p>\r\n<p>但这样得到的实际电路可能耗材过多，实际中有些式子通过观察还能发现可以化的更简，比如下面这个例子：</p>\r\n<p><span class=\"math inline\">\\(F = A\\overline{B} + B\\overline{C} +\r\nC\\overline{D} + D\\overline{A} = \\overline{\\overline{A\\overline{B}} \\cdot\r\n\\overline{B\\overline{C}} \\cdot \\overline{C\\overline{D}} \\cdot\r\n\\overline{D\\overline{A}}}\\)</span></p>\r\n<p>按理说这样就好了，但是还可以化简的。</p>\r\n<p><span class=\"math inline\">\\(\\overline{A\\overline{B}} \\cdot\r\n\\overline{B\\overline{C}} \\cdot \\overline{C\\overline{D}} \\cdot\r\n\\overline{D\\overline{A}} = (\\overline{A} + B)(\\overline{B} +\r\nC)(\\overline{C} + D)(\\overline{D} + A)\\)</span></p>\r\n<p>上面这个东西，学过二项式定理吗？假如我第一项如果挑B，则第二项不能挑<span\r\nclass=\"math inline\">\\(\\overline{B}\\)</span>，只能挑C，那么第三项也只能挑D，依次类推，第四项只能挑A，得到ABCD。同理，如果我第一项挑<span\r\nclass=\"math inline\">\\(\\overline{A}\\)</span>，那么我只能得到<span\r\nclass=\"math inline\">\\(\\overline{A}\\overline{B}\\overline{C}\\overline{D}\\)</span>。</p>\r\n<p>即：<span class=\"math inline\">\\((\\overline{A} + B)(\\overline{B} +\r\nC)(\\overline{C} + D)(\\overline{D} + A) = ABCD +\r\n\\overline{A}\\overline{B}\\overline{C}\\overline{D}\\)</span></p>\r\n<p>对上面那玩意再求两次反，得到<span\r\nclass=\"math inline\">\\(\\overline{\\overline{ABCD} \\cdot\r\n\\overline{\\overline{A}\\overline{B}\\overline{C}\\overline{D}}}\\)</span></p>\r\n<p>这样子，就得到<span class=\"math inline\">\\(F =\r\n\\overline{\\overline{\\overline{ABCD} \\cdot\r\n\\overline{\\overline{A}\\overline{B}\\overline{C}\\overline{D}}}}\\)</span></p>\r\n<p>总结下来这个第二种方法就是在第一种方法的基础上把内部通过二项式定理进一步化简。</p>\r\n<h5 id=\"用或非门设计电路\">2.1.2. 用或非门设计电路</h5>\r\n<p>对于逻辑表达式F = ...中的 <span class=\"math inline\">\\(\\cdot\\)</span>\r\n全部换成 + 就好了，按照这个思路，只要在 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span>\r\n的头上画两根取反号就行了，最上面那根保留，下面那根负责把 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> 换成 + 。</p>\r\n<p>还有第二种通用的方法，就是将F先求对偶，得到<span\r\nclass=\"math inline\">\\(F_d\\)</span>，这样F就由(xxx) + (xxx) +\r\n(xxx)的形式变为(x + x)(x + x)(x +\r\nx)的形式了。学过二项式定理吗？同理将<span\r\nclass=\"math inline\">\\(F_d\\)</span>化简，得到最简“与-或”式(yyy) +\r\n(yyy)。再在头上加两根取反，最顶上保留，下面那根为了把 + 变成 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> ，最后再对偶回去即可。</p>\r\n<p>上面那段文字是具体过程，流程总结下来如下：</p>\r\n<ol type=\"1\">\r\n<li>对F求对偶<span class=\"math inline\">\\(F_d\\)</span></li>\r\n<li>对<span\r\nclass=\"math inline\">\\(F_d\\)</span>展开，利用二项式原理或者卡诺图，得到最简\"与-或\"式<span\r\nclass=\"math inline\">\\(F_d&#39;\\)</span></li>\r\n<li>对<span\r\nclass=\"math inline\">\\(F_d&#39;\\)</span>取两次反，最上面保留，下面那根化开，得到<span\r\nclass=\"math inline\">\\(F_d&#39;&#39;\\)</span></li>\r\n<li>对<span class=\"math inline\">\\(F_d&#39;&#39;\\)</span>对偶回去</li>\r\n</ol>\r\n<h5 id=\"用与或非门设计电路\">2.1.3. 用与或非门设计电路</h5>\r\n<p>这个就更简单了，因为给出的函数表达式都是形如F = xyz + xyz +\r\nxyz，所以只需要在F头上加两条杠就好了。</p>\r\n<p>第二种思路就是跟用与非门设计电路的第二种方法一样。加两条杠，最上面不动，下面那个把xyz\r\n+ xyz +\r\nxyz变成()()()型，然后二项式定理展开即可。（如果是与非门第二种设计思路还要将展开的东西再取两次反）</p>\r\n<h4 id=\"多输出电路设计\">2.2. 多输出电路设计</h4>\r\n<p>啊，最直接的想法就是分别把每个输出对应的电路设计出来就好了。但是这样比较憨，当我们化简得到了每个输出对应的逻辑表达式的时候，我们应该能尽可能使每一项<strong>复用</strong>。看下面这个例子：</p>\r\n<p><img src=\"6.png\" /></p>\r\n<p>可以发现原<span class=\"math inline\">\\(F_1\\)</span>中的<span\r\nclass=\"math inline\">\\(A\\overline{B}\\)</span>可以变成<span\r\nclass=\"math inline\">\\(A\\overline{B}\\overline{C}\\)</span>，这样就跟<span\r\nclass=\"math inline\">\\(F_2\\)</span>中的<span\r\nclass=\"math inline\">\\(A\\overline{B}\\overline{C}\\)</span>一样了，做到了复用。</p>\r\n<h4 id=\"包含无关项的电路设计\">2.3. 包含无关项的电路设计</h4>\r\n<p>其实很简单，看下面这个例子就懂了。</p>\r\n<p><img src=\"7.png\" /></p>\r\n<p><img src=\"8.png\" /></p>\r\n<p>首先我们知道余3码是在8421码的基础上+3得到，因为8421码只有10位，所以余3码也只有10位。而且8421码最小是0000，所以余3码最小是0011（对应十进制数1）。所以这就在输出F中产生了许多无关项d。在画卡诺图时，若不考虑无关项，则把d全置为0；考虑无关项则把d全置为1。最后得到化简后的函数表达式。然后再将这个函数表达式用与非门设计。</p>\r\n<h4 id=\"考虑级数的电路设计\">2.4. 考虑级数的电路设计</h4>\r\n<p>也是看一道例题就可以理解了。</p>\r\n<p><img src=\"9.png\" /></p>\r\n<p>先用最直接的方法，与或非门直接加两条杠结束。与非门直接加两条杠，下面那条杠化开结束。</p>\r\n<p>但是这样设计级数会不会多呢？</p>\r\n<p>如果我们用\"与或非门设计电路\"中第二种化简方法，试一下：</p>\r\n<p><span class=\"math inline\">\\(F = \\overline{\\overline{AB +\r\n\\overline{A}C}} = \\overline{\\overline{AB} \\cdot\r\n\\overline{\\overline{A}C}} = \\overline{(\\overline{A} + \\overline{B})(A +\r\n\\overline{C})} = \\overline{\\overline{A}\\overline{C} + A\\overline{B} +\r\n\\overline{B}\\overline{C}} = \\overline{\\overline{A}\\overline{C} +\r\nA\\overline{B}}\\)</span></p>\r\n<p>可以发现，这样设计只有3层。但是原来那样直接加两条杠是4层。所以当考虑电路的级数时，在用与或非门设计电路时，可以考虑进一步化简优化电路的级数。</p>\r\n<p>如果用与非门，就不需要考虑进一步化简了。因为在与非门进一步化简后，还需要再内部再添加两条杠。级数肯定比不继续化简多。</p>\r\n<h4 id=\"综合题\">2.5. 综合题</h4>\r\n<ul>\r\n<li>设计一个组合电路，将8421BCD码变换为余3码。</li>\r\n</ul>\r\n<p>先确定输入输出变量，因为8421BCD码是用四个二进制数表示十进制数0~9，所以有四个输入A、B、C、D代表四个二进制数。同理四个输出W、X、Y、Z代表变换后的余3码。</p>\r\n<p>然后列出真值表，因为BCD只能表示十进制0~9，所以注意表中有无关项d。</p>\r\n<p><img src=\"10.png\" /></p>\r\n<p>这里不考虑无关项，所以在后续画卡诺图时都将d置为0。</p>\r\n<p>因为是四个输出，所以属于多输出电路。所以先画四个卡诺图得到四个逻辑表达式（其实对于Z，发现其很有规律不用画卡诺图都可以知道它就是<span\r\nclass=\"math inline\">\\(\\overline{D}\\)</span>）</p>\r\n<p>画卡诺图过程省略，得到四个逻辑表达式： <span class=\"math display\">\\[\r\nW = A + BC + BD \\\\\r\nX = \\overline{B}C + \\overline{B}D + B\\overline{C}\\overline{D} \\\\\r\nY = CD + \\overline{C}\\overline{D} \\\\\r\nZ = \\overline{D}\r\n\\]</span>\r\n此时我们需要思考，是否能做到项的<strong>复用</strong>呢？乍一看没发现能复用的，所以先不考虑复用，继续将式子进一步化简先。先从简单的开始画：</p>\r\n<p><span class=\"math inline\">\\(Z = \\overline{D}\\)</span></p>\r\n<p><span class=\"math inline\">\\(Y = \\overline{C} \\oplus D\\)</span></p>\r\n<p><span class=\"math inline\">\\(X = \\overline{B}(C + D) + B\\overline{(C +\r\nD)} = B \\oplus (C + D) = B \\oplus\r\n\\overline{\\overline{C}\\overline{D}}\\)</span></p>\r\n<p><span class=\"math inline\">\\(W = A + B(C + D) = A +\r\nB\\overline{\\overline{C}\\overline{D}}\\)</span></p>\r\n<p>化简后可以发现，<span\r\nclass=\"math inline\">\\(\\overline{\\overline{C}\\overline{D}}\\)</span>这个东西可以做到复用，真不错。</p>\r\n<p>接下来就是选择门电路来设计电路了。这里我选择最常用的与非门 +\r\n异或门设计电路。根据上面的逻辑表达式直接设计即可（W还需化简一下：<span\r\nclass=\"math inline\">\\(W = \\overline{\\overline{A} \\cdot\r\n\\overline{B\\overline{\\overline{C}\\overline{D}}}}\\)</span>）</p>\r\n<p>最后画出电路：</p>\r\n<p><img src=\"11.png\" /></p>\r\n<hr />\r\n<h3 id=\"三.-组合逻辑电路3\">三. 组合逻辑电路(3)</h3>\r\n<h4 id=\"编码器\">3.1 编码器</h4>\r\n<p>按照我的理解，就是把数字变成二进制数。比如把0 ~\r\n8变成3位二进制数，或者0 ~ 15变成4位二进制数。</p>\r\n<p>编码器分为普通编码器 和 优先编码器。</p>\r\n<ul>\r\n<li><strong>普通编码器</strong></li>\r\n</ul>\r\n<p>特点：任何时刻只允许输入一个编码信号。</p>\r\n<p>最常见的普通编码器为8线-3线编码器，如下图：</p>\r\n<p><img src=\"12.png\" /></p>\r\n<p>它的真值表如下：</p>\r\n<p><img src=\"13.png\" /></p>\r\n<p>可以看出，假如我<span\r\nclass=\"math inline\">\\(I_7\\)</span>为高电平，则输出111，就是7的二进制。</p>\r\n<p>那内部电路如何设计呢？根据真值表得出逻辑表达式然后化简，再选用与非门实现即可。</p>\r\n<p>上面这个是8线-3线普通编码器，那如何实现8421-BCD普通编码器呢？</p>\r\n<p>很简单，10个输入，4个输出。列出真值表，发现会有无关项。不考虑无关项，根据真值表得出4个输出的逻辑表达式，然后根据卡诺图化简。最后选用与非门实现即可。</p>\r\n<ul>\r\n<li><strong>优先编码器</strong></li>\r\n</ul>\r\n<p>特点：允许同时输入多个编码信号，只对其中优先权最高的一个进行编码。</p>\r\n<p>最常见的优先编码器是74148优先编码器，长下面这个样子，需要掌握：</p>\r\n<p><img src=\"14.png\" /></p>\r\n<p>这个图有两个要注意的地方，首先就是所有的<span\r\nclass=\"math inline\">\\(I\\)</span>上面都是有一个取反号的，只是这个图比较小可能看不清晰，然后所有的<span\r\nclass=\"math inline\">\\(Y、S\\)</span>上面也有取反号。还有就是看到红色箭头的地方了吗？这跟前面的8线-3线普通编码器不一样，这代表低电平有效。</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\overline{S}\\)</span>为选通输入端，只有当<span\r\nclass=\"math inline\">\\(\\overline{S} = 0\\)</span>时才能正常工作，当<span\r\nclass=\"math inline\">\\(\\overline{S} =\r\n1\\)</span>时所有输出端为封锁为高电平。</p>\r\n<p>​ <img src=\"15.png\" /></p>\r\n<p><span\r\nclass=\"math inline\">\\(\\overline{Y_s}\\)</span>为选通输出端，当<span\r\nclass=\"math inline\">\\(\\overline{Y_s} =\r\n0\\)</span>说明电路正常工作且无编码信号输入（<span\r\nclass=\"math inline\">\\(\\overline{S} = 0 且所有\\overline{I} =\r\n1\\)</span>）</p>\r\n<p>​ <img src=\"16.png\" /></p>\r\n<p><span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>为扩展端，当<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}} =\r\n0\\)</span>说明电路正常工作且有编码信号输入（<span\r\nclass=\"math inline\">\\(\\overline{S} = 0\\)</span>且存在<span\r\nclass=\"math inline\">\\(\\overline{I} = 0\\)</span>）</p>\r\n<p>​ <img src=\"17.png\" /></p>\r\n<p>知道了每个端口的作用，如何只通过输出端判断此时编码器处于什么状态呢？</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(\\overline{Y_s} =\r\n0\\)</span>：电路正常工作且无编码信号输入。（此时<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>必为1）</li>\r\n<li><span class=\"math inline\">\\(\\overline{Y_{EX}} =\r\n0\\)</span>：电路正常工作且有编码信号输入。（此时<span\r\nclass=\"math inline\">\\(\\overline{Y_s}\\)</span>必为1）</li>\r\n<li><span class=\"math inline\">\\(\\overline{Y_s} = \\overline{Y_{EX}} =\r\n1\\)</span>：电路被阻塞（此时<span\r\nclass=\"math inline\">\\(\\overline{S}\\)</span>必为1）</li>\r\n</ol>\r\n<p>最后，74148优先编码器的真值表贴上来，上面所有可能你觉得有困惑的点都可以在这张表中得到解答。</p>\r\n<p><img src=\"18.png\" /></p>\r\n<ul>\r\n<li><strong>练习</strong></li>\r\n</ul>\r\n<p>学了上面普通编码器和优先编码器的知识，来写一道题吧！</p>\r\n<blockquote>\r\n<p>请用两片74148接成16线-4线优先编码器，将16个低电平输入信号<span\r\nclass=\"math inline\">\\(\\overline{A_0} \\sim\r\n\\overline{A_{15}}\\)</span>编为'0000' ~ '1111'，其中<span\r\nclass=\"math inline\">\\(\\overline{A_{15}}\\)</span>的优先级最高。</p>\r\n</blockquote>\r\n<p>首先如果是0 ~\r\n7就直接用一片就好了。思考一下，如果是大于7怎么办？可以这样思考：</p>\r\n<p>15 = 8 + 7</p>\r\n<p>14 = 8 + 6</p>\r\n<p>13 = 8 + 5</p>\r\n<p>12 = 8 + 4</p>\r\n<p>11 = 8 + 3</p>\r\n<p>10 = 8 + 2</p>\r\n<p>9 = 8 + 1</p>\r\n<p>8 = 8 + 0</p>\r\n<p>发现规律了吗？如果是0 ~ 7直接用一片就好了，如果是8 ~\r\n15就肯定需要用到第二片，但是第二片同样能表达的范围只有0 ~ 7，所以就将8 ~\r\n15进行数字拆分。</p>\r\n<p>如果输入8，则点亮第四位输出（8421中的8），剩下3位二进制输入0</p>\r\n<p>如果输入9，则点亮第四位输出，剩下3位二进制输入1</p>\r\n<p>如果输入10，则点亮第四位输出，剩下3位二进制输入2</p>\r\n<p>... ...</p>\r\n<p>如果输入15，则点亮第四位输出，剩下3位二进制输入7</p>\r\n<p>思路就是这样，还有一些小细节我在放答案过后再解释：</p>\r\n<p><img src=\"19.png\" /></p>\r\n<p>可以看到<span\r\nclass=\"math inline\">\\(G_0、G_1、G_2\\)</span>门都采用了与非门的设计，因为两片74148必定只会用到一片的输出（0\r\n~ 7用右边那片，8 ~ 15用左边那片）。</p>\r\n<p>但是如果使得一片工作另一片就停止工作呢？注意左边那片的<span\r\nclass=\"math inline\">\\(\\overline{Y_s}\\)</span>端口，左边那片正常工作且有信号输入时输出1，使得右边那片<span\r\nclass=\"math inline\">\\(\\overline{S} =\r\n1\\)</span>，所以右边那片直接被堵塞了。如果左边那片正常工作但没信号输入时输出0，使得右边那片被激活。这样就实现了两片中只能有一片在工作。</p>\r\n<p>然后<span\r\nclass=\"math inline\">\\(Z_3\\)</span>就是第四个二进制输出。只要用到左边那片，就输出1。刚好<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>就可以实现这个功能，只要电路正常工作并且有信号输入<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>就为0，经过一个与非门之后就变成了1。</p>\r\n<h4 id=\"译码器\">3.2 译码器</h4>\r\n<p>译码器就是编码器的逆过程。编码器是给它一个数字，输出二进制。译码器就是给它一个二进制，输出一个数字。</p>\r\n<p>译码器分为二进制译码器（最小项译码器）、二—十进制译码器、显示译码器。其中二进制译码器需要掌握74138译码器。</p>\r\n<ul>\r\n<li><strong>二进制译码器（只讲74138译码器）</strong></li>\r\n</ul>\r\n<p>74138译码器长这个样子：</p>\r\n<p><img src=\"20.png\" /></p>\r\n<p>注意，跟74148解码器不同，这里的三个输入端<span\r\nclass=\"math inline\">\\(A\\)</span>都是高电平有效，输出端<span\r\nclass=\"math inline\">\\(\\overline{Y}\\)</span>是低电平有效。这里的<span\r\nclass=\"math inline\">\\(S、\\overline{S}\\)</span>是控制芯片是否工作的。</p>\r\n<p>具体来说，只有当<span class=\"math inline\">\\(S_1 = 1 且 \\overline{S_2}\r\n=0 且 \\overline{S_3} =\r\n0\\)</span>时，电路才处于正常工作状态。其余情况电路都处于被堵塞的状态。</p>\r\n<p>​ <img src=\"21.png\" /></p>\r\n<p>74138解码器的真值表如下：</p>\r\n<p><img src=\"22.png\" /></p>\r\n<ul>\r\n<li><strong>二—十进制译码器（只讲7442译码器）</strong></li>\r\n</ul>\r\n<p>我觉得二—十进制译码器就是二进制译码器啊...\r\n...搞不懂为啥还要专门分个类出来。二—十译码器就是说将4个二进制数变成十进制0\r\n~ 9。</p>\r\n<p>二—十进制译码器最常见的就是7442译码器，它的真值表如下：</p>\r\n<p><img src=\"23.png\" /></p>\r\n<p>可以看到有伪码的存在，这是为什么呢？因为4个二进制数可以表达0 ~\r\n15，但是因为是BCD码，所以我们得到的数范围是0 ~\r\n9。所以有一部分的二进制状态没有用到，没用到的地方就称为伪码。</p>\r\n<ul>\r\n<li><strong>显示译码器</strong></li>\r\n</ul>\r\n<p>啊就是能直观的显示出翻译后信息的译码器。看下面俩图就知道它是什么东西了。</p>\r\n<p><img src=\"24.png\" /><img src=\"25.png\" /></p>\r\n<ul>\r\n<li><strong>练习</strong></li>\r\n</ul>\r\n<blockquote>\r\n<p>试用两片74138组成4线-16线译码器。将输入的4位二进制代码<span\r\nclass=\"math inline\">\\(D_3D_2D_1D_0\\)</span>译成16个独立的低电平信号<span\r\nclass=\"math inline\">\\(\\overline{Z_0} \\sim\r\n\\overline{Z_{15}}\\)</span>。</p>\r\n</blockquote>\r\n<p>有了前面用两块74148组成16线-4线编码器的经验，这题的思考方式是一样的。首先如果只用一块板的话，3个二进制数，可以得到0\r\n~ 7。如果大于7怎么办呢？观察一下： <span class=\"math display\">\\[\r\n(8)_d = (1000)_b \\leftrightarrow (0)_d = (000)_b \\\\\r\n(9)_d = (1001)_b \\leftrightarrow (1)_d = (001)_b \\\\\r\n(10)_d = (1010)_b \\leftrightarrow (2)_d = (010)_b \\\\\r\n..... \\leftrightarrow ...\r\n\\]</span> 发现规律了没？</p>\r\n<p>只要四位二进制中第四位为0，将剩下3位二进制传给第一块板的三个输入接口。如果第四位二进制为1，那么堵塞第一块版，将剩下3位二进制传给第二块版的三个输入接口。答案如下：</p>\r\n<p><img src=\"26.png\" /></p>\r\n<h4 id=\"用译码器实现逻辑函数\">3.3 用译码器实现逻辑函数</h4>\r\n<p>因为任何逻辑函数均可化成最小项之和的形式。所以可以用译码器实现逻辑函数的电路，很牛逼。看下面这个例子你就懂了。</p>\r\n<p><img src=\"27.png\" /></p>\r\n<p>首先先将F化成主析取范式：<span class=\"math inline\">\\(F = ABC\r\n+AB\\overline{C} + A\\overline{B}C + \\overline{A}BC = m_7 + m_6 + m_5 +\r\nm_3\\)</span></p>\r\n<p>意思是说，只要三输入变量按照7、6、5、3的二进制输入，F就是1。否则F就是0。</p>\r\n<p>好，那我们在74138输出端将<span\r\nclass=\"math inline\">\\(\\overline{Y_7}、\\overline{Y_6}、\\overline{Y_5}、\\overline{Y_3}\\)</span>用与非门连接起来。只要三输入变量输入7、6、5、3二进制其中的一个，那么<span\r\nclass=\"math inline\">\\(\\overline{Y_7}、\\overline{Y_6}、\\overline{Y_5}、\\overline{Y_3}\\)</span>就有一个是0，与非后就得到1。如果三输入变量不属于7、6、5、3二进制中的任何一个，则<span\r\nclass=\"math inline\">\\(\\overline{Y_7}、\\overline{Y_6}、\\overline{Y_5}、\\overline{Y_3}\\)</span>都为1，与非后就得到0。</p>\r\n<hr />\r\n<h3 id=\"四.-组合逻辑电路4\">四. 组合逻辑电路(4)</h3>\r\n<h4 id=\"数据分配器\">4.1 数据分配器</h4>\r\n<p>定义：数据传输过程中，有时需要将数据分配到不同的数据通道上。数据分配器也叫多路分配器，简称DEMUX。</p>\r\n<p>示意图：通过A端口来选择数据输出通道。</p>\r\n<p><img src=\"28.png\" /></p>\r\n<p>电路图：</p>\r\n<p><img src=\"29.png\" /></p>\r\n<p>这个电路还是蛮简单的。</p>\r\n<p>提一嘴，前面学到的74138译码器就可以用来作1路-8路数据分配器。内部电路图ppt没给，但是我觉得就跟上面DEMUX的电路图差不多。</p>\r\n<p><img src=\"30.png\" /></p>\r\n<h4 id=\"数据选择器\">4.2 数据选择器</h4>\r\n<p>定义：能够实现从多路数据中选择一路进行传输的电路叫做数据选择器。也叫多路选择器、多路调制器，简称MUX。常见的类型有二选一、四选一、八选一、十六选一。</p>\r\n<p><img src=\"31.png\" /></p>\r\n<ul>\r\n<li><strong>二选一多路选择器</strong></li>\r\n</ul>\r\n<p><img src=\"32.png\" /></p>\r\n<p>w0和w1分别是两路的数据源，然后s是控制器。先看右边的电路图，假设s是0，则f\r\n= w0，假设s是1，则f = w1。左边就是二选一MUX的图形符号。</p>\r\n<ul>\r\n<li><strong>四选一多路选择器</strong></li>\r\n</ul>\r\n<p>先看真值表，根据真值表就可以直接设计电路了。</p>\r\n<p><img src=\"33.png\" /></p>\r\n<p>所以根据上面的真值表可以写出逻辑表达式：</p>\r\n<p><span class=\"math inline\">\\(f = w_0\\overline{s_1}\\overline{s_0} +\r\nw_1\\overline{s_1}s_0 + w_2s_1\\overline{s_0} + w_3s_1s_0\\)</span></p>\r\n<p>下面右图是用非门 + 与门 +\r\n或门来实现上面的逻辑表达式，左图是四选一MUX的图形符号</p>\r\n<p><img src=\"34.png\" /></p>\r\n<ul>\r\n<li><strong>更大规模的多路选择器</strong></li>\r\n</ul>\r\n<p>可以直接列真值表然后直接构建，也可以用小规模的多路选择器去构建。</p>\r\n<p>看一个由2选1多路选择器构建的4选1多路选择器，就知道如何构建了。</p>\r\n<p><img src=\"35.png\" /></p>\r\n<p>先将w俩俩分组，然后用s0去筛，一下筛掉一半，再用s1去筛，又筛掉一半，最后就选择出来了一路数据。</p>\r\n<h4 id=\"数据选择器的运用\">4.3 数据选择器的运用</h4>\r\n<ol type=\"1\">\r\n<li><p>2x2纵横开关（是否交换数据传输通道）</p>\r\n<p><img src=\"36.png\" /></p>\r\n<ul>\r\n<li>看图，s是选择器。如果s=0，则y1 = x1, y2 = x2。如果s=1，则y1 = x2，y2\r\n= x1。</li>\r\n</ul></li>\r\n<li><p>实现逻辑函数</p>\r\n<ul>\r\n<li><p>最暴力的想法就是列真值表，输入变量A、B、C就是选择器s。每一行的输出就是数据输入通道，输出通道就是f。例如函数<span\r\nclass=\"math inline\">\\(f = \\overline{w_1}w_2 +\r\nw_1\\overline{w_2}\\)</span>，用四选一多路选择器的实现如下：</p>\r\n<p><img src=\"38.png\" /></p></li>\r\n<li><p>但在暴力的基础上其实可以优化：可以对真值表做一个改动：</p>\r\n<p><img src=\"39.png\" /></p></li>\r\n<li><p>这样子输入变量只有一个w1了，它就是选择器。数据输入通道有两个，分别是<span\r\nclass=\"math inline\">\\(w_2\\)</span>和<span\r\nclass=\"math inline\">\\(\\overline{w_2}\\)</span>，数据输出通道一个为f。用二选一多路选择器实现如下：</p>\r\n<p><img src=\"40.png\" /></p></li>\r\n</ul></li>\r\n<li><p>实现3输入表决器</p>\r\n<ul>\r\n<li><p>先列出真值表</p>\r\n<p><img src=\"41.png\" /></p></li>\r\n<li><p>对真值表进行优化</p>\r\n<p><img src=\"42.png\" /></p></li>\r\n<li><p>此时输入变量两个w1、w2为选择器，数据输入通道4个分别是0、w3、w3、1，数据输出通道1个为f。用4选1多路选择器实现如下：</p>\r\n<p><img src=\"43.png\" /></p></li>\r\n</ul></li>\r\n<li><p>实现3位异或运算</p>\r\n<ul>\r\n<li><p>先列出真值表，并优化</p>\r\n<p><img src=\"44.png\" /></p></li>\r\n<li><p>此时输入变量两个w1、w2为选择器，数据输入通道4个分别是<span\r\nclass=\"math inline\">\\(w_3、\\overline{w_3}、\\overline{w_3}、w_3\\)</span>，数据输出通道一个为f。用4选1多路选择器实现如下：</p>\r\n<p><img src=\"45.png\" /></p></li>\r\n</ul></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"五.-组合逻辑电路5\">五. 组合逻辑电路(5)</h3>\r\n<p>这一节比较杂，主要是对第（4）内容的一个补充。具体来说，讲了如下内容：</p>\r\n<ol type=\"1\">\r\n<li>用香农展开定理搭配多路选择器实现逻辑函数</li>\r\n<li>八选一数据选择器74151</li>\r\n<li>双四选一数据选择器74153</li>\r\n<li>数据选择器的更多运用</li>\r\n</ol>\r\n<h4 id=\"用香农展开定理搭配多路选择器实现逻辑函数\">5.1\r\n用香农展开定理搭配多路选择器实现逻辑函数</h4>\r\n<ul>\r\n<li><p>香农展开定理：</p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(f\\left(w_{1}, w_{2}, \\ldots . .\r\nw_{\\mathrm{n}}\\right)=\\overline{w_{1}} f\\left(0, w_{2}, \\ldots . .\r\nw_{\\mathrm{n}}\\right)+w_{1} f\\left(1, w_{2}, \\ldots . .\r\nw_{\\mathrm{n}}\\right)\\)</span></p>\r\n<ul>\r\n<li><p>↑展开一个变量</p></li>\r\n<li><p>在香农表达式中<span\r\nclass=\"math inline\">\\(f\\left(0,w_{2}....w_{\\mathrm{n}}\\right)\\)</span>\r\n项称为对应于<span\r\nclass=\"math inline\">\\(\\bar{w}_{\\mathrm{1}}\\)</span>的<span\r\nclass=\"math inline\">\\(f\\)</span>的余因子式, 简写做<span\r\nclass=\"math inline\">\\(f_{\\overline{w}_1}\\)</span>。 同样的,<span\r\nclass=\"math inline\">\\(f(1,w_2.....w_n)\\)</span> 项称为对应于<span\r\nclass=\"math inline\">\\(w_{_1}\\)</span>的<span\r\nclass=\"math inline\">\\(f\\)</span>的余因子式,简写做<span\r\nclass=\"math inline\">\\(f_{_{w_1}}\\)</span>。所以香农展开定理可以简写成：\r\n<span class=\"math display\">\\[\r\nf=\\overline{w}_{1}f_{\\overline{w}_{1}}+w_{1}f_{w_{1}}\r\n\\]</span></p></li>\r\n</ul></li>\r\n<li><p><span class=\"math inline\">\\(f(w_1,w_2,....,w_n)=\\\\\r\n\\overline{w_1}\\overline{w_2}f(0,0,w_3....w_n)+\\overline{w_1}w_2f(0,1,w_3,.....w_n)+w_1\\overline{w_2}f(1,0,w_3,.....w_n)+\r\n\\\\ w_1w_2f(1,1,w_3,.....w_n)\\)</span></p>\r\n<ul>\r\n<li>↑展开多个变量</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<p>那如何用香农展开定理实现逻辑函数呢？举个例子，比如<span\r\nclass=\"math inline\">\\(f=\\overline{w}_{1}\\overline{w}_{3}+w_{1}w_{2}+w_{1}w_{3}\\)</span></p>\r\n<p>将f以w1用香农展开定理展开，得到<span\r\nclass=\"math inline\">\\(f=\\overline{w}_1f_{\\overline{w}_1}+w_1f_{w_1}=\\overline{w}_1(\\overline{w}_3)+w_1(w_2+w_3)\\)</span></p>\r\n<p>然后选用二路选择器，w1是选择器，数据输入通道2个分别是<span\r\nclass=\"math inline\">\\(\\overline{w_3}\\)</span>和<span\r\nclass=\"math inline\">\\(w_2 +\r\nw_3\\)</span>，数据输出通道一个为f。实现电路图如下：</p>\r\n<p><img src=\"46.png\" /></p>\r\n<p>同理，如果用香农展开定理展开两个变量，则搭配一个四路选择器也可以实现上述函数f。</p>\r\n<h4 id=\"八选一数据选择器74151\">5.2 八选一数据选择器74151</h4>\r\n<p>74151MUX的样子和真值表如下图</p>\r\n<p><img src=\"47.png\" /></p>\r\n<h4 id=\"双四选一数据选择器74153\">5.3 双四选一数据选择器74153</h4>\r\n<p>就是俩独立的四路选择器放一起，如图。（个人觉得左图很不直观，下面练习中的74153比较直观）</p>\r\n<p><img src=\"48.png\" /></p>\r\n<blockquote>\r\n<p>练习：如何用74153构建一个74151？</p>\r\n</blockquote>\r\n<p>很简单，跟以前练习题一样的套路。只要保证两个四选一板子有且只能有一块板子在工作就行了。看答案吧，很简单。</p>\r\n<p><img src=\"49.png\" /></p>\r\n<p>A2还有G1就是为了实现”只能有一个四选一“板子在工作我们自己加上去的电路。</p>\r\n<h4 id=\"小补充\">5.4 小补充</h4>\r\n<p>感觉代号多了有点乱了。让我来梳理一下。</p>\r\n<p>74148是最常见的8线-3线优先编码器。</p>\r\n<p>74138是最常见的二进制译码器。（3个输入、8个输出）</p>\r\n<p>数据分配器DEMUX可用74138实现。</p>\r\n<p>数据选择器MUX有74151（八路）、74153（俩独立四路放一起）</p>\r\n<h4 id=\"数据选择器的更多运用\">5.5 数据选择器的更多运用</h4>\r\n<ol type=\"1\">\r\n<li><p>与DEMUX实现多路信号分时传送</p>\r\n<p><img src=\"50.png\" /></p></li>\r\n<li><p>实现逻辑函数</p>\r\n<ul>\r\n<li><p>用MUX实现逻辑函数的方法有许多。</p>\r\n<ol type=\"1\">\r\n<li>直接列真值表实现</li>\r\n<li>列完真值表，对真值表优化后实现</li>\r\n<li>用香农展开公式后实现</li>\r\n<li>列引入变量的卡诺图实现</li>\r\n</ol></li>\r\n<li><p>前三种方法前面都介绍过了，这里放一个用第四种方法的例题。</p>\r\n<p><img src=\"51.png\" /></p></li>\r\n<li><p>因为74151是八位选择器，所以只能有3个选择变量。所以画卡诺图引入了一个变量。然后8个信号输入端口就输入0/1/D/<span\r\nclass=\"math inline\">\\(\\overline{D}\\)</span>即可。</p></li>\r\n<li><blockquote>\r\n<p>练习：请用一片74151实现逻辑函数<span\r\nclass=\"math inline\">\\(F(A,B,C,D,E)=A\\overline{B}C\\overline{D}E+AB\\overline{C}\\overline{D}\\overline{E}+A\\overline{B}C\\overline{D}\\overline{E}+\\overline{A}\\overline{B}\\overline{C}DE+\\overline{A}B\\overline{C}\\overline{D}\\overline{E}\\)</span></p>\r\n</blockquote></li>\r\n<li><p>74151是八路选择器，所以要有三个选择变量。但是这里F有5个，所以第一想法是用香农展开定理展开3个变量，但是这样太麻烦了。所以用第四种方法，引入两个变量进卡诺图即可。</p>\r\n<p><img src=\"52.png\" /></p></li>\r\n</ul></li>\r\n<li><p>数据选择器的扩展</p>\r\n<ul>\r\n<li><p>很好理解，看图即可。</p>\r\n<p><img src=\"53.png\" /></p></li>\r\n</ul></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"六.-组合逻辑电路6\">六. 组合逻辑电路(6)</h3>\r\n<h4 id=\"数值比较器\">6.1 数值比较器</h4>\r\n<ul>\r\n<li><strong>一位数值比较器</strong></li>\r\n</ul>\r\n<p>两个1位二进制数A,B相比的情况有以下几种: 1. A&gt;B，则<span\r\nclass=\"math inline\">\\(A\\overline{B}=1\\)</span>，所以可用<span\r\nclass=\"math inline\">\\(A\\overline{B}\\)</span>作为A&gt;B的输出信号<span\r\nclass=\"math inline\">\\({Y}_{(A&gt;B)}\\)</span> 。<br />\r\n2. 同理可用 <span class=\"math inline\">\\(\\overline{AB}\\)</span>\r\n作为A&lt;B的输出信号 <span class=\"math inline\">\\({Y}_{(A&lt;B)}\\)</span>\r\n。 3. 同理可用<span class=\"math inline\">\\(A \\odot B\\)</span>\r\n作为A=B的输出信号 <span class=\"math inline\">\\(Y_{A=B}\\)</span></p>\r\n<p>于是可以设计出如下电路（注意是低电平有效）</p>\r\n<p><img src=\"54.png\" /></p>\r\n<ul>\r\n<li><strong>多位数值比较器</strong></li>\r\n</ul>\r\n<p>多位数值比较器的原理就是从高位到低位逐位比较，最常见的是4位比较器14585，下面是其逻辑函数和电路图：</p>\r\n<p><img src=\"55.png\" /></p>\r\n<p><img src=\"56.png\" /></p>\r\n<p>这个图有4个要注意的地方，首先看蓝色箭头的地方，为啥这个地方用与非门呢？很简单，将上面的逻辑表达式进行进一步化简：\r\n<span class=\"math display\">\\[\r\nY_{A&lt;B} = \\overline{\\overline{\\overline{A_3}B_3} \\cdot\r\n\\overline{\\overline{A_3 \\oplus B_3}\\overline{A_2}B_2} \\cdot ...} \\,\r\n\\cdot I_{A&lt;B}  \\\\\r\n= \\overline{\\overline{\\overline{A_3}B_3} \\cdot ((A_3 \\oplus B_3) +\r\n\\overline{\\overline{A_2}B_2}) \\cdot \\, ...} \\, \\cdot I_{A&lt;B}\r\n\\]</span> 现在知道蓝色箭头为啥用与非门了吧=w=。</p>\r\n<p>那为啥绿色箭头那要用或门呢？还是看上面化简的式子，注意看第二项，第二项就是或门=w=。</p>\r\n<p>那为啥棕色箭头用或非门呢？还是化简上面的式子： <span\r\nclass=\"math display\">\\[\r\nY_{A=B} = \\overline{(A_3 \\oplus B_3) + (A_2 \\oplus B_2) + (略) + (略)}\r\n\\, \\cdot I_{A=B}\r\n\\]</span>\r\n很清楚吧=w=，就是一个或非门，每一项这里用异或表达了，其实就是图中判断是否每一项是否相等的那个逻辑门。</p>\r\n<p>那为啥红箭箭头那要用或非门呢？还是化简上面的式子： <span\r\nclass=\"math display\">\\[\r\nY_{A&gt;B} = \\overline{(Y_{A&lt;B} + Y_{A=B}) + \\overline{I_{A&gt;B}}}\r\n\\]</span> easy。</p>\r\n<p>还剩一个问题，那三个<span\r\nclass=\"math inline\">\\(I\\)</span>是干啥的。其实就是用来接收低位上的结果的。这样两块14585就能实现8位数字的比较。如下图：</p>\r\n<p><img src=\"57.png\" /></p>\r\n<p>有个问题，为啥左边的<span\r\nclass=\"math inline\">\\(Y_{A&gt;B}\\)</span>为啥不能连到右边的<span\r\nclass=\"math inline\">\\(I_{A=B}\\)</span>？</p>\r\n<p>其实可以，但是图中这样连也没问题。还是用逻辑表达式去解释：<span\r\nclass=\"math inline\">\\(Y_{A&gt;B} = \\overline{(Y_{A&lt;B} + Y_{A=B}) +\r\n\\overline{I_{A&gt;B}}}\\)</span>，可以发现必须要三者都是0才会使得<span\r\nclass=\"math inline\">\\(Y_{A&gt;B}=1\\)</span>，所以默认给<span\r\nclass=\"math inline\">\\(I_{A&gt;B}\\)</span>置为1不影响结果。</p>\r\n<h4 id=\"加法器\">6.2 加法器</h4>\r\n<ul>\r\n<li><strong>半加器</strong></li>\r\n</ul>\r\n<p>很简单，真值表、逻辑表达式、图形符号如下图：</p>\r\n<p><img src=\"58.png\" /></p>\r\n<ul>\r\n<li><strong>全加器</strong></li>\r\n</ul>\r\n<p>加了一个考虑上一位进位而已，也很简单，真值表、逻辑表达式、图形符号如下：</p>\r\n<p><img src=\"59.png\" /></p>\r\n<p>这里解释一下逻辑表达式，因为异或是不进位加法，所以S等于三者异或很合理。然后CO用或连接也很合理，无非就是A、B都是1可以进位，或者CI为1，A、B里任意一个为1也可以进位。</p>\r\n<ul>\r\n<li><strong>串行进位加法器</strong></li>\r\n</ul>\r\n<p>有了全加器之后，只需要将多个全加器串联起来就可以得到任意多位的加法器了。如下图：</p>\r\n<p><img src=\"60.png\" /></p>\r\n<p>虽然这样逻辑和电路都很简单，但是存在一个问题，就是速度过慢，如何解决呢？</p>\r\n<p>速度关键是慢在进行信号逐级传递的过程，所以要优化这个过程。不难发现，要想知道<span\r\nclass=\"math inline\">\\(CI_i\\)</span>，只需要知道<span\r\nclass=\"math inline\">\\(A_{i-1}A_{i-2}...A_0\\)</span>和<span\r\nclass=\"math inline\">\\(B_{i-1}B_{i-2}...B_0\\)</span>即可。</p>\r\n<p>个人觉得，这种优化思路就很像把递归函数展开来写了笑死。也有点像并查集路径压缩。</p>\r\n<ul>\r\n<li><strong>超前进位加法器</strong></li>\r\n</ul>\r\n<p>用上面提到的优化方法做成的加法器就叫做超前进位加法器。下图是74283的超前进位加法器电路图：</p>\r\n<p><img src=\"61.png\" /></p>\r\n<p>可以发现光4位加法器电路就那么复杂了，这或许就是空间换时间吧（笑）</p>\r\n<p>所以当我们需要更多位加法器的时候，可以拿74283超前进位加法器去串联做成一个多位的串行进位加法器。</p>\r\n<blockquote>\r\n<p>练习：用一片74283设计将BCD8421码转换成余3码的电路</p>\r\n</blockquote>\r\n<p>太简单啦！直接上图：</p>\r\n<p><img src=\"62.png\" /></p>\r\n<h4 id=\"竞争-冒险现象\">6.3 竞争-冒险现象</h4>\r\n<p>啊我懒得打很多字了，这里我放一个up主的视频，看完这道例题就知道什么是竞争-冒险现象了：（up主：海蓬莱）</p>\r\n<video src=\"video.mp4\" controls=\"controls\">\r\n</video>\r\n<p>视频中的险象就是这里的冒险。官方定义如下 ：</p>\r\n<p>竞争：一个逻辑门的两个输入端的信号同时向相反方向变化，而变化的时间有差异的现象。</p>\r\n<p>冒险：由于竞争而使电路输出发生瞬时错误</p>\r\n<p>注意，有竞争不一定会冒险（如视频中提到的非临界竞争）</p>\r\n<p>冒险分为两类：</p>\r\n<ol type=\"1\">\r\n<li>0型冒险：即本来是1的变成了0\r\n<ul>\r\n<li>当表达式在一定条件下能化成<span class=\"math inline\">\\(F = A +\r\n\\overline{A}\\)</span>时，就会出现0型冒险</li>\r\n</ul></li>\r\n<li>1型冒险：即本来是0的变成了1\r\n<ul>\r\n<li>当表达式在一定条件下能化成<span class=\"math inline\">\\(F = A \\cdot\r\n\\overline{A}\\)</span>时，就会出现1型冒险</li>\r\n</ul></li>\r\n</ol>\r\n<p>如何能消除竞争-冒险现象呢？ppt上给出了三种解决方案：</p>\r\n<ol type=\"1\">\r\n<li><p>接入滤波电容</p></li>\r\n<li><p>引入选通脉冲</p></li>\r\n<li><p>修改逻辑表达式</p>\r\n<ul>\r\n<li>前俩个反正我是没看懂，这里举个例子说一下第三种方法。比如有逻辑函数<span\r\nclass=\"math inline\">\\(F = AB + \\overline{A}C\\)</span>，当B = C =\r\n1时会出现0型冒险。所以可以修改一下逻辑表达式为：<span\r\nclass=\"math inline\">\\(F = AB + \\overline{A}C +\r\nBC\\)</span>，这样就不会出现0型冒险了。（为什么要这么修改呢？看下面的卡诺图你就知道了）</li>\r\n</ul>\r\n<p><img src=\"63.png\" /></p></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"七.-vivado的基本使用\">七. Vivado的基本使用</h3>\r\n<p>先来了解一下EDA技术：即电子设计自动化，其依赖功能强大的计算机，在\r\nEDA工具软件平台上，对以硬件描述语言(HDL)为系统逻辑描述手段完成的设计文件，自动地完成逻辑编译、逻辑化简、逻辑分割、逻辑综合、布局布线，以及逻辑优化和仿真测试，直至物理实现既定的电子设计系统功能。</p>\r\n<p>以我浅薄的理解，EDA = IDE，Verilog =\r\nC++，hhhhh，FPGA是可编程逻辑器件。</p>\r\n<h4 id=\"用verilog-hdl设计电路\">7.1 用Verilog HDL设计电路</h4>\r\n<p>写一个模块大致分为以下几步：</p>\r\n<ol type=\"1\">\r\n<li>打开Vivado，创建一个项目（根据自己开发板选型号，我的是xc7a35tcpg236-1）</li>\r\n<li>新建一个design文件，在里头写程序</li>\r\n<li>新建一个sim文件，在里头写仿真程序（初始化 + 实例化 +\r\n仿真过程代码）</li>\r\n<li>运行仿真，观察仿真结果是否跟设想一样</li>\r\n<li>封装IP核，以便此模块以后可被其它项目使用</li>\r\n</ol>\r\n<h4 id=\"用block-design设计电路\">7.2 用Block Design设计电路</h4>\r\n<ol type=\"1\">\r\n<li>打开Vivado，创建一个项目</li>\r\n<li>左侧新建一个Block Design项目</li>\r\n<li>引入IP核，开始画图</li>\r\n<li>新建一个sim文件，写仿真程序</li>\r\n<li>运行仿真，观察仿真结果是否跟设想一样</li>\r\n</ol>\r\n<h4 id=\"用rtl看电路图\">7.3 用RTL看电路图</h4>\r\n<p>点左侧RTL分析即可生成。</p>\r\n<h4 id=\"下板\">7.4 下板</h4>\r\n<ol type=\"1\">\r\n<li>写好constraint文件（我直接用的老师给的模板文件上修改）</li>\r\n<li>运行左侧Synthesis</li>\r\n<li>运行Implementation（记得勾选第二项产生二进制文件，然后选择Open\r\nHardware Manager）</li>\r\n<li>通过USB连上FPGA</li>\r\n<li>点击Auto Connect，连接成功后选择Program\r\nDevice下载刚才的二进制文件</li>\r\n<li>可以愉快的用板子观察程序结果啦~</li>\r\n</ol>\r\n<p>但是断电后程序就会丢失，为了解决这个问题，需要把程序烧录进ROM里：</p>\r\n<ol type=\"1\">\r\n<li>生成bin文件，Tools -&gt; Settings -&gt; Bitstream -&gt;\r\n勾选-bin-file* -&gt; OK，左侧Generate\r\nBitstream重新生成bit文件（此时就会生成bin文件）</li>\r\n<li>右键芯片选择Add Configuration Memory Device，选择合适的闪存型号</li>\r\n</ol>\r\n<h4 id=\"总结\">7.5 总结</h4>\r\n<p>Vivado这个软件其实蛮简单使用的。首先不考虑板子的话，只在电脑上设计电路有两种方法，第一种就是直接创建design文件写，第二种就是用Block\r\nDesign（若某个模块想封装成IP核必须要仿真过先）。然后想看设计的对不对，就创建仿真文件来看。另外，用RTL可以看设计好的电路。</p>\r\n<p>下板的话就需要通过constraint文件指定管脚，然后左侧Synthesis +\r\nImplementation + 生成二进制文件 + 连板子 + Auto Connect + Program\r\nDevice就可以在板子上观察了。</p>\r\n<hr />\r\n<p>现在是2023/10/28，又准备要做时序逻辑电路的实验了。所以继续把这个自学笔记写完吧hhhh</p>\r\n<h3 id=\"八.-触发器\">八. 触发器</h3>\r\n<p>定义：触发器是具有记忆功能的基本逻辑单元，一个触发器可以存储一个二值信号。</p>\r\n<h4 id=\"rs触发器\">8.1 RS触发器</h4>\r\n<p><img src=\"64.png\" /></p>\r\n<p>首先需要知道与非门的特点，对于与非门，如果有一端为0，那么输出就为1。如果两端都为1，那么输出才为0。所以对于上图，如果S=0,\r\nR=1，那么Q = 1, Q反馈回去得到<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>=0。如果R=0, Q=1，那么<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>=1，反馈回去得到Q=0。</p>\r\n<p>其实S为set，R为reset，Q为输出。而且S、R都是低电平有效。所以S=0,R=1的时候，输出将置位为1。R=0,\r\nS=1时，输出将reset为0。</p>\r\n<p>如果S = R = 1呢？按照感性理解就是set和reset都不起效，也就是Q和<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>维持上一个状态。让我们来验证一下，假设Q=0，则反馈回去<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>=1，再反馈回来Q=0。假设Q=1，则反馈回去<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>=0，再反馈回来Q=1。没有问题，就是维持上一个状态。</p>\r\n<p>如果S = R =\r\n0呢？按照感性理解就是set和reset都起效，那必然会存在一个“竞争”问题。也就是存在不唯一性。让我们来验证一下，假设S\r\n= R = 0，那么Q和<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>都将会为1。好，假设下一个时刻S\r\n= R = 1, 按照上面的分析应该维持原状对吧。但是假如Q先传回去，则<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>=0，再传回来Q=1，新状态Q=1,\r\n<span class=\"math inline\">\\(\\overline{Q}\\)</span>=0；假如<span\r\nclass=\"math inline\">\\(\\overline{Q}\\)</span>先传回去，则Q=0,\r\n再传回来<span class=\"math inline\">\\(\\overline{Q}\\)</span>=1，新状态Q=0,\r\n<span\r\nclass=\"math inline\">\\(\\overline{Q}=1\\)</span>。所以我们是要禁止出现S = R\r\n= 0的情况的！因为下一个时刻就会出现<strong>“不唯一性”</strong>。</p>\r\n<p>经过上面的分析，下面的真值表就十分清楚了：</p>\r\n<p><img src=\"65.png\" /></p>\r\n<p>用逻辑表达式<span class=\"math inline\">\\(Q^{n+1}=\\overline{S} + R(Q^n)\r\n\\quad ,R + S = 1,\\)</span>也可以表示上面的真值表（用卡诺图推）</p>\r\n<h4 id=\"钟控触发器\">8.2 钟控触发器</h4>\r\n<p>钟控触发器是在普通触发器上的一个改进。因为有时候我们只希望在某一个信号到来的时候，Q才随R和S改变。而其余时候，都希望Q维持原状，也就是这个触发器被“锁”起来。那么钟控触发器就可以实现这个功能。</p>\r\n<p>钟控触发器也分为几种：可控R-S触发器、主从式J-K触发器、D型触发器、T型触发器。</p>\r\n<ul>\r\n<li><strong>可控R-S触发器</strong></li>\r\n</ul>\r\n<p>先来看它的电路图和装置图：</p>\r\n<p><img src=\"66.png\" /></p>\r\n<p>可以发现，可控R-S触发器无非就是在R-S触发器的前面加了俩与非门。因为我们知道对于与非门，只要有一端是0，输出就为1。所以当cp为0时，Q将维持原状，触发器被“锁”住。当cp为1时，R、S的输入就可以影响到Q。可是注意，因为多了俩与非门的存在，所以本来对于R、S是低电平有效，现在变成了高电平有效了。也就是S\r\n= 1, R = 0时，Q = 1；S = 0, R = 1时，Q = 0；S = R = 0时维持原状；S = R =\r\n1时为不稳定态。</p>\r\n<p>总结来说，cp=0时锁触发器，cp=1时激活触发器，但是会变为高电平有效。</p>\r\n<p>逻辑表达式为：<span class=\"math inline\">\\(Q^{n+1} = S +\r\n\\overline{R}Q^n \\quad ,R \\cdot S = 0, CP = 1\\)</span></p>\r\n<ul>\r\n<li><strong>主从式J-K触发器</strong></li>\r\n</ul>\r\n<p>J-K触发器是可控R-S触发器的一个升级版，它的J、K分别对应R、S，而且允许J和K同时取1。同时取1的时候不会引入“竞争”，而是会翻转输出Q的结果。</p>\r\n<p>具体来说，当cp=0时，触发器被锁住。当cp=1时，触发器激活，J、K高电平有效。J\r\n= 1, K = 0时Q = 1；J = 0, K = 1时Q = 0；J = K = 0时保持原状；J = K =\r\n1时翻转Q。</p>\r\n<p>下面是它的逻辑表达式和电路图：</p>\r\n<p><span class=\"math inline\">\\(Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\r\n\\quad ,CP = 1\\)</span></p>\r\n<p><img src=\"67.png\" /></p>\r\n<ul>\r\n<li><strong>D型触发器</strong></li>\r\n</ul>\r\n<p>这个触发器最直观，只有两个输入端：cp和D。D输出什么，这个触发器就存储什么（我已经预感到实验会大量使用到这个触发器了hhhh）。</p>\r\n<p>详细来说，cp=0时，触发器被锁住。cp=1时，若D = 0，则Q = 0；若D =\r\n1，则Q = 1。</p>\r\n<p>它的电路图如下：（其实所有触发器都是在R-S触发器的基础上在输入端进行改动）</p>\r\n<p><img src=\"68.png\" /></p>\r\n<p>这个公式推导挺有趣的。R-S基础触发器的公式是：<span\r\nclass=\"math inline\">\\(Q^{n+1}=\\overline{S} + R(Q^n)\\)</span>。</p>\r\n<p>然后由图中可以推出，<span class=\"math inline\">\\(R = \\overline{CP\r\n\\cdot (\\overline{CP \\cdot D})} = \\overline{CP \\cdot \\overline{D}} \\quad\r\n, S = \\overline{CP \\cdot D}\\)</span>。</p>\r\n<p>将上面的R、S带入原始公式：<span class=\"math inline\">\\(Q^{n+1} = CP\r\n\\cdot D + (\\overline{CP} + D)Q^n = D(CP + Q^n) +\r\n\\overline{CP}Q^n\\)</span></p>\r\n<p><span class=\"math inline\">\\(CP=0\\)</span>时，<span\r\nclass=\"math inline\">\\(Q^{n+1} = DQ^n + Q^n = Q^n\\)</span></p>\r\n<p><span class=\"math inline\">\\(CP = 1\\)</span>时，<span\r\nclass=\"math inline\">\\(Q^{n+1} = D\\)</span></p>\r\n<p>完整公式：<span class=\"math inline\">\\(Q^{n+1} = D\\cdot CP +\r\n\\overline{CP}Q^n\\)</span></p>\r\n<ul>\r\n<li><strong>T型触发器</strong></li>\r\n</ul>\r\n<p>这个触发器也是只有两个输入端：cp和T。cp=0时，触发器被锁住。cp=1时，T=0时维持原态，T=1时翻转输出。</p>\r\n<p>它的电路图如下：</p>\r\n<p><img src=\"69.png\" /></p>\r\n<p>可以看出，T触发器就是在J-K触发器的基础上，把J和K变成一个接口T了。所以J-K触发器的公式：<span\r\nclass=\"math inline\">\\(Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\)</span>就应该改为<span\r\nclass=\"math inline\">\\(Q^{n+1} = T \\oplus Q^n\\)</span>。</p>\r\n<h4 id=\"总结-1\">8.3 总结</h4>\r\n<p>触发器这块，R-S触发器是最经典的，后续所有的钟控触发器都是由R-S触发器修改得到。所以R-S触发器的公式和电路图要记住：<span\r\nclass=\"math inline\">\\(Q^{n+1} = \\overline{S} +\r\nRQ^n\\)</span>。然后它是低电平有效，后续的钟控触发器都是高电平有效。它有两个缺点：</p>\r\n<ol type=\"1\">\r\n<li>没有时钟控制</li>\r\n<li>R、S不能同时为0</li>\r\n</ol>\r\n<p>可控R-S触发器就是在R-S的基础上加了两个与非门，多连了一个CP。公式为<span\r\nclass=\"math inline\">\\(Q^{n+1} = S +\r\n\\overline{R}Q^n\\)</span>。解决了缺点2。</p>\r\n<p>J-K触发器就是在可控R-S触发器的基础上将两个输出连接到J、K输入端，公式为<span\r\nclass=\"math inline\">\\(Q^{n+1}=J\\overline{Q^n}+\\overline{K}Q^n\\)</span>。又解决了缺点1。</p>\r\n<p>D触发器和T触发器背一下就好了，不要求掌握其电路图。D触发器就是CP=1时D是什么，Q就是什么。T触发器就是CP=1时T=0为维持原状，T=1为翻转输出，公式为<span\r\nclass=\"math inline\">\\(Q^{n+1} = T \\oplus Q^n\\)</span></p>\r\n<hr />\r\n<h3 id=\"九.-时序逻辑电路1\">九. 时序逻辑电路(1)</h3>\r\n<h4 id=\"概述-1\">9.1 概述</h4>\r\n<p>时序电路一般都是由两个部分构成的：组合电路和存储电路。</p>\r\n<p>存储电路的输出必须反馈到组合电路的输入端，从而与输入信号一起决定组合电路的输出。</p>\r\n<p>下面这两张图能很好的解释时序逻辑电路的特点：</p>\r\n<p><img src=\"70.png\" /></p>\r\n<p><img src=\"71.png\" /></p>\r\n<p>时序逻辑电路分类的话有两种分类方式：</p>\r\n<ul>\r\n<li><p>按触发器的动作特点分类</p>\r\n<ol type=\"1\">\r\n<li>同步时序逻辑电路（有统一的CP）</li>\r\n<li>异步时序逻辑电路（无统一的CP）</li>\r\n</ol></li>\r\n<li><p>按输出信号的特点分类</p>\r\n<ol type=\"1\">\r\n<li><p>米利型（输出跟输入变量和存储电路有关）</p>\r\n<p><img src=\"72.png\" /></p></li>\r\n<li><p>莫尔型（输出只跟存储电路有关）</p>\r\n<p><img src=\"73.png\" /></p></li>\r\n</ol></li>\r\n</ul>\r\n<h4 id=\"时序逻辑电路的描述方法\">9.2 时序逻辑电路的描述方法</h4>\r\n<p>从理论上：输出方程(通过输入和现态算输出) + 驱动方程 +\r\n状态方程(通过现态算次态)</p>\r\n<p>从图表上：状态转换表、状态转换图、时序图</p>\r\n<ul>\r\n<li><strong>状态转换表</strong></li>\r\n</ul>\r\n<p>若将任何一组输入变量及电路初态的取值代入状态方程和输出方程，即可算出电路的次态和现态下的输出值。如此继续下去，把全部的计算结果列成真值表的形式，就得到了状态转换表。</p>\r\n<p>通过下面这个例子就很容易看懂。左边第一、二个是状态方程，第三个是输出方程。右边是状态转换表。</p>\r\n<p><img src=\"74.png\" /></p>\r\n<ul>\r\n<li><strong>状态转换图</strong></li>\r\n</ul>\r\n<p>就是状态转换表形象化的表示。以小圆圈表示电路的各个状态，圆圈中填入存储单元的状态值，圆圈之间用箭头表示状态转换的方向，在箭头旁注明状态转换前的输入变量取值和输出值。</p>\r\n<p>下面这张图就是上面那个状态转换表的状态转换图，很容易理解。</p>\r\n<p><img src=\"75.png\" /></p>\r\n<ul>\r\n<li><strong>时序图</strong></li>\r\n</ul>\r\n<p>就是波形图。</p>\r\n<hr />\r\n<h3 id=\"十.-时序逻辑电路2\">十. 时序逻辑电路(2)</h3>\r\n<h4 id=\"同步时序逻辑电路的分析\">10.1 同步时序逻辑电路的分析</h4>\r\n<p>跟分析组合逻辑电路一样，也是画出真值表（状态转换表），然后观察得出功能。</p>\r\n<p>具体来说，分为下面几步：</p>\r\n<ol type=\"1\">\r\n<li>写出输出方程</li>\r\n<li>写出驱动方程</li>\r\n<li>写出状态方程</li>\r\n<li>根据方程画出状态转换表</li>\r\n</ol>\r\n<p>下面用一道例题来感受：</p>\r\n<p><img src=\"76.png\" /></p>\r\n<p>输出方程：<span class=\"math inline\">\\(Y = Q_0^nQ_2^n\\)</span></p>\r\n<p>驱动方程： <span class=\"math display\">\\[\r\nJ_0 = K_0 = 1 \\\\\r\nJ_1 = K_1 = \\overline{Q_2^n}Q_0^n \\\\\r\nJ_2 = Q_1^nQ_0^n, K_2 = Q_0^n\r\n\\]</span> 状态方程： <span class=\"math display\">\\[\r\nQ_0^{n+1} = J_0\\overline{Q_0^n} + \\overline{K_0}Q_0^n = \\overline{Q_0^n}\r\n\\\\\r\nQ_1^{n+1} = J_1\\overline{Q_1^n} + \\overline{K_1}Q_1^n =\r\n\\overline{Q_2^n}Q_0^n \\oplus Q_1^n \\\\\r\nQ_2^{n+1} = J_2\\overline{Q_2^n} + K_2Q_2^n = Q_1^nQ_0^n\\overline{Q_2^n}\r\n+ \\overline{Q_0^n}Q_2^n\r\n\\]</span> 根据状态方程和输出方程写出状态转换表：</p>\r\n<p>设电路初始状态为<span class=\"math inline\">\\(Q_2Q_1Q_0 =\r\n000\\)</span>，则</p>\r\n<p><img src=\"77.png\" /></p>\r\n<p>（注意，当出现循环（红圈）时，即可停下）。</p>\r\n<p>若有需要，还可以根据状态转换表画出状态转换图和时序图：</p>\r\n<p><img src=\"78.png\" /></p>\r\n<p>注意，CP是系统时钟，因为状态转换表中有6条不同的数据，电路又是低电平激发，所以CP需要有6次下沿，所以时序图中CP就有6次下沿信号。</p>\r\n<h4 id=\"异步时序逻辑电路的分析\">10.2 异步时序逻辑电路的分析</h4>\r\n<p>异步时序逻辑特点就是所有触发器的CP端并没有完全连接到一起。</p>\r\n<p>还是以一道例题来讲解：</p>\r\n<p><img src=\"79.png\" /></p>\r\n<p>分析跟同步时序逻辑一样的套路，但是多一个“时钟方程”</p>\r\n<p>时钟方程：</p>\r\n<p><span class=\"math inline\">\\(CP_0 = CP_2 = CP\\)</span></p>\r\n<p><span class=\"math inline\">\\(CP_1 = Q_0\\)</span></p>\r\n<p>输出方程：</p>\r\n<p><span class=\"math inline\">\\(Y = Q_2^n\\)</span></p>\r\n<p>驱动方程：</p>\r\n<p><span class=\"math inline\">\\(J_0 = \\overline{Q_2^n}, K_0 =\r\n1\\)</span></p>\r\n<p><span class=\"math inline\">\\(J_1 = K_1 = 1\\)</span></p>\r\n<p><span class=\"math inline\">\\(J_2 = Q_1^nQ_0^n, K_2 = 1\\)</span></p>\r\n状态方程： $$ .{\r\n<span\r\nclass=\"math display\">\\[\\begin{aligned}Q_0^{n+1}&amp;=\\overline{Q_2^n}\\overline{\\mathcal{Q_0}^n}\r\n\\qquad CP↓有效\\\\\r\n\r\nQ_1^{n+1}&amp;=\\overline{Q_1^n} \\qquad Q_0↓有效\\\\\r\n\r\nQ_2^{n+1}&amp;=Q_1^n\\mathcal{Q_0}^n\\overline{\\mathcal{Q_2}^n} \\qquad\r\nCP↓有效\r\n\r\n\\end{aligned}\\]</span>\r\n<p>.. $$ 有了上面的四个方程，就可以写出状态转换表：</p>\r\n<p><img src=\"80.png\" /></p>\r\n<p>注意，因为<span class=\"math inline\">\\(Q_1\\)</span>的更新是受<span\r\nclass=\"math inline\">\\(Q_0\\)</span>↓控制的，所以当更新<span\r\nclass=\"math inline\">\\(Q_1^{n+1}\\)</span>时，应该先更新<span\r\nclass=\"math inline\">\\(Q_0^{n+1}\\)</span>，然后得出<span\r\nclass=\"math inline\">\\(CP_1\\)</span>是↑还是↓，然后才能去更新<span\r\nclass=\"math inline\">\\(Q_1^{n+1}\\)</span>。</p>\r\n<p>有了状态转换表后就可以画出状态转换图和时序图：</p>\r\n<p><img src=\"81.png\" /></p>\r\n<hr />\r\n<h3 id=\"十一.-时序逻辑电路3\">十一. 时序逻辑电路(3)</h3>\r\n<h4 id=\"同步时序逻辑电路的设计\">11.1 同步时序逻辑电路的设计</h4>\r\n<p>套路为：</p>\r\n<ol type=\"1\">\r\n<li>进行逻辑抽象，并写出逻辑状态转换表，并进行化简合并</li>\r\n<li>将逻辑状态转换表映射到二进制状态转换表</li>\r\n<li>根据二进制状态转换表分别求出输出方程和状态方程</li>\r\n<li>选用一种触发器，根据触发器公式和状态方程推出驱动方程</li>\r\n<li>根据输出、驱动、状态方程画出电路图</li>\r\n<li>检查此电路是否有自启动能力</li>\r\n</ol>\r\n<p>以一道例题来举例：</p>\r\n<blockquote>\r\n<p>试设计一个串行数据检测器。对它的要求是：连续输入三个或三个以上的’1’时输出为’1’，其它情况输出为’0’(试用上边沿JK-FF完成设计)。</p>\r\n</blockquote>\r\n<ul>\r\n<li>逻辑抽象</li>\r\n</ul>\r\n<p>令输入数据为输入变量，用X表示。令检测结果为输出变量，用Y表示。设电路在没有输入‘1’以前的状态为S0；输入1个‘1’后电路转入S1状态；连续输入2个‘1’后电路转入S2状态；连续输入3个或3个以上‘1’以后电路转入S3状态。</p>\r\n<p><img src=\"82.png\" /></p>\r\n<ul>\r\n<li>状态化简</li>\r\n</ul>\r\n<p>将状态转换表和图化简后如下：（如何化简参考下面的化简教学）</p>\r\n<p><img src=\"86.png\" /></p>\r\n<ul>\r\n<li>状态分配（这一步是将逻辑状态映射到数字状态）</li>\r\n</ul>\r\n<p>用二进制表示状态，比如说有4个状态<span class=\"math inline\">\\(S_0 -\r\nS_2​\\)</span>，然后用00表示<span\r\nclass=\"math inline\">\\(S_0​\\)</span>，01表示<span\r\nclass=\"math inline\">\\(S_1​\\)</span>，11表示<span\r\nclass=\"math inline\">\\(S_2​\\)</span>。然后上面那个的表可以改写为：</p>\r\n<p><img src=\"87.png\" /></p>\r\n<p>根据这个表，就可以写出输出方程和状态方程：</p>\r\n<p><img src=\"88.png\" /></p>\r\n<p>即</p>\r\n<p><span class=\"math inline\">\\(Y = XQ_1^n\\)</span></p>\r\n<p><span class=\"math inline\">\\(Q_0^{n+1} = X\\)</span></p>\r\n<p><span class=\"math inline\">\\(Q_1^{n+1} = XQ_0^{n}\\)</span></p>\r\n<p>选用JK触发器，结合公式<span class=\"math inline\">\\(Q^{n+1} =\r\nJ\\overline{Q^n} + \\overline{K}Q^n\\)</span>和<span\r\nclass=\"math inline\">\\(Q_0^{n+1} = X = X(\\overline{Q_0^n} + Q_0^n) =\r\nX\\overline{Q_0^n} + XQ_0^n\\)</span></p>\r\n<p>可以得到，<span class=\"math inline\">\\(J_0 = X, K_0 =\r\n\\overline{X}\\)</span></p>\r\n<p>同理，可得到<span class=\"math inline\">\\(J_1 = XQ_0^n, K_1 =\r\n\\overline{XQ_0^n}\\)</span></p>\r\n<p>所以，全部方程如下：</p>\r\n<p>输出方程：<span class=\"math inline\">\\(Y = XQ_1^n\\)</span></p>\r\n<p>状态方程： <span class=\"math display\">\\[\r\nQ_0^{n+1} = X \\\\\r\nQ_1^{n+1} = XQ_0^{n}\r\n\\]</span> 驱动方程： <span class=\"math display\">\\[\r\nJ_0 = X \\qquad K_0 = \\overline{X} \\\\\r\nJ_1 = XQ_0^n \\qquad K_1 = \\overline{XQ_0^n}\r\n\\]</span> 所以根据方程即可画出电路图：</p>\r\n<p><img src=\"89.png\" /></p>\r\n<ul>\r\n<li>检查是否有自启动能力</li>\r\n</ul>\r\n<p>因为在映射的时候有一些数字状态没被用到，所以就要将没用到的数字状态代入方程中去看看得到的次态是否仍然是没用到的数字状态。如果是的话说明此电路没有自启动能力。如果次态都可以回到用到的数字状态，那么此电路拥有自启动能力。</p>\r\n<p>化简教学：</p>\r\n<ol type=\"1\">\r\n<li>次态相同</li>\r\n</ol>\r\n<p><img src=\"83.png\" /></p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>次态交错</li>\r\n</ol>\r\n<p><img src=\"84.png\" /></p>\r\n<ol start=\"3\" type=\"1\">\r\n<li>次态维持</li>\r\n</ol>\r\n<p><img src=\"85.png\" /></p>\r\n<hr />\r\n<h3 id=\"十二.-时序逻辑电路4\">十二. 时序逻辑电路(4)</h3>\r\n<p>接下来介绍几种常用的时序逻辑电路。</p>\r\n<h4 id=\"计数器\">12.1 计数器</h4>\r\n<p>计数器功能就是记录输入脉冲的个数，计数器所能记录的最大脉冲个数称为计数器的“模”。</p>\r\n<p>计数器有三种分类方式，如图：</p>\r\n<p><img src=\"91.png\" /></p>\r\n<p>先来看一个最简单的3位异步二进制加法计数器。</p>\r\n<p>原理就是用JK触发器实现每次激活后输出Q翻转。第一位的CP连系统时钟，第二位的CP连第一位的输出，第三位的CP连第二位的输出。</p>\r\n<p>这样子的话，每当第一位从1 -&gt;\r\n0时，第二位才会被激活从而翻转，也就实现了“进位”的感觉。</p>\r\n<p>电路图如下：</p>\r\n<p><img src=\"92.png\" /></p>\r\n<p>再来看一下异步二进制减法计数器。（学会了上面的思想这个就很简单了）</p>\r\n<p>首先二进制减法的规则是：若低位是1，则输入一个脉冲后应当翻转为0。若低位已经是0，则应翻转为1，然后令高位翻转。</p>\r\n<p>所以根据这个需求，设计就很简单了。所以也是用JK触发器实现翻转功能。然后第一位的CP连系统时钟，第二位的CP连第一位的输出的反，第三位的CP连第二位的输出的反。</p>\r\n<p>电路图如下：</p>\r\n<p><img src=\"93.png\" /></p>\r\n<p>其实还可以用同步时序逻辑去实现加法/减法计数器。但是比较复杂，我觉得考到的概率不大，所以这里就不展开了。</p>\r\n<hr />\r\n<h3 id=\"十三.-有限状态机设计\">十三. 有限状态机设计</h3>\r\n<p>状态机就跟上面同步时序逻辑电路的设计使用的思想一模一样。就是将现实问题建模成一个个状态，那么整个问题就是在这些状态中转移。</p>\r\n<hr />\r\n<h3 id=\"复习\">复习</h3>\r\n<ul>\r\n<li>组合逻辑设计：\r\n<ul>\r\n<li>第一道题：传统方法做组合逻辑设计：即写出逻辑函数表达式然后画电路图</li>\r\n<li>第二道题：利用已有的逻辑器件实现逻辑函数</li>\r\n<li>第三道题：利用已有的逻辑器件实现逻辑函数（函数与第二道题一样）</li>\r\n<li>8421、余3、BCD，有概率前三题会涉及到</li>\r\n</ul></li>\r\n<li>异步时序逻辑分析：\r\n<ul>\r\n<li>ppt上有两个例子，把那两个例子搞明白就差不多了</li>\r\n</ul></li>\r\n<li>时序逻辑设计：\r\n<ul>\r\n<li>第一道题：设计一个器件</li>\r\n<li>第二道题：设计一个器件</li>\r\n<li>第三道题：状态机，上课讲过一些例子，没那么复杂</li>\r\n<li>代码要写注释</li>\r\n</ul></li>\r\n</ul>\r\n<p><img src=\"90.png\" /></p>\r\n","categories":["4. 大学","数字逻辑"]},{"title":"数据库自学笔记","url":"/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"<p>懒得解释了，反正之前没咋认真听过课（其实是去做数据库期末项目了）。今天终于有点时间了抽空看了一下之前的内容，做一下笔记记录一下免得以后忘了。学点东西顺便应付一下期末考试。</p>\r\n<span id=\"more\"></span>\r\n<p>upd: (2024/1/14)：这门课满绩了，考试很简单，都是笔记里的东西。</p>\r\n<hr />\r\n<h3 id=\"数据库基础概念相关\">数据库基础概念相关</h3>\r\n<ol type=\"1\">\r\n<li><p>数据(Data)、数据库(DB)、数据库系统(DBS)、数据库管理系统(DBMS)数据定义</p>\r\n<ol type=\"1\">\r\n<li>数据是描述事物的符号记录。</li>\r\n<li>数据库是指长期存储在计算机内的、有组织的、可共享的大量数据集合。</li>\r\n<li>数据库系统是指在计算机系统中引入数据库后的系统构成，由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员(和用户)构成。</li>\r\n<li>数据库管理系统是位于用户(应用程序)与操作系统之间的一层数据库管理软件。</li>\r\n</ol></li>\r\n<li><p>数据库系统的开发环节</p>\r\n<p><img src=\"6.png\" /></p>\r\n<p>​\r\n概念设计：通常使用实体-关系模型（ER模型）来表示数据和数据间的关系。</p>\r\n<p>​\r\n逻辑设计：通常是关系模型(还有层次/网状模型)，包括了表/列/数据类型、约束（如主键、外键）等。</p>\r\n<p>​\r\n物理设计：确定如何在物理存储层面上存储数据，包括文件组织、索引结构、数据分布、存储分配等。</p></li>\r\n<li><p>数据管理的四个发展阶段：手工阶段、程序阶段、文件阶段、数据库阶段</p></li>\r\n<li><p>数据库、数据库系统、数据库管理系统的功能</p>\r\n<ol type=\"1\">\r\n<li>DB：存储、检索、维护数据</li>\r\n<li>DBS：管理数据库以及环境、支持用户与数据库交互、控制数据库权限及安全</li>\r\n<li>DBMS：提供数据定义(DDL)、数据操作(DML)、数据控制(DCL)语言，同时维护数据库，确保数据库的完整性、性能优化和恢复管理</li>\r\n</ol></li>\r\n<li><p>概念模型：是对现实世界的系统、概念或其他复杂对象的抽象表示。例如：层次模型(类似树)、网状模型(类似图)、关系模型(现在的数据库模型)、实体-联系模型(不是数据库模型，是一种用于数据库设计的高层次概念模型(ER图)</p></li>\r\n<li><p>关系模型的完整性约束</p>\r\n<ol type=\"1\">\r\n<li>实体完整性：确保每个表的主键是唯一的，且不允许为NULL。</li>\r\n<li>参照完整性：如果表A中的某个字段是表B中主键的外键，则表A中所有的外键值必须在表B中有相对应的主键值，或者是NULL。</li>\r\n<li>域完整性：数据列中的每个值都必须是定义的数据域中的有效值。</li>\r\n<li>用户定义完整性：是针对特定业务规则定制的约束条件。</li>\r\n</ol></li>\r\n<li><p>关系型数据库和非关系型数据库的主要区别是什么？并举出相应的软件产品</p>\r\n<ul>\r\n<li>关系数据库是基于关系模型的，数据以表格的形式组织，表格中的行表示记录，列表示属性。常见关系型数据库有MySql、PostgreSQL、SQL\r\nServer等；非关系型数据库采用不同的数据组织方式，如文档存储、键值对存储或图形数据库。常见的非关系型数据库有MongoDB、Hbase等。</li>\r\n</ul></li>\r\n<li><p>视图（Note：仅在少数简单视图上可以更新数据）</p></li>\r\n</ol>\r\n<ul>\r\n<li>定义：是一种虚拟表，其内容由查询定义，但不在数据库中以存储数据的形式存在。</li>\r\n<li>特点：\r\n<ul>\r\n<li>虚拟性：视图不存储数据，它是一个查询的结果集。</li>\r\n<li>逻辑独立性：可以更改底层数据表的结构而不影响视图。</li>\r\n<li>安全性：可以仅展示用户需要或允许看到的数据。</li>\r\n<li>简化复杂查询：可以创建视图来简化用户的操作。</li>\r\n</ul></li>\r\n</ul>\r\n<h3 id=\"数据库范式相关\">数据库范式相关</h3>\r\n<h4\r\nid=\"函数依赖函数依赖集依赖的推导\">函数依赖、函数依赖集、依赖的推导</h4>\r\n<ul>\r\n<li>函数依赖(FD)。</li>\r\n</ul>\r\n<p>假设在一张表中，任意挑俩元组i, j，若发现若<span\r\nclass=\"math inline\">\\(A_i = A_j\\)</span>，则<span\r\nclass=\"math inline\">\\(B_i = B_j\\)</span>，则说明属性A可推出B，写作<span\r\nclass=\"math inline\">\\(A \\rightarrow B\\)</span>，称为B依赖于A。</p>\r\n<ul>\r\n<li>函数依赖集(FDs)。</li>\r\n</ul>\r\n<p>就是一个集合，里头的元素是函数依赖。</p>\r\n<ul>\r\n<li>依赖的推导</li>\r\n</ul>\r\n<p>三个公理（要记住。这个其实感性理解很好理解）：</p>\r\n<ol type=\"1\">\r\n<li>如果Y是X的子集，则<span class=\"math inline\">\\(X \\rightarrow\r\nY\\)</span></li>\r\n<li>如果<span class=\"math inline\">\\(X \\rightarrow Y\\)</span>，则<span\r\nclass=\"math inline\">\\(XZ \\rightarrow YZ\\)</span></li>\r\n<li>如果<span class=\"math inline\">\\(X \\rightarrow Y, Y \\rightarrow\r\nZ\\)</span>，则<span class=\"math inline\">\\(X \\rightarrow Z\\)</span></li>\r\n</ol>\r\n<p>两个定理</p>\r\n<ol type=\"1\">\r\n<li>若<span class=\"math inline\">\\(X \\rightarrow Y, X \\rightarrow\r\nZ\\)</span>，则<span class=\"math inline\">\\(X \\rightarrow YZ\\)</span>\r\n<ul>\r\n<li>证明：因为<span class=\"math inline\">\\(X \\rightarrow\r\nY\\)</span>，所以<span class=\"math inline\">\\(XZ \\rightarrow\r\nYZ\\)</span></li>\r\n<li>因为<span class=\"math inline\">\\(X \\rightarrow Z\\)</span>，所以<span\r\nclass=\"math inline\">\\(X \\rightarrow XZ\\)</span></li>\r\n<li>所以<span class=\"math inline\">\\(X \\rightarrow XZ \\rightarrow\r\nYZ\\)</span></li>\r\n</ul></li>\r\n<li>若<span class=\"math inline\">\\(X \\rightarrow YZ\\)</span>，则<span\r\nclass=\"math inline\">\\(X \\rightarrow Y, X \\rightarrow Z\\)</span>\r\n<ul>\r\n<li>证明：因为Y, Z是YZ子集，所以<span class=\"math inline\">\\(YZ\r\n\\rightarrow Y, YZ \\rightarrow Z\\)</span></li>\r\n<li>所以<span class=\"math inline\">\\(X \\rightarrow YZ \\rightarrow Y, X\r\n\\rightarrow YZ \\rightarrow Z\\)</span></li>\r\n</ul></li>\r\n</ol>\r\n<p>任何的依赖推导用上面这五条性质一般都可以推出来了。</p>\r\n<h4 id=\"候选码非主属性主属性超键\">候选码、非主属性、主属性、超键</h4>\r\n<ul>\r\n<li>候选码：能唯一标识一个关系的属性集合且集合大小要保证最小\r\n<ul>\r\n<li>注意，一个关系R中可能存在多个候选码</li>\r\n</ul></li>\r\n<li>非主属性：只要有一个属性，它不属于任何一个候选码的属性，它就是非主属性</li>\r\n<li>主属性：只要有一个属性，它属于某一个候选码，它就是主属性</li>\r\n<li>超键：能唯一标识一个关系的属性集合\r\n<ul>\r\n<li>注意，跟候选码不同的是，候选码的要求是在能唯一标识的基础上，保证集合大小最小。但是超键则无所谓，多大都ok。</li>\r\n<li>注意，一个关系R中可能存在多个超键</li>\r\n</ul></li>\r\n</ul>\r\n<h4 id=\"函数依赖集的闭包属性的闭包\">函数依赖集的闭包、属性的闭包</h4>\r\n<p>一般关系都是R表示，关系的函数依赖集一般用F表示。函数依赖集的闭包用<span\r\nclass=\"math inline\">\\(F^+\\)</span>表示。</p>\r\n<p>求<span\r\nclass=\"math inline\">\\(F^+\\)</span>就是用F中的依赖把所有能推出来的依赖都推出来（画树状图+用5条性质去推），就是<span\r\nclass=\"math inline\">\\(F^+\\)</span>。</p>\r\n<p>假设有一个属性A，则属性A的闭包写作<span\r\nclass=\"math inline\">\\(A^+\\)</span>。推<span\r\nclass=\"math inline\">\\(A^+\\)</span>的方法用“背包材料”的理念。最初背包中只有A这一个材料，所以首先拿A去推，能推出来的东西都放入“背包”中。然后再用背包中的材料（材料可以组合）去推，依次类推。直到没有东西可以放入背包中。</p>\r\n<p>属性闭包蛮有用的，具体作用有如下2条：</p>\r\n<ol type=\"1\">\r\n<li>判断<span class=\"math inline\">\\(X \\rightarrow Y\\)</span>是否在<span\r\nclass=\"math inline\">\\(F^+\\)</span>里。\r\n<ul>\r\n<li>正常思路是先写出F+，然后就知道<span class=\"math inline\">\\(X\r\n\\rightarrow Y\\)</span>在不在F+里了。但其实可以先写出<span\r\nclass=\"math inline\">\\(X^+\\)</span>，只要<span\r\nclass=\"math inline\">\\(X^+\\)</span>里有Y，那么<span\r\nclass=\"math inline\">\\(X \\rightarrow Y\\)</span>就在<span\r\nclass=\"math inline\">\\(F^+\\)</span>里。</li>\r\n</ul></li>\r\n<li>判断某个属性集合是否是超键\r\n<ul>\r\n<li>假设属性集合叫S，那写出<span\r\nclass=\"math inline\">\\(S^+\\)</span>，如果<span\r\nclass=\"math inline\">\\(S^+\\)</span>里包含了所有属性，那么属性集合S就是超键。</li>\r\n</ul></li>\r\n</ol>\r\n<p>补充：假定有关系R和函数依赖集F，如何推出候补码？</p>\r\n<p>观察F，然后使用口诀：“只在左边的一定是，只在右边的一定不是，两边都在的试一试”</p>\r\n<p>具体来说，如果属性A在F中只出现在箭头的左边，那么A一定属于任意一个候补码。如果属性A在F中只出现在箭头的右边，那么A一定不属于任意一个候补码（即非主属性）。如果在箭头左右都出现过，那就试一试，用属性的闭包去验证一下即可。</p>\r\n<h4\r\nid=\"无损分解分解后是否保持函数依赖\">无损分解、分解后是否保持函数依赖</h4>\r\n<p>分解一个表有时是很有必要的。假设一个表有属性“学生等级”和“学生评价”。且我们知道，如果一个学生的等级是A、B、C，他的评价分别是优秀、良好、差。如果不分解的话每次记录都要把其等级和评价记下来。但是这显然没必要，只需要记录任意一个就好。因为他们俩只要知道其中一个，另外一个是可以推出来的。</p>\r\n<p>所以可以将表分解成两张表，第一张记录了其它数据 +\r\n学生等级，第二张表记录学生等级 + 学生评价。</p>\r\n<p>上面这个例子就是解释分解是什么个意思。接下来讨论无损分解。</p>\r\n<p>无损分解就是说分解成的两个表经过自然连接后可以得到原表。不会有额外数据的增添。</p>\r\n<p>先讲结论，如果讲表R分解为<span class=\"math inline\">\\(R_1,\r\nR_2\\)</span>，如果​俩表之交能通过FDs推出任意其中一个表，则这必然是一个无损分解。</p>\r\n<p>这很好感性理解，自然连接本质就是找到俩表相同的公共部分然后连接。所以如果俩表的公共部分可以推出其中一个表，就说明不会有额外数据的增添。看下面这个例子就很好理解。</p>\r\n<p><img src=\"1.png\" /></p>\r\n<p>至于分解后是否保持函数依赖，要看F。</p>\r\n<p>也就是F中的每一对依赖X、Y，必须出现在某个子表<span\r\nclass=\"math inline\">\\(R_i\\)</span>中。这样就分解后就保持函数依赖。</p>\r\n<h4 id=\"bcnf\">BCNF</h4>\r\n<p>BCNF是3.5NF，如果一个关系是3.5NF，那么它必定是3NF。</p>\r\n<p>如果一个关系R满足BCNF，那么这张表中就不存在“冗余”。所以BCNF是很棒的。</p>\r\n<p>如果一个关系R不满足BCNF呢？那么就将R分解成若干个子表，使得每个子表都满足BCNF，这样也就不会有冗余了，这样也是很棒的。</p>\r\n<p>所以问题的关键就是如何判断一个表是否满足BCNF？以及如果一个表不满足BCNF，如何将它分解成满足BCNF的子表？</p>\r\n<p>先讲第一个问题，如何判断一个表是否满足BCNF。</p>\r\n<p>假定现在有关系R，函数依赖集F。对于F中每一条关系<span\r\nclass=\"math inline\">\\(X \\rightarrow\r\nY\\)</span>，必须满足下面任意一条，则R满足BCNF。</p>\r\n<ol type=\"1\">\r\n<li>X是超键</li>\r\n<li>X包含Y</li>\r\n</ol>\r\n<p>下面讨论第二个问题，如何将一个不满足BCNF的表分解为满足BCNF的若干子表。</p>\r\n<p>若<span class=\"math inline\">\\(X \\rightarrow\r\nY\\)</span>不满足2条规则中任意一条，则将R分解为<span\r\nclass=\"math inline\">\\(R_1 = R - Y\\)</span>与<span\r\nclass=\"math inline\">\\(R_2 = X +\r\nY\\)</span>。显然，这是个无损分解（很容易证明，公共部分是X，且X可推出R2）。而且<span\r\nclass=\"math inline\">\\(R_1, R_2\\)</span>也是满足BCNF的。</p>\r\n<p>如果有多个依赖不满足规则呢？那就依次分解即可（注意，不同分解顺序带来的结果并不相同不过都是对的）</p>\r\n<p>综上，在设计自己的数据库时，我们要尽可能的使表都满足BCNF，这样就不会产生数据的冗余。但是BCNF有一个缺点，就是分解后不一定能保持函数的依赖。比如下面这个例子：</p>\r\n<p><img src=\"2.png\" /></p>\r\n<p><span class=\"math inline\">\\(L \\rightarrow\r\nK\\)</span>不满足规则，所以将R分解为<span class=\"math inline\">\\(R_1 = (J,\r\nL), R_2 = (L,\r\nK)\\)</span>。函数依赖有两个，第二个在R2中可得到保持，第一个在R1或R2都不能得到保持，所以分解后没能保持函数依赖。</p>\r\n<p>这就是BCNF的一个缺点，所以接下来就要介绍3NF。3NF的优点就是它可以保持函数的依赖，但是它的缺点就是仍然会存在一些冗余。</p>\r\n<h4 id=\"nf\">3NF</h4>\r\n<p>跟BCNF一样，3NF还是两个灵魂问题：（1）如何判断关系R是否满足3NF（2）如果R不满足3NF，如何将它分解为若干子表使得它们满足3NF</p>\r\n<p>先来解决第一个问题。</p>\r\n<p>假定现在有关系R，函数依赖集F。对于F中每一条关系<span\r\nclass=\"math inline\">\\(X \\rightarrow\r\nY\\)</span>，必须满足下面任意一条，则R满足3NF。</p>\r\n<ol type=\"1\">\r\n<li>X是超键</li>\r\n<li>Y被包含在X里</li>\r\n<li>Y属于候补码（注意不是超键噢）（所以先要求出候补码）</li>\r\n</ol>\r\n<p>现在来解决第二个问题。</p>\r\n<p>分为以下几步：</p>\r\n<ol type=\"1\">\r\n<li>求F最小覆盖集<span class=\"math inline\">\\(F_c\\)</span>\r\n<ol type=\"1\">\r\n<li>从第一个检查到最后一个，把能用其它依赖推出来的依赖去掉</li>\r\n<li>从第一个检查到最后一个，把左右边的变量尽量减少</li>\r\n<li>回到第一步，若第一步去不掉则进入第四步</li>\r\n<li>对于左边相同的，把右边合并起来</li>\r\n</ol></li>\r\n<li>将<span\r\nclass=\"math inline\">\\(F_c\\)</span>中每一个依赖拿出来组成新表</li>\r\n<li>求候选码</li>\r\n<li>看候选码在不在其中一个新表中，不在的话就新加一个表，表的属性就是候选码</li>\r\n</ol>\r\n<p>综上，3NF的好处就是可以保持函数依赖（而且也是无损分解），缺点就是会存在点冗余。</p>\r\n<h4 id=\"范式总结nf\">范式总结（NF）</h4>\r\n<p>第三范式前面是用“规则”定义出来的，其实它还有另一种定义。</p>\r\n<ul>\r\n<li>第一范式（1NF）：每个属性都是原子属性，本质上所有关系的都满足第一范式。</li>\r\n<li>第二范式（2NF）：在满足第一范式的前提下，满足所有非主属性必须依赖于整个候选码而不能依赖于候选码的部分属性。</li>\r\n<li>第三范式（3NF）：在满足第二范式的前提下，满足F中不能有非主属性之间的依赖传递。</li>\r\n</ul>\r\n<h3 id=\"数据库存储相关\">数据库存储相关</h3>\r\n<ol type=\"1\">\r\n<li><p>文件中记录的表示方式</p>\r\n<ol type=\"1\">\r\n<li>定长记录：每个记录的大小是固定的。每个字段（或属性）在记录中分配有固定数量的字节。这种方式简化了记录的定位和访问，因为可以直接计算出任何记录的位置。</li>\r\n<li>变长记录：不同记录可能有不同的长度。需要额外的信息来确定记录的确切位置和长度。</li>\r\n</ol></li>\r\n<li><p>文件中记录集合的组织方式</p>\r\n<ol type=\"1\">\r\n<li>堆文件：记录在文件空间中任意放置</li>\r\n<li>顺序文件：按一定的顺序在文件中组织记录</li>\r\n<li>散列文件：按照散列函数计算值存放相应记录</li>\r\n<li>多表簇集文件：不同关系表里的记录存放在同一个文件中</li>\r\n</ol></li>\r\n<li><p>元数据是指一个关系数据库系统需要维护关于关系的数据。元数据存储在称为“数据字典”或“系统目录”的结构中</p></li>\r\n<li><p>数据库缓冲区管理器的工作原理</p>\r\n<ul>\r\n<li>大致可以概括为以下几个步骤</li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>数据页的加载：当需要读取数据时，首先检查所需的数据页是否已经在缓冲区中。如果是，它就直接从缓冲区读取数据，反之则从硬盘上读取数据页，并将其加载到缓冲区中。</li>\r\n<li>缓冲区的替换策略：由于缓冲区的大小是有限的，当缓冲区满时，缓冲区管理器必须决定哪些数据页被保留，哪些被替换。</li>\r\n<li>脏页的写回：如果一个数据页在缓冲区中被修改，在它被替换出缓冲区之前，这些更改需要被写回到硬盘上以保持数据的持久性。</li>\r\n<li>并发控制：缓冲区管理器还需要处理多个事务或操作同时访问同一数据页的情况。这通常涉及锁定机制或乐观并发控制来保证数据的完整性和一致性。</li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"数据库索引相关\">数据库索引相关</h3>\r\n<ol type=\"1\">\r\n<li><p>索引分类</p>\r\n<ol type=\"1\">\r\n<li>顺序索引（按照排好的顺序储存搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。）\r\n<ol type=\"1\">\r\n<li>主索引(聚集索引)</li>\r\n<li>辅助索引(非聚集索引)(二级索引)</li>\r\n</ol></li>\r\n<li>B+树索引</li>\r\n<li>散列索引（基于将值平均分布到若干桶中，一个值所属的桶由散列函数决定）\r\n<ol type=\"1\">\r\n<li>静态索引：就是普通的桶</li>\r\n<li>动态索引：就是用二进制实现的桶</li>\r\n</ol></li>\r\n</ol>\r\n<ul>\r\n<li><p>稠密索引就是每条记录都有一个索引指针会指向它，稀疏索引就是只有部分索引会指向它。</p></li>\r\n<li><p>注意，稀疏索引必须是主索引，二级索引必须是稠密索引。因为主索引的顺序就是记录排列的顺序，所以主索引可以是稀疏索引。但是二级不行，因为二级的索引顺序不是记录排列的顺序，所以如果二级是稀疏索引的话，就有可能无法查到目标数据。所以二级索引必须是稠密索引，稀疏索引必须是主索引。</p></li>\r\n<li><p>稀疏索引的优点是占用空间小，缺点是速度慢，精确率相对较低；稠密索引的优点是查找效率快，方面插入和删除。缺点是占用空间大。</p></li>\r\n</ul></li>\r\n</ol>\r\n<h3 id=\"数据库查询有关\">数据库查询有关</h3>\r\n<ol type=\"1\">\r\n<li>对于一条SQL语句，先经过<strong>语法分析器</strong>分析语法是否正确，然后经过<strong>翻译器</strong>被翻译为关系代数表达式，这个关系代数表达式再经过<strong>优化器</strong>，得到一个执行计划，最后通过<strong>执行引擎</strong>被执行。</li>\r\n<li>两个表连接操作的几种实现方法：\r\n<ol type=\"1\">\r\n<li>嵌套循环连接：<span class=\"math inline\">\\(O(n^2)\\)</span></li>\r\n<li>排序-合并连接：<span class=\"math inline\">\\(O(nlogn +\r\nn)\\)</span></li>\r\n<li>索引连接：<span class=\"math inline\">\\(O(nlogn)\\)</span></li>\r\n<li>Hash连接：最好情况下<span class=\"math inline\">\\(O(n)\\)</span></li>\r\n</ol></li>\r\n<li>优化器要做的事：\r\n<ol type=\"1\">\r\n<li>将关系代数表达式转换为查询树</li>\r\n<li>对查询树做变换</li>\r\n<li>生成执行计划</li>\r\n</ol></li>\r\n<li>代数优化就是先做选择操作、再做连接操作。物理优化就是优化器决定是采用全盘扫描还是索引扫描，如果采用索引扫描的话是用顺序索引还是B+树索引还是Hash索引。</li>\r\n</ol>\r\n<h3 id=\"数据库事务相关\">数据库事务相关</h3>\r\n<ol type=\"1\">\r\n<li><p>事务的基本特性(ACID)（以银行转账为例）</p>\r\n<ul>\r\n<li>事务定义：事务是指构成单一逻辑单元的操作集合。</li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>A：原子性：事务要么就不执行，那么就执行，不会执行到一半退出去。</li>\r\n<li>C：一致性：事务的执行不会改变所有钱的总和。</li>\r\n<li>I：隔离性：尽管可能存在多个事务同时并发执行的情况，但系统保证，每个事务都感觉不到中其它事务在并发的执行。</li>\r\n<li>D：持久性：一旦事务完成，其对数据库的影响就是持久的。</li>\r\n</ol></li>\r\n<li><p>事务状态</p>\r\n<ul>\r\n<li><p>活动的：事务执行时的状态</p></li>\r\n<li><p>部分提交的：最后一条语句执行后</p></li>\r\n<li><p>提交的：成功完成后</p></li>\r\n<li><p>失败的：发现不能执行后</p></li>\r\n<li><p>中止的：事务回滚并且数据库已恢复到事务开始执行前的状态后</p></li>\r\n<li><p>事务状态图：</p>\r\n<p><img src=\"3.png\" /></p></li>\r\n</ul></li>\r\n<li><p>调度</p>\r\n<ol type=\"1\">\r\n<li><p>调度分类</p>\r\n<ol type=\"1\">\r\n<li>串行调度：一个事务完成后再去执行下一个事务</li>\r\n<li>并行调度：调度中多个事务的指令在时间上相互交叉地进行</li>\r\n<li>可串行化调度：这个概念是针对于并行调度的。一个并行调度可能是可串行化调度，也可能不是。如果存在一个串行调度，使得其运行结果等于一个并行调度，则称这个并行调度为可串行化调度。</li>\r\n</ol></li>\r\n<li><p>冲突可串行化</p>\r\n<ol type=\"1\">\r\n<li>冲突操作：如果俩操作属于不同事务，且至少有一个wire操作，且作用于相同数据项，则这俩操作是冲突的。</li>\r\n<li>注意，如果一个并行调度是可串行化调度，那么它就是冲突可串行化的。</li>\r\n<li>冲突可串行化的判定方法：如果一个并行调度不存在死锁，则可以转换为一个串行调度，也就是这个并行调度是冲突可串行化的。</li>\r\n<li>并行调度转换为串行调度的方法：先画出调度优先图，然后其拓扑序就是串行调度。</li>\r\n</ol></li>\r\n<li><p>调度优先图</p>\r\n<ul>\r\n<li><p>这个名字起的很烂，我愿意叫它“死锁图”。是一种用来检测事务调度中是否存在死锁的工具。</p></li>\r\n<li><p>图中的每一个节点代表一个事务，如果事务A需要等待B释放资源才能进行，则A向B连一条边。如果图中存在环，则存在死锁。</p></li>\r\n<li><p><img src=\"4.png\" /></p></li>\r\n<li><p>例如这个图，以数据Y举例，对于所有对Y的read/wire操作，若其时间后有其冲突操作，则俩事务之间连一条边。</p></li>\r\n</ul></li>\r\n<li><p>预防死锁的方法</p>\r\n<ol type=\"1\">\r\n<li>wait-die机制：当事务<span\r\nclass=\"math inline\">\\(T_i\\)</span>申请的数据项当前被<span\r\nclass=\"math inline\">\\(T_j\\)</span>持有，仅当<span\r\nclass=\"math inline\">\\(T_i\\)</span>的时间戳小于<span\r\nclass=\"math inline\">\\(T_j\\)</span>的时间戳时，允许<span\r\nclass=\"math inline\">\\(T_i\\)</span>等待。否则<span\r\nclass=\"math inline\">\\(T_i\\)</span>回滚。</li>\r\n<li>wound-die机制：当事务<span\r\nclass=\"math inline\">\\(T_i\\)</span>申请的数据项当前被<span\r\nclass=\"math inline\">\\(T_j\\)</span>持有，仅当<span\r\nclass=\"math inline\">\\(T_i\\)</span>的时间戳大于<span\r\nclass=\"math inline\">\\(T_j\\)</span>的时间戳时，允许<span\r\nclass=\"math inline\">\\(T_i\\)</span>等待。否则，<span\r\nclass=\"math inline\">\\(T_j\\)</span>回滚。</li>\r\n</ol></li>\r\n<li><p>解决死锁的方法</p>\r\n<ul>\r\n<li>选择一个或多个事务进行回滚，释放它们所占用的资源。通常会选择代价最小的事务进行回滚，代价的衡量标准可能包括事务的执行时间、所占用资源数量、距离完成的远近等。为了改进，可以采用部分回滚，这要求需要更多的额外信息。</li>\r\n</ul></li>\r\n<li><p>可恢复调度 &amp; 无级联调度</p>\r\n<ul>\r\n<li>对于调度中的任意俩事务A, B，如果B read 了A之前 wire\r\n的同个数据，则事务A必须在事务B之前提交。</li>\r\n<li>对于调度中的任意俩事务A, B，如果B read 了A之前 wire\r\n的同个数据，则事务A必须在事务B的read操作之前提交。</li>\r\n</ul></li>\r\n</ol></li>\r\n<li><p>事务的隔离级别</p>\r\n<ol type=\"1\">\r\n<li><p>读未提交：允许事务read未被其它事务提交的更改</p></li>\r\n<li><p>读提交：事务只能read已经被提交的更改（数据库的默认隔离级别）</p></li>\r\n<li><p>可重复读：确保在事务执行期间，如果事务重新读取之前已读取的数据，则会看到相同的数据。</p>\r\n<ul>\r\n<li><p>脏读：一个事务读取了另一个事务尚未提交的数据时。</p></li>\r\n<li><p>不可重复读：事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发\r\n生了改变。因此产生了不可重复读。</p></li>\r\n<li><p>幻读：与不可重复读类似，它发生在当一个事务T1读取了一系列符合特定条件的行，然后另一个并发事务T2插入或删除了一些符合T1搜索条件的新行并提交。当T1再次执行相同的查询时，它将“神奇地”看到之前不存在的新行（即“幻行”）。</p></li>\r\n</ul></li>\r\n<li><p>串行化：调度中事务只能串行运行</p></li>\r\n</ol>\r\n<p><img src=\"5.png\" /></p></li>\r\n</ol>\r\n<h3 id=\"数据库锁相关\">数据库锁相关</h3>\r\n<p>为了保证数据的一致性(事务的隔离性)和提高系统的并发处理能力，或者说为了保证应用的有效性，所以引入锁。封锁协议定义了事务如何获取和释放锁的规则。</p>\r\n<ol type=\"1\">\r\n<li><p>锁</p>\r\n<ol type=\"1\">\r\n<li>共享锁(S)：当一个事务想要读取数据时，它会在相应的数据项上放置一个共享锁。共享锁的特点是它允许多个读取事务并发地访问同一个数据项，因为读取操作不会互相冲突。所以如果一个事务获得了数据项的共享锁，则它可read但不能wire该数据项。</li>\r\n<li>排他锁(X)：当一个数据上了排他锁后，当某事务想要修改或读数据时，它会请求并获得排他锁。只有获得了排他锁，才能对其修改。而且注意，一旦一个数据的排他锁被拿了，那么其它事务就不能获得该数据的排他锁和共享锁，直至其排他锁被归还。</li>\r\n</ol></li>\r\n<li><p>封锁协议</p>\r\n<ol type=\"1\">\r\n<li><p>二阶段锁定协议</p>\r\n<ul>\r\n<li><p>最常用的就是二阶段锁定协议，即要求每个事务分两个阶段对数据进行锁定和解锁。增长阶段：事务可以获得锁，但不能释放锁。缩减阶段：事务可以释放锁，但不能获得新的锁。</p></li>\r\n<li><p>二阶段锁定协议特点：</p>\r\n<ol type=\"1\">\r\n<li>把两个阶段的定义抄一遍</li>\r\n<li>可以保证冲突可串行化：多个事务根据封锁点的顺序进行排序即是可串行化顺序。</li>\r\n</ol></li>\r\n<li><p>二阶段锁定协议保证了不会出现脏读的问题。但是不可重复读、死锁、活锁、级联回滚问题仍然可能会出现。另外，虽然两阶段封锁协议保证冲突可串行化，但是冲突可串行化未必符合两阶段封锁。</p></li>\r\n</ul></li>\r\n<li><p>严格两阶段封锁协议</p>\r\n<ul>\r\n<li>定义：在2PL的基础上，要求事务所持排他锁必须在事务提交后方可释放。这个要求保证了在提交前防止其它事务读这些数据。可以避免出现级联回滚。</li>\r\n</ul></li>\r\n<li><p>强两阶段封锁协议</p>\r\n<ul>\r\n<li>定义：要求事务提交之前不能释放任何锁。</li>\r\n</ul></li>\r\n<li><p>树形协议</p>\r\n<ul>\r\n<li>定义：树形协议是一种数据库并发控制机制，用于管理在树状数据结构（如B树索引）上的锁。它规定了事务在获得和释放锁的顺序，以确保在访问树形数据结构的不同部分时维护一致性和隔离性。事务必须按照从根节点到叶节点的顺序来获取锁，并且在向下遍历树时不能返回到已经释放锁的节点。这种方法避免了死锁的发生，因为它不允许事务在树结构中回溯并重新获取锁。</li>\r\n<li>优点：保证了冲突可串行化；不会产生死锁，不需要回滚；可较早地释放锁，以减少事务间的等待时间，从而可增强调度的并发性。</li>\r\n<li>缺点：不能保证事务的可恢复性；不能保证不发生级联回滚；可能会给那些根本不访问的数据项加锁，从而增加了锁的开销和额外的等待时间，使并发性降低。</li>\r\n</ul></li>\r\n<li><p>多粒度封锁协议</p>\r\n<ul>\r\n<li>规则：\r\n<ol type=\"1\">\r\n<li>引入意向锁，并规定了与S/X锁的兼容性规则</li>\r\n<li>事务必须首先在高级别上获取意向锁，然后才能在低级别上获取实际的共享或排他锁。</li>\r\n<li>锁可以在事务的任何时候释放，但一旦释放，事务就不能再在那个级别或更低级别上获取新的锁。</li>\r\n</ol></li>\r\n<li>特点：\r\n<ol type=\"1\">\r\n<li>事务可以根据需要锁定细粒度（如行）或粗粒度（如整个表）的数据，从而提高了系统的并发性。</li>\r\n<li>通过允许在不同粒度上加锁，多粒度封锁减少了锁冲突的可能性，提高了并发访问的效率。</li>\r\n</ol></li>\r\n</ul></li>\r\n<li><p>锁转换</p>\r\n<ul>\r\n<li>定义：允许一个事务在其执行过程中改变已经获得的锁的模式。锁转换分为两种情况：升级和降级。</li>\r\n</ul></li>\r\n<li><p>时间戳排序协议</p>\r\n<ul>\r\n<li>是数据库并发控制中使用的一种机制，用于在没有使用锁的情况下管理事务的并发执行。它通过为每个事务分配一个唯一的时间戳来确保数据库的一致性和隔离性。</li>\r\n</ul>\r\n<p><img src=\"9.png\" /></p></li>\r\n<li><p>快照隔离</p>\r\n<ul>\r\n<li>是数据库系统中一种并发控制方法，它允许事务看到数据库在某一特定时间点的一致性视图。这意味着即使其他事务对数据库进行了修改，一个在快照隔离级别下运行的事务也会看到它开始时数据库的状态，而不会看到这些修改。</li>\r\n</ul></li>\r\n</ol></li>\r\n</ol>\r\n<h3 id=\"数据库日志相关\">数据库日志相关</h3>\r\n<ol type=\"1\">\r\n<li><p>故障种类</p>\r\n<ol type=\"1\">\r\n<li>事务故障\r\n<ol type=\"1\">\r\n<li>逻辑错误：如非法输入、找不到数据、溢出或超出资源限制。</li>\r\n<li>系统错误：系统进入一种不良状态（如死锁），结果事务无法正常执行。</li>\r\n</ol></li>\r\n<li>系统崩溃：硬件故障，或者是数据库软件或操作系统的漏洞，导致易失性存储器内容的丢失，并使得事务处理停止。</li>\r\n<li>磁盘故障：在数据传送操作过程中由于磁头损坏或故障造成磁盘块上的内容丢失。</li>\r\n</ol></li>\r\n<li><p>什么是基于日志的恢复机制</p>\r\n<ul>\r\n<li>是DBMS中用来保证数据一致性和完整性的一种技术。这种机制依赖于日志文件，它记录了对数据库所做的所有修改。通过redo和undo操作，使得数据库能够在发生故障后恢复到一个一致的状态，保证了即使在系统崩溃后，也不会丢失已提交的数据，并且不会有未完成事务的残留影响。是实现持久性的关键机制。</li>\r\n</ul></li>\r\n<li><p>事务和日志的关系</p>\r\n<ul>\r\n<li>事务执行依赖于日志来记录和维护操作的历史，而日志则提供了必要的机制来保证事务的完整性和数据库的恢复能力。这种依赖关系是现代数据库系统实现高可靠性和数据一致性的基础。</li>\r\n</ul></li>\r\n<li><p>如何根据日志写出恢复日志（看图片+做题吧，懒得讲了）</p>\r\n<p><img src=\"7.png\" /></p>\r\n<p><img src=\"8.png\" /></p></li>\r\n</ol>\r\n<h3 id=\"数据库错题相关\">数据库错题相关</h3>\r\n<ol type=\"1\">\r\n<li><p><img src=\"10.png\" /></p></li>\r\n<li><p><img src=\"11.png\" /></p></li>\r\n<li><p>ER图的时候，n对n中间要新开一张表，左右俩表的主键分别为外键，整体作为主键。</p></li>\r\n<li><p>写关系代数/SQL的时候如果只是需要ID的话其实很多情况下不用与另一张表自然连接；注意有时候题目会强制让你写笛卡尔积的sql/关系代数；如果写关系代数没思路时，可以试试俩同样的表做自然连接或者group\r\nby或者用“-”</p></li>\r\n<li><p>3NF时如果被包含记得要删掉</p></li>\r\n<li><p>求BCNF的俩例子</p></li>\r\n</ol>\r\n<p><img src=\"12.png\" /></p>\r\n","categories":["4. 大学","数据库"]},{"title":"阶段性规划","url":"/2024/02/20/%E9%98%B6%E6%AE%B5%E6%80%A7%E8%A7%84%E5%88%92/","content":"<p>现在自己也大二了，讲实话。愈发感觉到要好好考虑接下来自己的道路了。</p>\r\n<p>以下内容都具有很强主观性，更多的还是想记录自己的想法，以免走着走着迷失了方向。所以如果你看到了这篇文章，看看就好hhh。</p>\r\n<span id=\"more\"></span>\r\n<p>本科生就三件事：绩点、科研、竞赛、扩展技术栈（Linux基础、Python基础、机器/深度学习基础）</p>\r\n<hr />\r\n<h4 id=\"行业现状\">行业现状</h4>\r\n<p>传统意义上的计算机找工作，抛开非技术类的不谈，无非就是开发、测试、运维、硬件。</p>\r\n<p>开发占大头，因为传统意义上的计算机大概就是开发app、小程序、网站、应用。所以开发分为前端和后端，前端就是冲浪能看到的都是前端做的。后端就是跟数据库、服务器打交道为前端提供接口的。</p>\r\n<p>测试就是干杂活，忽略。</p>\r\n<p>运维就是维护公司各方面业务稳定运行的人，比如数据库运维、网络运维、安全运维、服务器运维...，干的事比较单一，忽略。</p>\r\n<p>硬件，天天与电路板和各种实体物件打交道，需要学物理知识，不喜欢，忽略。</p>\r\n<p>所以大部分人所谓的从事IT行业，都是从事这些工作。</p>\r\n<p>但是随着AI的到来，很多学历高，理论知识强，但没有很多实际工程开发经验的人也需要找工作啊，要不然就饿死了。所以衍生出了“算法岗”，“开发岗”。</p>\r\n<ul>\r\n<li>算法岗：</li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>纯research岗：读论文、搞模型、写论文（大多去研究院或者大厂算法研发岗）</li>\r\n<li>算法工程师：用算法解决实际问题</li>\r\n</ol>\r\n<ul>\r\n<li>开发岗：此处的开发并不是指前端/后端传统意义上的开发，而是指涉及到很多高并行、调度算法、分布式、存储方向知识，用这些知识解决实际问题，力求从较底层技术方向上提高企业利益的岗位</li>\r\n</ul>\r\n<p>开放岗比算法岗需求大，但是卷算法岗的人更多。因为一堆清北上交或者非计算机专业（例如数学/经管/物理），他们因为没有太多实际工程开发经验，大多都是只搞过科研，在学生阶段没有接触所谓分布式、存储、高并行这些学校不教的知识，所以他们往往选择卷算法岗，因为算法这个领域相对容易上手。</p>\r\n<p>薪资其实差不多，到了这俩岗，更多的还是看企业/部门/个人能力。22年各大厂这俩岗薪资参考：https://mp.weixin.qq.com/s/30QTzshys2S4qCz13uEfYQ</p>\r\n<hr />\r\n<h4 id=\"本科研究生阶段\">本科研究生阶段</h4>\r\n<p>下面是在学生阶段需要打好的基础：</p>\r\n<ol type=\"1\">\r\n<li>个人背景\r\n<ol type=\"1\">\r\n<li>学校</li>\r\n<li>研究方向</li>\r\n</ol></li>\r\n<li>论文\r\n<ul>\r\n<li>如果只谈找工作，如果不是顶会的论文作用不大。但是如果论文与岗位方向match，即使不是顶会，作用也非常大</li>\r\n</ul></li>\r\n<li>实习\r\n<ul>\r\n<li>小厂转中厂，中厂转大厂，积累业务能力</li>\r\n<li>拥有多次实习经历起到的作用 跟 顶会论文相当</li>\r\n</ul></li>\r\n<li>比赛\r\n<ul>\r\n<li>比赛是为了找实习，去打知名公司创办的比赛</li>\r\n<li>acm</li>\r\n<li>百度之星</li>\r\n<li>阿里天池竞赛（机器/深度学习相关）</li>\r\n<li>华为软件精英挑战赛（机器/深度学习相关）</li>\r\n<li>CCF CSP</li>\r\n<li>PAT</li>\r\n<li>天梯赛</li>\r\n<li>蓝桥杯</li>\r\n</ul></li>\r\n<li>开源\r\n<ul>\r\n<li>个人博客\r\n<ul>\r\n<li>校内内容、论文相关</li>\r\n<li>竞赛内容</li>\r\n<li>numpy、pandas、matplotlib学习</li>\r\n<li>机器学习理论 &amp; 实战</li>\r\n<li>深度学习理论 &amp; 实战</li>\r\n<li>Linux基础</li>\r\n</ul></li>\r\n<li>Github\r\n<ul>\r\n<li>做过的项目</li>\r\n<li>自己捣鼓的小玩意</li>\r\n</ul></li>\r\n</ul></li>\r\n</ol>\r\n<hr />\r\n<h4 id=\"找工作\">找工作</h4>\r\n<p>说到找工作，讲实话，我更喜欢安安静静做科研。可是，谁都无法预料到自己将来会成为什么样的一个人。所以对于任何事情，无论热爱与否，先做些了解，总比不去了解好。</p>\r\n<p>下面是找工作的一些注意事项：</p>\r\n<ol type=\"1\">\r\n<li>秋招 -&gt; 第二年春招（补招）</li>\r\n<li>把握好提前批，提前批找到好工作的概率大于正式批</li>\r\n<li>提前批里有人才计划，固定区域-固定学校-固定岗位</li>\r\n<li>提前批不录入系统，也就是说不会因为一次面试不好影响后面的面试</li>\r\n</ol>\r\n<ul>\r\n<li>好部门 -&gt; 好公司\r\n<ul>\r\n<li>阿里：（阿里云，阿里妈妈，淘宝)</li>\r\n<li>腾讯： wxg,ieg(光子和天美工作室)</li>\r\n<li>百度： 凤巢，大搜</li>\r\n<li>字节：AML，抖音，tiktok</li>\r\n<li>美团：外卖</li>\r\n<li>滴滴：MPT网约车</li>\r\n<li>快手：社科</li>\r\n</ul></li>\r\n<li>“黑话”</li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>背书：也就是目标公司/部门在行业内认可度如何</li>\r\n<li>白菜：录取的最低标准offer</li>\r\n<li>sp：special offer，比白菜offer好一些</li>\r\n<li>ssp：super special\r\noffer，基础上是除了人才计划以外最好的offer，有概率拿到股票/签字费</li>\r\n<li>人才计划\r\n<ul>\r\n<li>能达到人才计划的真的是凤毛菱角了。以前非常优秀的研究毕业生还是很有竞争力的。但是现在更偏向于全能博士生了。要求高，通常是ccf\r\na一作、本硕博、竞赛成绩优异。</li>\r\n<li>人才计划岗位大致分为两个方向\r\n<ul>\r\n<li>算法方向（占大头）：cv，nlp，搜广推...</li>\r\n<li>开发方向：偏存储、分布式较为底层的技术</li>\r\n</ul></li>\r\n<li>各企业人才计划举例\r\n<ul>\r\n<li>腾讯：青云计划、技术大咖（https://join.qq.com/post.html?）</li>\r\n<li>阿里：阿里星</li>\r\n<li>快手：快star</li>\r\n<li>美团：北斗</li>\r\n<li>小米：未来星</li>\r\n<li>百度：AIdu</li>\r\n<li>华为：天才少年</li>\r\n<li>滴滴：未来精英</li>\r\n</ul></li>\r\n</ul></li>\r\n</ol>\r\n","categories":["杂项"]}]