[{"title":"0. 从博弈论到多智能体强化学习","url":"/2023/10/15/0-%E4%BB%8E%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%88%B0%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/","content":"<p>什么是多智能体强化学习？比如快递工厂里的一个个快递机器，或者王者荣耀人机模式里的每个小兵，异或是现在自动驾驶中的每一辆车，都可以定义为智能体。让智能体进行强化学习是为了他们做出更好的决策。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"博弈论基本概念\">博弈论基本概念</h3>\r\n<ul>\r\n<li>玩家集合：\r\n<ul>\r\n<li><span class=\"math inline\">\\(N = \\{1, 2, ..., n\\}\\)</span></li>\r\n</ul></li>\r\n<li>策略集合\r\n<ul>\r\n<li><span class=\"math inline\">\\(A_1, A_2, A_3, ..., A_n\\)</span></li>\r\n</ul></li>\r\n<li>收益函数\r\n<ul>\r\n<li><span class=\"math inline\">\\(r_1=f_1(A_1, A_2, ...,\r\nA_n)\\)</span></li>\r\n<li><span class=\"math inline\">\\(r_2=f_2(A_1, A_2, ...,\r\nA_n)\\)</span></li>\r\n<li>... ...</li>\r\n<li><span class=\"math inline\">\\(r_n=f_n(A_1, A_2, ...,\r\nA_n)\\)</span></li>\r\n</ul></li>\r\n</ul>\r\n<p>用“囚徒困境”这个例子来进一步理解：</p>\r\n<p><img src=\"1.png\" /></p>\r\n<p>如图是两个玩家，玩家一是绿色的，玩家二是红色的。每个人选择坦白 /\r\n抵赖所获得的分数如图。</p>\r\n<p>若玩家1选择坦白\r\n，则玩家2必然选择坦白，因为比起0分1，1分显然更好。</p>\r\n<p>若玩家1选择抵赖，则玩家2也是选择坦白。</p>\r\n<p>所以不管玩家1选什么，玩家2都会选择坦白，坦白是玩家2的<strong>占优策略</strong>。</p>\r\n<p>同样的，不管玩家2选什么，玩家1也都会选择坦白\r\n，坦白也是玩家1的<strong>占优策略</strong>。</p>\r\n<p>所以博弈结果必然就是俩人都选择坦白。</p>\r\n<p>假如修改一下游戏规则呢？</p>\r\n<p><img src=\"2.png\" /></p>\r\n<p>此时若玩家2的占优策略仍然是坦白。</p>\r\n<p>但是若玩家2选择坦白，则玩家1会选择坦白。若玩家2选择坦白，则玩家1会选择抵赖。此时坦白就不是玩家1的占优策略了。</p>\r\n<p>那么玩家1应该如何做决策呢？</p>\r\n<p>因为俩玩家都是绝顶聪明，所以玩家1肯定知道玩家2做出了它的占优策略——坦白。所以玩家1既然知道玩家2选坦白，他也就只能选坦白。此时坦白是玩家1的<strong>最佳应对</strong>。</p>\r\n<p>通过这个例子，我们感受了一下博弈论，还学到俩新名词，<strong>占优策略</strong>和<strong>最佳应对</strong>。</p>\r\n<p>下面我们来看博弈论的解：</p>\r\n<p>正如同上面的囚徒困境，一些博弈问题是存在解的：解 =\r\n即任何玩家都不能通过独自改变策略而获益时的策略组合，换句话说，解 =\r\n所有玩家处于最佳应对时的策略组合。</p>\r\n<p>数学定义如下：</p>\r\n<ul>\r\n<li><p>给定一个策略组合 <span\r\nclass=\"math inline\">\\(a=(a_1,a_2,...,a_n)\\in A_1\\times\r\nA_2\\times...\\times A_n,\\)</span></p></li>\r\n<li><p>若 <span class=\"math display\">\\[\r\nr_1(a_1,a_2,...,a_n)\\geq r_1(a_1^{\\prime},a_2,...,a_n), \\forall\r\na_1^{\\prime}\\in A_1 \\\\\r\nr_2(a_1,a_2,...,a_n)\\geq r_{1}(a_{1},a_{2}^{\\prime},...,a_{n}),\\forall\r\na_{2}^{\\prime}\\in A_{2} \\\\\r\n... ... \\\\\r\nr_n(a_1,a_2,...,a_n)\\geq r_n(a_1,a_2,...,a_n^{\\prime}),\\forall\r\na_n^{\\prime}\\in A_n\r\n\\]</span></p></li>\r\n<li><p>那么策略组合<span\r\nclass=\"math inline\">\\(a\\)</span>是一个纳什均衡。</p></li>\r\n<li><p>下面介绍另一种博弈情况（混合策略）下的解——混合纳什均衡。</p>\r\n<ul>\r\n<li>混合策略：每个玩家都有一个概率分布<span class=\"math inline\">\\((p_1,\r\np_2, ..., p_n), p_i\\)</span>为玩家选择动作i的概率。</li>\r\n<li>混合纳什均衡：等于一个混合策略组合。s.t.\r\n任何玩家都不能通过独自改变自身混合策略来提高自己的期望收益。</li>\r\n<li>定理：任意一个博弈，必然存在一个混合策略纳什均衡。</li>\r\n</ul></li>\r\n<li><p>例如下面这个例子，此博弈的混合策略纳什均衡就是每个人的混合策略都为<span\r\nclass=\"math inline\">\\(\\frac{1}{3}, \\frac{1}{3},\r\n\\frac{1}{3}\\)</span>。</p></li>\r\n</ul>\r\n<p><img src=\"3.png\" /></p>\r\n<ul>\r\n<li>当然博弈还有许多种均衡，上面只是介绍了最基础的纳什均衡和混合策略纳什均衡。博弈也有很多种博弈（只要加上不同的限定条件），比如所有人收益都是一样的就叫合作博弈，所有人收益之和是一个定值就叫竞争博弈。</li>\r\n</ul>\r\n<h3 id=\"从博弈论走到多智能体强化学习\">从博弈论走到多智能体强化学习</h3>\r\n<p>现实中，博弈玩家、玩家策略的数量都很大很大，而且玩家自身的收益函数可能并不知道，需要一点一点与环境交互才知道。所以用简单的博弈论模型去描述现实问题会比较困难。</p>\r\n<p>所以下面引入一个新的博弈模型——马尔科夫博弈</p>\r\n<ul>\r\n<li><p>玩家集合</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(N = \\{1, 2, ..., n\\}\\)</span></li>\r\n</ul></li>\r\n<li><p>策略集合</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(A_1, A_2, A_3, ..., A_n \\\\ A = A_1\r\n\\times A_2 \\times ... \\times A_n\\)</span></li>\r\n</ul></li>\r\n<li><p>状态集合</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(S = \\{s_1, s_2, ..., s_n\\}\\)</span></li>\r\n</ul></li>\r\n<li><p>转移函数</p>\r\n<ul>\r\n<li>如果已知当前状态<span class=\"math inline\">\\(s_i\\)</span>,\r\n和当前策略<span class=\"math inline\">\\(a_i\\)</span>,\r\n有概率得到下一个状态<span class=\"math inline\">\\(s_i&#39;\\)</span>。</li>\r\n<li>概率函数就是描述上面这个过程的概率是多少。</li>\r\n<li><span class=\"math inline\">\\(f(s_i, a_i, s_i&#39;)\\)</span></li>\r\n</ul></li>\r\n<li><p>收益函数</p>\r\n<ul>\r\n<li><span class=\"math inline\">\\(r_i\\)</span>由S和A确定</li>\r\n</ul></li>\r\n</ul>\r\n<p>上面这个博弈模型就可以描述现实生活中绝大多数博弈模型。</p>\r\n<p>那强化学习跟博弈论又有什么学习呢？</p>\r\n<p>强化学习也分好几种，第一种叫状态价值学习，即有一个状态价值函数<span\r\nclass=\"math inline\">\\(Q(s,\r\na)\\)</span>，表示在s状态下采取a动作所能获得的期望累积收益。通过神经网络拟合Q函数，不断学习来使得它收敛。这是状态价值学习。</p>\r\n<p>那放到多智能体中，在当前状态S下，每个玩家都可以通过强化学习得出自己的<span\r\nclass=\"math inline\">\\(Q_{max}(s_i, a_i), a_i∈A_i\\)</span>\r\n，拿前面囚徒困境去类比的话，就是<span\r\nclass=\"math inline\">\\(a_1\\)</span>为坦白，<span\r\nclass=\"math inline\">\\(a_2\\)</span>为抵赖。也就是此时就可以建模出一个简单的博弈论模型。</p>\r\n<p>当多智能体们通过博弈后，又得到了下一个状态S'。于是再用强化学习算出在状态S'下，每个玩家的<span\r\nclass=\"math inline\">\\(Q_{max}\\)</span>，循环往复以此类推。最后就可以收敛于最优解。</p>\r\n<h3 id=\"总结\">总结</h3>\r\n<p>上面所讲的知识的目的皆在引入博弈论和多智能体强化学习两个概念。所以许多地方为了方便理解没有很严谨，有许多漏洞之处。但作为一个刚入门的小白（比如我），已经可以给我一个大概的理解和感受了，这就是此篇blog的目的。</p>\r\n","categories":["多智能体强化学习","主线"]},{"title":"0. 引言","url":"/2023/10/05/0-%E5%BC%95%E8%A8%80/","content":"<p>在阅读一篇关于多智能体强化学习的论文时，发现涉及到凸优化的知识我不会。于是打算自学，参考的教程是<a\r\nhref=\"https://www.bilibili.com/video/BV19M411T7S7?p=1&amp;vd_source=2501060da9b4bef86e2b8ec8a8d880b5\">中科大凌青老师的教学视频</a>。</p>\r\n<p>文中的笔记是我看完课程后的思考与总结，可能有错误还请指出！我速速修改=w=</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n","categories":["多智能体强化学习","凸优化"]},{"title":"1. 仿射集/凸集/凸锥","url":"/2023/10/05/1-%E4%BB%BF%E5%B0%84%E9%9B%86-%E5%87%B8%E9%9B%86-%E5%87%B8%E9%94%A5/","content":"<p>介绍了仿射集、凸集、凸锥的概念，以及三者之间的联系。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n<p><img src=\"2.jpg\" /></p>\r\n","categories":["多智能体强化学习","凸优化"]},{"title":"1. 深度强化学习导论","url":"/2023/10/15/1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/","content":"<p>以下面这张图和一个例子来说明RL的基本逻辑</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.png\" /></p>\r\n<p>假设智能体是一个刚出生的机器人，我们的目的是想训练它学会站起来行走。</p>\r\n<p>那么它的动作有很多，比如脚摆动10°/20°，手摆动5°/2°，balablabla。</p>\r\n<p>环境就是一个简单的笔直的通道，从机器人出生点到终点，只不过这条直道上有许多很矮的障碍。</p>\r\n<p>奖励就是机器人离终点越近，它每走一个单位距离所能获得的奖励值就增加。并且规定如果机器人长时间没有前进，将会扣除奖励值。并且规定如果机器人被绊倒了，将会大大扣除奖励值。</p>\r\n<p>状态就是智能体通过与环境交互后每一时刻的状态。比如时刻1它到达了某个点是一个状态，时刻2它在某个点被绊倒了也是一个状态。</p>\r\n<p>通过设计这么一个机制，机器人为了得到最大奖励值，他就会逐渐学会站起来，并且走到终点。这就是深度强化学习（RL）。</p>\r\n<blockquote>\r\n<p>强化学习与监督学习的区别</p>\r\n<p>监督学习里，都是有标签的，网络可以通过正确的标签来修正自己的预测。但是强化学习里没有，它只能通过与环境不断交互来优化自己的策略。</p>\r\n</blockquote>\r\n<p>下面通过一个实验，通过实际写代码，来加深对RL的理解：</p>\r\n<p><img src=\"2.png\" /></p>\r\n<p>首先对问题进行建模，动作就是每个拉杆选择拉 /\r\n不拉。奖励就是拉下每个拉杆所获得奖励（中了得1分，没中得0分）。玩家就是我们自己。目标是在T次拉杆后，使得获得的奖励最大。</p>\r\n<p>作为一个没头脑的人，我们可能随便拉，这样子显然不会使最大奖励收敛。</p>\r\n<p>作为一个有一点头脑的人，他会这样做：拿出10%的机会去“冒险”，即随机拉一个杆，剩下90%机会去拉已经拉过的杆中获益估值最高的杆。</p>\r\n<p>作为一个更聪明的人，他随着拉杆次数的增加，拿去“冒险”的机会比例会逐渐降低。因为他知道，随着拉杆次数的增加，他对每根杆的获益估值越来越准确，所以此时更优的方法是去拉已知估值最高的，而不是拿去随机冒险浪费次数。</p>\r\n<p>通过上面这3个人的想法，我们其实已经可以有点感觉到本质了。“冒险”其实就是去探测每个拉杆的获奖概率值，“冒险”次数越多，拟合出来的每个拉杆的获奖概率值就越准。“不冒险”就是在自己拟合出来的每个拉杆概率下，选最优的。</p>\r\n<p>好的，思路知道了，代码开搞。文中附有注释：</p>\r\n<p>代码中有一点要解释一下，就是代码中的“懊悔”和“获益函数”。作为上帝视角的我们，肯定要评测不同策略（普通人、聪明人、更聪明的人）的表现。所以我们需要衡量标准。所以用“累计懊悔”来充当这个衡量标准。每次懊悔的计算公式很简单，即是(拉杆中最大获奖概率\r\n- 当前拉杆的获奖概率)。</p>\r\n<p>然后是“获益函数”，获益函数就是上面所说的我们拟合的每个拉杆的获奖概率值\r\n的平均值。他的计算公式为：<span class=\"math inline\">\\(E_k = E_k +\r\n\\frac{r_t - E_k}{N_k}\\)</span>，k是第k个拉杆，<span\r\nclass=\"math inline\">\\(r_t\\)</span>是在时刻t时拉下拉杆k所获得的收益，<span\r\nclass=\"math inline\">\\(N_k\\)</span>是第k根拉杆被拉下的次数。</p>\r\n<p>上面这个公式其实是这样推导的： <span class=\"math display\">\\[\r\nE_k = \\frac{\\sum_{t=1}^{N_t}r_t}{N_k} = \\frac{\\sum_{t=1}^{N_k-1}r_t +\r\nr_{N_k}}{N_k} = \\frac{(N_k-1)E_{k-1}+r_{N_k}}{N_k} = E_{k-1} +\r\n\\frac{r_{N_k}-E_{k-1}}{N_k}\r\n\\]</span> 这样就得到了<span\r\nclass=\"math inline\">\\(E_k\\)</span>的递推公式，需要注意的是，代码中给<span\r\nclass=\"math inline\">\\(E_k, k∈[1,\r\nK]\\)</span>赋了初值1。因为这样能保证至少先把每个拉杆都拉一遍。</p>\r\n<p>如果赋初值为0的话，那么真正只有“冒险”的时候才有几率去拉新杆了。这样的话新杆很难有机会拉到。</p>\r\n<p>所以我们希望先把全部杆至少拉一遍。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>: <span class=\"comment\"># 老虎机类</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, K</span>):</span><br><span class=\"line\">        self.K = K <span class=\"comment\"># 拉杆数量</span></span><br><span class=\"line\">        self.probs = np.random.uniform(low=<span class=\"number\">0</span>, high=<span class=\"number\">1</span>, size=K) <span class=\"comment\"># 生成K个0~1的值作为每根拉杆的获奖概率</span></span><br><span class=\"line\">        self.best_id = np.argmax(self.probs) <span class=\"comment\"># 返回self.probs最大元素的下标值</span></span><br><span class=\"line\">        self.best_prob = self.probs[self.best_id] <span class=\"comment\"># 最大获奖概率</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">play</span>(<span class=\"params\">self, k</span>): <span class=\"comment\"># 模拟拉杆</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> np.random.random() &lt; self.probs[k]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># np.random.seed(1) # 设定随机种子，不然每次的随机数值都不一样</span></span><br><span class=\"line\">K = <span class=\"number\">10</span></span><br><span class=\"line\">a = A(K) <span class=\"comment\"># 实例化老虎机</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;生成了一个拉杆为%d个的老虎机&#x27;</span> % K)</span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;%d号拉杆的获奖概率最大，是%.4f&#x27;</span> % (a.best_id, a.best_prob))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solver</span>: <span class=\"comment\"># 主实现函数</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, a</span>):</span><br><span class=\"line\">        self.a = a <span class=\"comment\"># self.a就是老虎机实例化的一个对象</span></span><br><span class=\"line\">        self.counts = np.zeros(a.K) <span class=\"comment\"># 用来计算每根拉杆的尝试次数</span></span><br><span class=\"line\">        self.regret = <span class=\"number\">0</span> <span class=\"comment\"># 当前步的累计懊悔</span></span><br><span class=\"line\">        self.actions = [] <span class=\"comment\"># 记录每一步的动作</span></span><br><span class=\"line\">        self.regrets = [] <span class=\"comment\"># 记录每一步的累计懊悔</span></span><br><span class=\"line\">        self.T = <span class=\"number\">0</span> <span class=\"comment\"># 记录run的次数</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run_one_step</span>(<span class=\"params\">self</span>): <span class=\"comment\"># 返回当前这一步应该拉哪一根拉杆，具体由不同策略实现</span></span><br><span class=\"line\">        <span class=\"keyword\">raise</span> NotImplementedError</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run</span>(<span class=\"params\">self, num_steps</span>):</span><br><span class=\"line\">        self.T = num_steps</span><br><span class=\"line\">        <span class=\"keyword\">for</span> _ <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(num_steps):</span><br><span class=\"line\">            k = self.run_one_step()</span><br><span class=\"line\">            <span class=\"comment\"># 更新第k根杆的拉动次数</span></span><br><span class=\"line\">            self.counts[k] += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"comment\"># 更新动作</span></span><br><span class=\"line\">            self.actions.append(k)</span><br><span class=\"line\">            <span class=\"comment\"># 更新懊悔</span></span><br><span class=\"line\">            self.regret += self.a.best_prob - self.a.probs[k]</span><br><span class=\"line\">            self.regrets.append(self.regret)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EpsilonGreedy</span>(<span class=\"title class_ inherited__\">Solver</span>): <span class=\"comment\"># epsilon贪心算法，继承Solver类（聪明人的策略）</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, a, epsilon=<span class=\"number\">0.01</span></span>): <span class=\"comment\"># 构造函数</span></span><br><span class=\"line\">        <span class=\"built_in\">super</span>(EpsilonGreedy, self).__init__(a) <span class=\"comment\"># 先对它的父类做一遍构造</span></span><br><span class=\"line\">        <span class=\"comment\"># 初始化探索率</span></span><br><span class=\"line\">        self.epsilon = epsilon</span><br><span class=\"line\">        <span class=\"comment\"># 初始化所有拉杆的预期估值</span></span><br><span class=\"line\">        self.estimates = np.array([<span class=\"number\">1.0</span>] * a.K)</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run_one_step</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> np.random.random() &lt; self.epsilon:</span><br><span class=\"line\">            k = np.random.randint(<span class=\"number\">0</span>, a.K) <span class=\"comment\"># 随机选择一根拉杆</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            k = np.argmax(self.estimates) <span class=\"comment\"># 选择期望估值最高的拉杆</span></span><br><span class=\"line\">        r = self.a.play(k) <span class=\"comment\"># 拉动</span></span><br><span class=\"line\">        <span class=\"comment\"># 更新预期估值</span></span><br><span class=\"line\">        self.estimates[k] += <span class=\"number\">1</span> / (self.counts[k] + <span class=\"number\">1</span>) * (r - self.estimates[k])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> k</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">plot_results</span>(<span class=\"params\">solvers, solver_name</span>): <span class=\"comment\"># 画图函数，solvers是策略列表，solver_name是策略的名字</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> idx, solver <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(solvers):</span><br><span class=\"line\">        x = <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(solver.actions))</span><br><span class=\"line\">        plt.plot(x, solver.regrets, label=solver_name[idx])</span><br><span class=\"line\">        plt.xlabel(<span class=\"string\">&#x27;Time steps&#x27;</span>)</span><br><span class=\"line\">        plt.ylabel(<span class=\"string\">&#x27;Cumulative regrets&#x27;</span>)</span><br><span class=\"line\">        plt.title(<span class=\"string\">&#x27;%d-bandit / Use method %s&#x27;</span> % (solver.a.K, solver_name[idx]))</span><br><span class=\"line\">        plt.legend()</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建不同的epsilon值</span></span><br><span class=\"line\">epsilons = [<span class=\"number\">1e-4</span>, <span class=\"number\">0.01</span>, <span class=\"number\">0.1</span>, <span class=\"number\">0.25</span>, <span class=\"number\">0.5</span>]</span><br><span class=\"line\"><span class=\"comment\"># 实例化EpsilonGreedy对象</span></span><br><span class=\"line\">epsilon_greedy_solvers = [EpsilonGreedy(a, epsilon=e) <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> epsilons]</span><br><span class=\"line\">epsilon_greedy_solvers_name = [<span class=\"string\">&#x27;EpsilonGreedy(epsilon=&#123;&#125;)&#x27;</span>.<span class=\"built_in\">format</span>(e) <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> epsilons]</span><br><span class=\"line\"><span class=\"comment\"># 开始run</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> idx, solver <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(epsilon_greedy_solvers):</span><br><span class=\"line\">    solver.run(<span class=\"number\">5000</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;The cumulative regrets of %s is %.4lf&#x27;</span> % (epsilon_greedy_solvers_name[idx], solver.regret))</span><br><span class=\"line\"><span class=\"comment\"># 画图</span></span><br><span class=\"line\">plot_results(epsilon_greedy_solvers, epsilon_greedy_solvers_name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">DecayingEpsilonGreedy</span>(<span class=\"title class_ inherited__\">EpsilonGreedy</span>): <span class=\"comment\"># 更聪明的人的策略</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, a, epsilon=<span class=\"number\">0.1</span></span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(DecayingEpsilonGreedy, self).__init__(a, epsilon=epsilon)</span><br><span class=\"line\">        self.count = -<span class=\"number\">1</span></span><br><span class=\"line\">        self.epsilon2 = self.epsilon</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">run_one_step</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"comment\"># 让epsilon随着拉杆次数增加线性递减到0</span></span><br><span class=\"line\">        self.count += <span class=\"number\">1</span></span><br><span class=\"line\">        self.epsilon =(-<span class=\"number\">1</span> * self.epsilon2 / self.T) * self.count + self.epsilon2</span><br><span class=\"line\">        <span class=\"keyword\">if</span> np.random.random() &lt; self.epsilon:</span><br><span class=\"line\">            k = np.random.randint(<span class=\"number\">0</span>, a.K) <span class=\"comment\"># 随机选择一根拉杆</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            k = np.argmax(self.estimates) <span class=\"comment\"># 选择期望估值最高的拉杆</span></span><br><span class=\"line\">        r = self.a.play(k) <span class=\"comment\"># 拉动</span></span><br><span class=\"line\">        <span class=\"comment\"># 更新预期估值</span></span><br><span class=\"line\">        self.estimates[k] += <span class=\"number\">1</span> / (self.counts[k] + <span class=\"number\">1</span>) * (r - self.estimates[k])</span><br><span class=\"line\">        <span class=\"keyword\">return</span> k</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>()</span><br><span class=\"line\">epsilons = [<span class=\"number\">1e-4</span>, <span class=\"number\">0.01</span>, <span class=\"number\">0.1</span>, <span class=\"number\">0.25</span>, <span class=\"number\">0.5</span>]</span><br><span class=\"line\"><span class=\"comment\"># 实例化DecayingEpsilonGreedy对象</span></span><br><span class=\"line\">decaying_epsilon_greedy_solvers = [DecayingEpsilonGreedy(a, epsilon=e) <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> epsilons]</span><br><span class=\"line\">decaying_epsilon_greedy_solvers_name = [<span class=\"string\">&#x27;DecayingEpsilonGreedy(epsilon=&#123;&#125;)&#x27;</span>.<span class=\"built_in\">format</span>(e) <span class=\"keyword\">for</span> e <span class=\"keyword\">in</span> epsilons]</span><br><span class=\"line\"><span class=\"comment\"># 开始run</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> idx, solver <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(decaying_epsilon_greedy_solvers):</span><br><span class=\"line\">    solver.run(<span class=\"number\">5000</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span> (<span class=\"string\">&#x27;The cumulative regrets of %s is %.4lf&#x27;</span> % (decaying_epsilon_greedy_solvers_name[idx], solver.regret))</span><br><span class=\"line\"><span class=\"comment\"># 画图</span></span><br><span class=\"line\">plot_results(decaying_epsilon_greedy_solvers, decaying_epsilon_greedy_solvers_name)</span><br></pre></td></tr></table></figure>\r\n<p>让我们来看一下代码的运行结果：</p>\r\n<p><img src=\"3.png\" /></p>\r\n<p><img src=\"4.png\" /></p>\r\n<p><img src=\"5.png\" /></p>\r\n<p><img src=\"6.png\" /></p>\r\n<p><img src=\"7.png\" /></p>\r\n<p>（俩图的标题的epsilon那错了懒得改了不影响）</p>\r\n<p>对于图中这次生成的数据来说，“冒险”概率越低效果越好（曲线几乎不增长）。当然我自己在本地测试各种生成数据后总结发现冒险概率=0.01/0.1时表现最优。</p>\r\n<p>然后使用DecayingEpsilonGreedy策略后表现更优了一些，对那些初始冒险率越大的优化效果越好。</p>\r\n<p>通过这个案例，已经可以对RL有一个初步理解了。老虎机这个案例除了用Epsilon-Greedy，还可以用<strong>上置信界算法</strong>、<strong>汤普森采样算法</strong>方法去解决。这三种方法是解决绝大多数RL的基本思想。</p>\r\n<p>但是老虎机这个案例是<strong>无状态强化学习</strong>，因为每一次与老虎机交互的结果和以往的动作无关。那有状态的强化学习怎么办呢？下一节将会对马尔可夫决策过程进行讲解。</p>\r\n","categories":["多智能体强化学习","主线"]},{"title":"2. 几种重要的凸集-上","url":"/2023/10/05/2-%E5%87%A0%E7%A7%8D%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%B8%E9%9B%86-%E4%B8%8A/","content":"<p>介绍了一个点、空集、超平面、半空间、球、椭球。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n<p><img src=\"2.jpg\" /></p>\r\n","categories":["多智能体强化学习","凸优化"]},{"title":"2. python急救包","url":"/2023/10/16/2-python%E6%80%A5%E6%95%91%E5%8C%85/","content":"<p>许多代码都是用python实现的，我的python基础一般，所以在实践中学咯。下面记录一些\r\npython常用的基础语法。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"numpy相关\">numpy相关</h3>\r\n<h4 id=\"随机数\">随机数</h4>\r\n<p>np.random.random()：生成一个[0, 1)的随机数</p>\r\n<p>np.random.uniform(low=, high=, size=)：生成size个[low,\r\nhigh)的随机数</p>\r\n<p>np.random.randint(x, y)：生成一个[x, y]的整数</p>\r\n<p>np.random.seed(可填数字)：不填就是随机数。填不同的数字就代表不同的世界线。处于同一个世界线的随机数们都是固定的</p>\r\n<h4 id=\"创建数组\">创建数组</h4>\r\n<p>np.zeros(k)：生成一个有k个元素，初始值为0的数组</p>\r\n<p>np.array(val * num)：生成一个有num个元素，初始值为val的数组</p>\r\n<h4 id=\"数组操作\">数组操作</h4>\r\n<p>np.argmax(数组)：返回数组中最大值的下标</p>\r\n<h3 id=\"python基本语法相关\">python基本语法相关</h3>\r\n<ul>\r\n<li>a.append()：列表追加元素</li>\r\n<li>for idx, x in\r\nenumerate(solvers)：使用enumerate方法可以下标和元素本身表示出来很方便</li>\r\n<li>a = range(num)：产生一个[0, 1, 2, ..., num]的数组</li>\r\n<li>epsilons = [1, 2, 3, 4], a = [fun(e) for e in\r\nepsilons]：很方便的定义一个列表，列表里的元素就是拿每个epsilons的元素丢进fun里返回来的东西</li>\r\n<li>print (\"啦啦啦%d，噜噜噜%s，嘻嘻嘻%.4lf\" % (a, b,\r\nc))：格式化输出</li>\r\n<li>‘啦啦啦{0}噜噜噜{1}’.format(a, b)：也是格式化输出，可以这样使用a =\r\n['abc is {}'.format(e) for e in epsilons]</li>\r\n<li>Python写一个类记得要写构造函数def __init__(self):\r\n若需参数自己加</li>\r\n<li>Python也可以写类，继承很简单，比如类A继承B，就写class A(B):\r\n即可</li>\r\n<li>class A继承B的话，记得在A的构造函数里第一句加一个super(A,\r\nself).__init__(B的构造函数的参数)。这一步就是在填父类的构造函数</li>\r\n</ul>\r\n<h3 id=\"matplotlib.pyplot相关\">matplotlib.pyplot相关</h3>\r\n<p>plt.plot(x, y,\r\nlabel=)：x是一个列表，代表x轴的数据；y是一个列表，代表y轴的数据；label也是一个列表，代表不同线的名字（绘制多条线时使用）</p>\r\n<p>plt.xlabel('xxx')：给x轴起名字</p>\r\n<p>plt.ylabel('xxx')：给y轴起名字</p>\r\n<p>plt.title('xxx')：起标题</p>\r\n<p>plt.legend()：显示图例，要配合plt.plot中的label使用</p>\r\n<p>plt.show()：把图画出来</p>\r\n","categories":["多智能体强化学习","主线"]},{"title":"3. 几种重要的凸集-下","url":"/2023/10/05/3-%E5%87%A0%E7%A7%8D%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%B8%E9%9B%86-%E4%B8%8B/","content":"<p>介绍了多面体、单纯形、多面体与单纯形的关系、对称矩阵集合、对称半正定矩阵集合、对称正定矩阵集合。</p>\r\n<span id=\"more\"></span>\r\n<p><img src=\"1.jpg\" /></p>\r\n<p><img src=\"2.jpg\" /></p>\r\n","categories":["多智能体强化学习","凸优化"]},{"title":"Linux基础","url":"/2023/10/14/Linux%E5%9F%BA%E7%A1%80/","content":"<p>大二学数据库这门课的时候接触到了Linux，因为期末大作业是在Linux环境下进行的。涉及到Linux系统编程函数的一些调用。所以学习Linux的基本使用就十分必要。</p>\r\n<span id=\"more\"></span>\r\n<h3 id=\"前言\">前言</h3>\r\n<p>在Windows上想使用Linux系统可以用虚拟机（VM /\r\nHyper-V）或者wsl或者docker。如果使用虚拟机的话建议装一个Finalshell，这样就不用频繁的在虚拟机和win界面里切换了。</p>\r\n<h3 id=\"linux系统目录\">Linux系统目录</h3>\r\n<p>Linux下一切皆文件，所以了解Linux的一些系统目录是干啥的就很重要：</p>\r\n<p>/dev：与本机设备（比如鼠标）有关的目录</p>\r\n<p>/etc：配置文件信息</p>\r\n<p>/home：用户目录</p>\r\n<p>/lib：库目录（比如C库、python库）</p>\r\n<p>/media、/mnt：磁盘挂载目录</p>\r\n<p>/opt、/proc：进程目录</p>\r\n<p>/usr：Unix Software Resource，软件目录，比如第三方安装的qq</p>\r\n<p>/bin：存放二进制可执行文件</p>\r\n<p>/boot：存放开机启动程序</p>\r\n<p>一般/etc和/home是经常用的，如果你是用wsl的话/mnt也比较常用。</p>\r\n<p>前面提到Linux下一切皆文件，但是Linux里对文件的命名比较不规范。文件名可以随便自己起，所以你可以起一个名为test.mp3的文件，然后在里面只写一点文本。</p>\r\n<p>所以使用file 文件名 命令可以知道这个文件到底是属于啥文件。</p>\r\n<p>在Linux下的文件类型如下：</p>\r\n<ol type=\"1\">\r\n<li>普通文件：-</li>\r\n<li>目录文件：d</li>\r\n<li>软链接：l</li>\r\n<li>字符设备文件：c</li>\r\n<li>块设备文件：b</li>\r\n<li>管道文件：p</li>\r\n<li>套接字：s</li>\r\n</ol>\r\n<p>一般前三种我比较常见。</p>\r\n<h3 id=\"linux基础命令\">Linux基础命令</h3>\r\n<h4 id=\"快捷键相关\">快捷键相关</h4>\r\n<p>ctrl + c：强制中断当前进程</p>\r\n<p>ctrl + l：清屏</p>\r\n<p>ctrl + a：跳转到行首</p>\r\n<p>ctrl + e：跳转到行尾</p>\r\n<p>ctrl + ←：往左跳一个单词</p>\r\n<p>ctrl + →：往右跳一个单词</p>\r\n<p>ctrl + r：进入命令搜索模式</p>\r\n<h4 id=\"用户相关\">用户相关</h4>\r\n<p>sudo - username：切换用户</p>\r\n<p>sudo 命令：以root用户的权限执行这条命令</p>\r\n<p>chmod 777 filename：修改文件的权限（三个数字分别对应user, group,\r\nothers）</p>\r\n<h4 id=\"查看文件相关\">查看文件相关</h4>\r\n<p>cat filename：查看文件</p>\r\n<p>more filename：分屏查看文件</p>\r\n<p>head filename：查看文件开头几行</p>\r\n<p>tail filename：查看文件后面几行</p>\r\n<p>tree：以树目录形式展现当前目录（需apt install tree）</p>\r\n<p>ls -l / -h /\r\n-a：查看文件详细信息，以列表/以人类形式(可以看文件占多少M)/显示隐藏文件</p>\r\n<h4 id=\"文件操作相关\">文件操作相关</h4>\r\n<p>mkdir dirname：创建文件夹</p>\r\n<p>touch filename：创建文件</p>\r\n<p>cp path1 path2 [-r]：将path1的东西复制到path2那</p>\r\n<p>mv path1 path2：将path1的东西移动到path2那</p>\r\n<p>rm [-r] path：删除path处的东西</p>\r\n<p>ln -s path\r\n链接：将path处的东西创建软链接（path处要写绝对路径，因为本质就是每次访问链接的时候都是去访问path）</p>\r\n<p>ln path 链接：将path处的东西创建硬链接，形成铁索连环的效果</p>\r\n<p>find path -name/-type/-size 条件 -exec rm {} ; ：批量删除文件</p>\r\n<h4 id=\"查找相关\">查找相关</h4>\r\n<ul>\r\n<li>文件—基本查找（看文件路径在哪）</li>\r\n</ul>\r\n<p>find path -name 'xxx'：按文件名字来找</p>\r\n<p>find path -type 'xxx'：按文件类型来找</p>\r\n<p>find path -size +/-(num)k/M/G：按文件大小来找</p>\r\n<ul>\r\n<li>文件—详细查找</li>\r\n</ul>\r\n<p>find ... ... | xargs ls -l -h</p>\r\n<ul>\r\n<li>内容查找</li>\r\n</ul>\r\n<p>grep 'xxx' path [-r]\r\n[-n]：-n是显示行号，如果path为文件夹则需要加-r</p>\r\n<p>ls -l | grep 'xxx' -n 或 cat filename | grep 'xxx' -n 或 ps aux |\r\ngrep 'xxx' -n 或 lsof -u username | grep 'xxx'\r\n-n：在某些输出内容中找特定内容</p>\r\n<h4 id=\"软件包解压缩相关\">软件包，解压缩相关</h4>\r\n<p>apt install xxx：安装软件包</p>\r\n<p>apt remove xxx：删除软件包</p>\r\n<p>dpkg -i xxx.deb：安装.deb软件包</p>\r\n<p>源码安装（具体方法看每个源码中的README.md）：</p>\r\n<ol type=\"1\">\r\n<li>解压源代码包</li>\r\n<li>cd dir（源代码包）</li>\r\n<li>运行./configure（这一步是检测文件是否缺失以及创建Makefile以及检测编译环境）</li>\r\n<li>运行make（这一步是在编译源码、生成库和可执行程序）</li>\r\n<li>运行make install（这一步是把库和可执行程序安装到系统路径下）</li>\r\n</ol>\r\n<p>tar -zcvf 压缩包名 压缩材料：压缩</p>\r\n<p>tar -zxvf 压缩包名：解压</p>\r\n<h4 id=\"其它常用指令\">其它常用指令</h4>\r\n<p>alias\r\n别名='指令'：给指令起别名，只能临时生效（永久生效将alias语句写入~/.bashrc，然后source\r\n~/.bashrc）</p>\r\n<p>ps aux：查看进程</p>\r\n<p>lsof -u username：查看user打开的文件</p>\r\n<p>gcc filename -o 输出名字：编译c程序（需apt install gcc）</p>\r\n<p>g++ filename -o 输出名字：编译c++程序（需apt install g++）</p>\r\n<p>man -k 函数名：查看Linux函数在man手册中的章节</p>\r\n<p>man 章节 函数：查看Linux函数在man手册中的讲解</p>\r\n<h4 id=\"vim相关\">vim相关</h4>\r\n<p>适应不了vim可以用nano。</p>\r\n<p>ESC：返回命令模式</p>\r\n<p>a/i：进入编辑模式</p>\r\n<p>冒号：进行底栏模式</p>\r\n<p>:wq：保存并退出</p>\r\n<p>:set nu：显示行号</p>\r\n<p>hjkl：上下左右</p>\r\n<p>0：移动到行首</p>\r\n<p>$：移动到行尾</p>\r\n<p>gg：移动到文件开头</p>\r\n<p>G：移动到文件结尾</p>\r\n<p>数字 + G：移动到指定行</p>\r\n<p>x：删除单个字符</p>\r\n<p>dd：删除当前行</p>\r\n<p>d0：删除光标到行首</p>\r\n<p>d$：删除光标到行尾</p>\r\n<p>v + hjkl + d：删除选定内容</p>\r\n<p>v + hjkl + y：复制选定内容</p>\r\n<p>p：粘贴</p>\r\n<p>u：撤销</p>\r\n<p>ctrl + u：反向撤销</p>\r\n","categories":["Linux"]},{"title":"个人博客搭建说明","url":"/2023/10/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%B4%E6%98%8E/","content":"<p>使用GitHub + Hexo搭建的本博客。</p>\r\n<p>教程参考<a\r\nhref=\"https://zhuanlan.zhihu.com/p/102592286\">从零开始搭建个人博客（超详细）\r\n- 知乎 (zhihu.com)</a>。</p>\r\n<p>上面这篇文章可以说是从0到1很详细的介绍了搭建个人博客的全流程，不过仍然有许多小错误，需要结合评论区和其它博文一起阅读才会避免踩坑。</p>\r\n<span id=\"more\"></span>\r\n<p>我大致总结一下流程：</p>\r\n<ol type=\"1\">\r\n<li>注册GitHub</li>\r\n<li>下载Git并将Git绑定到GitHub（使用token）</li>\r\n<li>购买域名</li>\r\n<li>安装node.js并配置环境变量（建议全程使用cmd管理员而不是git\r\nbash）</li>\r\n<li>安装hexo</li>\r\n<li>解析域名</li>\r\n<li>设置并美化主题</li>\r\n</ol>\r\n<p>另外，博客首页的头像是用的GitHub的头像链接，另外我不打算采用图床，因为怕翻车。所以文章里的全部图片都是存储在本地并push到GitHub中，若加载不出或速度慢可以尝试挂个梯子。</p>\r\n<p>域名第一年花了9块，之后续费好像是20多块一年。在阿里云买的。</p>\r\n<p>看板娘参考了两篇文章：<a\r\nhref=\"https://github.com/stevenjoezhang/live2d-widget\">设置看板娘</a>,\r\n<a\r\nhref=\"https://www.cnblogs.com/c10udlnk/p/14727173.html\">个性化配置看板娘</a>。</p>\r\n<p>但是live2d的模型默认的这几个我不是很熟悉，以后有空了想换成我自己喜欢的人物角色。</p>\r\n","categories":["杂项"]},{"title":"在VS Code中配置C/C++","url":"/2023/10/03/%E5%9C%A8VS-Code%E4%B8%AD%E9%85%8D%E7%BD%AEC-C/","content":"<p>之前因为学了一点html，所以下了一个VS Code来写html代码。</p>\r\n<p>今天要写C++的代码，以前都是用VS写的。但是突然想了一下既然都装了VS\r\nCode，为啥不配置一下。配置好了后以后写C/C++代码也不用打开繁重的VS了。而且VS\r\nCode还能加很多插件。</p>\r\n<span id=\"more\"></span>\r\n<p>说干就干，上网找了资料，终于配置好了。还是有蛮多坑的，主要是因为网上的教程大部分版本比较老了。所以我来写个教程，方便别人和以后自己在别的电脑上配置。我总结出以下几步：</p>\r\n<h3 id=\"下载mingw-w64并配置系统变量\">1. 下载MinGW-w64并配置系统变量</h3>\r\n<ul>\r\n<li><p>MinGW是是将经典的开源 C语言 编译器 GCC 移植到了 Windows\r\n平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows\r\n中运行的可执行程序。</p></li>\r\n<li><p>但是MinGW的很早就停止维护了，版本很老了。</p></li>\r\n<li><p>MinGW-w64相当于升级版的MinGW，是一个开源项目，不断在更新维护着。</p></li>\r\n<li><p><a\r\nhref=\"https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/\">下载链接</a>，划到最下面，选择“MinGW-W64\r\nGCC-8.1.0”下的“x86_64-win32-seh”进行下载。</p></li>\r\n<li><p>下载好后，解压到自己想要的位置。然后将其中的bin路径配置到系统变量中。</p></li>\r\n<li><p>打开cmd，输入gcc --version和gdb\r\n--version，弹出版本信息就说明这一步完成了。</p></li>\r\n</ul>\r\n<h3 id=\"下载插件cccode-runner\">2. 下载插件C/C++，Code Runner</h3>\r\n<ul>\r\n<li>在VS Code中下载即可。</li>\r\n</ul>\r\n<h3 id=\"配置文件\">3. 配置文件</h3>\r\n<ul>\r\n<li><p>新建一个项目文件夹，在下面建立一个.vscode文件夹，下面建立三个文件，launch.json，tasks.json，c_cpp_properties.json，然后依次把我的代码复制进去。注意代码中的“（改为自己的路径）”</p></li>\r\n<li><p>lauch.json</p></li>\r\n</ul>\r\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\"><span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0.2.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"><span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">\t<span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;C++ Launch (GDB)&quot;</span><span class=\"punctuation\">,</span>                </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cppdbg&quot;</span><span class=\"punctuation\">,</span>                         </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;request&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;launch&quot;</span><span class=\"punctuation\">,</span>                        </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;targetArchitecture&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;x86&quot;</span><span class=\"punctuation\">,</span>                </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;program&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;workspaceRoot&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">,</span>                 </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;miDebuggerPath&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;D:\\\\app\\\\mingw64\\\\bin\\\\gdb.exe&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span>     </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;stopAtEntry&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span>                  </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;cwd&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class=\"punctuation\">,</span>                  </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;externalConsole&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span>                  </span><br><span class=\"line\">\t\t<span class=\"attr\">&quot;preLaunchTask&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:/app/mingw64/bin/g++.exe&quot;</span>  （改为自己的路径）          </span><br><span class=\"line\">\t\t<span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>tasks.json</li>\r\n</ul>\r\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;2.0.0&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:/app/mingw64/bin/g++.exe&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">    <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;-g&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;-std=c++11&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;$&#123;file&#125;&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;-o&quot;</span><span class=\"punctuation\">,</span><span class=\"string\">&quot;$&#123;workspaceRoot&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;problemMatcher&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;owner&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cpp&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;fileLocation&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"string\">&quot;relative&quot;</span><span class=\"punctuation\">,</span> <span class=\"string\">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;pattern&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;regexp&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;file&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;line&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;column&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;severity&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;message&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">5</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;tasks&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;label&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:/app/mingw64/bin/g++.exe&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">            <span class=\"attr\">&quot;command&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;D:/app/mingw64/bin/g++.exe&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">            <span class=\"attr\">&quot;args&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-g&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-std=c++11&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;file&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;-o&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;workspaceRoot&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;problemMatcher&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;owner&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;cpp&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;fileLocation&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;relative&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;$&#123;workspaceRoot&#125;&quot;</span></span><br><span class=\"line\">                <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;pattern&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;regexp&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;file&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;line&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;column&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;severity&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;message&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">5</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;group&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;_id&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;build&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;isDefault&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li>c_cpp_properties.json</li>\r\n</ul>\r\n<p><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;configurations&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;Win32&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;includePath&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include//c++/tr1&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"string\">&quot;D:/app/mingw64/x86_64-w64-mingw32/include&quot;</span>（改为自己的路径）</span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;defines&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                <span class=\"string\">&quot;_DEBUG&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;UNICODE&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;__GNUC__=6&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"string\">&quot;__cdecl=__attribute__((__cdecl__))&quot;</span></span><br><span class=\"line\">            <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;intelliSenseMode&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;msvc-x64&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;browse&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;path&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include//c++/tr1&quot;</span><span class=\"punctuation\">,</span>  （改为自己的路径）</span><br><span class=\"line\">                    <span class=\"string\">&quot;D:/app/mingw64/x86_64-w64-mingw32/include&quot;</span>  （改为自己的路径）</span><br><span class=\"line\">                <span class=\"punctuation\">]</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;compilerPath&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;C:\\\\Program Files\\\\Microsoft Visual Studio\\\\2022\\\\Professional\\\\VC\\\\Tools\\\\MSVC\\\\14.36.32532\\\\bin\\\\Hostx64\\\\x64\\\\cl.exe&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c17&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cppStandard&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;c++17&quot;</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">    <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;version&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure></p>\r\n<ul>\r\n<li><p>在项目文件夹中新建cpp文件，随便写一个程序。然后F5调试。</p></li>\r\n<li><p>如果能输出正确结果就没问题。如果不能，比如std或者cout报错的话，就打开设置，在\"C/C++\"中找到C_Cpp:intelli\r\nSense Engine，将默认的“Default”改为“Tag Parser”。</p></li>\r\n<li><p>此时按F5就可以正常实现调试功能了。</p></li>\r\n<li><p>其实如果你不用调试的话，直接Ctrl + F5用Code\r\nRunner跑代码就行了。</p></li>\r\n</ul>\r\n","categories":["杂项"]},{"title":"数字逻辑自学笔记","url":"/2023/10/06/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","content":"<p>写于2023/10/6，这门课其实还是有点意思的。但是上个月身体原因一直在关心我自己的身体，所以这门课我全翘掉了，一点没听。现在马上就要实验课了，于是打算在国庆的末尾把这门课学了。目的是能做出几个组合逻辑电路的实验项目。</p>\r\n<p>自学参考的内容为老师ppt、各种网上博客。</p>\r\n<p>学完后打算去刷题巩固一下，刷题打算在一个up主视频里刷：<a\r\nhref=\"https://www.bilibili.com/video/BV1H54y1k7kM?p=1&amp;vd_source=2501060da9b4bef86e2b8ec8a8d880b5\">传送门</a></p>\r\n<p>最后，如果有朋友打算认真看这篇Blog进行学习的话，为了更好的阅读体验建议开梯子，因为本文有许多图片和一个视频。（存储在github中）</p>\r\n<span id=\"more\"></span>\r\n<p>先放一张各种门的符号图，后面忘了的话可以参考：</p>\r\n<p><img src=\"1.png\" /></p>\r\n<p><img src=\"2.png\" /></p>\r\n<h3 id=\"一.-组合逻辑电路1\">一. 组合逻辑电路(1)</h3>\r\n<h4 id=\"概述\">1.1. 概述</h4>\r\n<p>电路分为组合逻辑电路和时序逻辑电路。差别就是组合逻辑电路无记忆功能，时序逻辑电路有。</p>\r\n<p>描述电路的逻辑功能有以下几种形式：</p>\r\n<ol type=\"1\">\r\n<li>语言描述</li>\r\n<li>电路图</li>\r\n<li>逻辑表达式，即y = f(a1, a2, a3, ..., an)</li>\r\n<li>真值表</li>\r\n<li>卡诺图</li>\r\n<li>波形图</li>\r\n</ol>\r\n<h4 id=\"组合逻辑电路的分析-和-逻辑函数的设计方法\">1.2.\r\n组合逻辑电路的分析 和 逻辑函数的设计方法</h4>\r\n<ul>\r\n<li><p><strong>分析</strong>：</p>\r\n<ul>\r\n<li><p>即给你一个电路，让你告诉我这个电路是干啥用的。</p></li>\r\n<li><p>分析一个组合逻辑电路的固定套路很简单：</p>\r\n<ol type=\"1\">\r\n<li>一层一层写出逻辑表达式</li>\r\n<li>对最后得到的逻辑表达式进行化简\r\n<ul>\r\n<li>化简手段1：卡诺图</li>\r\n<li>化简手段2：<span class=\"math inline\">\\(A + A \\cdot B = A 或 A \\cdot\r\n(A + B) = A\\)</span></li>\r\n<li>化简手段3：<span class=\"math inline\">\\(A + \\overline{A}B = A + B 或\r\nA \\cdot (\\overline{A} + B) = A \\cdot B\\)</span></li>\r\n<li>化简手段4：<span class=\"math inline\">\\(\\overline{A}\\overline{C} +\r\nA\\overline{B} + \\overline{B}\\overline{C} = \\overline{A}\\overline{C} +\r\nA\\overline{B}\\)</span>（对于<span\r\nclass=\"math inline\">\\(\\overline{B}\\overline{C}\\)</span>添项即可证明）</li>\r\n<li>化简手段5：<span class=\"math inline\">\\(A \\oplus B = \\overline{A}B +\r\nA\\overline{B}\\)</span></li>\r\n<li>化简手段6：<span class=\"math inline\">\\(A \\odot B = (\\overline{A} +\r\nB)(A + \\overline{B})\\)</span></li>\r\n</ul></li>\r\n<li>对化简后的逻辑表达式列真值表，观察真值表，观察出此电路的功能</li>\r\n</ol></li>\r\n<li><p>例子：</p>\r\n<p><img src=\"3.png\" /></p>\r\n<ul>\r\n<li>T1是个与门，T2是个或门，第一层剩下都是与门，第二层一个或门，第三层一个非门，第四层一个与门，最后一层一个或门。最后通过真值表很容易看出ABC三个输入变量但有两个输出变量。不难想到是一个全加器。A、B是两个加数，C是上一位的进位，F1是当前位，F2是进位。</li>\r\n<li>还有许多功能电路啦...\r\n...比如半加器（2输入2输出）、投票表决器（多输入1输出）、奇校验电路（多输入1输出）、一致性电路（多输入1输出）</li>\r\n</ul></li>\r\n</ul></li>\r\n<li><p><strong>设计</strong>：</p>\r\n<ul>\r\n<li><p>告诉你一个功能，让你设计出一个电路来实现它。</p></li>\r\n<li><p>也是有固定套路的：</p>\r\n<ol type=\"1\">\r\n<li><p>分析功能，确定输入输出变量</p>\r\n<ul>\r\n<li>确定输入输出变量还是有点讲究的，有时候设计的好了可以大大减少运算量和电路的复杂程度。比如下面两个功能，换做是你，你会怎样设计？</li>\r\n</ul>\r\n<p><img src=\"4.png\" /> <img src=\"5.png\" /></p>\r\n<ul>\r\n<li>设计的关键其实是做到尽可能的<strong>复用</strong>，即对于不同对象的同一属性，尽量用一个变量表达出来。</li>\r\n</ul></li>\r\n<li><p>根据题意，直接构造出电路。或者写出真值表然后写出主析取范式然后再用卡诺图化简后得到最终逻辑表达式</p></li>\r\n<li><p>根据逻辑表达式，选取一种门电路，画出电路图</p></li>\r\n</ol></li>\r\n</ul></li>\r\n</ul>\r\n<hr />\r\n<h3 id=\"二.-组合逻辑电路2\">二. 组合逻辑电路(2)</h3>\r\n<p>上一节我们已经可以设计出逻辑表达式。但是具体选用哪一种门电路呢？每一种门电路应该如何设计呢？这一节我们就来学习。</p>\r\n<h4 id=\"单输出电路设计\">2.1. 单输出电路设计</h4>\r\n<h5 id=\"用与非门设计电路\">2.1.1. 用与非门设计电路</h5>\r\n<p>对于逻辑表达式F = ...中的 + 全部换成 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> 就好了，按照这个思路，只要在 +\r\n的头上画两根取反号就行了，最上面那根保留，下面那根负责把 + 换成 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> 。</p>\r\n<p>但这样得到的实际电路可能耗材过多，实际中有些式子通过观察还能发现可以化的更简，比如下面这个例子：</p>\r\n<p><span class=\"math inline\">\\(F = A\\overline{B} + B\\overline{C} +\r\nC\\overline{D} + D\\overline{A} = \\overline{\\overline{A\\overline{B}} \\cdot\r\n\\overline{B\\overline{C}} \\cdot \\overline{C\\overline{D}} \\cdot\r\n\\overline{D\\overline{A}}}\\)</span></p>\r\n<p>按理说这样就好了，但是还可以化简的。</p>\r\n<p><span class=\"math inline\">\\(\\overline{A\\overline{B}} \\cdot\r\n\\overline{B\\overline{C}} \\cdot \\overline{C\\overline{D}} \\cdot\r\n\\overline{D\\overline{A}} = (\\overline{A} + B)(\\overline{B} +\r\nC)(\\overline{C} + D)(\\overline{D} + A)\\)</span></p>\r\n<p>上面这个东西，学过二项式定理吗？假如我第一项如果挑B，则第二项不能挑<span\r\nclass=\"math inline\">\\(\\overline{B}\\)</span>，只能挑C，那么第三项也只能挑D，依次类推，第四项只能挑A，得到ABCD。同理，如果我第一项挑<span\r\nclass=\"math inline\">\\(\\overline{A}\\)</span>，那么我只能得到<span\r\nclass=\"math inline\">\\(\\overline{A}\\overline{B}\\overline{C}\\overline{D}\\)</span>。</p>\r\n<p>即：<span class=\"math inline\">\\((\\overline{A} + B)(\\overline{B} +\r\nC)(\\overline{C} + D)(\\overline{D} + A) = ABCD +\r\n\\overline{A}\\overline{B}\\overline{C}\\overline{D}\\)</span></p>\r\n<p>对上面那玩意再求两次反，得到<span\r\nclass=\"math inline\">\\(\\overline{\\overline{ABCD} \\cdot\r\n\\overline{\\overline{A}\\overline{B}\\overline{C}\\overline{D}}}\\)</span></p>\r\n<p>这样子，就得到<span class=\"math inline\">\\(F =\r\n\\overline{\\overline{\\overline{ABCD} \\cdot\r\n\\overline{\\overline{A}\\overline{B}\\overline{C}\\overline{D}}}}\\)</span></p>\r\n<p>总结下来这个第二种方法就是在第一种方法的基础上把内部通过二项式定理进一步化简。</p>\r\n<h5 id=\"用或非门设计电路\">2.1.2. 用或非门设计电路</h5>\r\n<p>对于逻辑表达式F = ...中的 <span class=\"math inline\">\\(\\cdot\\)</span>\r\n全部换成 + 就好了，按照这个思路，只要在 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span>\r\n的头上画两根取反号就行了，最上面那根保留，下面那根负责把 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> 换成 + 。</p>\r\n<p>还有第二种通用的方法，就是将F先求对偶，得到<span\r\nclass=\"math inline\">\\(F_d\\)</span>，这样F就由(xxx) + (xxx) +\r\n(xxx)的形式变为(x + x)(x + x)(x +\r\nx)的形式了。学过二项式定理吗？同理将<span\r\nclass=\"math inline\">\\(F_d\\)</span>化简，得到最简“与-或”式(yyy) +\r\n(yyy)。再在头上加两根取反，最顶上保留，下面那根为了把 + 变成 <span\r\nclass=\"math inline\">\\(\\cdot\\)</span> ，最后再对偶回去即可。</p>\r\n<p>上面那段文字是具体过程，流程总结下来如下：</p>\r\n<ol type=\"1\">\r\n<li>对F求对偶<span class=\"math inline\">\\(F_d\\)</span></li>\r\n<li>对<span\r\nclass=\"math inline\">\\(F_d\\)</span>展开，利用二项式原理或者卡诺图，得到最简\"与-或\"式<span\r\nclass=\"math inline\">\\(F_d&#39;\\)</span></li>\r\n<li>对<span\r\nclass=\"math inline\">\\(F_d&#39;\\)</span>取两次反，最上面保留，下面那根化开，得到<span\r\nclass=\"math inline\">\\(F_d&#39;&#39;\\)</span></li>\r\n<li>对<span class=\"math inline\">\\(F_d&#39;&#39;\\)</span>对偶回去</li>\r\n</ol>\r\n<h5 id=\"用与或非门设计电路\">2.1.3. 用与或非门设计电路</h5>\r\n<p>这个就更简单了，因为给出的函数表达式都是形如F = xyz + xyz +\r\nxyz，所以只需要在F头上加两条杠就好了。</p>\r\n<p>第二种思路就是跟用与非门设计电路的第二种方法一样。加两条杠，最上面不动，下面那个把xyz\r\n+ xyz +\r\nxyz变成()()()型，然后二项式定理展开即可。（如果是与非门第二种设计思路还要将展开的东西再取两次反）</p>\r\n<h4 id=\"多输出电路设计\">2.2. 多输出电路设计</h4>\r\n<p>啊，最直接的想法就是分别把每个输出对应的电路设计出来就好了。但是这样比较憨，当我们化简得到了每个输出对应的逻辑表达式的时候，我们应该能尽可能使每一项<strong>复用</strong>。看下面这个例子：</p>\r\n<p><img src=\"6.png\" /></p>\r\n<p>可以发现原<span class=\"math inline\">\\(F_1\\)</span>中的<span\r\nclass=\"math inline\">\\(A\\overline{B}\\)</span>可以变成<span\r\nclass=\"math inline\">\\(A\\overline{B}\\overline{C}\\)</span>，这样就跟<span\r\nclass=\"math inline\">\\(F_2\\)</span>中的<span\r\nclass=\"math inline\">\\(A\\overline{B}\\overline{C}\\)</span>一样了，做到了复用。</p>\r\n<h4 id=\"包含无关项的电路设计\">2.3. 包含无关项的电路设计</h4>\r\n<p>其实很简单，看下面这个例子就懂了。</p>\r\n<p><img src=\"7.png\" /></p>\r\n<p><img src=\"8.png\" /></p>\r\n<p>首先我们知道余3码是在8421码的基础上+3得到，因为8421码只有10位，所以余3码也只有10位。而且8421码最小是0000，所以余3码最小是0011（对应十进制数1）。所以这就在输出F中产生了许多无关项d。在画卡诺图时，若不考虑无关项，则把d全置为0；考虑无关项则把d全置为1。最后得到化简后的函数表达式。然后再将这个函数表达式用与非门设计。</p>\r\n<h4 id=\"考虑级数的电路设计\">2.4. 考虑级数的电路设计</h4>\r\n<p>也是看一道例题就可以理解了。</p>\r\n<p><img src=\"9.png\" /></p>\r\n<p>先用最直接的方法，与或非门直接加两条杠结束。与非门直接加两条杠，下面那条杠化开结束。</p>\r\n<p>但是这样设计级数会不会多呢？</p>\r\n<p>如果我们用\"与或非门设计电路\"中第二种化简方法，试一下：</p>\r\n<p><span class=\"math inline\">\\(F = \\overline{\\overline{AB +\r\n\\overline{A}C}} = \\overline{\\overline{AB} \\cdot\r\n\\overline{\\overline{A}C}} = \\overline{(\\overline{A} + \\overline{B})(A +\r\n\\overline{C})} = \\overline{\\overline{A}\\overline{C} + A\\overline{B} +\r\n\\overline{B}\\overline{C}} = \\overline{\\overline{A}\\overline{C} +\r\nA\\overline{B}}\\)</span></p>\r\n<p>可以发现，这样设计只有3层。但是原来那样直接加两条杠是4层。所以当考虑电路的级数时，在用与或非门设计电路时，可以考虑进一步化简优化电路的级数。</p>\r\n<p>如果用与非门，就不需要考虑进一步化简了。因为在与非门进一步化简后，还需要再内部再添加两条杠。级数肯定比不继续化简多。</p>\r\n<h4 id=\"综合题\">2.5. 综合题</h4>\r\n<ul>\r\n<li>设计一个组合电路，将8421BCD码变换为余3码。</li>\r\n</ul>\r\n<p>先确定输入输出变量，因为8421BCD码是用四个二进制数表示十进制数0~9，所以有四个输入A、B、C、D代表四个二进制数。同理四个输出W、X、Y、Z代表变换后的余3码。</p>\r\n<p>然后列出真值表，因为BCD只能表示十进制0~9，所以注意表中有无关项d。</p>\r\n<p><img src=\"10.png\" /></p>\r\n<p>这里不考虑无关项，所以在后续画卡诺图时都将d置为0。</p>\r\n<p>因为是四个输出，所以属于多输出电路。所以先画四个卡诺图得到四个逻辑表达式（其实对于Z，发现其很有规律不用画卡诺图都可以知道它就是<span\r\nclass=\"math inline\">\\(\\overline{D}\\)</span>）</p>\r\n<p>画卡诺图过程省略，得到四个逻辑表达式： <span class=\"math display\">\\[\r\nW = A + BC + BD \\\\\r\nX = \\overline{B}C + \\overline{B}D + B\\overline{C}\\overline{D} \\\\\r\nY = CD + \\overline{C}\\overline{D} \\\\\r\nZ = \\overline{D}\r\n\\]</span>\r\n此时我们需要思考，是否能做到项的<strong>复用</strong>呢？乍一看没发现能复用的，所以先不考虑复用，继续将式子进一步化简先。先从简单的开始画：</p>\r\n<p><span class=\"math inline\">\\(Z = \\overline{D}\\)</span></p>\r\n<p><span class=\"math inline\">\\(Y = \\overline{C} \\oplus D\\)</span></p>\r\n<p><span class=\"math inline\">\\(X = \\overline{B}(C + D) + B\\overline{(C +\r\nD)} = B \\oplus (C + D) = B \\oplus\r\n\\overline{\\overline{C}\\overline{D}}\\)</span></p>\r\n<p><span class=\"math inline\">\\(W = A + B(C + D) = A +\r\nB\\overline{\\overline{C}\\overline{D}}\\)</span></p>\r\n<p>化简后可以发现，<span\r\nclass=\"math inline\">\\(\\overline{\\overline{C}\\overline{D}}\\)</span>这个东西可以做到复用，真不错。</p>\r\n<p>接下来就是选择门电路来设计电路了。这里我选择最常用的与非门 +\r\n异或门设计电路。根据上面的逻辑表达式直接设计即可（W还需化简一下：<span\r\nclass=\"math inline\">\\(W = \\overline{\\overline{A} \\cdot\r\n\\overline{B\\overline{\\overline{C}\\overline{D}}}}\\)</span>）</p>\r\n<p>最后画出电路：</p>\r\n<p><img src=\"11.png\" /></p>\r\n<hr />\r\n<h3 id=\"三.-组合逻辑电路3\">三. 组合逻辑电路(3)</h3>\r\n<h4 id=\"编码器\">3.1 编码器</h4>\r\n<p>按照我的理解，就是把数字变成二进制数。比如把0 ~\r\n8变成3位二进制数，或者0 ~ 15变成4位二进制数。</p>\r\n<p>编码器分为普通编码器 和 优先编码器。</p>\r\n<ul>\r\n<li><strong>普通编码器</strong></li>\r\n</ul>\r\n<p>特点：任何时刻只允许输入一个编码信号。</p>\r\n<p>最常见的普通编码器为8线-3线编码器，如下图：</p>\r\n<p><img src=\"12.png\" /></p>\r\n<p>它的真值表如下：</p>\r\n<p><img src=\"13.png\" /></p>\r\n<p>可以看出，假如我<span\r\nclass=\"math inline\">\\(I_7\\)</span>为高电平，则输出111，就是7的二进制。</p>\r\n<p>那内部电路如何设计呢？根据真值表得出逻辑表达式然后化简，再选用与非门实现即可。</p>\r\n<p>上面这个是8线-3线普通编码器，那如何实现8421-BCD普通编码器呢？</p>\r\n<p>很简单，10个输入，4个输出。列出真值表，发现会有无关项。不考虑无关项，根据真值表得出4个输出的逻辑表达式，然后根据卡诺图化简。最后选用与非门实现即可。</p>\r\n<ul>\r\n<li><strong>优先编码器</strong></li>\r\n</ul>\r\n<p>特点：允许同时输入多个编码信号，只对其中优先权最高的一个进行编码。</p>\r\n<p>最常见的优先编码器是74148优先编码器，长下面这个样子，需要掌握：</p>\r\n<p><img src=\"14.png\" /></p>\r\n<p>这个图有两个要注意的地方，首先就是所有的<span\r\nclass=\"math inline\">\\(I\\)</span>上面都是有一个取反号的，只是这个图比较小可能看不清晰，然后所有的<span\r\nclass=\"math inline\">\\(Y、S\\)</span>上面也有取反号。还有就是看到红色箭头的地方了吗？这跟前面的8线-3线普通编码器不一样，这代表低电平有效。</p>\r\n<p><span\r\nclass=\"math inline\">\\(\\overline{S}\\)</span>为选通输入端，只有当<span\r\nclass=\"math inline\">\\(\\overline{S} = 0\\)</span>时才能正常工作，当<span\r\nclass=\"math inline\">\\(\\overline{S} =\r\n1\\)</span>时所有输出端为封锁为高电平。</p>\r\n<p>​ <img src=\"15.png\" /></p>\r\n<p><span\r\nclass=\"math inline\">\\(\\overline{Y_s}\\)</span>为选通输出端，当<span\r\nclass=\"math inline\">\\(\\overline{Y_s} =\r\n0\\)</span>说明电路正常工作且无编码信号输入（<span\r\nclass=\"math inline\">\\(\\overline{S} = 0 且所有\\overline{I} =\r\n1\\)</span>）</p>\r\n<p>​ <img src=\"16.png\" /></p>\r\n<p><span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>为扩展端，当<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}} =\r\n0\\)</span>说明电路正常工作且有编码信号输入（<span\r\nclass=\"math inline\">\\(\\overline{S} = 0\\)</span>且存在<span\r\nclass=\"math inline\">\\(\\overline{I} = 0\\)</span>）</p>\r\n<p>​ <img src=\"17.png\" /></p>\r\n<p>知道了每个端口的作用，如何只通过输出端判断此时编码器处于什么状态呢？</p>\r\n<ol type=\"1\">\r\n<li><span class=\"math inline\">\\(\\overline{Y_s} =\r\n0\\)</span>：电路正常工作且无编码信号输入。（此时<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>必为1）</li>\r\n<li><span class=\"math inline\">\\(\\overline{Y_{EX}} =\r\n0\\)</span>：电路正常工作且有编码信号输入。（此时<span\r\nclass=\"math inline\">\\(\\overline{Y_s}\\)</span>必为1）</li>\r\n<li><span class=\"math inline\">\\(\\overline{Y_s} = \\overline{Y_{EX}} =\r\n1\\)</span>：电路被阻塞（此时<span\r\nclass=\"math inline\">\\(\\overline{S}\\)</span>必为1）</li>\r\n</ol>\r\n<p>最后，74148优先编码器的真值表贴上来，上面所有可能你觉得有困惑的点都可以在这张表中得到解答。</p>\r\n<p><img src=\"18.png\" /></p>\r\n<ul>\r\n<li><strong>练习</strong></li>\r\n</ul>\r\n<p>学了上面普通编码器和优先编码器的知识，来写一道题吧！</p>\r\n<blockquote>\r\n<p>请用两片74148接成16线-4线优先编码器，将16个低电平输入信号<span\r\nclass=\"math inline\">\\(\\overline{A_0} \\sim\r\n\\overline{A_{15}}\\)</span>编为'0000' ~ '1111'，其中<span\r\nclass=\"math inline\">\\(\\overline{A_{15}}\\)</span>的优先级最高。</p>\r\n</blockquote>\r\n<p>首先如果是0 ~\r\n7就直接用一片就好了。思考一下，如果是大于7怎么办？可以这样思考：</p>\r\n<p>15 = 8 + 7</p>\r\n<p>14 = 8 + 6</p>\r\n<p>13 = 8 + 5</p>\r\n<p>12 = 8 + 4</p>\r\n<p>11 = 8 + 3</p>\r\n<p>10 = 8 + 2</p>\r\n<p>9 = 8 + 1</p>\r\n<p>8 = 8 + 0</p>\r\n<p>发现规律了吗？如果是0 ~ 7直接用一片就好了，如果是8 ~\r\n15就肯定需要用到第二片，但是第二片同样能表达的范围只有0 ~ 7，所以就将8 ~\r\n15进行数字拆分。</p>\r\n<p>如果输入8，则点亮第四位输出（8421中的8），剩下3位二进制输入0</p>\r\n<p>如果输入9，则点亮第四位输出，剩下3位二进制输入1</p>\r\n<p>如果输入10，则点亮第四位输出，剩下3位二进制输入2</p>\r\n<p>... ...</p>\r\n<p>如果输入15，则点亮第四位输出，剩下3位二进制输入7</p>\r\n<p>思路就是这样，还有一些小细节我在放答案过后再解释：</p>\r\n<p><img src=\"19.png\" /></p>\r\n<p>可以看到<span\r\nclass=\"math inline\">\\(G_0、G_1、G_2\\)</span>门都采用了与非门的设计，因为两片74148必定只会用到一片的输出（0\r\n~ 7用右边那片，8 ~ 15用左边那片）。</p>\r\n<p>但是如果使得一片工作另一片就停止工作呢？注意左边那片的<span\r\nclass=\"math inline\">\\(\\overline{Y_s}\\)</span>端口，左边那片正常工作且有信号输入时输出1，使得右边那片<span\r\nclass=\"math inline\">\\(\\overline{S} =\r\n1\\)</span>，所以右边那片直接被堵塞了。如果左边那片正常工作但没信号输入时输出0，使得右边那片被激活。这样就实现了两片中只能有一片在工作。</p>\r\n<p>然后<span\r\nclass=\"math inline\">\\(Z_3\\)</span>就是第四个二进制输出。只要用到左边那片，就输出1。刚好<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>就可以实现这个功能，只要电路正常工作并且有信号输入<span\r\nclass=\"math inline\">\\(\\overline{Y_{EX}}\\)</span>就为0，经过一个与非门之后就变成了1。</p>\r\n<h4 id=\"译码器\">3.2 译码器</h4>\r\n<p>译码器就是编码器的逆过程。编码器是给它一个数字，输出二进制。译码器就是给它一个二进制，输出一个数字。</p>\r\n<p>译码器分为二进制译码器（最小项译码器）、二—十进制译码器、显示译码器。其中二进制译码器需要掌握74138译码器。</p>\r\n<ul>\r\n<li><strong>二进制译码器（只讲74138译码器）</strong></li>\r\n</ul>\r\n<p>74138译码器长这个样子：</p>\r\n<p><img src=\"20.png\" /></p>\r\n<p>注意，跟74148解码器不同，这里的三个输入端<span\r\nclass=\"math inline\">\\(A\\)</span>都是高电平有效，输出端<span\r\nclass=\"math inline\">\\(\\overline{Y}\\)</span>是低电平有效。这里的<span\r\nclass=\"math inline\">\\(S、\\overline{S}\\)</span>是控制芯片是否工作的。</p>\r\n<p>具体来说，只有当<span class=\"math inline\">\\(S_1 = 1 且 \\overline{S_2}\r\n=0 且 \\overline{S_3} =\r\n0\\)</span>时，电路才处于正常工作状态。其余情况电路都处于被堵塞的状态。</p>\r\n<p>​ <img src=\"21.png\" /></p>\r\n<p>74138解码器的真值表如下：</p>\r\n<p><img src=\"22.png\" /></p>\r\n<ul>\r\n<li><strong>二—十进制译码器（只讲7442译码器）</strong></li>\r\n</ul>\r\n<p>我觉得二—十进制译码器就是二进制译码器啊...\r\n...搞不懂为啥还要专门分个类出来。二—十译码器就是说将4个二进制数变成十进制0\r\n~ 9。</p>\r\n<p>二—十进制译码器最常见的就是7442译码器，它的真值表如下：</p>\r\n<p><img src=\"23.png\" /></p>\r\n<p>可以看到有伪码的存在，这是为什么呢？因为4个二进制数可以表达0 ~\r\n15，但是因为是BCD码，所以我们得到的数范围是0 ~\r\n9。所以有一部分的二进制状态没有用到，没用到的地方就称为伪码。</p>\r\n<ul>\r\n<li><strong>显示译码器</strong></li>\r\n</ul>\r\n<p>啊就是能直观的显示出翻译后信息的译码器。看下面俩图就知道它是什么东西了。</p>\r\n<p><img src=\"24.png\" /><img src=\"25.png\" /></p>\r\n<ul>\r\n<li><strong>练习</strong></li>\r\n</ul>\r\n<blockquote>\r\n<p>试用两片74138组成4线-16线译码器。将输入的4位二进制代码<span\r\nclass=\"math inline\">\\(D_3D_2D_1D_0\\)</span>译成16个独立的低电平信号<span\r\nclass=\"math inline\">\\(\\overline{Z_0} \\sim\r\n\\overline{Z_{15}}\\)</span>。</p>\r\n</blockquote>\r\n<p>有了前面用两块74148组成16线-4线编码器的经验，这题的思考方式是一样的。首先如果只用一块板的话，3个二进制数，可以得到0\r\n~ 7。如果大于7怎么办呢？观察一下： <span class=\"math display\">\\[\r\n(8)_d = (1000)_b \\leftrightarrow (0)_d = (000)_b \\\\\r\n(9)_d = (1001)_b \\leftrightarrow (1)_d = (001)_b \\\\\r\n(10)_d = (1010)_b \\leftrightarrow (2)_d = (010)_b \\\\\r\n..... \\leftrightarrow ...\r\n\\]</span> 发现规律了没？</p>\r\n<p>只要四位二进制中第四位为0，将剩下3位二进制传给第一块板的三个输入接口。如果第四位二进制为1，那么堵塞第一块版，将剩下3位二进制传给第二块版的三个输入接口。答案如下：</p>\r\n<p><img src=\"26.png\" /></p>\r\n<h4 id=\"用译码器实现逻辑函数\">3.3 用译码器实现逻辑函数</h4>\r\n<p>因为任何逻辑函数均可化成最小项之和的形式。所以可以用译码器实现逻辑函数的电路，很牛逼。看下面这个例子你就懂了。</p>\r\n<p><img src=\"27.png\" /></p>\r\n<p>首先先将F化成主析取范式：<span class=\"math inline\">\\(F = ABC\r\n+AB\\overline{C} + A\\overline{B}C + \\overline{A}BC = m_7 + m_6 + m_5 +\r\nm_3\\)</span></p>\r\n<p>意思是说，只要三输入变量按照7、6、5、3的二进制输入，F就是1。否则F就是0。</p>\r\n<p>好，那我们在74138输出端将<span\r\nclass=\"math inline\">\\(\\overline{Y_7}、\\overline{Y_6}、\\overline{Y_5}、\\overline{Y_3}\\)</span>用与非门连接起来。只要三输入变量输入7、6、5、3二进制其中的一个，那么<span\r\nclass=\"math inline\">\\(\\overline{Y_7}、\\overline{Y_6}、\\overline{Y_5}、\\overline{Y_3}\\)</span>就有一个是0，与非后就得到1。如果三输入变量不属于7、6、5、3二进制中的任何一个，则<span\r\nclass=\"math inline\">\\(\\overline{Y_7}、\\overline{Y_6}、\\overline{Y_5}、\\overline{Y_3}\\)</span>都为1，与非后就得到0。</p>\r\n<hr />\r\n<h3 id=\"四.-组合逻辑电路4\">四. 组合逻辑电路(4)</h3>\r\n<h4 id=\"数据分配器\">4.1 数据分配器</h4>\r\n<p>定义：数据传输过程中，有时需要将数据分配到不同的数据通道上。数据分配器也叫多路分配器，简称DEMUX。</p>\r\n<p>示意图：通过A端口来选择数据输出通道。</p>\r\n<p><img src=\"28.png\" /></p>\r\n<p>电路图：</p>\r\n<p><img src=\"29.png\" /></p>\r\n<p>这个电路还是蛮简单的。</p>\r\n<p>提一嘴，前面学到的74138译码器就可以用来作1路-8路数据分配器。内部电路图ppt没给，但是我觉得就跟上面DEMUX的电路图差不多。</p>\r\n<p><img src=\"30.png\" /></p>\r\n<h4 id=\"数据选择器\">4.2 数据选择器</h4>\r\n<p>定义：能够实现从多路数据中选择一路进行传输的电路叫做数据选择器。也叫多路选择器、多路调制器，简称MUX。常见的类型有二选一、四选一、八选一、十六选一。</p>\r\n<p><img src=\"31.png\" /></p>\r\n<ul>\r\n<li><strong>二选一多路选择器</strong></li>\r\n</ul>\r\n<p><img src=\"32.png\" /></p>\r\n<p>w0和w1分别是两路的数据源，然后s是控制器。先看右边的电路图，假设s是0，则f\r\n= w0，假设s是1，则f = w1。左边就是二选一MUX的图形符号。</p>\r\n<ul>\r\n<li><strong>四选一多路选择器</strong></li>\r\n</ul>\r\n<p>先看真值表，根据真值表就可以直接设计电路了。</p>\r\n<p><img src=\"33.png\" /></p>\r\n<p>所以根据上面的真值表可以写出逻辑表达式：</p>\r\n<p><span class=\"math inline\">\\(f = w_0\\overline{s_1}\\overline{s_0} +\r\nw_1\\overline{s_1}s_0 + w_2s_1\\overline{s_0} + w_3s_1s_0\\)</span></p>\r\n<p>下面右图是用非门 + 与门 +\r\n或门来实现上面的逻辑表达式，左图是四选一MUX的图形符号</p>\r\n<p><img src=\"34.png\" /></p>\r\n<ul>\r\n<li><strong>更大规模的多路选择器</strong></li>\r\n</ul>\r\n<p>可以直接列真值表然后直接构建，也可以用小规模的多路选择器去构建。</p>\r\n<p>看一个由2选1多路选择器构建的4选1多路选择器，就知道如何构建了。</p>\r\n<p><img src=\"35.png\" /></p>\r\n<p>先将w俩俩分组，然后用s0去筛，一下筛掉一半，再用s1去筛，又筛掉一半，最后就选择出来了一路数据。</p>\r\n<h4 id=\"数据选择器的运用\">4.3 数据选择器的运用</h4>\r\n<ol type=\"1\">\r\n<li><p>2x2纵横开关（是否交换数据传输通道）</p>\r\n<p><img src=\"36.png\" /></p>\r\n<ul>\r\n<li>看图，s是选择器。如果s=0，则y1 = x1, y2 = x2。如果s=1，则y1 = x2，y2\r\n= x1。</li>\r\n</ul></li>\r\n<li><p>实现逻辑函数</p>\r\n<ul>\r\n<li><p>最暴力的想法就是列真值表，输入变量A、B、C就是选择器s。每一行的输出就是数据输入通道，输出通道就是f。例如函数<span\r\nclass=\"math inline\">\\(f = \\overline{w_1}w_2 +\r\nw_1\\overline{w_2}\\)</span>，用四选一多路选择器的实现如下：</p>\r\n<p><img src=\"38.png\" /></p></li>\r\n<li><p>但在暴力的基础上其实可以优化：可以对真值表做一个改动：</p>\r\n<p><img src=\"39.png\" /></p></li>\r\n<li><p>这样子输入变量只有一个w1了，它就是选择器。数据输入通道有两个，分别是<span\r\nclass=\"math inline\">\\(w_2\\)</span>和<span\r\nclass=\"math inline\">\\(\\overline{w_2}\\)</span>，数据输出通道一个为f。用二选一多路选择器实现如下：</p>\r\n<p><img src=\"40.png\" /></p></li>\r\n</ul></li>\r\n<li><p>实现3输入表决器</p>\r\n<ul>\r\n<li><p>先列出真值表</p>\r\n<p><img src=\"41.png\" /></p></li>\r\n<li><p>对真值表进行优化</p>\r\n<p><img src=\"42.png\" /></p></li>\r\n<li><p>此时输入变量两个w1、w2为选择器，数据输入通道4个分别是0、w3、w3、1，数据输出通道1个为f。用4选1多路选择器实现如下：</p>\r\n<p><img src=\"43.png\" /></p></li>\r\n</ul></li>\r\n<li><p>实现3位异或运算</p>\r\n<ul>\r\n<li><p>先列出真值表，并优化</p>\r\n<p><img src=\"44.png\" /></p></li>\r\n<li><p>此时输入变量两个w1、w2为选择器，数据输入通道4个分别是<span\r\nclass=\"math inline\">\\(w_3、\\overline{w_3}、\\overline{w_3}、w_3\\)</span>，数据输出通道一个为f。用4选1多路选择器实现如下：</p>\r\n<p><img src=\"45.png\" /></p></li>\r\n</ul></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"五.-组合逻辑电路5\">五. 组合逻辑电路(5)</h3>\r\n<p>这一节比较杂，主要是对第（4）内容的一个补充。具体来说，讲了如下内容：</p>\r\n<ol type=\"1\">\r\n<li>用香农展开定理搭配多路选择器实现逻辑函数</li>\r\n<li>八选一数据选择器74151</li>\r\n<li>双四选一数据选择器74153</li>\r\n<li>数据选择器的更多运用</li>\r\n</ol>\r\n<h4 id=\"用香农展开定理搭配多路选择器实现逻辑函数\">5.1\r\n用香农展开定理搭配多路选择器实现逻辑函数</h4>\r\n<ul>\r\n<li><p>香农展开定理：</p>\r\n<ul>\r\n<li><p><span class=\"math inline\">\\(f\\left(w_{1}, w_{2}, \\ldots . .\r\nw_{\\mathrm{n}}\\right)=\\overline{w_{1}} f\\left(0, w_{2}, \\ldots . .\r\nw_{\\mathrm{n}}\\right)+w_{1} f\\left(1, w_{2}, \\ldots . .\r\nw_{\\mathrm{n}}\\right)\\)</span></p>\r\n<ul>\r\n<li><p>↑展开一个变量</p></li>\r\n<li><p>在香农表达式中<span\r\nclass=\"math inline\">\\(f\\left(0,w_{2}....w_{\\mathrm{n}}\\right)\\)</span>\r\n项称为对应于<span\r\nclass=\"math inline\">\\(\\bar{w}_{\\mathrm{1}}\\)</span>的<span\r\nclass=\"math inline\">\\(f\\)</span>的余因子式, 简写做<span\r\nclass=\"math inline\">\\(f_{\\overline{w}_1}\\)</span>。 同样的,<span\r\nclass=\"math inline\">\\(f(1,w_2.....w_n)\\)</span> 项称为对应于<span\r\nclass=\"math inline\">\\(w_{_1}\\)</span>的<span\r\nclass=\"math inline\">\\(f\\)</span>的余因子式,简写做<span\r\nclass=\"math inline\">\\(f_{_{w_1}}\\)</span>。所以香农展开定理可以简写成：\r\n<span class=\"math display\">\\[\r\nf=\\overline{w}_{1}f_{\\overline{w}_{1}}+w_{1}f_{w_{1}}\r\n\\]</span></p></li>\r\n</ul></li>\r\n<li><p><span class=\"math inline\">\\(f(w_1,w_2,....,w_n)=\\\\\r\n\\overline{w_1}\\overline{w_2}f(0,0,w_3....w_n)+\\overline{w_1}w_2f(0,1,w_3,.....w_n)+w_1\\overline{w_2}f(1,0,w_3,.....w_n)+\r\n\\\\ w_1w_2f(1,1,w_3,.....w_n)\\)</span></p>\r\n<ul>\r\n<li>↑展开多个变量</li>\r\n</ul></li>\r\n</ul></li>\r\n</ul>\r\n<p>那如何用香农展开定理实现逻辑函数呢？举个例子，比如<span\r\nclass=\"math inline\">\\(f=\\overline{w}_{1}\\overline{w}_{3}+w_{1}w_{2}+w_{1}w_{3}\\)</span></p>\r\n<p>将f以w1用香农展开定理展开，得到<span\r\nclass=\"math inline\">\\(f=\\overline{w}_1f_{\\overline{w}_1}+w_1f_{w_1}=\\overline{w}_1(\\overline{w}_3)+w_1(w_2+w_3)\\)</span></p>\r\n<p>然后选用二路选择器，w1是选择器，数据输入通道2个分别是<span\r\nclass=\"math inline\">\\(\\overline{w_3}\\)</span>和<span\r\nclass=\"math inline\">\\(w_2 +\r\nw_3\\)</span>，数据输出通道一个为f。实现电路图如下：</p>\r\n<p><img src=\"46.png\" /></p>\r\n<p>同理，如果用香农展开定理展开两个变量，则搭配一个四路选择器也可以实现上述函数f。</p>\r\n<h4 id=\"八选一数据选择器74151\">5.2 八选一数据选择器74151</h4>\r\n<p>74151MUX的样子和真值表如下图</p>\r\n<p><img src=\"47.png\" /></p>\r\n<h4 id=\"双四选一数据选择器74153\">5.3 双四选一数据选择器74153</h4>\r\n<p>就是俩独立的四路选择器放一起，如图。（个人觉得左图很不直观，下面练习中的74153比较直观）</p>\r\n<p><img src=\"48.png\" /></p>\r\n<blockquote>\r\n<p>练习：如何用74153构建一个74151？</p>\r\n</blockquote>\r\n<p>很简单，跟以前练习题一样的套路。只要保证两个四选一板子有且只能有一块板子在工作就行了。看答案吧，很简单。</p>\r\n<p><img src=\"49.png\" /></p>\r\n<p>A2还有G1就是为了实现”只能有一个四选一“板子在工作我们自己加上去的电路。</p>\r\n<h4 id=\"小补充\">5.4 小补充</h4>\r\n<p>感觉代号多了有点乱了。让我来梳理一下。</p>\r\n<p>74148是最常见的8线-3线优先编码器。</p>\r\n<p>74138是最常见的二进制译码器。（3个输入、8个输出）</p>\r\n<p>数据分配器DEMUX可用74138实现。</p>\r\n<p>数据选择器MUX有74151（八路）、74153（俩独立四路放一起）</p>\r\n<h4 id=\"数据选择器的更多运用\">5.5 数据选择器的更多运用</h4>\r\n<ol type=\"1\">\r\n<li><p>与DEMUX实现多路信号分时传送</p>\r\n<p><img src=\"50.png\" /></p></li>\r\n<li><p>实现逻辑函数</p>\r\n<ul>\r\n<li><p>用MUX实现逻辑函数的方法有许多。</p>\r\n<ol type=\"1\">\r\n<li>直接列真值表实现</li>\r\n<li>列完真值表，对真值表优化后实现</li>\r\n<li>用香农展开公式后实现</li>\r\n<li>列引入变量的卡诺图实现</li>\r\n</ol></li>\r\n<li><p>前三种方法前面都介绍过了，这里放一个用第四种方法的例题。</p>\r\n<p><img src=\"51.png\" /></p></li>\r\n<li><p>因为74151是八位选择器，所以只能有3个选择变量。所以画卡诺图引入了一个变量。然后8个信号输入端口就输入0/1/D/<span\r\nclass=\"math inline\">\\(\\overline{D}\\)</span>即可。</p></li>\r\n<li><blockquote>\r\n<p>练习：请用一片74151实现逻辑函数<span\r\nclass=\"math inline\">\\(F(A,B,C,D,E)=A\\overline{B}C\\overline{D}E+AB\\overline{C}\\overline{D}\\overline{E}+A\\overline{B}C\\overline{D}\\overline{E}+\\overline{A}\\overline{B}\\overline{C}DE+\\overline{A}B\\overline{C}\\overline{D}\\overline{E}\\)</span></p>\r\n</blockquote></li>\r\n<li><p>74151是八路选择器，所以要有三个选择变量。但是这里F有5个，所以第一想法是用香农展开定理展开3个变量，但是这样太麻烦了。所以用第四种方法，引入两个变量进卡诺图即可。</p>\r\n<p><img src=\"52.png\" /></p></li>\r\n</ul></li>\r\n<li><p>数据选择器的扩展</p>\r\n<ul>\r\n<li><p>很好理解，看图即可。</p>\r\n<p><img src=\"53.png\" /></p></li>\r\n</ul></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"六.-组合逻辑电路6\">六. 组合逻辑电路(6)</h3>\r\n<h4 id=\"数值比较器\">6.1 数值比较器</h4>\r\n<ul>\r\n<li><strong>一位数值比较器</strong></li>\r\n</ul>\r\n<p>两个1位二进制数A,B相比的情况有以下几种: 1. A&gt;B，则<span\r\nclass=\"math inline\">\\(A\\overline{B}=1\\)</span>，所以可用<span\r\nclass=\"math inline\">\\(A\\overline{B}\\)</span>作为A&gt;B的输出信号<span\r\nclass=\"math inline\">\\({Y}_{(A&gt;B)}\\)</span> 。<br />\r\n2. 同理可用 <span class=\"math inline\">\\(\\overline{AB}\\)</span>\r\n作为A&lt;B的输出信号 <span class=\"math inline\">\\({Y}_{(A&lt;B)}\\)</span>\r\n。 3. 同理可用<span class=\"math inline\">\\(A \\odot B\\)</span>\r\n作为A=B的输出信号 <span class=\"math inline\">\\(Y_{A=B}\\)</span></p>\r\n<p>于是可以设计出如下电路（注意是低电平有效）</p>\r\n<p><img src=\"54.png\" /></p>\r\n<ul>\r\n<li><strong>多位数值比较器</strong></li>\r\n</ul>\r\n<p>多位数值比较器的原理就是从高位到低位逐位比较，最常见的是4位比较器14585，下面是其逻辑函数和电路图：</p>\r\n<p><img src=\"55.png\" /></p>\r\n<p><img src=\"56.png\" /></p>\r\n<p>这个图有4个要注意的地方，首先看蓝色箭头的地方，为啥这个地方用与非门呢？很简单，将上面的逻辑表达式进行进一步化简：\r\n<span class=\"math display\">\\[\r\nY_{A&lt;B} = \\overline{\\overline{\\overline{A_3}B_3} \\cdot\r\n\\overline{\\overline{A_3 \\oplus B_3}\\overline{A_2}B_2} \\cdot ...} \\,\r\n\\cdot I_{A&lt;B}  \\\\\r\n= \\overline{\\overline{\\overline{A_3}B_3} \\cdot ((A_3 \\oplus B_3) +\r\n\\overline{\\overline{A_2}B_2}) \\cdot \\, ...} \\, \\cdot I_{A&lt;B}\r\n\\]</span> 现在知道蓝色箭头为啥用与非门了吧=w=。</p>\r\n<p>那为啥绿色箭头那要用或门呢？还是看上面化简的式子，注意看第二项，第二项就是或门=w=。</p>\r\n<p>那为啥棕色箭头用或非门呢？还是化简上面的式子： <span\r\nclass=\"math display\">\\[\r\nY_{A=B} = \\overline{(A_3 \\oplus B_3) + (A_2 \\oplus B_2) + (略) + (略)}\r\n\\, \\cdot I_{A=B}\r\n\\]</span>\r\n很清楚吧=w=，就是一个或非门，每一项这里用异或表达了，其实就是图中判断是否每一项是否相等的那个逻辑门。</p>\r\n<p>那为啥红箭箭头那要用或非门呢？还是化简上面的式子： <span\r\nclass=\"math display\">\\[\r\nY_{A&gt;B} = \\overline{(Y_{A&lt;B} + Y_{A=B}) + \\overline{I_{A&gt;B}}}\r\n\\]</span> easy。</p>\r\n<p>还剩一个问题，那三个<span\r\nclass=\"math inline\">\\(I\\)</span>是干啥的。其实就是用来接收低位上的结果的。这样两块14585就能实现8位数字的比较。如下图：</p>\r\n<p><img src=\"57.png\" /></p>\r\n<p>有个问题，为啥左边的<span\r\nclass=\"math inline\">\\(Y_{A&gt;B}\\)</span>为啥不能连到右边的<span\r\nclass=\"math inline\">\\(I_{A=B}\\)</span>？</p>\r\n<p>其实可以，但是图中这样连也没问题。还是用逻辑表达式去解释：<span\r\nclass=\"math inline\">\\(Y_{A&gt;B} = \\overline{(Y_{A&lt;B} + Y_{A=B}) +\r\n\\overline{I_{A&gt;B}}}\\)</span>，可以发现必须要三者都是0才会使得<span\r\nclass=\"math inline\">\\(Y_{A&gt;B}=1\\)</span>，所以默认给<span\r\nclass=\"math inline\">\\(I_{A&gt;B}\\)</span>置为1不影响结果。</p>\r\n<h4 id=\"加法器\">6.2 加法器</h4>\r\n<ul>\r\n<li><strong>半加器</strong></li>\r\n</ul>\r\n<p>很简单，真值表、逻辑表达式、图形符号如下图：</p>\r\n<p><img src=\"58.png\" /></p>\r\n<ul>\r\n<li><strong>全加器</strong></li>\r\n</ul>\r\n<p>加了一个考虑上一位进位而已，也很简单，真值表、逻辑表达式、图形符号如下：</p>\r\n<p><img src=\"59.png\" /></p>\r\n<p>这里解释一下逻辑表达式，因为异或是不进位加法，所以S等于三者异或很合理。然后CO用或连接也很合理，无非就是A、B都是1可以进位，或者CI为1，A、B里任意一个为1也可以进位。</p>\r\n<ul>\r\n<li><strong>串行进位加法器</strong></li>\r\n</ul>\r\n<p>有了全加器之后，只需要将多个全加器串联起来就可以得到任意多位的加法器了。如下图：</p>\r\n<p><img src=\"60.png\" /></p>\r\n<p>虽然这样逻辑和电路都很简单，但是存在一个问题，就是速度过慢，如何解决呢？</p>\r\n<p>速度关键是慢在进行信号逐级传递的过程，所以要优化这个过程。不难发现，要想知道<span\r\nclass=\"math inline\">\\(CI_i\\)</span>，只需要知道<span\r\nclass=\"math inline\">\\(A_{i-1}A_{i-2}...A_0\\)</span>和<span\r\nclass=\"math inline\">\\(B_{i-1}B_{i-2}...B_0\\)</span>即可。</p>\r\n<p>个人觉得，这种优化思路就很像把递归函数展开来写了笑死。也有点像并查集路径压缩。</p>\r\n<ul>\r\n<li><strong>超前进位加法器</strong></li>\r\n</ul>\r\n<p>用上面提到的优化方法做成的加法器就叫做超前进位加法器。下图是74283的超前进位加法器电路图：</p>\r\n<p><img src=\"61.png\" /></p>\r\n<p>可以发现光4位加法器电路就那么复杂了，这或许就是空间换时间吧（笑）</p>\r\n<p>所以当我们需要更多位加法器的时候，可以拿74283超前进位加法器去串联做成一个多位的串行进位加法器。</p>\r\n<blockquote>\r\n<p>练习：用一片74283设计将BCD8421码转换成余3码的电路</p>\r\n</blockquote>\r\n<p>太简单啦！直接上图：</p>\r\n<p><img src=\"62.png\" /></p>\r\n<h4 id=\"竞争-冒险现象\">6.3 竞争-冒险现象</h4>\r\n<p>啊我懒得打很多字了，这里我放一个up主的视频，看完这道例题就知道什么是竞争-冒险现象了：（up主：海蓬莱）</p>\r\n<video src=\"video.mp4\" controls=\"controls\">\r\n</video>\r\n<p>视频中的险象就是这里的冒险。官方定义如下 ：</p>\r\n<p>竞争：一个逻辑门的两个输入端的信号同时向相反方向变化，而变化的时间有差异的现象。</p>\r\n<p>冒险：由于竞争而使电路输出发生瞬时错误</p>\r\n<p>注意，有竞争不一定会冒险（如视频中提到的非临界竞争）</p>\r\n<p>冒险分为两类：</p>\r\n<ol type=\"1\">\r\n<li>0型冒险：即本来是1的变成了0\r\n<ul>\r\n<li>当表达式在一定条件下能化成<span class=\"math inline\">\\(F = A +\r\n\\overline{A}\\)</span>时，就会出现0型冒险</li>\r\n</ul></li>\r\n<li>1型冒险：即本来是0的变成了1\r\n<ul>\r\n<li>当表达式在一定条件下能化成<span class=\"math inline\">\\(F = A \\cdot\r\n\\overline{A}\\)</span>时，就会出现1型冒险</li>\r\n</ul></li>\r\n</ol>\r\n<p>如何能消除竞争-冒险现象呢？ppt上给出了三种解决方案：</p>\r\n<ol type=\"1\">\r\n<li><p>接入滤波电容</p></li>\r\n<li><p>引入选通脉冲</p></li>\r\n<li><p>修改逻辑表达式</p>\r\n<ul>\r\n<li>前俩个反正我是没看懂，这里举个例子说一下第三种方法。比如有逻辑函数<span\r\nclass=\"math inline\">\\(F = AB + \\overline{A}C\\)</span>，当B = C =\r\n1时会出现0型冒险。所以可以修改一下逻辑表达式为：<span\r\nclass=\"math inline\">\\(F = AB + \\overline{A}C +\r\nBC\\)</span>，这样就不会出现0型冒险了。（为什么要这么修改呢？看下面的卡诺图你就知道了）</li>\r\n</ul>\r\n<p><img src=\"63.png\" /></p></li>\r\n</ol>\r\n<hr />\r\n<h3 id=\"七.-vivado的基本使用\">七. Vivado的基本使用</h3>\r\n<p>先来了解一下EDA技术：即电子设计自动化，其依赖功能强大的计算机，在\r\nEDA工具软件平台上，对以硬件描述语言(HDL)为系统逻辑描述手段完成的设计文件，自动地完成逻辑编译、逻辑化简、逻辑分割、逻辑综合、布局布线，以及逻辑优化和仿真测试，直至物理实现既定的电子设计系统功能。</p>\r\n<p>以我浅薄的理解，EDA = IDE，Verilog =\r\nC++，hhhhh，FPGA是可编程逻辑器件。</p>\r\n<h4 id=\"用verilog-hdl设计电路\">用Verilog HDL设计电路</h4>\r\n<p>写一个模块大致分为以下几步：</p>\r\n<ol type=\"1\">\r\n<li>打开Vivado，创建一个项目（根据自己开发板选型号，我的是xc7a35tcpg236-1）</li>\r\n<li>新建一个design文件，在里头写程序</li>\r\n<li>新建一个sim文件，在里头写仿真程序（初始化 + 实例化 +\r\n仿真过程代码）</li>\r\n<li>运行仿真，观察仿真结果是否跟设想一样</li>\r\n<li>封装IP核，以便此模块以后可被其它项目使用</li>\r\n</ol>\r\n<h4 id=\"用block-design设计电路\">用Block Design设计电路</h4>\r\n<ol type=\"1\">\r\n<li>打开Vivado，创建一个项目</li>\r\n<li>左侧新建一个Block Design项目</li>\r\n<li>引入IP核，开始画图</li>\r\n<li>新建一个sim文件，写仿真程序</li>\r\n<li>运行仿真，观察仿真结果是否跟设想一样</li>\r\n</ol>\r\n<h4 id=\"用rtl看电路图\">用RTL看电路图</h4>\r\n<p>点左侧RTL分析即可生成。</p>\r\n<h4 id=\"下板\">下板</h4>\r\n<ol type=\"1\">\r\n<li>写好constraint文件（我直接用的老师给的模板文件上修改）</li>\r\n<li>运行左侧Synthesis</li>\r\n<li>运行Implementation（记得勾选第二项产生二进制文件，然后选择Open\r\nHardware Manager）</li>\r\n<li>通过USB连上FPGA</li>\r\n<li>点击Auto Connect，连接成功后选择Program\r\nDevice下载刚才的二进制文件</li>\r\n<li>可以愉快的用板子观察程序结果啦~</li>\r\n</ol>\r\n<p>但是断电后程序就会丢失，为了解决这个问题，需要把程序烧录进ROM里：</p>\r\n<ol type=\"1\">\r\n<li>生成bin文件，Tools -&gt; Settings -&gt; Bitstream -&gt;\r\n勾选-bin-file* -&gt; OK，左侧Generate\r\nBitstream重新生成bit文件（此时就会生成bin文件）</li>\r\n<li>右键芯片选择Add Configuration Memory Device，选择合适的闪存型号</li>\r\n</ol>\r\n<h4 id=\"总结\">总结</h4>\r\n<p>Vivado这个软件其实蛮简单使用的。首先不考虑板子的话，只在电脑上设计电路有两种方法，第一种就是直接创建design文件写，第二种就是用Block\r\nDesign（若某个模块想封装成IP核必须要仿真过先）。然后想看设计的对不对，就创建仿真文件来看。另外，用RTL可以看设计好的电路。</p>\r\n<p>下板的话就需要通过constraint文件指定管脚，然后左侧Synthesis +\r\nImplementation + 生成二进制文件 + 连板子 + Auto Connect + Program\r\nDevice就可以在板子上观察了。</p>\r\n","categories":["大学","数字逻辑"]},{"title":"期末Lab1 存储管理","url":"/2023/10/09/%E6%9C%9F%E6%9C%ABLab1-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/","content":"<p>今天突然就上强度了。实验课是让我们设计一个简单的RDBMS原型系统。（本质上就是参考的CMU15-445课程和StanfordCS346的课程）我觉得还是蛮有趣的，开一个系列来记录实验过程。</p>\r\n<p>本篇是Lab 1，存储管理部分的内容。</p>\r\n<span id=\"more\"></span>\r\n<p>课程目标：</p>\r\n<p><img src=\"1.png\" /></p>\r\n<h3 id=\"一.-安装docker以及基本操作\">一. 安装Docker以及基本操作</h3>\r\n<p>为了简化实验过程，尽可能的避免复杂的环境配置过程。助教推荐我们使用Docker，这样直接就能使用他配置好的环境。</p>\r\n<h4 id=\"docker是什么\">1. Docker是什么</h4>\r\n<p>根据我浅薄的理解，Docker就是虚拟机。装一个Docker，下载网上的镜像，然后把实例化为一个容器。此时容器就是一台虚拟机了。</p>\r\n<h4 id=\"如何安装docker\">2. 如何安装Docker</h4>\r\n<p>先安装wsl，wsl是在window下的linux子系统功能。本人Win11电脑，先在“启动或关闭Windows功能”里打开“虚拟机平台”和“适用于Linux的Windows子系统”，然后终端里输入wsl\r\nupdate，更新完后再输入wsl --install -d\r\nUbuntu，设置好Ubuntu用户名和密码后退出即可。</p>\r\n<p>然后下载Docker\r\nDesktop，下载好后不要安装。因为默认路径是C盘，后续可能会很占空间。通过软链接的方法把Docker装到D盘，终端里输入（记得用管理员权限）：mklink\r\n/j \"C:\\Program Files\\Docker\"\r\n\"D:\\app\\Docker\"（如果报错没找到文件夹则在目标路径下自己新建文件夹后再执行）。</p>\r\n<p>点击安装包，一路Next。安装好后在Docker设置里的Docker\r\nEnginel里改变源：</p>\r\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;registry-mirrors&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">    <span class=\"string\">&quot;http://hub-mirror.c.163.com&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">    <span class=\"string\">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span></span><br><span class=\"line\">  <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;insecure-registries&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;debug&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">true</span></span><span class=\"punctuation\">,</span></span><br><span class=\"line\">  <span class=\"attr\">&quot;experimental&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\r\n<p>至此，Docker就安装好了。</p>\r\n<h4 id=\"docker的基本操作\">3. Docker的基本操作</h4>\r\n<p>Docker里有三种东西，镜像、容器、仓库。</p>\r\n<p>镜像(image)是类似模板的东西，是一个只读文件。可以用来创建容器。</p>\r\n<p>容器(container)就是我们操作的“虚拟机”，它需要根据镜像实例化出来。</p>\r\n<p>仓库(repository)就是存储镜像的地方，我们通常可以从三个地方获得镜像：官方仓库、第三方仓库、本地</p>\r\n<p>基本操作如下：</p>\r\n<ol type=\"1\">\r\n<li><p>列出本地的所有镜像</p>\r\n<ul>\r\n<li>docker image ls</li>\r\n</ul></li>\r\n<li><p>拉取镜像到本地</p>\r\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 拉取官方镜像</span><br><span class=\"line\">docker pull 镜像名称</span><br><span class=\"line\">例：docker pull ubuntu</span><br><span class=\"line\"></span><br><span class=\"line\"># 拉取个人镜像</span><br><span class=\"line\">docker pull 仓库名称/镜像名称</span><br><span class=\"line\">例：docker pull xunmi/django</span><br><span class=\"line\"></span><br><span class=\"line\"># 第三方仓库拉取</span><br><span class=\"line\">docker pull 第三方仓库地址/仓库名称/镜像名称</span><br><span class=\"line\">例：docker pull hub.c.163.com/library/mysql:latest</span><br></pre></td></tr></table></figure></li>\r\n<li><p>删除镜像</p>\r\n<ul>\r\n<li>docker rmi 镜像名</li>\r\n<li>注意删镜像时需保证此时没有容器以该镜像为模板进行实例化。</li>\r\n</ul></li>\r\n<li><p>删除容器</p>\r\n<ul>\r\n<li>docker rm 容器名</li>\r\n<li>注意删除容器时需保证该容器没有在运行。</li>\r\n</ul></li>\r\n<li><p>关于管理镜像 &amp; 容器</p>\r\n<ul>\r\n<li>可以在Docker Desktop的Dashboard里进行管理。</li>\r\n</ul></li>\r\n</ol>\r\n<h3 id=\"二.-docker在本实验中的运用\">二. Docker在本实验中的运用</h3>\r\n<p>本实验要实现一个RDBMS，所以代码基本框架可以从助教发布的GitHub上clone到本地。但是当你完善了代码，如何知道自己对不对呢？肯定要测评嘛，以及编译这个RDBMS应该怎么办呢？比如代码用到了C++17的特性但是本地编译不了就很尴尬。所以需要Docker，助教发给我们一个镜像文件，我们把它实例化一个容器到本地。然后将刚刚clone下来的项目文件夹同步到容器中（也就是实现文件共享）。这样子我们就可以在本地编写程序，文件自动就会同步到容器中，编写完成后。通过Docker进入容器中，编译程序并进行测评，查看自己编写的程序是否正确。</p>\r\n<h4 id=\"初次配置流程\">1. 初次配置流程：</h4>\r\n<ol type=\"1\">\r\n<li>下载助教发的base-env.img镜像文件到本地，cd到img所在文件夹，在终端里输入docker\r\nimage load --input ./base-env.img拉取镜像到Docker中。（或者直接docker\r\npull cc0de/base-env:1.0）</li>\r\n<li>将助教上传到GitHub的项目文件夹clone到本地，我自己的路径是：D:/Projects/dbProjects/lab1/UniBase(UniBase是clone下来的文件夹)</li>\r\n<li>cd到lab1下，在终端里输入docker run -itd -v .\\UniBase:/mnt/UniBase\r\n--name unibase-env\r\nbase-env。这句话的意思就是将名为base-env的镜像文件实例化为一个容器到本地，名字起为unibase-env。并且将当前目录下的UniBase文件夹同步到unibase-env容器中/mnt下的UniBase文件夹。（mnt文件夹是wsl子系统与宿主系统进行文件交互的文件夹）</li>\r\n<li>cd到UniBase下，输入git submodule init和git submodule\r\nupdate来拉取子模块(google test)</li>\r\n<li>如果需要进容器，输入docker exec -it unibase-env\r\n/bin/bash。如果退出，输入exit。</li>\r\n</ol>\r\n<h4 id=\"编写流程\">2. 编写流程：</h4>\r\n<ol type=\"1\">\r\n<li>先在本地，用vscode写好程序</li>\r\n<li>开docker desktop，然后进容器docker exec -it unibase-env\r\n/bin/bash（建议为了了方便可以在win下的powershell里写一个alias，我把这段命令起别名为dockerC1了），进UniBase里，新建一个build文件夹，在里面运行：cmake\r\n..\r\n-DCMAKE_BUILD_TYPE=Debug（我把这段代码起别名ccmake了），就可以生成整个项目的编译文件，然后make\r\n某个module，比如make\r\ndisk_manager_test，就会编译这个模块并在/build/bin里生成可执行文件，进入bin里运行它就可以看到评测信息。</li>\r\n</ol>\r\n","categories":["大学","数据库"]}]