<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"manual","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="标题全称为：Distributed Nash Equilibrium Seeking for Aggregative Games With Directed Communication Graphs 中文翻译为：在使用有向图结构的聚合博弈中寻找离散式纳什均衡">
<meta property="og:type" content="article">
<meta property="og:title" content="Distributed Nash Equilibrium Seeking for...">
<meta property="og:url" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/index.html">
<meta property="og:site_name" content="Error_666">
<meta property="og:description" content="标题全称为：Distributed Nash Equilibrium Seeking for Aggregative Games With Directed Communication Graphs 中文翻译为：在使用有向图结构的聚合博弈中寻找离散式纳什均衡">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/1.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/5.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/6.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/2.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/3.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/4.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/7.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/8.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/9.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/10.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/11.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/12.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/13.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/14.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/15.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/16.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/17.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/18.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/19.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/26.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/20.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/21.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/22.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/23.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/24.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/25.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/27.png">
<meta property="og:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/28.png">
<meta property="article:published_time" content="2023-10-16T06:45:10.000Z">
<meta property="article:modified_time" content="2023-12-04T10:41:24.644Z">
<meta property="article:author" content="Error_666">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/1.png">

<link rel="canonical" href="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Distributed Nash Equilibrium Seeking for... | Error_666</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <script src="/live2d-widget/autoload.js"></script>
<link rel="alternate" href="/atom.xml" title="Error_666" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Error_666</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-tools">

    <a href="/tools/" rel="section"><i class="fa fa-toolbox fa-fw"></i>工具</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Error_666">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Error_666">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Distributed Nash Equilibrium Seeking for...
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-10-16 14:45:10" itemprop="dateCreated datePublished" datetime="2023-10-16T14:45:10+08:00">2023-10-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-12-04 18:41:24" itemprop="dateModified" datetime="2023-12-04T18:41:24+08:00">2023-12-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index"><span itemprop="name">论文</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>标题全称为：Distributed Nash Equilibrium Seeking for Aggregative
Games With Directed Communication Graphs</p>
<p>中文翻译为：在使用有向图结构的聚合博弈中寻找离散式纳什均衡</p>
<span id="more"></span>
<h3 id="abstract">Abstract</h3>
<p>在聚合博弈中寻找分布式纳什均衡的关键点就是聚合博弈采取什么样的图结构。</p>
<p>若采取无向图或者权衡平衡图结构，则这个问题已经被前人解决。</p>
<p>如果采取有向图，则这仍然是个无人解决的问题。</p>
<p>本文解决的是当图结构采取“固定有向图”或者“时变有向图”时的分布式NE寻找问题。</p>
<p>使用了两种算法来分别解决上面所提到的两种图结构时的分布式NE寻找问题。</p>
<p>创新点是受凸优化中重球法的启发，向玩家策略的更新规范中引入了“动量项”，使得加速了算法寻找NE的收敛速度。</p>
<p>对于强连通固定图和b强连通时变图，从理论上证明，如果代价函数和参与人的集合满足一定条件，在步长减小的情况下，参与人的行动将收敛到集合博弈的NE上。</p>
<p>本文最后将该算法运用于插电式混合动力汽车的能耗控制，检验了算法的正确性。</p>
<hr />
<h3 id="section-1-introduction">Section 1: Introduction</h3>
<h4 id="研究背景">1-1: 研究背景</h4>
<ul>
<li><p>本文研究的是聚合游戏，也就是每个玩家的花费除了依赖自身动作还依赖所有玩家的聚合行为。在聚合游戏中寻找NE是个有挑战性的问题，因为每个玩家只能与自己的邻居通信。</p></li>
<li><p>在分布式通信计算领域，一些解决聚合游戏中NE寻找问题的分布式算法已经被提出。具体分为“分布式离散时间算法”[6],
[7]和“分布式连续时间算法”[8]-[15]</p></li>
</ul>
<p>[6]：在这篇文章中，作者专注于研究有向图中的两种特殊的聚合游戏，分别叫做“network
aggregative games” 和 "average aggregative games"。使用"optimal response
strategy"方法去研究的。而且，在图的加权邻接矩阵为双随机矩阵的条件下，<span
class="math inline">\(\varepsilon-NE\)</span>在average aggregative
games的寻找得以被解决。</p>
<p>[7]：在这篇文章中，作者专注于研究无向图中的聚合游戏。并相应提出了几种分布式同步和异步算法。</p>
<p>[8]：在这篇文章中，作者专注于研究权重平衡有向图中的聚合游戏，其中玩家的dynamics
were described by disturbed first-order systems.
为了寻找寻找外部干扰下具有coupled equality
constraint的聚合游戏的NE，作者在文中提出了一种利用内部模型排斥外部干扰来找NE的分布式算法。同时利用dynamic
average consensus来估计所有玩家的总和。</p>
<p>[9]：在这篇文章中，研究了玩家成本函数非光滑，同时玩家动作受到局部可行性约束和线性耦合约束时的情况。具体来说，作者利用微分包含和微分投影算子，提出了一种基于连续时间分布投影的算法来找权重平衡有向图上的非光滑聚合游戏的NE。</p>
<p>[10]：在这篇文章中，作者研究了无向连通图上具有耦合约束的聚合游戏。</p>
<p>[11]：结合projected gradient dynamics 和 consensus tracking
dynamics，本文讨论了无向连通图上的聚合游戏。</p>
<p>[12]：结合projected gradient dynamics 和 consensus tracking
dynamics，本文讨论了权重平衡有向图上的聚合游戏。</p>
<p>[13]：研究了存在对通信链路持续攻击的网络上的聚合游戏。其中玩家的动态是受未知时变干扰和未建模项影响的双积分器。</p>
<p>[14]：研究了聚合游戏在智能电网能耗控制中的运用。其中玩家采用平均共识协议来估计总能耗，并且表明玩家的行为以指数形式收敛于NE。</p>
<p>[15]：将PHEVs建模成一个无向连通图上的聚合游戏，并对NE的稳定性进行了分析。</p>
<ul>
<li>可以发现上面的文章大多都是在无向图或者权重平衡有向图上的工作。在一般有向图上利用分布式离散时间算法来寻找NE仍然是一个未解决的问题。因为难点就在于玩家之间的通信结构不平衡。</li>
<li>但是到目前为止，关于在不平衡有向图上的分布式优化问题已经被广泛研究。例如下面几篇文章：</li>
</ul>
<p>[16]：提出了一种连续时间算法来解决权重不平衡图上的聚合游戏的NE寻找问题。</p>
<p>[17]：通过结合(子)梯度下降和推和共识协议开发了分布式(子)梯度推算法，其中双随机矩阵的要求可被推广到列随机矩阵。</p>
<p>[18]：为了不需要提前知道列-随机矩阵的出度，这篇文章仅使用行-随机矩阵，通过估计行-随机矩阵的左Perron特征向量来求解具有不平衡有向图的分布无约束优化问题。</p>
<p>[19],
[20]：通过估计行随机矩阵的左Perron特征向量，研究有向图的分布式约束优化问题。</p>
<ul>
<li>所以本文受到上述文章中处理不平衡有向图的方法启发，分别运用行随机矩阵（algorithm
1）和列随机矩阵（algorithm
2）来研究不平衡有向图上（两种算法分别对应fixed digraph和time-varying
digraph）的聚合游戏。</li>
<li>具体来说，通过估计与拓扑相关的行随机矩阵的左特征向量，成功消除了这种拓扑相关行随机矩阵对所有玩家聚合行为估计的不平衡影响。此外，针对时变有向图下的聚集博弈，提出了一种基于推和协议的分布式算法来寻找NE。而且由于玩家的动作受到设定的约束，因此采用投影梯度法根据聚集的局部估计更新玩家的动作。</li>
<li>另一方面，考虑到步长恒定的投影梯度法只能在存在集合约束的情况下使玩家的动作收敛到NE的一个邻域，所以本文采用步长递减的方法来保证收敛到准确的NE，并且允许参与者采用不协调的步长。</li>
<li>然而，步长递减也带来了另一个挑战，即收敛速度慢。受到[21]中重球法的启发下，本文在玩家行为更新规律中引入动量项，以加快算法的收敛速度。证明了所提出的步长递减离散NE搜索算法能够保证收敛到精确NE。</li>
<li>此外，还分析了在步长递减时所提出的NE搜索算法的收敛速度。最后，将所提出的算法应用于有向图上的插电式混合动力汽车系统能耗博弈的求解，数值结果表明，动量项加速了算法的收敛速度。</li>
</ul>
<blockquote>
<p>看了上面的introduction，个人感觉其实就是说：</p>
<p>不平衡有向图上的聚合问题没人解决，因为玩家之间通信结构不平衡。</p>
<p>然后本文用[18] ~
[20]“估计行随机矩阵左特征向量”的方法解决上面这个难点。</p>
<p>另外，本文还讨论了时变有向图下的聚集博弈，用的是[17]的方法，但是在他基础上把步长固定改为步长递减从而使NE收敛更精确。另外还加了一个[21]里的重球法中的动量项来加快收敛速度。</p>
</blockquote>
<h4 id="大致目录-基础公式">1-2: 大致目录 &amp; 基础公式</h4>
<p>Section 2：图论的基础结论、问题建模、算法引入</p>
<p>Section 3、4：算法的收敛性证明</p>
<p>Section 5：验证算法在插电式混合动力汽车能耗控制的正确性</p>
<ul>
<li><span class="math inline">\(\mathbb{R,
N_+}\)</span>：分别是实数集和正整数集</li>
<li><span class="math inline">\(e_i ∈ \mathbb{R^n}\)</span>
：n维列向量，其中第i项为1，其余项为0</li>
<li><span class="math inline">\(1_n ∈ \mathbb{R^n}\)</span>
：n维列向量，每一项都是1</li>
<li><span class="math inline">\(I_n\)</span>：n维单位矩阵</li>
<li><span class="math inline">\(\|\cdot\|\)</span>：欧几里得范式</li>
<li><span class="math inline">\(\|x\|_H, H \in \mathbb{R^{n \times
n}}\)</span>：加权范数（weighed norm）（结果为一个常数），定义为：<span
class="math inline">\(\|x\|_H = \sqrt{x^THx}\)</span></li>
<li><span class="math inline">\(\Omega \in
\mathbb{R^n}\)</span>：n维的非空闭凸集，里面每个元素都是n维列向量</li>
<li><span class="math inline">\(P_{\Omega}[x]\)</span>: x(<span
class="math inline">\(\Omega\)</span>外一点)在<span
class="math inline">\(\Omega\)</span>上的投影点(结果为一个n维列向量),
定义为: <span class="math inline">\(P_{\Omega}[x] = argmin_{y \in
\Omega}\|x - y\| = y^*, y^* \in \Omega\)</span>
<ul>
<li>具有非扩张性，即：<span
class="math inline">\(\|P_{\Omega}[x]-P_{\Omega}[z]\| \le
\|x-z\|\)</span></li>
</ul></li>
<li><span
class="math inline">\([x]_i\)</span>：x这个n维向量中的第i项</li>
<li><span
class="math inline">\(H_{ij}\)</span>：矩阵H的i行j列那个元素</li>
</ul>
<hr />
<h3 id="section-2-preliminary-knowledge">Section 2: Preliminary
knowledge</h3>
<h4 id="图理论">2-1: 图理论</h4>
<p><span class="math inline">\(\mathcal{N}=\{1, 2, ...,
N\}\)</span>：玩家集合</p>
<p><span class="math inline">\(\varepsilon(k) \subseteq \{(i, j), i, j
\in \mathcal{N}\}\)</span>：时刻为k时的边集 <span
class="math inline">\((i, j) \in \varepsilon(k)\)</span> means that
player i can receive information from player j at time j.</p>
<p><span class="math inline">\(\mathcal{G}(k) = \{\mathcal{N},
\varepsilon(k)\}\)</span>：时刻为k时的图</p>
<p><span class="math inline">\(N^{in}_{i}(k) = \{i\} \cup \{j | (j, i)
\in \varepsilon(k)\}\)</span>：时刻为k时，点i的入点集合</p>
<p><span class="math inline">\(N^{out}_{i}(k) = \{i\} \cup \{j | (i, j)
\in \varepsilon(k)\}\)</span>：时刻为k时，点i的出点集合</p>
<p><span
class="math inline">\(d_i^k=|N^{out}_{i}(k)|\)</span>：时刻为k时，点i的出度</p>
<p>strongly connected fixed digraph：强连通有向图。即任意俩点可通</p>
<p>For the time-varying digraph <span
class="math inline">\(\mathcal{G}(k), \{\mathcal{G}(k)\}\)</span> is
said to be B-strongly connected if there exists a <span
class="math inline">\(B \in \mathbb{N_+}\)</span> such that the union
digraph <span
class="math inline">\(\cup_{t=kB}^{(k+1)B}\mathcal{G}(t)\)</span> is
strongly connected for any <span class="math inline">\(k \in
\mathbb{N_+}\)</span>
换句话说，如果一定时间段内的所有时变图的并（边并起来，边权不相加）为强连通，则这些时变图的集合是B-连通的。</p>
<p>后面依次类推。</p>
<h4 id="问题建模">2-2: 问题建模</h4>
<p>每个玩家的动作集合定义为<span
class="math inline">\(\Omega_i\)</span>，动作定义为<span
class="math inline">\(x_i\)</span>。每个玩家的花费函数定义为<span
class="math inline">\(J_i(x), x = [x_1, x_2, ...,
x_n]^T\)</span>，通过这个表达式可以看出来，每个玩家的花费函数跟所有玩家的动作相关。</p>
<p><span class="math inline">\(J_i(x)\)</span>还有几种等价的定义：</p>
<p>定义1：<span class="math display">\[J_i(x) = f_i(x_i, \sigma(x)), \\
\sigma(x)=\sum_{j=1}^{N}\phi_{j}(x_j) \qquad (1)\]</span></p>
<p>定义2：<span class="math inline">\(J_i(x)=J_i(x_i, x_{-i}),
x_{-i}=[x_1, ..., x_{i-1}, x_{i+1}, ..., x_n]\)</span></p>
<p>要解决的问题是最小化每一个玩家的花费函数，即：</p>
<p><span class="math inline">\(min \, f_i(x_i, \sigma(x)), \forall{i}
\in \mathcal{N} \qquad (2)\)</span></p>
<p>实际上就是求一个纳什均衡问题，因为纳什均衡就是任何一个玩家改变它的动作都不能使得它的花费函数更小。如果纳什均衡的观点表达上面的式子，就是：</p>
<p>假如<span class="math inline">\(x^*\)</span>是NE，当且仅当<span
class="math inline">\(J_i(x_i^*, x_{-i}^*) \le J_i(x_i, x_{-i}^*),
\forall{x_i} \in \Omega_i, \forall{i} \in \mathcal{N}\)</span></p>
<blockquote>
<p>Note that the players in the considered game have no knowledge of the
aggregation <span class="math inline">\(\sigma(x)\)</span> due to the
privacy of <span class="math inline">\(\phi_j(x_j), j \in
\mathcal{N}\)</span>。</p>
<p>也就是说，<span
class="math inline">\(\phi_i(x_i)\)</span>函数是每个人特有的，只有自己知道，别人不知道。但是可以通过有向图与邻居交换信息。</p>
</blockquote>
<p>下面是论文的几个假设，论文解决的问题都是基于这几个假设作为前提的。</p>
<h5 id="assumption-1">Assumption 1</h5>
<ul>
<li>论文讨论的图不是一般有向图，而是两类。分别是固定有向图（fixed
digraph）和时变有向图（time-varying digraph）。</li>
<li>而且fixed digraph一定满足强连通，time-varying
digraph一定满足B-强连通。</li>
</ul>
<h5 id="assumption-2">Assumption 2</h5>
<ul>
<li><p>对于所有玩家的动作集合<span
class="math inline">\(\Omega_{i}\)</span>，都是非空、紧致、凸的。</p></li>
<li><p>定义<span class="math inline">\(\Omega_{-i}=\Omega_{1} \times
\Omega_{2} \times ... \times \Omega_{i-1} \times \Omega_{i+1} \times ...
\times \Omega_{N}\)</span>。More over, for given <span
class="math inline">\(x_{-i} \in \Omega_{-i}, J_i(x_i, x_{-i})\)</span>
is convex about <span class="math inline">\(x_i\)</span> on <span
class="math inline">\(\Omega_{i}\)</span></p></li>
<li><p><span class="math inline">\(J_i(x_i, x_{-i})\)</span>对<span
class="math inline">\(x\)</span>连续可微，<span
class="math inline">\(\phi_i(x_i)\)</span>对<span
class="math inline">\(x_i\)</span>连续可微。</p>
<ul>
<li>定义<span class="math inline">\(\nabla_z{f(z,
y)}\)</span>为对z求一阶偏导</li>
<li>按照此定义，将<span class="math inline">\(J_i(x_i,
x_{-i})\)</span>对<span
class="math inline">\(x_i\)</span>求导，将得到<span
class="math inline">\(\nabla_{x_i}J_i(x_i, x_{-i}) =\nabla_{x_i}f_i(x_i,
\sigma(x)) + \nabla_{\sigma}f_i(x_i, \sigma(x)) \,
\nabla_{x_i}\phi_i(x_i)\)</span>。这里实际上是有点歧义的，作者想表达的意思就是关注玩家i的动作对其花费函数的影响。</li>
<li>定义<span class="math inline">\(\Gamma(x)=[\nabla_{x_1}J_1(x_1,
x_{-1}), ..., \nabla_{x_N}J_N(x_N,
x_{-N})]^T\)</span>，即每个玩家花费函数对自身动作求导组成的一个列向量</li>
<li>定义<span class="math inline">\(G_i(x_i, \tilde{\sigma_i}) =
\nabla_{x_i}f_i(x_i, \sigma(x))|_{\sigma(x)=\tilde{\sigma_i}} +
\nabla_{\sigma}f_i(x_i, \sigma(x)) \,
\nabla_{x_i}\phi_i(x_i)|_{\sigma(x)=\tilde{\sigma_i}}\)</span>。不是把每个花费函数对动作求导嘛，这里就是把求导结果里的<span
class="math inline">\(\sigma(x)\)</span>赋值为<span
class="math inline">\(\tilde{\sigma_i}\)</span>了。</li>
</ul></li>
</ul>
<h5 id="assumption-3">Assumption 3</h5>
<ul>
<li><span
class="math inline">\(\Gamma(x)\)</span>满足下列俩条件之一：</li>
<li><span class="math inline">\(\Gamma(x)\)</span>在<span
class="math inline">\(\Omega\)</span>上是严格单调的，也就是说，<span
class="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,
\forall{x, x&#39;} \in \Omega, x \ne x&#39;\)</span></li>
<li><span class="math inline">\(\Gamma(x)\)</span>在<span
class="math inline">\(\Omega\)</span>上是强单调的，也就是说，存在一个常数<span
class="math inline">\(\mu &gt; 0\)</span>使得<span
class="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) \ge
\mu\|x-x&#39;\|^2, \forall{x, x&#39;} \in \Omega, x \ne
x&#39;\)</span></li>
</ul>
<h5 id="assumption-4">Assumption 4</h5>
<ul>
<li><p>The mapping <span class="math inline">\(G_i(x_i, \sigma) is
L_1-Lipschitz\)</span> continuous with repect to <span
class="math inline">\(\sigma \in \mathbb{R}\)</span> and <span
class="math inline">\(\phi_i(x_i)\)</span> is <span
class="math inline">\(L_2-Lipschitz\)</span> continuous with repect to
<span class="math inline">\(x_i \in \Omega_i\)</span> for all <span
class="math inline">\(i \in \mathcal{N}\)</span>, i.e.,</p></li>
<li><p>(<span class="math inline">\(L_1, L_2\)</span> are two positive
constants) <span class="math display">\[
\begin{aligned}\|G_i(x_i,\sigma_1)-G_i(x_i,\sigma_2)\|_2&amp;\le
L_1\left\|\sigma_1-\sigma_2\right\|,&amp;\forall\sigma_1,\sigma_2\in\mathbb{R},\\\|\phi_i(z_1)-\phi_i(z_2)\|&amp;\le
L_2\left\|z_1-z_2\right\|,&amp;\forall z_1,z_2\in\Omega_i,\end{aligned}
\]</span></p></li>
</ul>
<h4 id="算法引入">2-3: 算法引入</h4>
<h5
id="algorithm-1-ne-seeking-with-row-stochastic-adjacency-matrix">Algorithm
1 NE Seeking With Row-Stochastic Adjacency Matrix</h5>
<ul>
<li>Initialization: <span class="math inline">\(x_i^0=x_i^1 \in
\Omega_i, v_i^1=e_i, \tilde\sigma_i^1=\phi_i(x_i^1)\)</span></li>
<li>for <span class="math inline">\(k \in \mathbb{N}_+\)</span> do
<ul>
<li>for each player <span class="math inline">\(i \in
\mathcal{N}\)</span> do
<ul>
<li><span class="math inline">\(x_i^{k+1}=P_{\Omega_i}[x_i^k -
\alpha_i^kG_i(x_i^k, \tilde\sigma_i^k) + \lambda_i(x_i^k-x_i^{k-1})]
\qquad (3a)\)</span></li>
<li><span class="math inline">\(v_i^{k+1}=\sum_{j=1}^Na_{ij}v_j^k \qquad
(3b)\)</span></li>
<li><span
class="math inline">\(\tilde{\sigma}_{i}^{k+1}=\sum_{j=1}^{N}a_{ij}\tilde{\sigma}_{j}^{k}+\frac{\phi_{i}\left(x_{i}^{k+1}\right)}{\left[v_{i}^{k+1}\right]_{i}}-\frac{\phi_{i}\left(x_{i}^{k}\right)}{\left[v_{i}^{k}\right]_{i}}
\qquad (3c)\)</span></li>
</ul></li>
<li>end for</li>
</ul></li>
<li>end for</li>
</ul>
<p>行随机邻接矩阵记为<span
class="math inline">\(A=[a_{ij}]\)</span>，其中<span
class="math inline">\(a_{ii}&gt;0\)</span>，且若<span
class="math inline">\((j, i) \in \varepsilon\)</span>则<span
class="math inline">\(a_{ij}&gt;0\)</span>, 否则<span
class="math inline">\(a_{ij}=0\)</span>。另外，行随机矩阵的特征就是每一行元素和为1。</p>
<p><span
class="math inline">\(x_i^k\)</span>表示第i个玩家在时刻k的动作</p>
<p><span class="math inline">\(v_i^k \in
\mathbb{R}^N\)</span>用来estimate the left eigenvector <span
class="math inline">\(v\)</span> associated with eigenvalue <span
class="math inline">\(1\)</span> of the matrix A.</p>
<p><span class="math inline">\(\tilde\sigma_i^k\)</span> be the player
i's estimate on the aggregation <span
class="math inline">\(\sigma(x_k)\)</span> at iteration <span
class="math inline">\(k\)</span>, <span
class="math inline">\(x_k=[x_1^k, ..., x_N^k]^T\)</span></p>
<p><span
class="math inline">\(\alpha_i^k\)</span>表示步长，它遵循下面三个限制：</p>
<ol type="1">
<li>每个玩家在任意时刻的步长都是大于0的，且对于每个玩家，其<span
class="math inline">\(\{\alpha_i^k\}\)</span>单调不增加</li>
<li><span
class="math inline">\(\sum_{k=1}^{\infty}\alpha_{i}^{k}=\infty,\sum_{k=1}^{\infty}(\alpha_{i}^{k})^{2}&lt;\infty\)</span></li>
<li><span
class="math inline">\(\sum\limits_{k=1}^{\infty}(\overline{\alpha}_{k}-\underline{\alpha}_{k})&lt;\infty,\text{
where
}\overline{\alpha}_{k}=\max\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\text{
and
}\underline{\alpha}_{k}=\min\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}.\)</span></li>
</ol>
<p>在algorithm 1中，玩家使用非精确梯度<span
class="math inline">\(G_i(x_i^k,
\tilde\sigma_i^k)\)</span>来更新自身动作。为了消除不精确梯度带来的误差，引入递减的步长而不是固定的步长，从而保证精确收敛到NE。另外，动量项<span
class="math inline">\(\lambda_i(x_i^k-x_i^{k-1})]\)</span>可以加速算法的收敛，<span
class="math inline">\(0&lt;\lambda_i&lt;1\)</span>是动量参数。以上就是对于(3a)的解释。</p>
<p>在(3c)中的第二项和第三项，其存在的目的是为了解决矩阵<span
class="math inline">\(A\)</span>可能不是列随机的问题。</p>
<p>可以看出，(3b)和(3c)都用到了<span
class="math inline">\(a_{ij}\)</span>，所以algorithm 1只适用于fixed
digraph。</p>
<h5
id="algorithm-2-ne-seeking-with-column-stochastic-adjacency-matrix">Algorithm
2 NE Seeking With Column-Stochastic Adjacency Matrix</h5>
<p>这个算法是针对time-varying
digraph的。在算法2中，每个玩家需要知道自己在每次交流中的出度，因为不同时刻每个点的出度会变化。</p>
<ul>
<li>Initialization: <span
class="math inline">\(x_{i}^{0}=x_{i}^{1}\in\Omega_{i},y_{i}^{1}=1,\tilde{\sigma}_{i}^{1}=\phi_{i}(x_{i}^{1})\)</span></li>
<li>for <span class="math inline">\(k \in \mathbb{N}_+\)</span> do
<ul>
<li>for each player <span class="math inline">\(i \in
\mathcal{N}\)</span> do
<ul>
<li><span class="math inline">\(w_i^{k+1}=\sum_{j\in
N_i^{in}(k)}\frac{\tilde{\sigma}_j^k}{d_j^k} \qquad (4a)\)</span></li>
<li><span class="math inline">\(y_i^{k+1}=\sum_{j\in
N_i^{in}(k)}\frac{y_j^k}{d_j^k} \qquad (4b)\)</span></li>
<li><span class="math inline">\(z_i^{k+1}=\frac{w_i^{k+1}}{y_i^{k+1}}
\qquad (4c)\)</span></li>
<li><span
class="math inline">\(x_i^{k+1}=P_{\Omega_i}\left[x_i^k-\alpha_i^kG_i(x_i^k,Nz_i^{k+1})+\lambda_i(x_i^k-x_i^{k-1})\right]
\qquad (4d)\)</span></li>
<li><span
class="math inline">\(\tilde{\sigma}_i^{k+1}=w_i^{k+1}+\phi_i\left(x_i^{k+1}\right)-\phi_i\left(x_i^k\right)
\qquad (4e)\)</span></li>
</ul></li>
<li>end for</li>
</ul></li>
<li>end for</li>
</ul>
<p>可以发现，这里求<span
class="math inline">\(x_i^{k+1}\)</span>第二项<span
class="math inline">\(G_i\)</span>中并没用<span
class="math inline">\(\tilde\sigma_i^k\)</span>，而是用的<span
class="math inline">\(Nz_i^{k+1}\)</span>。z是w跟y的比值，w与y又与点的入点和(入点的出度)有关。</p>
<blockquote>
<p>Note: 在algorithm 1中，若把"若<span class="math inline">\((j, i) \in
\varepsilon\)</span>则<span
class="math inline">\(a_{ij}&gt;0\)</span>"改为“若<span
class="math inline">\((j, i) \in \varepsilon\)</span>则<span
class="math inline">\(a_{ij}=\frac{1}{d_j^k}\)</span>”，则(3c)与(4e)等价</p>
</blockquote>
<hr />
<h3 id="section-3-convergence-analysis-of-algorithm-1">Section 3:
Convergence analysis of algorithm 1</h3>
<h4 id="theorem-1">3-1: Theorem 1</h4>
<p>条件：</p>
<ol type="1">
<li><p>采用固定有向图结构</p></li>
<li><p><span class="math inline">\(\nabla_{x_i}J_i(x_i, x_{-i})
=\nabla_{x_i}f_i(x_i, \sigma(x)) + \nabla_{\sigma}f_i(x_i, \sigma(x)) \,
\nabla_{x_i}\phi_i(x_i)\)</span></p>
<p><span class="math inline">\(\Gamma(x)=[\nabla_{x_1}J_1(x_1, x_{-1}),
..., \nabla_{x_N}J_N(x_N, x_{-N})]^T\)</span></p>
<p><span class="math inline">\(G_i(x_i, \tilde{\sigma_i}) =
\nabla_{x_i}f_i(x_i, \sigma(x))|_{\sigma(x)=\tilde{\sigma_i}} +
\nabla_{\sigma}f_i(x_i, \sigma(x)) \,
\nabla_{x_i}\phi_i(x_i)|_{\sigma(x)=\tilde{\sigma_i}}\)</span></p></li>
<li><p><span
class="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,
\forall{x, x&#39;} \in \Omega, x \ne x&#39;\)</span></p></li>
<li><p><span class="math display">\[
\begin{aligned}\|G_i(x_i,\sigma_1)-G_i(x_i,\sigma_2)\|_2&amp;\le
L_1\left\|\sigma_1-\sigma_2\right\|,&amp;\forall\sigma_1,\sigma_2\in\mathbb{R},\\\|\phi_i(z_1)-\phi_i(z_2)\|&amp;\le
L_2\left\|z_1-z_2\right\|,&amp;\forall z_1,z_2\in\Omega_i,\end{aligned}
\]</span></p></li>
<li><p>对于<span
class="math inline">\(\alpha\)</span>步长，满足下面三条性质(C1-C3)</p>
<ol type="1">
<li><span
class="math inline">\(\{\alpha_i^k\}\)</span>不严格递减，且<span
class="math inline">\(\alpha_i^k&gt;0\)</span></li>
<li><span
class="math inline">\(\sum_{k=1}^{\infty}\alpha_{i}^{k}=\infty,\sum_{k=1}^{\infty}(\alpha_{i}^{k})^{2}&lt;\infty\)</span></li>
<li><span
class="math inline">\(\sum\limits_{k=1}^{\infty}(\overline{\alpha}_{k}-\underline{\alpha}_{k})&lt;\infty,\text{
where
}\overline{\alpha}_{k}=\max\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\text{
and
}\underline{\alpha}_{k}=\min\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}.\)</span></li>
</ol></li>
<li><p><span
class="math inline">\(\begin{matrix}0&amp;&lt;&amp;\lambda_i&amp;&lt;&amp;\frac{\sqrt{2}}{2}\end{matrix}\)</span></p></li>
</ol>
<p>结论：all players' actions converge to the unique NE <span
class="math inline">\(x^*\)</span> under algorithm 1.</p>
<h4 id="preliminary-analysis-about-algorithm-1">3-2: Preliminary
analysis about algorithm 1</h4>
<p>先来求一下algorithm 1里的<span
class="math inline">\(v_i^k\)</span></p>
<p>定义：<span
class="math inline">\(\left.V_{k}=\left[\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\ldots,v_{N}^{k}}\end{array}\right.\right]^{T}\)</span></p>
<p>所以<span class="math inline">\(v_i^{k+1}=\sum_{j=1}^Na_{ij}v_j^k
\qquad (3b)\)</span>等价于<span
class="math inline">\(V_{k+1}=AV_{k}\qquad (5)\)</span></p>
<p>因为<span class="math inline">\(V_1 = [v_1, v_2, ..., v_N]^T =
I_N\)</span>，即<span class="math inline">\(v_i =
e_i\)</span>（条件）</p>
<p>所以<span
class="math inline">\(\lim_{k\to\infty}V_k=\operatorname*{lim}_{k\to\infty}A^{k-1}V_1=\operatorname*{lim}_{k\to\infty}A^{k}\)</span></p>
<p>因为A是行随机矩阵，所以显然<span
class="math inline">\(1_n\)</span>是特征值为1时的一个特征向量。</p>
<p>所以得出<span
class="math inline">\(\operatorname*{lim}_{k\to\infty}A^{k}=1_Nv^T\)</span>
（根据Perron-Frobenius定理）, where <span
class="math inline">\(v\)</span> 是A关于特征值1的左特征向量且<span
class="math inline">\(v\)</span>每一项大于0，且<span
class="math inline">\(v^T1_N=1\)</span>。</p>
<p>所以<span
class="math inline">\(\lim_{k\to\infty}\left.V_{k}=\left[\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\ldots,v_{N}^{k}}\end{array}\right.\right]^{T}
= 1_Nv^T\)</span>。又<span class="math inline">\(1_Nv^T=[v, v, ...,
v]^T\)</span>。</p>
<p>也就是说，当k趋近于无穷大时，每个玩家的<span
class="math inline">\(v_i\)</span>都收敛于<span
class="math inline">\(v\)</span>。</p>
<p>再来求一下algorithm 1里的<span
class="math inline">\(\tilde{\sigma}_{i}^{k}\)</span></p>
<p>首先<span
class="math inline">\(V_k\)</span>对角线上的元素都是正的，通过<span
class="math inline">\(V_{k+1}=AV_{k}\)</span>可看出。首先<span
class="math inline">\(V_1\)</span>是单位阵肯定对角线为正，然后A的对角线元素都是正的（这是algorithm
1引入时提到的条件）。所以他俩乘出来的对角线也是正的。不断递推，对角线上都是正的。</p>
<p>所以现在我定义一个<span
class="math inline">\(\left.\hat{V}_k=\operatorname{diag}\left(\begin{bmatrix}v_1^k\end{bmatrix}\right._1,\begin{bmatrix}v_2^k\end{bmatrix}_2,\ldots,\begin{bmatrix}v_N^k\end{bmatrix}_N\right)\)</span></p>
<p>上面这个<span
class="math inline">\(\hat{V}_k\)</span>其实就是取了<span
class="math inline">\(V_k\)</span>的对角线，其余地方都是0。</p>
<p>因为前面说了对角线都是正的嘛，所以<span
class="math inline">\(\hat{V_k}\)</span>是满秩可逆的。而且我们知道最终<span
class="math inline">\(V_k\)</span>是收敛的，所以<span
class="math inline">\(\hat{V_k}\)</span>最终也是收敛的。</p>
<p>最后我再定义<span
class="math inline">\(\tilde{\sigma}_{k}=\left[\tilde{\sigma}_{1}^{k},\tilde{\sigma}_{2}^{k},\ldots,\tilde{\sigma}_{N}^{k}\right]^{T}\)</span>和<span
class="math inline">\(\phi_k =
\left[\phi_{1}(x_{1}^{k}),\phi_{2}(x_{2}^{k}),\ldots,\phi_{N}(x_{N}^{k})\right]^{T}\)</span></p>
<p>则<span
class="math inline">\(\tilde{\sigma}_{i}^{k+1}=\sum_{j=1}^{N}a_{ij}\tilde{\sigma}_{j}^{k}+\frac{\phi_{i}\left(x_{i}^{k+1}\right)}{\left[v_{i}^{k+1}\right]_{i}}-\frac{\phi_{i}\left(x_{i}^{k}\right)}{\left[v_{i}^{k}\right]_{i}}
\qquad (3c)\)</span>可改写为：</p>
<p><span
class="math inline">\(\tilde{\sigma}_{k+1}=A\tilde{\sigma}_k+\hat{V}_{k+1}^{-1}\Phi_{k+1}-\hat{V}_k^{-1}\Phi_k
\qquad (6)\)</span></p>
<h4 id="lemmas">3-3: Lemmas</h4>
<p>为了接下来的叙述方便，定义<span
class="math inline">\(V_{\infty}=\lim\limits_{k\to\infty}V_{k}=1_{N}v^{T}\)</span>和<span
class="math inline">\(\hat{V}_{\infty}=\operatorname{diag}([v]_1,\ldots,[v]_N)\)</span></p>
<h5 id="lemma-1">Lemma 1</h5>
<p>因为<span
class="math inline">\(\hat{V}_{k}\)</span>是收敛的，所以会有<span
class="math inline">\(\|\hat{V}_{k}^{-1}\|\leq \varrho, \varrho &gt;
0\)</span></p>
<blockquote>
<p>矩阵的二范式从几何意义上来说就是单位圆在经过矩阵变换后离原点最远的距离。假设要求<span
class="math inline">\(\|A\|\)</span>，则先求<span
class="math inline">\(A^TA\)</span>，然后再求<span
class="math inline">\(A^TA\)</span>的特征值，取最大的特征值开方就是矩阵A的二范数</p>
</blockquote>
<p>引理1：<span
class="math inline">\(\|\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1}\|\leq\varrho^{2}\gamma\theta^{k},
k \in \mathbb{N_+}, \gamma &gt; 0, 0 &lt; \theta &lt; 1, \varrho &gt;
0\)</span></p>
<p>证明：</p>
<p>因为<span class="math inline">\((\hat{V_k}^{-1})(\hat{V_k} -
\hat{V}_\infty)(\hat{V}_\infty^{-1}) =
(\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1})\)</span></p>
<p>两边取范数，得：<span
class="math inline">\(\|\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1}\| =
\|(\hat{V_k}^{-1})(\hat{V_k} - \hat{V}_\infty)(\hat{V}_\infty^{-1})\|
\le \|\hat{V_k}^{-1}\|\|\hat{V_k} -
\hat{V}_\infty\|\|\hat{V}_\infty^{-1}\|\)</span></p>
<p>定义<span class="math inline">\(\varrho =
{sup}_{k}\left\|\widetilde{V}_{k}^{-1}\right\|_{2}\)</span>，则<span
class="math inline">\(\|\hat{V_k}^{-1}\|\|\hat{V}_\infty^{-1}\| \le
\varrho^2\)</span></p>
<p>又<span class="math inline">\(\|\hat{V}_k - \hat{V}_\infty\| \le
\gamma\theta^{k}\)</span>, [17]。</p>
<p>所以<span
class="math inline">\(\|\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1}\| \le
\varrho^{2}\gamma\theta^{k}\)</span>，得证。</p>
<h5 id="lemma-2">Lemma 2</h5>
<p>引理2：<span
class="math inline">\(V_{\infty}\tilde{\sigma}_{k}=V_{\infty}\hat{V}_{k}^{-1}\Phi_{k},
k \in \mathbb{N_+}\)</span></p>
<p>证明如下：</p>
<p><img src="1.png" /></p>
<h5 id="lemma-3">Lemma 3</h5>
<p>先来点前置知识</p>
<p>因为<span
class="math inline">\(\operatorname*{lim}_{k\to\infty}\left(A-1_{N}v^{T}\right)^{k}=\operatorname*{lim}_{k\to\infty}A^{k}-1_{N}v^{T}=0\)</span>（这个极限推导可以先放着不管），所以根据谱半径的知识，可以知道<span
class="math inline">\(\rho(A-1_Nv^T)~&lt;~1\)</span></p>
<p>又因为<span class="math inline">\(\rho(A-1_Nv^T) \le \|A -
1_Nv^T\|\)</span></p>
<p>所以必然存在一个矩阵范数<span
class="math inline">\(\|\cdot\|_\epsilon\)</span>，使得<span
class="math inline">\(\rho(A-1_{N}v^{T})\leq\|A-1_{N}v^{T}\|_{\epsilon}\leq
\rho(A-1_{N}v^{T})+\epsilon&lt;1\)</span></p>
<p>另外，又因为所有的矩阵范式都是等价的，所以有：</p>
<p><span class="math inline">\(\|\cdot\|_{\epsilon}\leq
c\|\cdot\|\)</span> and <span class="math inline">\(\|\cdot\|\leq
d\|\cdot\|_{\epsilon}\)</span></p>
<p>接下来再定义两个东西</p>
<p><span class="math inline">\(\rho_1=\left\|A-1_Nv^T\right\|_\epsilon,
\rho_1 &lt; 1 \qquad (7)\)</span></p>
<p><span class="math inline">\(\rho_2=\left\|I_N-1_Nv^T\right\| \qquad
(8)\)</span></p>
<p>引理3：Under Assumption 1(a), 2 and 4, <span
class="math inline">\(\|\tilde{\sigma}_i^k-v^T\tilde{\sigma}_k\|\)</span>
is bounded, i.e., there exists a constant <span
class="math inline">\(\hat{C} &gt; 0\)</span> such that <span
class="math inline">\(\|\tilde{\sigma}_{i}^{k}-v^{T}\tilde{\sigma}_{k}\|\leq\hat{C}\)</span></p>
<p>证明如下：</p>
<p><img src="5.png" /></p>
<p><img src="6.png" /></p>
<h5 id="lemma-4">Lemma 4</h5>
<p>引理4：<span
class="math inline">\(\|G_i\left(x_i^k,\sigma(x_k)\right)\|\le M,
\|G_i(x_i^k, \tilde{\sigma}_i^k) \| \le M, M &gt; 0\)</span></p>
<p>证明如下：</p>
<p><img src="2.png" /></p>
<h5 id="lemma-5">Lemma 5</h5>
<p>定义<span
class="math inline">\(\overline{\lambda}=\max_{j\in\mathcal{N}}\{\lambda_j\}\)</span>，若<span
class="math inline">\(0&lt;\overline{\lambda}&lt;\frac{\sqrt{2}}2\)</span>，则下面三条性质将会满足：</p>
<ol type="a">
<li><p><span
class="math inline">\(\left\|x_{i}^{k+1}-x_{i}^{k}\right\|\leq
M\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s},\forall
k\in\mathbb{N}_{+}\)</span></p></li>
<li><p><span
class="math inline">\(\lim\limits_{k\to\infty}\left\|x_{i}^{k+1}-x_{i}^{k}\right\|=0\)</span></p></li>
<li><p><span
class="math inline">\(\sum_{k=1}^{\infty}\|x_{i}^{k+1}-x_{i}^{k}\|^{2}&lt;\infty\)</span></p></li>
</ol>
<p>where <span class="math inline">\(M\)</span> is given in Lemma 4, and
<span
class="math inline">\(\overline{\alpha}_{k}=\max_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\)</span></p>
<p>证明如下：</p>
<p><img src="3.png" /></p>
<p><img src="4.png" /></p>
<p>补充：因为所有动作<span
class="math inline">\(x_i^k\)</span>都属于compact的<span
class="math inline">\(\Omega_i\)</span>，所以<span
class="math inline">\(\{x_k\}\)</span>是有界的，又由Lemma
5(b)和柯西收敛准测可容易推出<span
class="math inline">\(\{x_k\}​\)</span>是收敛的。</p>
<h5 id="lemma-6">Lemma 6</h5>
<ol type="a">
<li><p>For any <span class="math inline">\(k \geq 2\)</span>, one has
<span
class="math display">\[\left\|\tilde{\sigma}_{k}-V_{\infty}\tilde{\sigma}_{k}\right\|\leq
dc\rho_{1}^{k-1}\left\|\tilde{\sigma}_{1}-1_{N}v^{T}\tilde{\sigma}_{1}\right\|
+
D_1\sum_{l=1}^{k-1}\rho_1^{k-l-1}\beta_l+D_2\sum_{l=1}^{k-1}\rho_1^{k-l-1}\theta^l
\qquad (9)\]</span>where <span
class="math inline">\(D_{1}=dc\rho_{2}\varrho
L_{2}\sqrt{N}M,D_{2}=2dc\rho_{2}C\varrho^{2}\gamma,
\beta_l=\sum_{s=1}^{l}\overline{\lambda}^{l-s}\overline{\alpha}_{s}\)</span>and<span
class="math inline">\(0&lt;\theta&lt;1\)</span> is given in Lemma
1.</p></li>
<li><p>For step-size sequence <span
class="math inline">\(\{\alpha_i^k\}\)</span> satisfying conditions
C1-C3, one has <span
class="math inline">\(\sum_{k=1}^{\infty}\overline{\alpha}_{k}\left\|\tilde{\sigma}_{k}-V_{\infty}\tilde{\sigma}_{k}\right\|&lt;\infty\)</span></p></li>
</ol>
<p>证明如下：</p>
<p><img src="7.png" /></p>
<p><img src="8.png" /></p>
<h4 id="proof-of-theorem-1">3-4: Proof of theorem 1</h4>
<p><img src="9.png" /></p>
<p><img src="10.png" /></p>
<p><img src="11.png" /></p>
<p><img src="12.png" /></p>
<p><img src="13.png" /></p>
<p><img src="14.png" /></p>
<p><img src="15.png" /></p>
<p><img src="16.png" /></p>
<h4 id="theorem-2">3-5: Theorem 2</h4>
<p>在满足Assumption 1(a), 2, 3(b) and 4的前提下。令<span
class="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}=\alpha_{k}\)</span>。且<span
class="math inline">\(0&lt;\lambda_i&lt;\frac{\sqrt{2}}{2}\)</span>，则<span
class="math inline">\(\{q_t\}\)</span>收敛到0的速率为<span
class="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span>。 <span
class="math display">\[
q_t=\frac{\sum\limits_{k=1}^t\alpha_k\|x_k-x^*\|^2}{\sum\limits_{k=1}^t\alpha_k}
\]</span> 证明：暂略</p>
<h4 id="convergence-rate-analysis-of-algorithm-1">3-6: Convergence rate
analysis of algorithm 1</h4>
<p>如果<span
class="math inline">\(\Gamma(x)\)</span>是强单调，且步长满足<span
class="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}\)</span>。则可以分析algorithm
1的收敛速率。</p>
<p>结论就是<span class="math inline">\(x_k\)</span>收敛到<span
class="math inline">\(x^*\)</span>的速率与<span
class="math inline">\(q_t\)</span>收敛到0的速率相同。证明如下：</p>
<p><img src="17.png" /></p>
<hr />
<h3 id="section-4-convergence-analysis-of-algorithm-2">Section 4:
Convergence analysis of algorithm 2</h3>
<p>对于之前的algorithm 2中的公式(4a) - (4c)，用矩阵表示如下： <span
class="math display">\[
\begin{aligned}
&amp;w_{k+1} =A\left(k\right)\tilde{\sigma}_{k},  \\
&amp;y_{k+1} =A\left(k\right)y_{k},  \\
&amp;z_{i}^{k+1} =\frac{w_{i}^{k+1}}{y_{i}^{k+1}},\quad i=1,\ldots,N,
&amp; (24)
\end{aligned}
\]</span> (4e)则可以表达为以下形式：</p>
<p><span
class="math inline">\(\tilde{\sigma}_{k+1}=A\left(k\right)\tilde{\sigma}_{k}+\Phi_{k+1}-\Phi_{k},\quad(25)\)</span></p>
<p>其中A矩阵是一个列随机矩阵，如果点j连向i，则A(i, j) = 1 /
(点j的出度)。如果j不连向i，则A(i, j) = 0。</p>
<p>定义<span
class="math inline">\(\epsilon_{k}=[\epsilon_{1}^{k},\ldots,\epsilon_{N}^{k}]^{T}=\Phi_{k+1}-\Phi_{k}\)</span>，这个是。再定义<span
class="math inline">\(\epsilon_{i}^{k}=\phi_{i}(x_{i}^{k+1})-\phi_{i}(x_{i}^{k})\)</span>。</p>
<p>因为A是列随机矩阵，所以<span
class="math inline">\(1_{N}^{T}A({k})=1_{N}^{T}\)</span>。所以(25)左右同乘一个<span
class="math inline">\(1_N^T\)</span>，然后移项得到递推式，通过递推式可得<span
class="math inline">\(1_{N}^{T}\tilde{\sigma}_{k} - 1_N^T\phi_k =
1_N^T\tilde{\sigma}_1 - 1_N^T\phi_1 = 0\)</span></p>
<p>所以<span class="math inline">\(1_N^T\tilde{\sigma}_k = 1_N^T\phi_k =
\phi_1(x_1^k) + \phi_2(x_2^k) + ... + \phi_n(x_n^k) =
\sigma(x_k)\)</span></p>
<h4 id="lemmas-1">4-1: Lemmas</h4>
<h5 id="lemma-7">Lemma 7</h5>
<p>定理：在满足Assumptions 1(b), 2, 4的前提下，there exists a constant
<span class="math inline">\(\tilde{M} &gt; 0\)</span>, s.t, <span
class="math inline">\(\|G_{i}(x_{i}^{k},\sigma(x_{k}))\|\leq\tilde{M}\)</span>
and <span
class="math inline">\(\|G_{i}(x_{i}^{k},Nz_{i}^{k+1})\|\leq\tilde{M}\)</span></p>
<p>证明：</p>
<p>Lemma 4已经证出了<span
class="math inline">\(\left\|G_i\left(x_i^k,\sigma(x_k)\right)\right\|\leq
M_1\)</span>，所以<span
class="math inline">\(\|G_{i}(x_{i}^{k},\sigma(x_{k}))\|\leq\tilde{M}\)</span>就不用证了。主要证后面那个。</p>
<p><span
class="math display">\[\begin{Vmatrix}G_i(x_i^k,Nz_i^{k+1})\end{Vmatrix}\le\begin{Vmatrix}G_i(x_i^k,Nz_i^{k+1})-G_i(x_i^k,1_N^T\tilde{\sigma}_k)\end{Vmatrix}+\left\|G_{i}(x_{i}^{k},1_{N}^{T}\tilde{\sigma}_{k})\right\|
\\ \qquad \le L_{1}\left\Vert
Nz_{i}^{k+1}-1_{N}^{T}\tilde{\sigma}_{k}\right\Vert+\left\Vert
G_{i}(x_{i}^{k},1_{N}^{T}\tilde{\sigma}_{k})\right\Vert \]</span></p>
<p>显然，<span
class="math inline">\(\|G_{i}(x_{i}^{k},1_{N}^{T}\tilde{\sigma}_{k})\|\)</span>就是<span
class="math inline">\(\|G_i(x_i^k,\sigma(x_k))\|\)</span>，所以其有界。</p>
<p>由[17, lemma 1(a)]可知，k &gt;=2 时，有：</p>
<p><span
class="math inline">\(\left|z_{i}^{k+1}-\frac{1_{N}^{T}\tilde{\sigma}_{k}}{N}\right|\le\frac{8}{\delta}\Bigg(\iota^{k-1}\|\tilde{\sigma}_{1}\|_{1}+\sum_{s=1}^{k-1}\iota^{k-s-1}\|\epsilon_{s}\|_{1}\Bigg)
\quad (26)\)</span></p>
<p>with <span class="math inline">\(\delta &gt; 0, 0 &lt; \iota &lt;
1\)</span></p>
<p>因为<span class="math inline">\(\|\epsilon_{s}\|_{1}\le
N\|\epsilon_{s}\|=N\|\Phi_{s+1}-\Phi_{s}\|\leq2NC\)</span></p>
<p>所以不难证出：<span
class="math inline">\(L_{1}\left\|Nz_{i}^{k+1}-1_{N}^{T}\tilde{\sigma}_{k}\right\|\)</span>有界</p>
<p>所以<span class="math inline">\(\|
G_i(x_i^k,Nz_i^{k+1})\|\)</span>有界，即<span
class="math inline">\(\parallel G_i(x_i^k,Nz_i^{k+1})\parallel \le
\tilde{M}_2\)</span></p>
<p>令<span class="math inline">\(\tilde{M} = max (M_1,
\tilde{M}_2)\)</span>，得证。</p>
<blockquote>
<p>Note: 如果<span
class="math inline">\(\overline{\lambda}=\operatorname*{max}_{j\in\mathcal{N}}\{\lambda_{j}\}\)</span>
satisfies <span class="math inline">\(0 &lt; \overline{\lambda} &lt;
\frac{\sqrt{2}}{2}\)</span>，则Lemma
5中的结论和证明过程仍然成立，只需要将其中涉及到的M换成<span
class="math inline">\(\tilde{M}\)</span></p>
</blockquote>
<h5 id="lemma-8">Lemma 8</h5>
<p>定理：如果<span
class="math inline">\(\overline{\lambda}=\max_{j\in\mathcal{N}}\{\lambda_{j}\}\)</span>
satisfies <span class="math inline">\(0 &lt; \overline{\lambda} &lt;
\frac{\sqrt{2}}{2}\)</span>，且<span
class="math inline">\(\alpha_i^k\)</span> satisfies conditions
C1-C3。则<span
class="math inline">\(\lim_{k\rightarrow\infty}\epsilon_{i}^{k}=0\)</span>，且
<span
class="math inline">\(\sum_{k=1}^\infty\overline{\alpha}_k\|\epsilon_i^k\|&lt;\infty\)</span></p>
<p>证明：</p>
<p>由于上面的Note存在，所以Lemma 5的结论可以直接用于Lemma 8的证明。</p>
<p>先证第一个：</p>
<p>因为<span class="math inline">\(\phi_i(x_i)\)</span>是L2-Lipschitz
continuous，所以<span class="math inline">\(\|\epsilon_{i}^{k}\|\le
L_{2}\|x_{i}^{k+1}-x_{i}^{k}\|\)</span></p>
<p>而且由Lemma 5(b)知：<span
class="math inline">\(\lim_{k\to\infty}\|x_{i}^{k+1}-x_{i}^{k}\|=0\)</span></p>
<p>所以<span
class="math inline">\(\lim_{k\to\infty}\epsilon_{i}^{k}=0\)</span></p>
<p>再证第二个：</p>
<p>由Lemma 5(a)知：<span
class="math inline">\(\left\|x_i^{k+1}-x_i^k\right\|\leq
M\sum_{s=1}^k\overline{\lambda}^{k-s}\overline{\alpha}_s\)</span></p>
<p>所以：<span class="math inline">\(\overline{\alpha}_k||\epsilon_i^k||
\le
\overline{\alpha}_{k}L_{2}\tilde{M}\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s}
\le
L_{2}\tilde{M}\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s}^{2}\)</span></p>
<p>又根据[31 Lemma 3.1(b)]，可得到：<span
class="math inline">\(\sum_{k=1}^{\infty}\overline{\alpha}_{k}||\epsilon_{i}^{k}||\leq
L_{2}\tilde{M}\sum_{k=1}^{\infty}\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s}^{2}&lt;\infty\)</span></p>
<blockquote>
<p>Note：通过Lemma 8证明的这两个结论，通过[17 Lemma
1]，可以进一步证明出：</p>
<p><span
class="math inline">\(\lim\limits_{k\to\infty}\left\|z_i^{k+1}-\frac{1_N^T\tilde{\sigma}_k}{N}\right\|=0,\sum\limits_{k=1}^{\infty}\overline{\alpha}_k\left\|z_i^{k+1}-\frac{1_N^T\tilde{\sigma}_k}{N}\right\|&lt;\infty\)</span></p>
<p>因为<span
class="math inline">\(1_{N}^{T}\tilde{\sigma}_{k}\)</span>就是<span
class="math inline">\(\sigma\left(x_{k}\right)\)</span></p>
<p>所以<span
class="math inline">\(\sum_{k=1}^{\infty}\overline{\alpha}_{k}\left\Vert
Nz_{i}^{k+1}-\sigma(x_{k})\right\Vert &lt; \infty\)</span></p>
<p>上面这个公式在algorithm 2的收敛分析中有作用。</p>
</blockquote>
<h4 id="theorem-3">4-2: Theorem 3</h4>
<p>定理：在满足Assumptions 1(b), 2, 3(a), 4，以及<span
class="math inline">\(0 &lt; \lambda_i &lt;
\frac{\sqrt{2}}{2}\)</span>，以及C1-C3的条件下。所有玩家的动作最终会收敛到<span
class="math inline">\(x^*\)</span></p>
<p>证明：</p>
<p><img src="18.png" /></p>
<p><img src="19.png" /></p>
<h4 id="theorem-4">4-3: Theorem 4</h4>
<p>定理：在Assumptions 1(b), 2, 3(b), 4 are satisfied 的前提下，令<span
class="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}=\alpha_{k}\)</span>，且<span
class="math inline">\(0 &lt; \lambda_i &lt;
\frac{\sqrt{2}}{2}\)</span>。则<span
class="math inline">\(\{q_t\}\)</span>收敛到0的速率为<span
class="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span> <span
class="math display">\[
q_t=\frac{\sum\limits_{k=1}^t\alpha_k\|x_k-x^*\|^2}{\sum\limits_{k=1}^t\alpha_k}
\]</span> 证明：需要参考[17 Corollary 3]和Theorem 2的证明。</p>
<blockquote>
<p>Note：如果<span
class="math inline">\(\Gamma(x)\)</span>是强单调且步长满足<span
class="math inline">\(\alpha_i^k=\frac1{\sqrt{k}}\)</span>，则可分析algorithm
2的收敛速度。结论也是<span class="math inline">\(x_k\)</span>收敛到<span
class="math inline">\(x^*\)</span>的速率与<span
class="math inline">\(\{q_t\}\)</span>收敛到0的速率相同。</p>
</blockquote>
<hr />
<h3 id="section-5-energy-consumption-control-of-phevs">Section 5: Energy
consumption control of PHEVs</h3>
<p>每个PHEV就是一个玩家。第 i 个PHEV的电量消耗为<span
class="math inline">\(x_i, x_i \in [x_i^{min},
x_i^{max}]\)</span>。每台车的成本函数<span
class="math inline">\(J_i\)</span>定义为： <span class="math display">\[
J_i(x_i,x_{-i})=x_i\left(a\sigma(x)+b\right)+p_o\left(\kappa_i\left(1-\frac{x_i}{x_i^{\max}}\right)^2+d_i\right)
\qquad (30)
\]</span> a &gt; 0，<span
class="math inline">\(\sigma(x)=\sum_{i=1}^N{x_i}\)</span>，<span
class="math inline">\(p_0\)</span>是油价，<span
class="math inline">\(\kappa_{i}\)</span>是油价的换算系数，<span
class="math inline">\(d_i\)</span>是第 i 台车所需的基本油量。</p>
<p>总结一下，按照我的理解，上面那个式子就是每台车的花费函数嘛。花费分为俩部分：电费、油费。电费不仅跟自己的耗电量有关，也跟所有人的耗电量有关，所以是第
i
台车的电费是两者相乘。对于油费，首先一台车的油量分为两部分，第一是<span
class="math inline">\(x_i^{max} -
x_i\)</span>剩下的用油来跑，第二是一台车最起码要存储的油量<span
class="math inline">\(d_i\)</span>。分别就对应着上面括号里的两项。乘个油价就为油费了。</p>
<p>这个实际问题建模后显然满足Assumption 2,
4。而且值得注意的是，其成本函数还具有一个势函数<span
class="math inline">\(F(x)\)</span>： <span class="math display">\[
\begin{aligned}F(x)&amp;=\frac12\sum_{i=1}^Nax_i\left(\sigma(x)-x_i\right)+\sum_{i=1}^N\left(ax_i^2+bx_i\right)\\&amp;+\sum_{i=1}^Np_o\left(\kappa_i\left(1-\frac{x_i}{x_i^{\max}}\right)^2+d_i\right)
\qquad(31)\end{aligned}
\]</span> （势函数就是指，对于所有i，有：<span
class="math inline">\(\frac{\partial{J}_{i}(x)}{\partial
x_{i}}=\frac{\partial{F}(x)}{\partial x_{i}}\)</span>）</p>
<p>接下来，来验证这个建模满足Assumption 3(a)。即<span
class="math inline">\(\Gamma(x)\)</span>在<span
class="math inline">\(\Omega\)</span>上是严格单调的。</p>
<h4 id="lemma-9">Lemma 9</h4>
<p>定理：如果<span class="math inline">\(N &gt; 3\)</span>且a满足：
<span class="math display">\[
a&lt;\min_{i\in\mathcal{N}}\frac{2p_{o}\kappa_{i}}{\left(N-3\right)\left(x_{i}^{\max}\right)^{2}}
\]</span> 则势函数<span
class="math inline">\(F(x)\)</span>是严格凸的。</p>
<p>证明：</p>
<p>先求<span
class="math inline">\(\nabla^2F(x)\)</span>，不难求出，其对角元素为<span
class="math inline">\(2a+\frac{2p_{o}\kappa_{i}}{(x_{i}^{\operatorname*{max}})^{2}}\)</span>，非对角元素为<span
class="math inline">\(a\)</span>。因为<span class="math inline">\(N &gt;
3\)</span>且a满足<span
class="math inline">\(a&lt;\min_{i\in\mathcal{N}}\frac{2p_{o}\kappa_{i}}{\left(N-3\right)\left(x_{i}^{\max}\right)^{2}}\)</span>，所以<span
class="math inline">\(\nabla^2F(x)\)</span>是一个严格对角占优矩阵（严格对角占有矩阵就是对于每一行其对角线上元素的绝对值大于该行中其它所有元素绝对值之和）。所以由[30]中的Gershgorin’s
disctheorem可知<span
class="math inline">\(\nabla^2F(x)\)</span>是一个正定矩阵。那么凸函数的第四种定义即可知道<span
class="math inline">\(F(x)\)</span>是一个严格凸函数。证毕。</p>
<p>所以，这个建模在满足<span class="math inline">\(N &gt; 3,
a&lt;\min_{i\in\mathcal{N}}\frac{2p_{o}\kappa_{i}}{\left(N-3\right)\left(x_{i}^{\max}\right)^{2}}\)</span>的时候，就满足<span
class="math inline">\(F(x)\)</span>是个凸函数，即：<span
class="math inline">\((x-y)^{T}(\nabla F(x)-{\nabla F(y)})&gt;0, x \ne
y\)</span> 。又因为<span
class="math inline">\(\frac{\partial{J}_{i}(x)}{\partial
x_{i}}=\frac{\partial{F}(x)}{\partial x_{i}}\)</span>，所以Assumption
3(a)满足（这里的<span
class="math inline">\(F(x)\)</span>其实就是Assumption 3中的<span
class="math inline">\(\Gamma(x)\)</span>）。</p>
<p>至此，满足了Assumption 1, 2, 3(a), 4。只要控制好动量系数满足<span
class="math inline">\(0&lt;\lambda_i&lt;\frac{\sqrt{2}}2\)</span>，以及步长系数<span
class="math inline">\(\lambda_i\)</span>满足C1-C3，那么这个建模就满足Algorithm
1、2的使用条件了。</p>
<h4 id="numerical-simulations">Numerical simulations</h4>
<p>下面，分别通过两个实际的数值模拟来验证Algorithm 1、2。</p>
<p>考虑有8台车，5种不同类型的车分别用不同颜色表示。每台车的具体参数见下表：</p>
<p><img src="26.png" /></p>
<p>先来验证Algorithm 1。</p>
<p><img src="20.png" /></p>
<p>可以看到，这个图是强连通的且不是一个权重平衡图。通过计算，<span
class="math inline">\(x^* =
[17.6859,17.6859,15.5682,15.5682,12.5484,12.5484, 16.587,
16.3481]\)</span>。</p>
<p>设置步长为<span
class="math inline">\(\alpha_{i}^{k}=\frac{1}{k^{0.6}}+\frac{1}{k^{1.2}}\)</span>。</p>
<p>Fig 2是在不同<span
class="math inline">\(\lambda_i\)</span>下，使用Algorithm 1收敛到<span
class="math inline">\(x^*\)</span>的迭代次数。</p>
<p><img src="21.png" /></p>
<p>可以看到，加了动量项收敛速度确实会快一些。而且动量系数越大速度越快。而且虽然理论要求<span
class="math inline">\(0&lt;\lambda_i&lt;\frac{\sqrt{2}}2\)</span>，但是<span
class="math inline">\(\frac{\sqrt{2}}{2} &lt; \lambda_i &lt;
1\)</span>时在数值仿真中仍然可以收敛。</p>
<p>再来验证Algorithm 2。</p>
<p><img src="22.png" /></p>
<p>如图Fig. 3，考虑车子的通信图周期性地在Fig. 3中的两个状态中切换。</p>
<p>Fig. 4是在不同<span
class="math inline">\(\lambda_i\)</span>下，使用Algorithm 2收敛到<span
class="math inline">\(x^*\)</span>的迭代次数。</p>
<p><img src="23.png" /></p>
<p>可以发现，加了动量项收敛速度确实会快一些。而且动量系数越大速度越快。而且<span
class="math inline">\(\lambda_i\)</span>也是可以大于<span
class="math inline">\(\frac{\sqrt{2}}{2}\)</span> ，小于1。</p>
<p>最后通过数值模拟证明一下<span
class="math inline">\(\{q_t\}\)</span>收敛到0的速率为<span
class="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span>。</p>
<p>下面两幅图就是分别用了Algorithm 1和2（<span
class="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}, \lambda_i =
0.6\)</span>）。其中<span class="math inline">\(c_t = \frac{\ln
t}{\sqrt{t}}\)</span>。</p>
<p><img src="24.png" /></p>
<p><img src="25.png" /></p>
<p>可以发现，迭代次数越多的时候，<span
class="math inline">\(q_t\)</span>与<span
class="math inline">\(c_t\)</span>的比值越接近1。也就通过数值模拟证明了在Algorithm1或2下，它俩收敛到0的速度是一样的。</p>
<hr />
<h3 id="section-6-conclusion">Section 6: Conclusion</h3>
<p>本文提出了两种算法分别解决固定有向图和时变有向图上的NE寻找问题（且图不需要权重平衡）。这俩算法分别是基于行随机矩阵左特征向量估计法、列随机矩阵推和法。</p>
<p>而且为了加速算法收敛，算法1、2中均加入了动量项。</p>
<p>但是算法中采用的是学习率递减到0的方式，这种方式会导致收敛速度较慢，这是本算法的不足。</p>
<p>最后，本文作者认为，进一步研究“在聚合游戏中采用分布式算法加速寻找NE”将是一件很有趣的课题。</p>
<hr />
<h3 id="personal-summary">Personal summary</h3>
<h4 id="分布式发展历史">分布式发展历史</h4>
<p>这篇文章是我在分布式领域看的第一篇文章，所以在这里写点关于分布式算法优化领域的发展过程：</p>
<blockquote>
<p>1960s，Everett Dantzig, Wolfe and Benders
思考了关于严格凸问题的拉格朗日松弛和线性规范的分解方法。（分解方法是为了将大型优化问题分解为小问题）</p>
<p>后来，拉格朗日松弛和Hestenes, Powell and
Miele发展的增广拉格朗日技术相结合，解决了一些凸但非严格凸的问题。可以理解为现代ADMM算法的前身。</p>
<p>2000年初，出现了为了适应大规模数据的分布式算法，例如SGD（分布式随机梯度下降）。</p>
<p>2010年初，为了解决大规模机器学习问题，出现了ADMM（交替方向乘子法）等算法。</p>
<p>至今，分布式优化算法在算法效率、鲁棒性、以及适应动态和不确定环境方面取得了显著进展。出现了更加高效的分布式在线优化方法，以及能够适应网络拓扑变化和通信不确定性的算法。</p>
</blockquote>
<h4 id="文章总结">文章总结</h4>
<p>本文就是研究了一种特殊的博弈——聚合博弈。</p>
<p>每个玩家的花费不仅跟自身动作有关，还跟其他人的动作有关。</p>
<p>本论文设计了两种算法，在作者规定的特定条件下，可以使得每个人的花费尽可能低。分别用于固定有向图和时变有向图。</p>
<p>文章内容为：算法介绍、算法的正确性证明、收敛速度分析、在PHEVs上的应用。</p>
<h5 id="算法介绍">算法介绍</h5>
<p><strong>Algorithm 1</strong> <span class="math display">\[
\begin{gathered}
x_i^0=x_i^1\in\Omega_i,v_i^1=e_i,\tilde{\sigma}_i^1=\phi_i(x_i^1) \\
x_{k+1}=P_{\Omega_{i}}[x_{k}-\alpha_{k}G_{i}(x_{k},\tilde{\sigma}_{k})+\lambda_{i}(x_{k}-x_{k-1})]
\\
V_{k+1}=AV_k \\
\tilde{\sigma}_{k+1}=A\tilde{\sigma}_k+\hat{V}_{k+1}^{-1}\Phi_{k+1}-\hat{V}_{k}^{-1}\Phi_{k}
\end{gathered}
\]</span> 目的就是为了把<span
class="math inline">\(x_k\)</span>收敛到<span
class="math inline">\(x^*\)</span>。使得玩家动作为<span
class="math inline">\(x^*\)</span>时，每个玩家的花费最少。</p>
<p>因为动作<span class="math inline">\(x_i\)</span>会对花费<span
class="math inline">\(J_i\)</span>产生影响，故定义<span
class="math inline">\(G_i\)</span>为<span
class="math inline">\(J_i\)</span>对<span
class="math inline">\(x_i\)</span>求导，用来评估<span
class="math inline">\(x_i\)</span>对<span
class="math inline">\(J_i\)</span>产生的影响。</p>
<p>那么<span class="math inline">\(x_i^{k+1}\)</span>就可以通过<span
class="math inline">\(x_i^k\)</span>和<span
class="math inline">\(G_i(x_i^k,
\tilde{\sigma}_i^k)\)</span>来更新。</p>
<p><span class="math inline">\(\tilde{\sigma}_i^k\)</span>是什么？</p>
<p>需要注意的是，花费函数<span
class="math inline">\(J_i\)</span>除了要知道<span
class="math inline">\(i\)</span>玩家的动作<span
class="math inline">\(x_i\)</span>，还需要知道所有玩家的输出函数<span
class="math inline">\(\phi_i\)</span>。所以定义<span
class="math inline">\(\sigma(x)\)</span>为所有玩家的输出函数之和。但是因为每个玩家没有上帝视角，所以<span
class="math inline">\(\sigma(x)\)</span>是未知的，所以我们可以用<span
class="math inline">\(\tilde\sigma_i\)</span>来代替<span
class="math inline">\(\sigma(x)\)</span>。即每个玩家都有一个对<span
class="math inline">\(\sigma(x)\)</span>的评估函数<span
class="math inline">\(\tilde\sigma_i\)</span>（这个评估函数也是需要迭代更新的，最终要收敛于<span
class="math inline">\(\sigma(x)\)</span>）</p>
<p>至于<span
class="math inline">\(V_k\)</span>，个人目前觉得是一个辅助矩阵，在迭代更新<span
class="math inline">\(\tilde\sigma_k\)</span>时会用到。</p>
<p>至于<span
class="math inline">\(\lambda_i\)</span>，是动量项，加速收敛用的。</p>
<p><strong>Algorithm 2</strong> <span class="math display">\[
\begin{gathered}
\\
x_i^0=x_i^1\in\Omega_i,y_i^1=1,\tilde{\sigma}_i^1=\phi_i(x_i^1) \\
w_{k+1}=A\left(k\right)\tilde{\sigma}_{k} \\
y_{k+1}=A\left(k\right)y_{k} \\
z_i^{k+1}=\frac{w_i^{k+1}}{y_i^{k+1}} \\
x_{k+1}=P_{\Omega_i}\left[x_k-\alpha_kG_i(x_k,Nz_{k+1})+\lambda_i(x_k-x_{k-1})\right]
\\
\begin{aligned}\tilde{\sigma}_{k+1}=w_{k+1}+\phi_i\left(x_{k+1}\right)-\phi_i\left(x_k\right)\end{aligned}
\end{gathered}
\]</span> 目的同样是为了把<span
class="math inline">\(x_k\)</span>收敛到<span
class="math inline">\(x^*\)</span>。使得玩家动作为<span
class="math inline">\(x^*\)</span>时，每个玩家的花费最少。</p>
<p>整体思路跟Algorithm 1类似，通过<span
class="math inline">\(x_i^k\)</span>和<span
class="math inline">\(G_i(x_i^k, \tilde{\sigma}_i^k)\)</span>来更新<span
class="math inline">\(x_i^{k+1}\)</span>。</p>
<p>但是注意，Algorithm 2没有直接将<span
class="math inline">\(\tilde{\sigma}_i^k\)</span>带入<span
class="math inline">\(G_i\)</span>中。而是带入了<span
class="math inline">\(Nz_{k+1}\)</span>，<span
class="math inline">\(z_{k+1}\)</span>通过<span
class="math inline">\(w_{k+1}, y_{k+1}\)</span>更新，<span
class="math inline">\(w_{k+1}\)</span>又通过<span
class="math inline">\(\tilde{\sigma}_k\)</span>更新。所以相当于多了<span
class="math inline">\(w, y, z\)</span>三个中间辅助矩阵。</p>
<h5 id="算法正确性证明">算法正确性证明</h5>
<p>本文大篇幅都是在证这个。</p>
<p>本质就是证<span class="math inline">\(x_k\)</span>最终收敛于<span
class="math inline">\(x^*\)</span>。即<span class="math inline">\(\|x_k
- x^*\|^2 \rightarrow 0\)</span>。</p>
<p>具体内容过多不好总结 ，具体看下文证明。</p>
<p>证明过程主要用到了：矩阵范数性质、范数的放缩、Cauchy-Schwarz。</p>
<h5 id="收敛速度分析">收敛速度分析</h5>
<p>在作者规定的更多特定条件下（条件比它提出的俩算法更严格），Algorithm
1、2的收敛速度跟<span
class="math inline">\(\{q_t\}\)</span>收敛到0的速度一样： <span
class="math display">\[
q_t=\frac{\sum\limits_{k=1}^t\alpha_k\|x_k-x^*\|^2}{\sum\limits_{k=1}^t\alpha_k}
\]</span> 而<span
class="math inline">\(\{q_t\}\)</span>收敛到0的速度经证明为：<span
class="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span></p>
<h5 id="在phevs上的应用">在PHEVs上的应用</h5>
<p>这个部分论文中也没给出实现代码，只给出了数值模拟的结果和效果图。所以我自己复现了一遍论文的算法。</p>
<p><strong>Algorithm 1的数值仿真</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Algorithm 1的数值仿真</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">n = <span class="number">8</span></span><br><span class="line">x_best = [-<span class="number">1</span>, <span class="number">17.6859</span>, <span class="number">17.6859</span>, <span class="number">15.5682</span>, <span class="number">15.5682</span>, <span class="number">12.5484</span>, <span class="number">12.5484</span>, <span class="number">16.587</span>, <span class="number">16.3481</span>]</span><br><span class="line">x_min = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">x_max = [-<span class="number">1</span>, <span class="number">27.5</span>, <span class="number">27.5</span>, <span class="number">34.2</span>, <span class="number">34.2</span>, <span class="number">40.6</span>, <span class="number">40.6</span>, <span class="number">28.8</span>, <span class="number">35.7</span>]</span><br><span class="line">x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">p_0 = <span class="number">5.6</span></span><br><span class="line">a = <span class="number">0.004</span></span><br><span class="line">b = <span class="number">0.1</span></span><br><span class="line">k = [-<span class="number">1</span>, <span class="number">4.6</span>, <span class="number">4.6</span>, <span class="number">3.7</span>, <span class="number">3.7</span>, <span class="number">3.4</span>, <span class="number">3.4</span>, <span class="number">4.0</span>, <span class="number">3.9</span>]</span><br><span class="line">d = [-<span class="number">1</span>, <span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>]</span><br><span class="line">alpha = <span class="number">2</span></span><br><span class="line">A = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">3</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>]</span><br><span class="line">]   <span class="comment"># 这里因为论文中没明确指定具体的值，只说是行随机，所以对于每行有值的位置我直接平均分了</span></span><br><span class="line">v = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line">sigma = [-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    sigma.append(x[i])</span><br><span class="line"></span><br><span class="line">xx = copy.deepcopy(x)</span><br><span class="line">xxx = copy.deepcopy(x)</span><br><span class="line">vv = copy.deepcopy(v)</span><br><span class="line">ssigma = copy.deepcopy(sigma)</span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">i, x, sigma</span>):</span><br><span class="line">    <span class="keyword">return</span> a * (sigma + x) + b  - <span class="number">2</span> * p_0 * k[i] / x_max[i] * (<span class="number">1</span> - x / x_max[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_x</span>(<span class="params">i, vec</span>):</span><br><span class="line">    x[i] = xx[i] - alpha * G(i, xx[i], ssigma[i]) + vec * (xx[i] - xxx[i])</span><br><span class="line">    <span class="keyword">if</span> x[i] &lt; x_min[i]: x[i] = x_min[i]</span><br><span class="line">    <span class="keyword">if</span> x[i] &gt; x_max[i]: x[i] = x_max[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_v</span>(<span class="params">i</span>):</span><br><span class="line">    vvv = copy.deepcopy(vv)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            vvv[j][l] *= A[i][j]</span><br><span class="line">    res = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> += vvv[l][j]</span><br><span class="line">        res.append(<span class="built_in">sum</span>)</span><br><span class="line">    v[i] = res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_sigma</span>(<span class="params">i</span>):</span><br><span class="line">    add_1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        add_1 += ssigma[j] * A[i][j]</span><br><span class="line">    add_2 = x[i] / v[i][i]</span><br><span class="line">    add_3 = xx[i] / vv[i][i]</span><br><span class="line">    sigma[i] = add_1 + add_2 - add_3</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    <span class="keyword">global</span> x, alpha, v, sigma, xx, xxx, vv, ssigma</span><br><span class="line">    x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">    alpha = <span class="number">2</span></span><br><span class="line">    v = [</span><br><span class="line">        [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    ]</span><br><span class="line">    sigma = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        sigma.append(x[i])</span><br><span class="line">    xx = copy.deepcopy(x)</span><br><span class="line">    xxx = copy.deepcopy(x)</span><br><span class="line">    vv = copy.deepcopy(v)</span><br><span class="line">    ssigma = copy.deepcopy(sigma)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm_1</span>(<span class="params">iter_num, vec</span>):</span><br><span class="line">    <span class="keyword">global</span> xx, xxx, vv, ssigma, alpha</span><br><span class="line">    init()</span><br><span class="line">    res = []</span><br><span class="line">    sum_1 = <span class="number">0</span></span><br><span class="line">    sum_2 = <span class="number">0</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 计算差距值</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> += (x[i] - x_best[i]) ** <span class="number">2</span></span><br><span class="line">        res.append(<span class="built_in">sum</span> ** <span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># 计算qt的分子（这里的alpha注意步长设置为1/sqrt(j)）</span></span><br><span class="line">        sum_1 += (<span class="number">1</span> / j ** <span class="number">0.5</span>) * <span class="built_in">sum</span></span><br><span class="line">        sum_2 += (<span class="number">1</span> / j ** <span class="number">0.5</span>)</span><br><span class="line">        q.append(sum_1 / sum_2)</span><br><span class="line">        <span class="comment"># Algorithm 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            upd_x(i, vec)</span><br><span class="line">            upd_v(i)</span><br><span class="line">            upd_sigma(i)</span><br><span class="line">        xxx = copy.deepcopy(xx)</span><br><span class="line">        xx = copy.deepcopy(x)</span><br><span class="line">        vv = copy.deepcopy(v)</span><br><span class="line">        ssigma = copy.deepcopy(sigma)</span><br><span class="line">        alpha = <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">0.6</span> + <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">1.2</span></span><br><span class="line">    <span class="keyword">return</span> res, q</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results</span>(<span class="params">iter_num, vecs, vecs_name</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, iter_num):</span><br><span class="line">        x.append(i)</span><br><span class="line">        y.append(i)</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(vecs)):</span><br><span class="line">        y = algorithm_1(iter_num, vecs[T])[<span class="number">0</span>]</span><br><span class="line">        plt.plot(x, y, label=vecs_name[T])</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;Iterations k&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;||xk - x*||&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        <span class="built_in">print</span>(vecs_name[T], end=<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span>%y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">vecs = [<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>]</span><br><span class="line">vecs_name = [<span class="string">&#x27;vec=0.0&#x27;</span>, <span class="string">&#x27;vec=0.2&#x27;</span>, <span class="string">&#x27;vec=0.4&#x27;</span>, <span class="string">&#x27;vec=0.6&#x27;</span>, <span class="string">&#x27;vec=0.8&#x27;</span>]</span><br><span class="line">plot_results(<span class="number">1000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">2000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">3000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">4000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">5000</span>, vecs, vecs_name)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results_convergence_1</span>(<span class="params">iter_num</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    z = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, iter_num + <span class="number">1</span> + <span class="number">1</span>): <span class="comment"># 第一项ct是0，所以从第二项开始</span></span><br><span class="line">        x.append(i)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        z.append(math.log(i) / (i ** <span class="number">0.5</span>))</span><br><span class="line">    y = algorithm_1(iter_num, <span class="number">0.6</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># qt的图像</span></span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        经过调整参数为(x_min + x_max) / 2, 初始差距值已经比论文还低一些</span></span><br><span class="line"><span class="string">        但是qt始终无法收敛到0, 这是为什么呢?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        当迭代次数很大时, 分子中的差距值已经很小, 所以导致分子比分母小许多, 所以假设论文中的迭代次数是8w次, 我比它多10倍,</span></span><br><span class="line"><span class="string">        比它多那么多后, 即使我刚开始迭代时的分子很大, 分子也会被后面10倍迭代次数的分母追上来。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这是用来画qt / ct的图像</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num):</span><br><span class="line">        y[i] = y[i] / z[i]</span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x[<span class="number">1</span>:], y[<span class="number">1</span>:])</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;qt / ct&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_results_convergence_1(<span class="number">80000</span>)</span><br></pre></td></tr></table></figure>
<p>效果图如下：（最后一张图，第一行数字是qt的收敛值，第二行数字是qt/ct的收敛值）</p>
<p><img src="27.png" /></p>
<p><strong>Algorithm 2的数值仿真</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Algorithm 2的数值仿真</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">n = <span class="number">8</span></span><br><span class="line">x_best = [-<span class="number">1</span>, <span class="number">17.68591179305579</span>, <span class="number">17.68591178894396</span>, <span class="number">15.568177079669734</span>, <span class="number">15.568176869116588</span>,</span><br><span class="line">            <span class="number">12.54841009221712</span>, <span class="number">12.548433755340588</span>, <span class="number">16.50869895275612</span>, <span class="number">16.348072510972873</span>]</span><br><span class="line">x_min = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">x_max = [-<span class="number">1</span>, <span class="number">27.5</span>, <span class="number">27.5</span>, <span class="number">34.2</span>, <span class="number">34.2</span>, <span class="number">40.6</span>, <span class="number">40.6</span>, <span class="number">28.8</span>, <span class="number">35.7</span>]</span><br><span class="line">x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">p_0 = <span class="number">5.6</span></span><br><span class="line">a = <span class="number">0.004</span></span><br><span class="line">b = <span class="number">0.1</span></span><br><span class="line">k = [-<span class="number">1</span>, <span class="number">4.6</span>, <span class="number">4.6</span>, <span class="number">3.7</span>, <span class="number">3.7</span>, <span class="number">3.4</span>, <span class="number">3.4</span>, <span class="number">4.0</span>, <span class="number">3.9</span>]</span><br><span class="line">d = [-<span class="number">1</span>, <span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>]</span><br><span class="line">alpha = <span class="number">2</span></span><br><span class="line">A_1 = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">]</span><br><span class="line">A_2 = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">]</span><br><span class="line">A = copy.deepcopy(A_1)</span><br><span class="line">sigma = [-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    sigma.append(x[i])</span><br><span class="line">w = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">y = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">z = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">xx = copy.deepcopy(x)</span><br><span class="line">xxx = copy.deepcopy(x)</span><br><span class="line">ssigma = copy.deepcopy(sigma)</span><br><span class="line">yy = copy.deepcopy(y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    <span class="keyword">global</span> x, alpha, sigma, w, y, z, xx, xxx, ssigma, yy</span><br><span class="line">    x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">    alpha = <span class="number">2</span></span><br><span class="line">    sigma = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        sigma.append(x[i])</span><br><span class="line">    w = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    y = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">    z = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    xx = copy.deepcopy(x)</span><br><span class="line">    xxx = copy.deepcopy(x)</span><br><span class="line">    ssigma = copy.deepcopy(sigma)</span><br><span class="line">    yy = copy.deepcopy(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_w</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">sum</span> += A[i][j] * ssigma[j]</span><br><span class="line">    w[i] = <span class="built_in">sum</span>    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_y</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">sum</span> += A[i][j] * yy[j]</span><br><span class="line">    y[i] = <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_z</span>(<span class="params">i</span>):</span><br><span class="line">    z[i] = w[i] / y[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">i, x, sigma</span>):</span><br><span class="line">    <span class="keyword">return</span> a * (sigma + x) + b  - <span class="number">2</span> * p_0 * k[i] / x_max[i] * (<span class="number">1</span> - x / x_max[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_x</span>(<span class="params">i, vec</span>):</span><br><span class="line">    x[i] = xx[i] - alpha * G(i, xx[i], n * z[i]) + vec * (xx[i] - xxx[i])</span><br><span class="line">    <span class="keyword">if</span> x[i] &lt; x_min[i]: x[i] = x_min[i]</span><br><span class="line">    <span class="keyword">if</span> x[i] &gt; x_max[i]: x[i] = x_max[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_sigma</span>(<span class="params">i</span>):</span><br><span class="line">    sigma[i] = w[i] + x[i] - xx[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm_2</span>(<span class="params">iter_num, vec</span>):</span><br><span class="line">    <span class="keyword">global</span> A, A_1, A_2, w, ssigma, y, yy, z, x, xx, alpha, xxx, sigma</span><br><span class="line">    init()</span><br><span class="line">    res = []</span><br><span class="line">    sum_1 = <span class="number">0</span></span><br><span class="line">    sum_2 = <span class="number">0</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 计算差距</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> += (x[i] - x_best[i]) ** <span class="number">2</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> ** (<span class="number">0.5</span>)</span><br><span class="line">        res.append(<span class="built_in">sum</span>)</span><br><span class="line">        <span class="comment"># 计算qt的分子（这里的alpha注意步长设置为1/sqrt(j)）</span></span><br><span class="line">        sum_1 += (<span class="number">1</span> / j ** <span class="number">0.5</span>) * <span class="built_in">sum</span> * <span class="built_in">sum</span></span><br><span class="line">        sum_2 += (<span class="number">1</span> / j ** <span class="number">0.5</span>)</span><br><span class="line">        q.append(sum_1 / sum_2)</span><br><span class="line">        <span class="comment"># 选择矩阵</span></span><br><span class="line">        <span class="keyword">if</span> j % <span class="number">2</span>: A = copy.deepcopy(A_1)</span><br><span class="line">        <span class="keyword">else</span>: A = copy.deepcopy(A_2)</span><br><span class="line">        <span class="comment"># Algorithm 2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            upd_w(i)</span><br><span class="line">            upd_y(i)</span><br><span class="line">            upd_z(i)</span><br><span class="line">            upd_x(i, vec)</span><br><span class="line">            upd_sigma(i)</span><br><span class="line">        <span class="comment"># 更新状态</span></span><br><span class="line">        xxx = copy.deepcopy(xx)</span><br><span class="line">        xx = copy.deepcopy(x)</span><br><span class="line">        yy = copy.deepcopy(y)</span><br><span class="line">        ssigma = copy.deepcopy(sigma)</span><br><span class="line">        alpha = <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">0.6</span> + <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">1.2</span></span><br><span class="line">    <span class="keyword">return</span> res, q</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results</span>(<span class="params">iter_num, vecs, vecs_name</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, iter_num):</span><br><span class="line">        x.append(i)</span><br><span class="line">        y.append(i)</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(vecs)):</span><br><span class="line">        y = algorithm_2(iter_num, vecs[T])[<span class="number">0</span>]</span><br><span class="line">        plt.plot(x, y, label=vecs_name[T])</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;Iterations k&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;||xk - x*||&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        <span class="built_in">print</span>(vecs_name[T], end=<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span>%y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">vecs = [<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>]</span><br><span class="line">vecs_name = [<span class="string">&#x27;vec=0.0&#x27;</span>, <span class="string">&#x27;vec=0.2&#x27;</span>, <span class="string">&#x27;vec=0.4&#x27;</span>, <span class="string">&#x27;vec=0.6&#x27;</span>, <span class="string">&#x27;vec=0.8&#x27;</span>]</span><br><span class="line">plot_results(<span class="number">1000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">2000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">3000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">4000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">5000</span>, vecs, vecs_name)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results_convergence_2</span>(<span class="params">iter_num</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    z = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, iter_num + <span class="number">1</span> + <span class="number">1</span>): <span class="comment"># 第一项ct是0，所以从第二项开始</span></span><br><span class="line">        x.append(i)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        z.append(math.log(i) / (i ** <span class="number">0.5</span>))</span><br><span class="line">    y = algorithm_2(iter_num, <span class="number">0.6</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># qt的图像</span></span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        经过调整参数为(x_min + x_max) / 2, 初始差距值已经比论文还低一些</span></span><br><span class="line"><span class="string">        但是qt始终无法收敛到0, 这是为什么呢?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        当迭代次数很大时, 分子中的差距值已经很小, 所以导致分子比分母小许多, 所以假设论文中的迭代次数是8w次, 我比它多10倍,</span></span><br><span class="line"><span class="string">        比它多那么多后, 即使我刚开始迭代时的分子很大, 分子也会被后面10倍迭代次数的分母追上来。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这是用来画qt / ct的图像</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num):</span><br><span class="line">        y[i] = y[i] / z[i]</span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x[<span class="number">1</span>:], y[<span class="number">1</span>:])</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;qt / ct&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_results_convergence_2(<span class="number">80000</span>)</span><br></pre></td></tr></table></figure>
<p>效果图如下：（最后一张图，第一行数字是qt的收敛值，第二行数字是qt/ct的收敛值）</p>
<p><img src="28.png" /></p>
<hr />
<p>这篇blog发表于2023.10.16，现在是2023.12.4，看了2个月，目前算是告一段落了。</p>
<p>分布式领域读的第一篇论文，挺有趣的，算是跨过了一道入门槛。</p>
<p>接下来阅读论文的速度就要加快了。同时要去原理上去思考为什么这样做以及还可以怎样去优化。</p>
<p>假如您正在阅读这篇blog，如发现错误，恳请在评论区中指出。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/10/16/2-python%E6%80%A5%E6%95%91%E5%8C%85/" rel="prev" title="2. python急救包">
      <i class="fa fa-chevron-left"></i> 2. python急救包
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/" rel="next" title="数据库自学笔记">
      数据库自学笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81OTA0Ny8zNTUwOQ=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#abstract"><span class="nav-text">Abstract</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section-1-introduction"><span class="nav-text">Section 1: Introduction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A0%94%E7%A9%B6%E8%83%8C%E6%99%AF"><span class="nav-text">1-1: 研究背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E8%87%B4%E7%9B%AE%E5%BD%95-%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F"><span class="nav-text">1-2: 大致目录 &amp; 基础公式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section-2-preliminary-knowledge"><span class="nav-text">Section 2: Preliminary
knowledge</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE%E7%90%86%E8%AE%BA"><span class="nav-text">2-1: 图理论</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98%E5%BB%BA%E6%A8%A1"><span class="nav-text">2-2: 问题建模</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#assumption-1"><span class="nav-text">Assumption 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#assumption-2"><span class="nav-text">Assumption 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#assumption-3"><span class="nav-text">Assumption 3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#assumption-4"><span class="nav-text">Assumption 4</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E5%BC%95%E5%85%A5"><span class="nav-text">2-3: 算法引入</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#algorithm-1-ne-seeking-with-row-stochastic-adjacency-matrix"><span class="nav-text">Algorithm
1 NE Seeking With Row-Stochastic Adjacency Matrix</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#algorithm-2-ne-seeking-with-column-stochastic-adjacency-matrix"><span class="nav-text">Algorithm
2 NE Seeking With Column-Stochastic Adjacency Matrix</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section-3-convergence-analysis-of-algorithm-1"><span class="nav-text">Section 3:
Convergence analysis of algorithm 1</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#theorem-1"><span class="nav-text">3-1: Theorem 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#preliminary-analysis-about-algorithm-1"><span class="nav-text">3-2: Preliminary
analysis about algorithm 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lemmas"><span class="nav-text">3-3: Lemmas</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lemma-1"><span class="nav-text">Lemma 1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lemma-2"><span class="nav-text">Lemma 2</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lemma-3"><span class="nav-text">Lemma 3</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lemma-4"><span class="nav-text">Lemma 4</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lemma-5"><span class="nav-text">Lemma 5</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lemma-6"><span class="nav-text">Lemma 6</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#proof-of-theorem-1"><span class="nav-text">3-4: Proof of theorem 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#theorem-2"><span class="nav-text">3-5: Theorem 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#convergence-rate-analysis-of-algorithm-1"><span class="nav-text">3-6: Convergence rate
analysis of algorithm 1</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section-4-convergence-analysis-of-algorithm-2"><span class="nav-text">Section 4:
Convergence analysis of algorithm 2</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lemmas-1"><span class="nav-text">4-1: Lemmas</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#lemma-7"><span class="nav-text">Lemma 7</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#lemma-8"><span class="nav-text">Lemma 8</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#theorem-3"><span class="nav-text">4-2: Theorem 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#theorem-4"><span class="nav-text">4-3: Theorem 4</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section-5-energy-consumption-control-of-phevs"><span class="nav-text">Section 5: Energy
consumption control of PHEVs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lemma-9"><span class="nav-text">Lemma 9</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#numerical-simulations"><span class="nav-text">Numerical simulations</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#section-6-conclusion"><span class="nav-text">Section 6: Conclusion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#personal-summary"><span class="nav-text">Personal summary</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="nav-text">分布式发展历史</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E7%AB%A0%E6%80%BB%E7%BB%93"><span class="nav-text">文章总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">算法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%97%E6%B3%95%E6%AD%A3%E7%A1%AE%E6%80%A7%E8%AF%81%E6%98%8E"><span class="nav-text">算法正确性证明</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%B6%E6%95%9B%E9%80%9F%E5%BA%A6%E5%88%86%E6%9E%90"><span class="nav-text">收敛速度分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8phevs%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">在PHEVs上的应用</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Error_666"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Error_666</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/potatoQi" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;potatoQi" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.acwing.com/user/myspace/index/8252/" title="AcWing → https:&#x2F;&#x2F;www.acwing.com&#x2F;user&#x2F;myspace&#x2F;index&#x2F;8252&#x2F;" rel="noopener" target="_blank"><i class="fas fa-rocket fa-fw"></i>AcWing</a>
      </span>
  </div>



      </div>
	<br>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2023-10-1 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Error_666</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
 -->


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
setInterval(function () {
    var box = document.querySelector(".trc_rbox_container");
    if(box) box.outerHTML = "";
}, 2000);
</script>

</body>
</html>
