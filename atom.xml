<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Error_666</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-30T16:13:34.181Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Error_666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>六级刷题笔记</title>
    <link href="http://example.com/2024/03/30/%E5%85%AD%E7%BA%A7%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/03/30/%E5%85%AD%E7%BA%A7%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-30T15:07:39.000Z</published>
    <updated>2024-03-30T16:13:34.181Z</updated>
    
    <content type="html"><![CDATA[<p>准备考六级了，刷刷题。</p><p>格式：[四/六]级, 年份, 月份, 第几套。</p><span id="more"></span><h3 id="六级-2023-12-2">六级, 2023, 12, 2</h3><ul><li>Section A</li></ul><blockquote><ol type="1"><li>沙漠是具有欺骗性的，乍一看，荒原/一毛不拔的火星基地。但其实，它是充满生机/神奇/有魔力的地方</li><li>M沙漠是一个极端的地方，天气变化很大</li><li>沙漠中心是保护区，穿着宽边帽的当地百姓，是优胜美地的代名词</li><li>摄影师去那必须要准备好装备</li><li>作为摄影师，如果你足够耐心，你会在沙漠收获颇丰。</li></ol></blockquote><ol type="1"><li><p>For most passersby <u>humming through</u> the Mojave on their wayto <u>try their luck</u> in <u>Los Vegas</u> or heading towards the<u>Grand Canyon</u>.</p></li><li><p>It's just a <u>flat</u> stretch of land with some mountains inthe distance and more <u>apt</u> to be a setting for a movie that takesplace on Mars.</p></li><li><p>The desert, however, is <u>overflowing</u> with life, mystery,and magic.</p></li><li><p>The Mojave desert is a land of <u>extremes</u>.</p></li><li><p>The folks managing and working there wear the wide-brimmed hatsthat have become <u>synonymous</u> with places like Yosemite.</p></li></ol><ul><li>Section C</li></ul><blockquote><ol type="1"><li>通过女明星“戒网“引入话题</li><li>戒网并不是简单的一件事，它很微妙复杂，因为生活中许多事都跟网络挂钩</li><li>因为网很重要，所以戒网对于普通人来说很难，但是却是富人的一项“权利”，因为富人有专业团队维护账号，所以他们可以做到平衡戒网与名利</li><li>数字鸿沟是英国面临的一项问题</li><li>戒网能让一部分人内心健康，但不能否定的是，也让一些人收获了分享的快乐</li><li>网络以后肯定会越来越发达，所以我们需要更多行动去维护贫穷人连接网络的权利</li><li>对于那些觉得网络危害了内心的人，就少玩点。对于那些处于数字鸿沟的人，就多玩点。</li></ol></blockquote><ol type="1"><li><u>Ditching</u> the web at large, however, is a far more<u>subtle</u> and complicated <u>prospect</u>.</li><li>Actively <u>opting</u> out of using the internet becomes a matter of<u>privilege</u>.</li><li>Ms Gomez’s multi-millionaire <u>status</u> has allowed her to takethe “social” out of social media, so she can continue to <u>leverage</u>her <u>enormous fame</u> while keeping the trolls (恶意挑衅的贴子) atbay.</li><li>The fact that she’s still the second most-followed woman onInstagram <u>suggests</u> it’s entirely possible to maintain asignificant web profile to promote various projects — by way of a<u>dedicated</u> team.</li><li><u>It goes without saying</u> that this is fundamentally differentfrom how the rest of us without beauty deals and films to publicise usethe likes of Instagram, TikTok and Twitter.</li><li>The UK’s digital divide has worsened over the past two years,leaving poorer families without <u>broadband</u> connections in theirhomes.</li><li>Digital <u>exclusion</u> is a major threat to wider societalequality in the UK.</li><li><u>Consequently</u>, it’s worth <u>bearing in mind</u> that whiledeleting all social media accounts will undoubtedly make some feelinfinitely better, many other people benefit from the strong sense ofcommunity that sharing platforms can breed.</li><li>It’s <u>crucial</u> that people who feel that social media is havinga <u>detrimental</u> effect on their mental health are allowed to<u>switch off</u> — and for those living in digital <u>exclusion</u> tobe able to <u>switch on</u> in the first place.</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;准备考六级了，刷刷题。&lt;/p&gt;
&lt;p&gt;格式：[四/六]级, 年份, 月份, 第几套。&lt;/p&gt;</summary>
    
    
    
    <category term="竞赛" scheme="http://example.com/categories/%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理实验笔记</title>
    <link href="http://example.com/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-28T13:12:34.000Z</published>
    <updated>2024-03-28T13:31:06.105Z</updated>
    
    <content type="html"><![CDATA[<p>用Verilog实现一个简易RISC-V指令集CPU软核。</p><p>本次实验是重庆大学2022级弘深计算机拔尖班计算机组成原理的实验项目。</p><span id="more"></span><p>在开始做实验之前，首先要对CPU的物理结构和数据是如何在regfile, ram,rom中传输的有比较清晰的认知。建议观看视频: <ahref="https://www.bilibili.com/video/BV1wi4y157D3?p=1">从0到1设计一台计算机</a>，掌握理论知识。</p><p>在看完视频后，可以先跟着这个<ahref="https://www.bilibili.com/video/BV1pK4y1C7es?p=1&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0">教你写一个简单的CPU</a>视频，实现一个简单的MIPS指令集CPU软核，掌握实践知识。不用完全写对，跟着写一遍知道各个模块是如何互相运作的即可。因为视频中没有测试文件测试各个模块，都是一口气写下来的。所以最终版仿真是跑不起来的，因为存在诸多bug。</p><p>在以上两个内容完成后，即可自己动手写一个RISC-V指令集的CPU软核了。</p><h3 id="思路">思路</h3><p>等待结构图中... ...</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;用Verilog实现一个简易RISC-V指令集CPU软核。&lt;/p&gt;
&lt;p&gt;本次实验是重庆大学2022级弘深计算机拔尖班计算机组成原理的实验项目。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="计算机组成原理" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>2024华为软件精英挑战赛游记</title>
    <link href="http://example.com/2024/03/24/2024%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%E6%B8%B8%E8%AE%B0/"/>
    <id>http://example.com/2024/03/24/2024%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%E6%B8%B8%E8%AE%B0/</id>
    <published>2024-03-24T03:44:25.000Z</published>
    <updated>2024-03-29T17:51:52.018Z</updated>
    
    <content type="html"><![CDATA[<p>初赛正式赛35名，遗憾离场，略微可惜。</p><span id="more"></span><h3 id="第一周">第一周</h3><p>参加这个比赛也是心血来潮。一方面想着现在已经大二了，保研之前要丰富一下自己的简历，另一方面我还从没参加过企业举办的大型赛事，而且去看了下历年的题目，都是用算法去解决实际问题，对我来说蛮有吸引力。所以拉上我们班一位同学就去参加了。（比赛要求三个人所以去网上又找了一个重邮研二的）</p><p>报了名之后就没管了，一直到赛题发布的那一天。</p><p>第一眼看到赛题感觉有点难蚌，我之前去看了22、23年的华为软挑真题，认为23年既然已经考过这种控制机器人移动做任务的题目，那么24年考这个的概率就不大了。24考的题应该更接近于22年这种调度问题。没成想，24年居然还是机器人移动（当然也是包括调度问题的）。</p><p>第一天，看了看题目，下午和队友在线上开了个会，每个人分别讲了讲自己对赛题的理解。大致确定下了本题核心任务：调度+ 控制。</p><p>调度即为考虑机器人搬哪些货物，去哪个泊位；船去哪个泊位，什么时候回家，什么时候转运。调度问题为了简单起见，都是选择的编码难度最容易的调度方式。即机器人选最贵的物品，机器人选有船要来且最近的泊位，船满了就走先不考虑转运情况。</p><p>控制即操控机器人在最短时间内走到目标点。因为地图数据规模不大，所以我们选用每一步每一个机器人bfs一遍的策略。</p><p>晚上，我根据上面的思路，写了一个文字框架以及如何维护关键参数的思路：</p><p><img src="1.png" /></p><p>写完框架后就摆烂了几天，主要那几天刚好事特别多... ...</p><p>最后在周末的时候，拉着我同学，花了大概2个多小时，一起对着上面的文字框架实现了一个基本的代码框架。并确定好了分工，他负责最短路算法以及机器人的运动，我负责船以及泊位的调度部分。</p><p>（P.S.考虑到因为第三个队友跟我们不在同一个学校，不方便同时维护一份代码，所以让他根据自己想法写一个版本，无需受我写的文字框架的约束。兵分两路策略。）</p><h3 id="第二周">第二周</h3><p>到了比赛第二个星期，首先星期一星期二熬大夜把我负责的部分写完了。然后周末同学把他负责的那一部分也写完了。可是不能跑，机器人跑了几百帧就卡死了。于是周末的两个晚上，继续熬大夜，修复代码中的小BUG。最后成功让代码跑起来了，第一次有分。</p><p><img src="2.png" /></p><p>跑出分说明代码框架已经没问题了，但是仍然存在跑了几百帧后几个机器人撞一块再也不动的情况。说明碰撞部分还是存在BUG。</p><p>于是我改变了原先解决碰撞的策略，在原先只有等待机制的情况下，引入失控机制：</p><ol type="1"><li>俩机器人即将碰撞时，其中一个机器人进行等待模式，另一个机器人继续动</li><li>俩机器人若在同一个地方死锁，其中一个机器人进入等待模式，另一个机器人进入失控模式</li><li>等待模式的机器人原地不动，失控模式的机器人乱走</li></ol><p>最后解决了碰撞问题，确定了我们组的baseline代码，8w分。</p><p><img src="3.png" /></p><h3 id="第三周">第三周</h3><p>最忙的一周。几乎每天都熬到3、4点。主要问题就是优化baseline。其实优化之处还是非常多的。我按照我们的代码版本顺序来讲讲每个版本优化了哪些地方吧。</p><ul><li><p>v1.0</p><ul><li>baseline版本</li></ul></li><li><p>v2.0</p><ul><li>机器人挑选物品由原先的挑最贵的，变为挑val（物品价值） /dis（机器人与物品的最短距离）最大的</li><li>机器人由原先的锁定泊位，改为了锁定泊位的具体坐标</li></ul></li><li><p>v3.0</p><ul><li><p>我同学想出了一个“革命性”的优化，不用每一步都对每个机器人求最短路，只需在机器人每次改变目标点时或者碰撞后求一个最短路就好了。将时间由原先的几乎一半时间都掉帧，优化到了几乎不掉帧</p></li><li><p>完善了失控机制，原地等待wait_max_tim帧后同样进入失控状态，解决死锁</p></li><li><p>调整了失控策略，由原先的4个方向顺序去搜变为4个方向随机数去走，避免来回踱步</p></li><li><p>新增更换目标机制，若机器人road_tim帧内没到达目标，则会更换目标，解决死锁</p></li></ul></li><li><p>v3.5</p><ul><li>规范了v3.0的代码风格和缩进</li><li>略微调整了参数</li></ul></li><li><p>v4.0</p><ul><li>初始时令每个机器人去到离他自己最近的泊位，将十个机器人分配到十个泊位上，避免陷入局部最优解</li><li>改变了机器人确定目标泊位的策略：由原先的去已blocked的最近泊位改为去最近的泊位</li><li>增加了船转运的功能，如果超过最低容量且一定时间内没装载，则去别的泊位装货</li></ul></li><li><p>v5.0</p><ul><li>每个泊位里新增了一个队列q，可以统计泊位上的货物情况</li><li>优化了船挑选目标泊位的策略，由原先的去最大价值泊位变成去能取到最大价值的泊位</li></ul></li><li><p>v6.0</p><ul><li>增加了泊位聚类功能，可设置距离阈值控制聚类范围（这是个负优化，悲）</li><li>增加了船排队功能，可设置每个泊位最多等待船数</li></ul></li></ul><p>当写完这7个版本的代码后，还剩2天就正式赛了。此时的代码在练习赛排行榜处于44名。于是剩下两天试图继续优化代码，可是我们写了很多优化最后都是负优化并无很大提升。于是最后一天用ChatGpt写了一个python调参程序开始炼丹。</p><h3 id="正式赛">正式赛</h3><p>正式赛在第三周的周六。上午队友交了一发13名。后面大家陆陆续续起床了，排名就被刷到20多名了。正式赛这一天我们继续改了改泊位的调度思路，可是没啥正优化。最后排名被刷到30名。最后几个小时没有啥思路了，于是对着两个地图开始炼丹。最后交了几发提升了几千分，封榜前，排名上升到了29名（笑。</p><p>周天晚8点多去看了看晋级名单，35名。看来差一点。</p><p><img src="4.png" /></p><h3 id="后记">后记</h3><p>第一次参加软挑，然后蛮有收获的。首先，第一次维护那么长（臭）的代码，接近1k行代码。极大了提高了我编码和debug能力。其次让我知道了面向对象的重要性。下次再写这种大型项目最好用面向对象。其次，团队之间的合作也是非常重要的，就像这次比赛有两个突破性的难点都是我同学大佬想出来的。</p><p>最后，希望大家身体健康，学业顺利！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;初赛正式赛35名，遗憾离场，略微可惜。&lt;/p&gt;</summary>
    
    
    
    <category term="3. 竞赛" scheme="http://example.com/categories/3-%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理自学笔记</title>
    <link href="http://example.com/2024/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-26T17:06:20.000Z</published>
    <updated>2024-03-28T15:22:38.344Z</updated>
    
    <content type="html"><![CDATA[<p>更新中... ...</p><p>资料来源：ChatGPT、课件</p><span id="more"></span><h3 id="一.-汇编">一. 汇编</h3><ul><li><p>在线RISC-V汇编编写网站：<ahref="https://venus.kvakil.me/">venus</a></p></li><li><p>更多指令细节请参考：<ahref="https://inst.eecs.berkeley.edu/~cs61c/fa23/pdfs/resources/reference-card.pdf">CS61C Reference Card</a></p></li><li><p>RISC-V的大部分指令长度固定，为32位。每条指令都是由32个0/1序列组成。</p></li><li><p>寄存器：RISC-V中，寄存器是处理器内部用于存储数据的小存储单元。它们可以非常快速地被访问和写入，比起访问主内存来说速度要快得多。</p></li><li><p>RISC-V定义了一组32个通用寄存器，编号从0到31。在代码中就是x0, x1,x2, ..., x31。</p><p><img src="1.png" /></p></li></ul><ol type="1"><li><p>R(register)型指令：操作寄存器操作的指令</p><ul><li>格式：<img src="2.png" /></li><li>opcode操作码，rd目标寄存器号，rs1/rs2第一/二个源寄存器号，funct3附加操作码，funct7附加操作码。</li><li>add x3, x1, x2（+）</li><li>sub x3, x1, x2（-）</li><li>and x3, x1, x2（&amp;）</li><li>or x3, x1, x2（|）</li><li>xor x3, x1, x2（^）</li></ul></li><li><p>I(immediate)型指令：寄存器与常数操作的指令</p><ul><li>格式：<img src="3.png" /></li><li>immediate立即数。</li><li>addi x1, x2, 10</li><li>slti x1, x2, 15：如果x2小于15，将x1设置位1。否则设置为0</li><li>andi x1, x2, 0xFF：寄存器与常数进行&amp;操作</li><li>ori x1, x2, 0xFF</li><li>xori x1, x2, 0xFF</li><li>slli x1, x2, 2（将x2右移2位结果存到x1中）</li><li>ld x1, 0(x5)：从内存地址 x5+0 处加载 64 位的值到 x10</li></ul></li><li><p>S(store)型指令：寄存器与内存操作的指令</p><ul><li>格式：<img src="4.png" /></li><li>rs1访存基址寄存器编号，r2源操作数寄存器编号，imm立即数（表示从基址开始的偏移量。</li><li>sw x1, 10(x2)：将x1内容存储到x2为基址，偏移量为10的内存地址中</li></ul></li><li><p>B(branch)型指令：程序的有条件跳转指令</p><ul><li>格式：<img src="5.png" /></li><li>imm立即数：表示要跳转的语句的地址。</li><li>beq x1, x2, label：如果x1==x2，程序跳转到label处</li><li>blt(Branch less than) x1, x2, label：如果x1 &lt;x2，程序跳转到label处</li><li>bgt(Branch greater than) x1, x2, label：如果x1 &gt;x2，程序跳转到label处</li><li>bgtz(Branch greater than zero) x1label：如果x1大于0，程序跳转到label处</li><li>bgez(Branch greater or equal to zero) x1label：如果x1大于等于0，程序跳转到label处</li></ul></li><li><p>J(jump)型指令：程序的无条件跳转指令</p><ul><li>格式：<img src="6.png" /></li><li>也可以叫UJ(Unconditional Jump)指令。</li><li>jr rd：跳转到rd寄存器存的地址那里</li><li>jal x1,offset：跳转到当前指令地址加上offset的位置，并将下一条指令的地址存入x1中</li></ul></li><li><p>U(upper immediate)型指令：将20位立即数加载到寄存器的高位<br /></p><ul><li>格式：<img src="7.png" /></li><li>lui x1 imm：将20位立即数imm加载到x1的高20位，低12位清零</li></ul></li></ol><ul><li>练习题：写一个斐波那契数列程序</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">fib</span><span class="operator">:</span></span><br><span class="line"><span class="variable">addi</span> <span class="variable">sp</span><span class="operator">,</span> <span class="variable">sp</span><span class="operator">,</span> <span class="operator">-</span><span class="number">16</span><span class="type">#</span> 开辟<span class="number">16</span>字节的栈空间</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">ra</span><span class="operator">,</span> <span class="number">0</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span><span class="type">#</span> 保存函数地址</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">a0</span><span class="operator">,</span> <span class="number">4</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span><span class="type">#</span> 保存参数<span class="variable">n</span><span class="operator">,</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable">addi</span> <span class="variable">t0</span><span class="operator">,</span> <span class="variable">x0</span><span class="operator">,</span> <span class="number">2</span><span class="type">#</span> <span class="variable">t0</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    <span class="variable">blt</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">t0</span><span class="operator">,</span> <span class="type">less_or</span><span class="type">_equal</span><span class="type">_than</span><span class="type">_one</span><span class="type">#</span> 如果<span class="variable">n</span> <span class="operator">&lt;=</span> <span class="number">1</span>，直接返回<span class="variable">n</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable">addi</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span><span class="type">#</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">jal</span> <span class="variable">ra</span><span class="operator">,</span> <span class="variable">fib</span><span class="type">#</span> 执行<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">    <span class="variable">add</span> <span class="variable">t1</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">x0</span><span class="type">#</span> 将<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span>的结果存到<span class="variable">t1</span>中</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">t1</span><span class="operator">,</span> <span class="number">8</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span><span class="type">#</span> 将结果存到栈中</span><br><span class="line">    </span><br><span class="line">    <span class="variable">lw</span> <span class="variable">a0</span><span class="operator">,</span> <span class="number">4</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span><span class="type">#</span> 恢复参数<span class="variable">n</span><span class="operator">,</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span></span><br><span class="line">    <span class="variable">addi</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span><span class="type">#</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span></span><br><span class="line">    <span class="variable">jal</span> <span class="variable">ra</span><span class="operator">,</span> <span class="variable">fib</span><span class="type">#</span> 执行<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">    <span class="variable">add</span> <span class="variable">t2</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">x0</span><span class="type">#</span> 将<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span>的结果存到<span class="variable">t2</span>中</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">t2</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span><span class="type">#</span> 将结果存到栈中</span><br><span class="line">    </span><br><span class="line">    <span class="variable">lw</span> <span class="variable">t1</span><span class="operator">,</span> <span class="number">8</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span><span class="type">#</span> 重新把结果读到<span class="variable">t1</span>中</span><br><span class="line">    <span class="variable">lw</span> <span class="variable">t2</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span><span class="type">#</span> 重新把结果读到<span class="variable">t2</span>中</span><br><span class="line">    </span><br><span class="line">    <span class="variable">add</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">t1</span><span class="operator">,</span> <span class="variable">t2</span><span class="type">#</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">    <span class="variable">lw</span> <span class="variable">ra</span><span class="operator">,</span> <span class="number">0</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span><span class="type">#</span> 恢复当前<span class="variable">fib</span>的返回地址</span><br><span class="line">    <span class="variable">addi</span> <span class="variable">sp</span><span class="operator">,</span> <span class="variable">sp</span><span class="operator">,</span> <span class="number">16</span><span class="type">#</span> 恢复栈空间</span><br><span class="line">    <span class="variable">jr</span> <span class="variable">ra</span><span class="type">#</span> 返回到调用<span class="variable">fib</span>函数的地方</span><br><span class="line">    </span><br><span class="line"><span class="type">less_or</span><span class="type">_equal</span><span class="type">_than</span><span class="type">_one</span><span class="operator">:</span></span><br><span class="line"><span class="variable">addi</span> <span class="variable">sp</span><span class="operator">,</span> <span class="variable">sp</span><span class="operator">,</span> <span class="number">16</span><span class="type">#</span> 栈空间恢复</span><br><span class="line">    <span class="variable">add</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">x0</span><span class="type">#</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="variable">n</span></span><br><span class="line">    <span class="variable">jr</span> <span class="variable">ra</span><span class="type">#</span> 返回</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;更新中... ...&lt;/p&gt;
&lt;p&gt;资料来源：ChatGPT、课件&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="计算机组成原理" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Python进阶</title>
    <link href="http://example.com/2024/02/24/Python%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2024/02/24/Python%E8%BF%9B%E9%98%B6/</id>
    <published>2024-02-24T08:49:18.000Z</published>
    <updated>2024-03-26T06:02:00.149Z</updated>
    
    <content type="html"><![CDATA[<p>说是进阶，其实就讲了三个数据分析常用包：numpy、pandas、matplotlib</p><span id="more"></span><h3 id="numpy">numpy</h3><ul><li>其实就是列表，但是好处就是速度快、操作方便、许多好用的数学计算接口</li></ul><h4 id="定义">定义</h4><ul><li>通过列表定义<ul><li>a = [0, 1, 2, 3] arr = np.array(a)</li><li>arr = np.array([0, 1, 2, 3])</li></ul></li><li>初始化为全0/1/指定元素<ul><li>np.zeros(5) # 结果为array([0., 0., 0., 0., 0.])</li><li>np.ones(5) # 结果为array([1., 1., 1., 1., 1.])</li><li>.zeros和.ones默认都是小数，改为整数可以写.zeros(5, dtype='int')</li><li>a.fill(3)：将a的所有元素改为3（注意这里a要是一个ndarray类型）</li></ul></li><li>生成整数数列<ul><li>np.arrange(l, r, d)：在[l, r)内，从l开始，每次递增d</li></ul></li><li>生成随机数<ul><li>np.random.rand(10)：生成10个[0, 1)的随机数</li><li>np.random.randn(10)：生成10个服从标准正态分布的随机数</li><li>np.random.randint(l, r, 10)：生成10个在[l, r)范围内的随机整数</li></ul></li></ul><h4 id="属性">属性</h4><ul><li>a.dtype：查看a里元素的类型</li><li>a.shape：返回一个元组，里面元素分别代表每一维元素的数目</li><li>a.ndim：查看维度</li><li>a.size：查看元素个数</li><li>a.astype('float')：返回将a内元素类型转换为float后的结果</li></ul><h4 id="运算">运算</h4><ul><li><p>ndarray支持切片，同时可直接与数字/ndarray进行运算</p></li><li><p>注意复制的时候不能像列表那样用a[:]切片复制，要使用.copy()来复制</p></li><li><p>a + 1：每个元素+1</p></li><li><p>a * 5：每个元素*5</p></li><li><p>a + b：两个ndarray对应元素相加</p></li><li><p>a * b：两个ndarray对应元素相乘</p></li><li><p>a / b：两个ndarray对应元素相除</p></li></ul><h4 id="多维情况">多维情况</h4><ul><li><p>np.zeros((2, 3))：创建2行3列的全零ndarray</p></li><li><p>np.ones((2, 3))：创建2行3列的全一ndarray</p></li><li><p>a.fill(3)：将a全部元素换为3</p></li><li><p>a[1, 2]：访问第1行第2列的元素</p></li><li><p>a[1]：返回第一行，以ndarray形式</p></li></ul><h4 id="常用函数">常用函数</h4><ul><li>np.sort(a)：返回将a排序后的结果</li><li>np.argsort(a)：返回每个元素在排序过后所处的排名（排名从0开始）</li><li>np.sum(a)：求和</li><li>np.max(a)：求最大值</li><li>np.mean(a)：求均值</li><li>np.vstack((a, b))：纵向堆叠</li><li>np.hstack((a, b))：横向堆叠</li><li>np.dstack((a, b))：维度上堆叠</li></ul><h4 id="矩阵运算">矩阵运算</h4><ul><li><p>a.T：转置</p></li><li><p>np.eye(3)：产生一个3*3的单位矩阵</p></li><li><p>np.dot(a, b)：返回俩矩阵相乘的结果</p></li><li><p>np.linalg.det(a)：求矩阵的行列式</p></li><li><p>np.linalg.inv(a)：求矩阵的逆矩阵</p></li><li><p>np.diagonal(a)：提取矩阵的对角线元素，返回一个一维ndarray</p></li><li><p>np.diag(a)：这里a是一个一维ndarray，返回一个以a为对角线元素的矩阵</p></li><li><p>矩阵只保留对角线元素：先np.digonal()，再np.diag()一下即可</p></li></ul><hr /><h3 id="pandas">pandas</h3><ul><li>提供了许多处理数据的接口</li></ul><h4 id="series">Series</h4><ul><li>pd.Series([1, 3, 5, nan,7])：创建一个Series，其实Series跟列表差不多，就是多了一个索引index。列表的索引就是下标0,1, 2, ...，Series索引默认也是0, 1, 2，但是可以自己更改</li><li>a.values：返回a的值</li><li>a.index：返回a的键</li></ul><h4 id="dataframe">DataFrame</h4><ul><li>DataFrame其实就是一个二维数组，但是有表头。行表头叫做columns，列表头叫做index</li><li>a =pd.read_excel('路径')：把一个excel表文件读入到一个dataframe变量中</li><li>a.head()：查看前5行</li><li>a.tail()：查看后5行</li></ul><hr /><h3 id="matplotlib">Matplotlib</h3><ul><li><p>matplotlib 是一个Python 的2D图形包。pyplot封装了很多画图的函数。所以在实际的使用过程中，常常以plt作为 matplotlib.pyplot 的省略</p></li><li><p>plt.show()：显示图像</p></li><li><p>plt.title("xxx")：设置图像标题</p></li><li><p>plt.ylabel("xxx")：对y轴命名</p></li><li><p>plt.xlabel("xxx")：对x轴命名</p></li><li><p>在上面仨方法中，可使用fontsize参数对字体大小进行设置</p></li><li><p>plt.axis([xmin, xmax, ymin, ymax])：：改变坐标轴范围</p></li><li><p>plt.plot([a1, a2, ..., an], [b1, b2, ...,bn])：前一个列表是x轴，后一个列表是y轴</p></li><li><p>在plot方法中，linewidth参数可以设置线条宽度</p></li><li><p>字符参数（直接写在plot在第三个参数即可，例如'bs:'蓝色正方形标点,点线）</p><table><thead><tr class="header"><th>字符</th><th>颜色</th></tr></thead><tbody><tr class="odd"><td>'b'</td><td>蓝色</td></tr><tr class="even"><td>'g'</td><td>绿色</td></tr><tr class="odd"><td>'r'</td><td>红色</td></tr><tr class="even"><td>'c'</td><td>青色</td></tr><tr class="odd"><td>'m'</td><td>品红</td></tr><tr class="even"><td>'y'</td><td>黄色</td></tr><tr class="odd"><td>'k'</td><td>黑色</td></tr><tr class="even"><td>'w'</td><td>白色</td></tr></tbody></table><table><thead><tr class="header"><th>字符</th><th>类型</th></tr></thead><tbody><tr class="odd"><td>'--'</td><td>虚线</td></tr><tr class="even"><td>'-.'</td><td>虚点线</td></tr><tr class="odd"><td>':'</td><td>点线</td></tr><tr class="even"><td>'.'</td><td>坐标点标点</td></tr><tr class="odd"><td>'s'</td><td>坐标点正方形</td></tr><tr class="even"><td>......</td><td>更多请查阅资料</td></tr></tbody></table></li><li><p>还可以通过plt.plot(x, y, marker = 'x', color ='black')来设置点的形状和颜色</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;说是进阶，其实就讲了三个数据分析常用包：numpy、pandas、matplotlib&lt;/p&gt;</summary>
    
    
    
    <category term="2. 技能栈" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/"/>
    
    <category term="Python" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="http://example.com/2024/02/23/Python%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/02/23/Python%E5%9F%BA%E7%A1%80/</id>
    <published>2024-02-23T15:08:48.000Z</published>
    <updated>2024-03-26T07:46:08.339Z</updated>
    
    <content type="html"><![CDATA[<p>什么？你连基本的Python相关知识都不会？</p><span id="more"></span><h3 id="顺序判断循环">顺序、判断、循环</h3><ol type="1"><li><p>变量类型</p><ol type="1"><li>int、float、str、bool</li><li>list（列表）[1, 2, 3]</li><li>tuple（元组）(1, 2, 3)</li><li>set（集合）{1, 2, 3}</li><li>dict（字典）{1: “python”, “acwing”: 2, 3: 4.0}</li></ol></li><li><p>输入</p><ul><li><p>使用input()函数，input()函数可读入一行内容，返回类型为str。一般配合split()、map()函数使用。</p><ul><li>a = (int)(input()) b =(int)(input())：读入两个整数，一个整数一行。</li><li>a, b = map(int, input().split())：读入两个空格隔开的整数。</li><li>split()会将一行字符串以空格作为分割符分开，返回一个字符串列表。map(func,var)会将func作用于var里的每个元素，返回作用后的var。</li><li>a = list(map(int, input().split())))：读入一行数存到列表a中</li></ul></li><li><p>当不知道读入的行数时，使用下列代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdin</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> stdin.readlines():</span><br><span class="line">  <span class="built_in">print</span>(line.strip()) <span class="comment"># strip()是为了去掉行末的回车</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>输出</p><ul><li>print(val1, val2, ...,end='')：输出多个内容默认用空格隔开，可自定义结尾字符<ul><li>round(x, 1)：将x保留1位小数</li><li>print("x = %.2f, y = %.3f" % (x,y))：同样也可以用格式化输出（%分割，后面多个参数的话要用括号括起来）</li><li>格式化输出想输出%的话，写%%</li></ul></li></ul></li><li><p>if/while/for里的变量，在语句外可以访问</p><ul><li><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">max_value = a</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">max_value = b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(max_value)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>条件表达式</p><ol type="1"><li>and、or、not：与或非</li><li>max_value = a if a &gt; b elseb：三目运算符，max_value=a仅当a&gt;b时成立，否则=b</li></ol></li><li><p>运算</p><ol type="1"><li>a, b = b, a：交换两个数</li><li>python支持链式运算，例如if a &gt;= b &gt;= c: ...</li></ol></li><li><p>for循环</p><ol type="1"><li>for c in "abc"：依次输出每个字符</li><li>for i in range(r)：输出0, 1, ..., r - 1</li><li>for i in range(l, r)：输出l, l + 1, ... , r - 1</li><li>for i in range(l, r + 1, 2)：在[l, r]范围内，输出l, l + 2, l + 4,...</li></ol></li></ol><hr /><h3 id="列表">列表</h3><ul><li>初始化<ul><li>用循环 + append初始化</li><li>直接初始化<ul><li>a = [0 for i in range(3 + 1)]：a此时为[0, 0, 0, 0]</li><li>a = [i * i for i in range(3 + 1)]：a此时为[0, 1, 4, 9]</li></ul></li></ul></li><li>切片<ul><li>a[l:r]：返回a[l], a[l+1], ..., a[r-1]（l、r可缺省）</li><li>a[1:]：返回a[1], a[2], ... a[len(a) - 1]</li><li>a[1:3] = [2, 3]：等价于a[1]=2, a[2]=3</li><li>a[1:3] = [0]：等价于a[1]=0，把a[2]删掉</li><li>a[1:3] = []：等价于把a[1]、a[2]删掉</li></ul></li><li>复制<ul><li>不能用等号复制，用等号复制的话相当于新列表只是原列表的一个别名。修改新列表仍会对原列表产生影响。</li><li>用切片复制即可，即b = a[:]</li></ul></li><li>列表的运算<ul><li>列表的加法可以将两个列表拼接起来，得到一个新列表。</li><li>列表乘以一个整数，可以将若干个自身拼接起来，得到一个新列表。</li><li>将列表中的每个元素加上一个1<ul><li>a = [x + 1 for x in a]</li></ul></li></ul></li><li>列表常用函数<ul><li>len(a)：返回列表长度</li><li>a.append(x)：尾部插入x</li><li>a.insert(pos, x)：在pos处插入x</li><li>a.pop()：删除尾部最后一个元素</li><li>a.pop(pos)：删除下标为pos处的元素</li><li>a.reverse()：翻转</li><li>a.sort()：排序<ul><li>a.sort(key=lambda x: (x[1],x[0]))：a是一个列表，列表里的元素也是列表（里头有2个数），想先按照第二关键字排序，相等再按照第一关键字排序，就这样写。（默认是从小到大，从大到小可以加一个负号）</li></ul></li></ul></li></ul><hr /><h3 id="字符串">字符串</h3><ul><li>ord(c)：返回一个字符的ascii码</li><li>chr(a)：返回一个ascii码对应的字符</li><li>注意，虽然字符可以跟整数相互转化，但在Python中字符不能参与数值运算</li><li>使用""直接赋值，使用""" """可以赋值多行</li><li>字符串不能修改，切片也不像列表一样支持写操作</li><li>字符串支持加法、乘法、比较运算</li><li>常用函数<ul><li>len(s)：返回字符串长度</li><li>s.split(sep)：返回一个字符串列表。如果给出了sep就按sep分隔；如果没给出，则会按空格分隔，但连续的空格会被视为单个分隔符，而且会忽略首尾的空白字符。</li><li>s.strip()：返回将首尾的空白字符删除后的结果</li><li>s.replace(old, new)：将s中所有的old子串都改成new</li><li>s.find("abc")：查询某个子串在s中第一次出现的下标；如果不存在，则返回-1。</li><li>s.lower()：将所有大写字母变成小写。</li><li>s.upper()：将所有小写字母变成大写。</li><li>s.join(a)：a是一个字符串列表，这个函数返回将a中的字符用s作为分隔符拼接起来的结果。</li><li>s.startswith(prefix)：判断prefix是否为s的前缀。</li><li>s.endswith(suffix)：判断suffix是否为s的后缀。</li></ul></li></ul><hr /><h3 id="元组">元组</h3><ul><li><p>元组跟列表类似，只是不支持动态添加、删除元素，以及不能修改元素。其余用法类似。</p></li><li><p>元组需要用小括号括起来（也可以不加），中间的元素用逗号隔开。如果初始化只包含一个元素的元组，需要在该元素后添加逗号。</p></li><li><p>元组的解包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">x, y, z = t <span class="comment"># 将元组t解包，将元组内的三个值按顺序赋值给x、y、z</span></span><br><span class="line"></span><br><span class="line">a, b = b, a <span class="comment"># 这句话本质也是元组解包，就是将元组(b, a)解包，分别赋值给a, b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y, x * y <span class="comment"># 函数的返回值本质也是元组的解包</span></span><br><span class="line"></span><br><span class="line">a, b = cal(a, b)</span><br></pre></td></tr></table></figure></li></ul><hr /><h3 id="集合">集合</h3><ul><li><p>创建集合用花括号或set()函数。创建空集合只能用set()，不能用{}，因为{}创建的是空字典。</p></li><li><p>初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;  <span class="comment"># 会自动去除重复元素</span></span><br><span class="line"><span class="built_in">print</span>(basket)  <span class="comment"># 重复的元素已经去除了</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">b = <span class="built_in">set</span>(a)  <span class="comment"># 将列表转化成集合，一般是为了去重。</span></span><br><span class="line">c = <span class="built_in">list</span>(b)  <span class="comment"># 将集合转化回列表</span></span><br><span class="line"><span class="built_in">print</span>(b, c)</span><br></pre></td></tr></table></figure></li><li><p>常用函数</p><ul><li>len(a)：返回集合中的元素数量</li><li>a.add(x)：向集合中添加一个元素</li><li>a.remove(x)：删除集合中的x，如果集合中没x则报错</li><li>a.discard(x)：删除集合中的x，如果集合中x不存在也不会管</li><li>x in a：判断x是否在a中</li><li>x not in a：判断x是否不在a中</li></ul></li></ul><hr /><h3 id="字典">字典</h3><ul><li><p>创建字典用花括号或dict()函数。</p></li><li><p>初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tel = &#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;  <span class="comment"># 创建一个字典</span></span><br><span class="line"><span class="built_in">print</span>(tel)  <span class="comment"># 输出 &#123;&#x27;jack&#x27;: 4098, &#x27;sape&#x27;: 4139&#125;</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">dict</span>()  <span class="comment"># 创建一个空字典</span></span><br><span class="line">a[<span class="number">123</span>] = <span class="string">&quot;abc&quot;</span>  <span class="comment"># 在字典中插入一个key-value对</span></span><br><span class="line">a[<span class="number">456</span>] = <span class="string">&quot;def&quot;</span>  <span class="comment"># 在字典中插入一个key-value对</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出 &#123;123: &#x27;abc&#x27;, 456: &#x27;def&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">list</span>(a)  <span class="comment"># 将字典的关键字转化成列表</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出[123, 456]</span></span><br></pre></td></tr></table></figure></li><li><p>常用函数</p><ul><li>len(a)：返回字典中键值对个数</li><li>a[x]：获取关键字x对应的值，如果x不存在，会报异常</li><li>a.get(x)：获取关键字x对应的值，如果x不存在，不会报异常</li><li>a.get(x, y)：获取关键字x对应的值，如果x不存在，会返回默认值y</li><li>del a[x]：删除关键字x对应的元素对</li><li>x in a：字典中是否有x关键字</li><li>x not in a：字典中是否没有x关键字</li><li>a.keys()：返回字典中所有关键字，以列表形式</li><li>a.values()：返回字典中所有值，以列表形式</li><li>a.items()：返回字典中所有键值对，以列表形式，每对键值对是一个元组</li></ul></li></ul><hr /><h3 id="函数">函数</h3><ul><li>函数内定义的变量为局部变量，只能在函数内部使用。当需要修改用全局变量时，需要用global关键字在函数内声明全局变量。</li><li>传参时，传数/str是值传递，列表是引用传递。</li></ul><hr /><h3 id="类">类</h3><ul><li><p>类中函数的第一个参数都是self，用来调用类本身的变量和函数。当调用类中函数的时候，第一个参数self不需要自己传递，Python会自动传递这个参数。</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>:</span><br><span class="line">    hero_count = <span class="number">0</span>  <span class="comment"># 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, level=<span class="number">10</span></span>):  <span class="comment"># 构造函数</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.level = level</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hero %s has been created.&quot;</span> % name)</span><br><span class="line">        Hero.hero_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  <span class="comment"># 定义str()函数的效果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero: %s&quot;</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):  <span class="comment"># 问候</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):  <span class="comment"># 移动</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Move!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_level</span>(<span class="params">self</span>):  <span class="comment"># 获取这个英雄的等级</span></span><br><span class="line">        <span class="keyword">return</span> self.level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_level</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get_level() + <span class="number">1</span>  <span class="comment"># 调用类中的其他函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zeus = Hero(<span class="string">&quot;Zeus&quot;</span>)</span><br><span class="line">athena = Hero(<span class="string">&quot;Athena&quot;</span>, <span class="number">6</span>)</span><br><span class="line">zeus.greet()</span><br><span class="line">athena.move()</span><br><span class="line"><span class="built_in">print</span>(zeus.name, athena.get_level(), athena.next_level())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(zeus), athena)</span><br><span class="line"><span class="built_in">print</span>(Hero.hero_count)</span><br></pre></td></tr></table></figure></li><li><p>每个类可以创建任意多实例。例如上面的Hero类，可以创建zeus和athena等实例。类变量由所有实例共享，一般通过类名访问，例如Hero.hero_count。实例变量与每个具体的实例绑定，一般通过具体实例来访问，例如zeus.name。</p></li><li><p>子类可以继承父类的变量和函数。self可以调用自身和父类中的变量和函数，如果子类和父类的变量或函数重名，优先使用子类的变量和函数。super()可以优先调用父类中的函数。</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>:</span><br><span class="line">    hero_count = <span class="number">0</span>  <span class="comment"># 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, level=<span class="number">10</span></span>):  <span class="comment"># 构造函数</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.level = level</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hero %s has been created.&quot;</span> % name)</span><br><span class="line">        Hero.hero_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  <span class="comment"># 定义str()函数的效果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero: %s&quot;</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):  <span class="comment"># 问候</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):  <span class="comment"># 移动</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Move!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_level</span>(<span class="params">self</span>):  <span class="comment"># 获取这个英雄的等级</span></span><br><span class="line">        <span class="keyword">return</span> self.level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_level</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get_level() + <span class="number">1</span>  <span class="comment"># 调用类中的其他函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zeus</span>(<span class="title class_ inherited__">Hero</span>):</span><br><span class="line">    hero_name = <span class="string">&quot;Zeus&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(Zeus.hero_name, level)  <span class="comment"># 通过super()调用父类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!(from child class)&quot;</span> % self.name)  <span class="comment"># 使用的是父类的`name`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Athena</span>(<span class="title class_ inherited__">Hero</span>):</span><br><span class="line">    hero_name = <span class="string">&quot;Athena&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(Athena.hero_name, level)  <span class="comment"># 通过super()调用父类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!(from child class)&quot;</span> % self.name)  <span class="comment"># 使用的是父类的`name`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zeus = Zeus(<span class="number">6</span>)</span><br><span class="line">athena = Athena(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(zeus.name, athena.level, Hero.hero_count)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(zeus), <span class="built_in">str</span>(athena))</span><br><span class="line">zeus.greet()</span><br><span class="line">athena.greet()</span><br><span class="line"><span class="built_in">print</span>(zeus.get_level())</span><br></pre></td></tr></table></figure></li><li><p>模块可以自定义，自己新建一个文件夹，里头可以写若干个.py文件，但是一定要有一个空的__init__.py文件，这样Python才知道这个文件夹是一个模块。导入函数可以写：from文件夹名.文件名 import 函数名</p></li></ul><hr /><h3 id="包管理">包管理</h3><ul><li><p>使用conda进行包管理，以下命令使用Anaconda控制台打开</p></li><li><p>conda envlist：查看当前有哪些虚拟环境（*号是当前所处环境）</p></li><li><p>conda activate 环境名：进入某个虚拟环境</p></li><li><p>conda list：查看当前虚拟环境内安装了哪些包</p></li><li><p>conda install 包名：在当前虚拟环境内安装一个包</p></li><li><p>conda create -n xxx python=x.x：创建一个虚拟环境</p></li><li><p>conda remove -n xxx --all：删除一个虚拟环境</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么？你连基本的Python相关知识都不会？&lt;/p&gt;</summary>
    
    
    
    <category term="2. 技能栈" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/"/>
    
    <category term="Python" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>VS Code基本使用</title>
    <link href="http://example.com/2024/02/23/VS-Code%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2024/02/23/VS-Code%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2024-02-22T18:06:19.000Z</published>
    <updated>2024-02-26T17:29:07.592Z</updated>
    
    <content type="html"><![CDATA[<p>VS Code作为最常用的IDE，掌握其使用方法以及相关插件十分必要。</p><p>而且这玩意还可以通过Github同步配置，所以配置一次，永久享用。</p><p>而且VS Code里有终端，于是写项目配合git使用很方便。</p><span id="more"></span><h3 id="快捷键">快捷键</h3><ul><li>ctrl + ,：设置</li><li>ctrl + shift + p：命令面板</li><li>ctrl + p：最近文件列表</li><li>ctrl + j：切出下面板（用来在代码和终端输入间跳转）</li></ul><h3 id="插件">插件</h3><h4 id="code-runner">code runner</h4><ul><li>ctrl + alt + n：编译运行程序</li><li>ctrl + c：退出当前命令（死循环时退出运行）</li></ul><h4 id="wsl">WSL</h4><ul><li>直接在本地vscode登入进wsl子系统中的vscode</li><li>或者在wsl中输入code .进入vscode界面</li></ul><h4 id="git-graph">Git Graph</h4><ul><li>装了之后，直接在vscode中就可以查看提交/分支状态</li><li>可以查看每次commit的id/author/date/parents/与上一次commit的不同之处<ul><li>查看与任意一次commit的不同之处：先点一个，再按住ctrl点另一个</li></ul></li></ul><h4 id="todo-tree">Todo Tree</h4><ul><li>TODO表示待办，FIXME表示写了一半还没写完，BUG表示这段程序有问题，HACK表示这段程序可以优化，NOTE表示想法</li><li>这个插件除了方便写注释，还可以充当打标签的作用</li></ul><h4 id="bookmarks">Bookmarks</h4><ul><li>打标签，当程序很长的时候，用鼠标跳转很不方便，用书签跳转就很快。</li></ul><h4 id="jupyter">Jupyter</h4><ul><li>无需安装jupyter notebook即可在vscode实现相同功能</li><li>Esc + M：markdown模式</li><li>Esc + Y：代码模式</li><li>ctrl + enter：运行</li><li>Esc + D, D：删除该单元</li><li>Esc + B：在下方添加一个单元</li><li>Esc + A：在上方添加一个单元</li><li>Esc + L：显示行号</li></ul><h4 id="markdown-all-in-one-markdown-preview-enhanced">Markdown All inOne &amp; Markdown Preview Enhanced</h4><ul><li>第一个插件就是markdown插件，第二个是增强功能插件</li><li>第二个增强插件很强大，甚至可以渲染出matplotlib代码的图像。</li><li>ctrl + k, v：打开预览面板</li><li>``：行内代码</li><li>- [x]：任务列表</li><li>[^1]和[^1]: 配套使用 ：脚注</li><li>==xxx==：高亮</li><li>渲染plt代码图片：（只需将```python改为```python {cmd=truematplotlib=true}）<ul><li>这个功能只能在本地写markdo使用，hexo博客渲染不了</li></ul></li></ul><h4 id="draw.io-integration">Draw.io Integration</h4><ul><li>配合markdown使用，画流程图</li></ul><h4 id="markdown-table">Markdown Table</h4><ul><li>配合markdown使用，快速生成表格</li><li>选中一段文字，右键菜单中选择Markdown Table: Convert TSV totable就能把这段文字变成表格。</li><li>插入新的一行：当新行输入|，按tab补全</li><li>在某列左/右插入新的一列：选中当前列，右键菜单插入即可</li><li>当前列对齐方式：选中当前列，右键菜单选择即可</li><li>交换相邻两列：选中当前列，右键菜单选择即可</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;VS Code作为最常用的IDE，掌握其使用方法以及相关插件十分必要。&lt;/p&gt;
&lt;p&gt;而且这玩意还可以通过Github同步配置，所以配置一次，永久享用。&lt;/p&gt;
&lt;p&gt;而且VS Code里有终端，于是写项目配合git使用很方便。&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://example.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>SAI2的基本使用</title>
    <link href="http://example.com/2024/02/22/SAI2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2024/02/22/SAI2%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</id>
    <published>2024-02-22T15:57:31.000Z</published>
    <updated>2024-02-22T16:13:55.542Z</updated>
    
    <content type="html"><![CDATA[<p>SAI2的最最最基本使用（我不玩板绘）</p><span id="more"></span><p>因为最近接了一个线上一对一的算法家教，所以买了一块数位板（高漫1060pro）方便授课，然后下了个SAI2。</p><p>首先改板子的映射区，这个型号的板子对我来说太大了，手移动距离太多很累。所以把板子工作区域改小。</p><p>然后是改板子的快捷键，我板子的快捷键从上到下分别是：（对应着SAI2里的功能）</p><ul><li>选中、剪切</li><li>复制、粘贴</li><li>画笔、橡皮</li><li>ctrl、shift</li><li>文字、ESC</li><li>合并图层、画面居中</li></ul><p>所以设置好快捷键后，基本上只需要打开SAI2，然后在板子上操作就好了。不怎么需要去SAI2里操作了。</p><hr /><p>说一下SAI2的操作逻辑，首先是文字，每次输入文字SAI2都会新建一个图层，所以在输入完文字后要按ESC+ 合并图层，才能将文字和原本内容合并到同一图层中。</p><p>然后是粘贴，在你选中、复制、粘贴后，粘贴的内容会新开一个图层。所以需要按住ctrl移动到恰当位置后，按下合并图层，才能实现粘贴的内容和原内容在同一图层中。</p><hr /><p>最后是操作时遇到的一些问题：</p><ol type="1"><li>为什么切换到画笔后，写不出东西？<ul><li>可能是因为你选中了某个区域，没有取消就切换到画笔模式了。所以可以先按剪切后，再切换到画笔模式即可正常工作。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;SAI2的最最最基本使用（我不玩板绘）&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://example.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>算法刷题笔记</title>
    <link href="http://example.com/2024/02/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-19T16:27:02.000Z</published>
    <updated>2024-03-29T17:53:23.775Z</updated>
    
    <content type="html"><![CDATA[<p>信息学竞赛刷题笔记</p><span id="more"></span><h3 id="思维题">思维题</h3><ul><li><p><a href="https://www.acwing.com/problem/content/97/">95.费解的开关 - AcWing题库</a></p><ul><li>经过思考后，发现一个开关按2次与没按没差别。所以对于每个开关，要不就按，要不就不按。继续思考，对于一个开关，它的状态取决于它自己以及上下左右共5个开关按or不按，而且跟顺序无关。</li><li>接着往下想，既然与顺序无关，那我就可以从第一个开始按。假设（1，1）按了，那么......感觉还是不好想。</li><li>这时要学会给自己增加已知信息。假设我第一行开关按or不按已经知道。那么我就可以推出第二行的按法。因为当第一行按完之后，能改变第一行状态的只有第二行（不能再按第一行了，因为按两次等于没按）。所以如果（1，j）是0，那么（2，j）就要按。</li><li>思路就出来了，枚举第一行的按法，然后推出第二行按法，继续推出第三行按法，直至推出第五行按法。此时1-4行都是1了，最后检查第5行是否全是1即可。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/107/">105. 七夕祭- AcWing题库</a></p><ul><li><p>首先很容易看出行和列是独立的问题，而且本质是一样的。所以接下来都讨论列。</p></li><li><p>然后略加思考也可以发现最终每列的数量就是全部列加起来取平均，取不了平均就没解。</p></li><li><p>假设a1, a2, ...,an平均值为avg，假设1号给2号b1个，2号给3号b2个，n号给1号bn个。则所求可表达为：<spanclass="math inline">\(|b_1|+|b_2|+...+|b_n|\)</span>。且有下列方程组成立：<span class="math display">\[a1 - b1 + bn = avg \\a2 - b2 + b1 = avg \\a3 - b3 + b2 = avg \\... \\an - bn + b_{n-1} = avg\]</span></p></li><li><p>整理可得</p></li></ul><p><span class="math display">\[-b_1+b_n = avg - a_1 \\-b_2+b_n = 2avg - (a_1+a_2) \\-b_3+b_n = 3avg - (a_1+a_2+a_3) \\...-b_{n-1}+b_n = (n-1)avg - (a_1+a_2+...+a_{n-1})\]</span></p><ul><li>继续整理</li></ul><p><span class="math display">\[b_1 = -avg + a_1 + b_n \\b_2 = -2avg + (a_1 + a_2) + b_n \\... \\b_{n-1} = -(n-1)avg + (a_1+a_2+...+a_{n-1})\]</span></p><ul><li>继续整理</li></ul><p><span class="math display">\[b_1 = b_n - avg + a_1 \\b_2 = b_n - 2avg + (a_1+a_2) \\...\\b_{n-1} = b_n - (n-1)avg + (a_1+a_2+...+a_{n-1})\]</span></p><ul><li>令x = bn，则所求为：<spanclass="math inline">\(|x-c1|+|x-c2|+...+|x-c_{n-1}|+|x - c_n|,c_n=0\)</span></li><li>一目了然，x取c的中位数时，所求最小。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/1535/">1533. 1的个数 - AcWing题库</a></p><ul><li>考虑每一位能出现多少次1。</li></ul><p><img src="2.png" /></p><ul><li>如上图，考虑d，如果d是0。那么当d这一位取1的话，左边只能是000 ~(abc-1)，右边可以是000 ~ 999。上图都清晰明了了，分情况讨论即可。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/1643/">1641.狼人杀-简单版 - AcWing题库</a></p><ul><li>枚举哪两个人是狼人，那么此时所有人的身份就确定了。然后检查两个条件。(1):是否有且仅有两个人在说谎；(2):俩狼人中是否有且仅有一个人在说谎。若俩条件满足则是一组解。</li></ul></li></ul><h3 id="基础算法">基础算法</h3><h4 id="位运算">位运算</h4><ul><li><a href="https://www.acwing.com/problem/content/92/">90.64位整数乘法 - AcWing题库</a><ul><li>计算a * b %p的结果。O(1)即可得出结果，但是a和b的范围很大会爆longlong。所以要用时间换空间。考虑a* b = a * (b的二进制表示)，例如a * 5 = a * (101) = a * (4 + 0 +1)。于是很容易的想到用logn的时间去分解b，用个中间变量sum对自己做累加（sum初始值为a），这样sum就会等于a，然后等于2a，然后等于4a......。分解b的过程中如果最后一位二进制是1，就ans +=sum即可。这种用加法代替乘法的方法，叫做龟速乘。</li><li>注意，%的优先级比+高。</li></ul></li><li><a href="https://www.acwing.com/problem/content/877/">875. 快速幂 -AcWing题库</a><ul><li>计算<span class="math inline">\(a^b %p\)</span>的结果。思路跟龟速乘一样，都是分解b。考虑<spanclass="math inline">\(a^b = a^{b的二进制形式}\)</span>，例如<spanclass="math inline">\(a^5 = a^{101} = a^{4 + 0 + 1} = a^4 *a^1\)</span>。用while去分解b的二进制，用个中间变量sum对自己做累乘（sum初始值为b），如果分解过程中b的最后一位二进制是1，就ans*= sum即可。</li></ul></li></ul><h4 id="递归分治">递归/分治</h4><ul><li><a href="https://www.acwing.com/problem/content/description/99/">97.约数之和 - AcWing题库</a><ul><li>求<spanclass="math inline">\(a^b\)</span>的所有约数之和。不难想到分解质因数。假设数num分解为<spanclass="math inline">\(p_1^{k1} \cdot p_2^{k2} \cdot ... \cdotp_n^{kn}\)</span>，那么数num的约数的个数就是(k1 + 1) * (k2 + 1) * ... *(kn +1)（相当于每个质数是材料，可以拿0/1/2/...个）。数num的约数之和就是<spanclass="math inline">\((1+p_1+p_1^2+...+p_1^{k1}) \cdot(1+p_2+p_2^2+...+p_2^{k2}) \cdot ... \cdot(1+p_n+p_n^2+...+p_n^{kn})\)</span>。</li><li>上面的数学推导作为一个大学生不难想出。那么这题思路就是先将a分解质因数，然后将每个质数的次数乘b。然后求<spanclass="math inline">\((1+p_1+p_1^2+...+p_1^{k1}) \cdot(1+p_2+p_2^2+...+p_2^{k2}) \cdot ... \cdot(1+p_n+p_n^2+...+p_n^{kn})\)</span>即可。</li><li>关键<spanclass="math inline">\((1+p_1+p_1^2+...+p_1^{k1})\)</span>怎么求，其实这种看起来有规律的东西都是用递归去加速，根据直觉尝试一下，假设sum= 1, mul = p1，然后while( sum += mul, mul *= mul )。第一次：sum=1+p1,mul=p1<sup>2；第二次：sum=1+p1+p1</sup>2+p1^3, mul = p1^4......你看，这不就出来了。</li><li>递归是俩倍俩倍去递归的，所以最后可能剩一点边角料。假设<spanclass="math inline">\(p_1^{cnt}\)</span>到<spanclass="math inline">\(p_1^{k1}\)</span>还没求，很简单，直接递归调用函数cal(p1,k1-cnt) * ksm(p1, cnt)</li><li>这题坑点较多，注意b有可能为0。注意a可能为0/1。</li></ul></li><li><a href="https://www.acwing.com/problem/content/100/">98. 分形之城 -AcWing题库</a><ul><li>一道找规律模拟题，挺恶心的。本质上就是给一个数num，找出其对应的坐标（x,y）。观察后不难发现，num会落到4个区，其中2、3区的区内坐标就等于上一个等级的对应数的坐标。1区的区内坐标等于上一个等级的对应数的坐标沿[左上到右下对角线]对称的坐标。4区的区内坐标等于上一个等级的对应数的坐标沿[右上到左下对角线]对称的坐标。</li></ul></li></ul><h4 id="前缀和差分">前缀和/差分</h4><ul><li><a href="https://www.acwing.com/problem/content/101/">99. 激光炸弹 -AcWing题库</a><ul><li>简单二维前缀和</li></ul></li><li><a href="https://www.acwing.com/problem/content/102/">100. 增减序列- AcWing题库</a><ul><li>差分题。最关键的一步是要联想到看一看差分数组。做题多就有经验了，这种区间操作问题一般要想到转换为差分数组，然后区间操作问题就转为端点修改问题。</li><li>将a转化为差分数组b后，这题就变成了，将b2~bn全部变为0的最少次数是多少？在最少次数的前提下，b1有多少种取值方式？每一次区间操作等价于将<spanclass="math inline">\(b_i\)</span>加或减1，<spanclass="math inline">\(b_j\)</span>加或减1（i &lt; j &amp;&amp; 1 &lt;= i&lt;= n &amp;&amp; 2 &lt;= j &lt;= n + 1）</li><li>然后由于贪心思想，尽可能将b2~bn中的正负数抵消掉。剩下抵消不掉的数的绝对值+1其实就是b1的不同取值个数。因为剩下不能凑对抵消的只能通过和b1或者<spanclass="math inline">\(b_{n+1}\)</span>凑对来抵消。选择用b1凑对多少次，b1就有多少种取值方式。</li></ul></li></ul><h4 id="二分">二分</h4><ul><li><ahref="https://www.acwing.com/problem/content/description/104/">102.最佳牛围栏 - AcWing题库</a><ul><li>看到平均数就想到整体减平均数，假设答案是一个数，然后每个数减掉这个数，那么只要找出一段区间长度&gt;=f的区间和&gt;=0就可以了。只要找出这样的区间。说明答案还可以更大，如果找不出，答案就要减小。所以二分答案即可。</li><li>关键是如何找到“一段区间长度&gt;=f的区间和&gt;=0”，如果没有区间长度限制O(n)扫一遍用最大连续子段和即可。主要有区间限制，那么就多开一个数组minn[i]表示截止到0~i位置中sum[i]中的最小值即可。（其实这也是最大连续子段和的另一种做法）</li></ul></li><li><a href="https://www.acwing.com/problem/content/1484/">1482. 进制 -AcWing题库</a><ul><li>首先将已知进制的数转为十进制。然后枚举另一个数的进制即可。但是另一个数的进制可能非常大。而且满足进制数越大，转换后的数就越大。所以可以二分。二分右边界是多少呢？极端一点，假设第二个数是10，第一个数是target进制。那么右端点至少要到（第一个数拉满的target进制转为的十进制）才行。</li><li>坑点：如果当前数为tar进制，那么当前数的每一位数都要在[0,tar)中。</li></ul></li></ul><h4 id="排序">排序</h4><ul><li><ahref="https://www.acwing.com/problem/content/description/115/">113.特殊排序 - AcWing题库</a><ul><li>本质上就是裸排序题，用归并或者快排把&lt;号换成题中的compare即可。</li></ul></li></ul><h3 id="贪心">贪心</h3><ul><li><ahref="https://www.acwing.com/problem/content/description/1519/">1517.是否加满油 - AcWing题库</a><ul><li>很多细节的贪心模拟题。</li><li>思路就是在当前加油站，在最远能行驶的距离之内找到第一个价钱比当前加油站低的加油站，然后开过去。如果找不到，就找价钱最少的，然后在当前加油站加满油开过去。如果一个加油站都找不到，就输出无解。</li></ul></li></ul><h3 id="数学">数学</h3><ul><li><a href="https://www.acwing.com/problem/content/1588/">1586.连续因子 - AcWing题库</a><ul><li>用分解因数的方法去枚举连续因子的开头，然后对于每个开头，看看最多能连多少个，取个max即可。</li></ul></li></ul><h3 id="数据结构">数据结构</h3><h4 id="链表">链表</h4><ul><li><ahref="https://www.acwing.com/problem/content/description/828/">826.单链表 - AcWing题库</a><ul><li>其实上链表的模拟题几乎都可以用数组去做。</li><li>其实用数组模拟的思路很暴力，假设有N次操作，那么就实例化N个结构体对象。给每次操作分配一个node，每个node里有l,r,x。然后按照题目要求改变node的l、r即可。（l、r初始为-1，a[0]为虚拟头节点）</li></ul></li></ul><h4 id="并查集">并查集</h4><ul><li><a href="https://www.acwing.com/problem/content/1252/">1250.格子游戏 - AcWing题库</a><ul><li>乍一看题目觉得很复杂，但实际上想到把二维转为一维就简单了。给每一个二维坐标赋予一个独一的一维坐标。每次一条边就是将两个点merge起来。如果一条边的两个点已经在一个集合里面了，说明产生了环。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1254/">1252.搭配购买 - AcWing题库</a><ul><li>将所有捆绑在一起的东西看作一个物品，然后01背包即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/239/">237.程序自动分析 - AcWing题库</a><ul><li>对于一组约束，将相等条件都用并查集并起来。然后依次检查不相等条件的两个点是否在同一集合中，如果在就是NO。全部检查完没问题就是YES。</li></ul></li><li><a href="https://www.acwing.com/problem/content/241/">239. 奇偶游戏- AcWing题库</a><ul><li>这题涉及到区间问题，都应该往是否可以转换成“前缀和数组和差分数组上的区间俩端点“问题这个方向思考。这题考虑前缀和数组sum，区间[l,r]有偶数个1说明sum[r]与sum[l - 1]的奇偶性相同，区间[l,r]有奇数个1说明sum[r]与sum[l - 1]的奇偶性不同。</li><li>看出这个后这题就好做了，二分M，每次检查前mid个条件是否满足。显然满足当且仅当是一个二分图，那么用染色法就检查前mid个条件形成的图是不是一个二分图即可。</li><li>这题其实我还这样想过，就是用的[程序自动分析]这题的思路：二分M，每次检查前mid个条件是否满足。检查方法使用并查集，先将前mid个条件中相同条件的俩元素并起来，再检查前mid个条件中不相同条件的俩元素是否在同一集合，在就return0。都检查完了没问题就return 1。</li><li>但上面这样想是错的，因为这题是有个隐藏条件的，任意一个元素，它不是奇数，就是偶数。所以上面并查集的做法是无法做到保证只有两个集合的。例如下面这个例子：</li><li><img src="1.png" /></li><li>通过三句红话其实可以推出这些条件无法共存（不是二分图）。但是上面的并查集做法是检查不出来的。</li><li>如果要用并查集的话要用这种思路：维护d[x]，表示x与父亲的奇偶性（如果俩点奇偶性相同则为0，不相同则为1）。在更新fat[x]的时候顺便更新一下d[x]，那么更新完后d[x]就成为了x与祖先的奇偶性。</li></ul></li><li><a href="https://www.acwing.com/problem/content/240/">238.银河英雄传说 - AcWing题库</a><ul><li>跟上一题一样维护d[x]，表示x到父亲的距离。也是在更新fat[x]时顺便更新一下d[x]即可，更新完后d[x]就成为了x到祖先的距离。</li><li>这题在merge时会用到并查集大小信息，所以还要多维护一个siz[x]。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1555/">1553. 用Swap(0, i) 操作进行排序 - AcWing题库</a><ul><li>很巧妙的解法，没做过很难想出来。</li><li>如果当前位置i上的数是x，那么x向i连一条边。最终形成的图是一个个环。最终想到达到的目的就是n个自环。考虑交换操作会对这个图产生什么影响。如果0跟不在一个环的数交换，那么两个环会合并。如果0跟在一个环的数交换，那么环会分裂成两个。贪心的想，先把所有跟0不在一个环的环合并到0这个环上，然后再一个一个元素分裂出去形成自环即可。那么用并查集维护一下就好了。</li></ul></li></ul><h4 id="对顶堆">对顶堆</h4><ul><li><a href="https://www.acwing.com/problem/content/108/">106.动态中位数 - AcWing题库</a><ul><li>将数分为较大的一部分和较小的一部分。而且保证较大一部分的数的数量在偶数时与较小一部分的数的数量相等，在奇数时较大一部分的数的数量比较小一部分数的数量大1。</li><li>用小根堆b维护较大的一部分，大根堆a维护较小的一部分。每次一进来一个数t，先与b.top()（也就是较大一部分中的最小的数）比较，如果比b.top()小，则把t插入a中。反之，把t插入b中。</li><li>然后就要保证两个堆之间的数量关系。维护一下即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1545/">1543. 栈 -AcWing题库</a><ul><li>相对于上面一题，就多了一个删除操作。</li><li>使用multiset，这玩意内部是自动从小到大排序的。支持插入、删除、用迭代器访问，两个堆分别用俩multiset代替就行了。</li><li>删除要a.erase(a.find(x))，而不是a.erase(x)，后者会把所有x全删掉。</li></ul></li></ul><h4 id="优先双端队列">优先/双端队列</h4><ul><li><a href="https://www.acwing.com/problem/content/1543/">1541.世界首富 - AcWing题库</a><ul><li>把每个人的信息都用结构体记录下来，然后对于每个查询，二分找到左右端点，然后对区间内的点重新sort一遍。这种做法时间过不去，因为n有1e5。极端情况每次查询都要对1e5个元素重新sort。</li><li>看题目年龄最多200，所以考虑以年龄作为索引。相当于每个年龄开一条链，然后把对应年龄人的信息链上去。</li><li>输出规定年龄区间内前m个人的信息，其实就是一个多路合并问题。用一个优先队列解决。</li><li>（P.S.vector类型可以定义为pair/struct，写一个排序函数cmp即可。但是priority_queue里若想实现自己定义的规则，不要用pair最好用struct，而且不是写排序函数，而是写一个重载&lt;的规则，注意规则内部大于要变小于，小于要变大于）</li></ul></li></ul><h4 id="线段树">线段树</h4><ul><li><a href="https://www.acwing.com/problem/content/1275/">1273.天才的记忆 - AcWing题库</a><ul><li>区间查询最大值。</li></ul></li><li><a href="https://www.acwing.com/problem/content/248/">242.一个简单的整数问题 - AcWing题库</a><ul><li>区间修改，单点查询。</li></ul></li><li><a href="https://www.acwing.com/problem/content/244/">243.一个简单的整数问题2 - AcWing题库</a><ul><li>区间修改，区间查询。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1279/">1277.维护序列 - AcWing题库</a><ul><li>区间修改（乘法加法），区间查询。</li><li>假设sum' = sum * a + b，那么加一个数sum' + c = sum * a + (b +c)，相当于加法标记加了个c；乘一个数sum' * c = sum * ac +(bc)，相当于加法和乘法标记都自乘了个c。所以就这样维护俩标记即可，然后按照sum= sum * mul + add的规则去更新sum即可。</li><li>但如果假设sum' = (sum + a) * b，那么加一个数sum' + c = sum * b + ab+ c，你看，就不好可持续性维护了。</li><li>这题注意build初始化时每个t[p]的mul标记都要初始化为1。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1277/">1275. 最大数- AcWing题库</a><ul><li>动态维护后L个数中的最大值，可以发现数组的数量是只会增加不会减少的，而且数组元素数量最多增长到2e5。所以对数组下标建一颗线段树维护区间最大值即可。单点修改+ 区间查询。</li></ul></li><li><a href="https://www.acwing.com/problem/content/246/">245.你能回答这些问题吗 - AcWing题库</a><ul><li>考虑t[p]的最大子段和sm如何转移：max(t[p1].sm, t[p2].sm,跨过mid的最大子段和)。跨过mid的最大子段和 = t[p1]的最大后缀和 +t[p2]的最大前缀和。</li><li>所以t[p]需要维护最大子段和sm，最大前缀和lm，最大后缀和rm，在维护lm,rm时还会用到区间和sum。</li><li>查询区间[l, r]时，ask函数应返回一个Tree类型，当l &lt;= mid &lt;=r（mid = (t[p].l + t[p].r) / 2）时，可以通过子树t1,t2表示出状态。如果不返回Tree类型的话，就没有子树t1,t2的信息，状态不好表示出来。</li></ul></li><li><a href="https://www.acwing.com/problem/content/247/">246.区间最大公约数 - AcWing题库</a><ul><li>由更相减损术可知gcd(a, b) = gcd(a, b -a)。次公式可扩展到多个变量：gcd(a, b, c, d) = gcd(a, b - a, c - b, d -c)，这其实就是差分形式。所以可以线段树维护原数组的差分数组的区间gcd和区间和，那么操作1就是单点修改（单点修改那可以完全不用考虑懒标记问题了很舒服），操作2求gcd(A[l],A[l + 1], A[l + 2], ..., A[r]) = gcd(A[l], A[l + 1] - A[l], A[l + 2] -A[l + 1], ..., A[r] - A[r - 1]) = gcd(差分数组[1 ~ l]之和，差分数组[l +1到r]的gcd)。</li><li>这题有俩小细节，第一差分单点修改r +1有可能到n外边去，第二查询时如果l = r则要特判下。</li></ul></li><li><a href="https://www.acwing.com/problem/content/249/">247.亚特兰蒂斯 - AcWing题库</a><ul><li>扫描线算法，扫描线算法是个比较死的算法，因为其有一个特殊性质：线段是成对出现的。</li><li>做法两种，我喜欢这种：维护区间最小值min和区间最小值的长度minlen。这样，如果t[1].min= 0，则被覆盖的长度 = 全部长度 - t[1].minlen。如果t[1].min !=0，则被覆盖的长度 =全部长度。区间最小值和区间最小值长度都非常好维护，区间修改就是给最小值打个懒标记即可，不用管minlen，因为最小值加一个数减一个数仍然是最小值，minlen不会变。</li><li>上面就是扫描线的做法。所以扫描线很简单，关键这题的细节处理有点点小麻烦。</li><li>一，坐标都是小数，所以需要离散化处理成整数才能建线段树。二，t[p]管理的实际区间为getVal(t[p].r+ 1) -getVal(t[p].l)，因为只有这样，线段树的子节点才可以初始化minlen，不然minlen不好初始化。三，离散化的俩函数getRank,getVal的参数类型要注意。</li></ul></li><li><a href="https://ac.nowcoder.com/acm/contest/67742/H">H-Tokitsukazeand Power Battle (hard)_2024牛客寒假算法基础集训营2</a><ul><li>是“最大区间和”的变形题。</li><li>考虑i，j的位置，如果i，j都在mid左边是一种情况，即t[p].ans =t[p1].ans。如果i，j都在mid右边是一种情况，即t[p].ans =t[p2].ans。如果i，j分布在mid两边，则需要考虑x(即中间砍的那一刀)的位置。</li><li>如果砍的一刀在mid, mid + 1之间，则t[p].ans =t[p1].包含右端点的最大后缀和 - t[p2].包含左端点的最小前缀和。</li><li>如果砍的一刀在左半边，则t[p].ans = t[p1].包含右端点的答案 -t[p2].包含左端点的最小前缀和。</li><li>如果砍的一刀在右半边，则t[p].ans = t[p1].包含右端点的最大后缀和 +t[p2].包含左端点的答案。</li><li>所以t[p].ans就是在上面几种情况取max。发现用到了“包含右端点的最大后缀和rmax”，“包含左端点的最小前缀和lmin”，“包含右端点的答案rans”，“包含左端点的答案lans”，rmax和lmin很好维护，现在来看lans和rans如何维护。</li><li>先考虑t[p].lans。此时i是卡死的就在l上，考虑j的位置。如果j左半边，则t[p].lans= t[p1].lans。如果j在右半边，则考虑砍的一刀位置，如果砍在mid,mid+1中间，则t[p].lans = t[p1].sum -t[p2].lmin；如果砍在左半边，则t[p].lans = t[p1].包含左右端点的答案 -t[p2].lmin；如果砍在右半边，则t[p].lans = t[p1].sum + t[p2].lans。</li><li>t[p].rans同理。发现在维护这俩的时候还用到了"包含左右端点的答案lrans"。</li><li>现在考虑t[p].lrans。因为i，j都定死了，所以只需考虑砍的一刀的位置。如果砍在mid,mid+1中间，则t[p].lrans= t[p1].sum - t[p2].sum。如果砍在左半边，则t[p].lrans = t[p1].lrans -t[p2].sum。如果砍在右半边，则t[p].lrans = t[p1].sum + t[p2].lrans。</li></ul></li></ul><h4 id="树状数组">树状数组</h4><ul><li><a href="https://www.acwing.com/problem/content/109/">107.超快速排序 - AcWing题库</a><ul><li>求逆序对。</li></ul></li><li><a href="https://www.acwing.com/problem/content/243/">241. 楼兰图腾- AcWing题库</a><ul><li>简单的求每个数之前比它大的数的个数。</li></ul></li><li><a href="https://www.acwing.com/problem/content/245/">244.谜一样的牛 - AcWing题库</a><ul><li>最后一头牛的高度是确定的，在确定最后一头牛高度后，倒数第二头牛的高度也确定了，依次类推。假设现在要求第i头牛的高度，则若数组c的区间和[1,k] = 比第i头牛矮的牛数量 + 1，则第i头牛的高度为k（最开始每个位置的c[i] =1）。</li><li>区间和查询用树状数组，找高度时配合二分。找到该牛高度k后，upd(x,-1)。</li></ul></li></ul><h4 id="字典树">字典树</h4><ul><li><a href="https://www.acwing.com/problem/content/837/">835.Trie字符串统计 - AcWing题库</a><ul><li>板子题，字典树空间一般不知道开多少合适，建议用vector。就比如这题，开个vector&lt;Node&gt;a。Node结构体里放指向信息，这题的指向信息有26个，就在Node里开一个alpha[26]。</li><li>从根节点编号0出发，若a[0].alpha[k] =0，那就新开一个点，a[0].alpha[k] = ++dex,a.push_back(tmp)即可。然后编号跳到a[0].alpha[k]，继续依次类推。</li><li>通过这种方法，就不需要考虑空间应该开多大了。</li></ul></li><li><a href="https://www.acwing.com/problem/content/145/">143.最大异或对 - AcWing题库</a><ul><li>思考每个数的二进制形式，将每个数的二进制形式insert到字典树中（字典树就两个指向信息p[0/1]），然后对于每个数，依次扫二进制的每一位数k，在字典树里找a[p].nxt[k^1]是否存在，存在p就指向它，不存在就指向a[p].nxt[k]。在过程中统计答案求最大值即可。</li></ul></li><li><ahref="https://www.acwing.com/problem/content/description/258/">256.最大异或和 - AcWing题库</a><ul><li>涉及到区间异或运算，所以尝试是否可以前缀和/差分转化为单点运算，发现是可以的。考虑维护前缀异或数组，s[i]= a[1] ^ a[2] ... ^ a[i]，这样a[p] ^ a[p + 1] ^ a[p + 2] ^ ... ^ a[n] =s[n] ^ s[l - 1]。所以所求为x ^ s[n] ^ s[p - 1]。(x ^s[n])是一个定值C，所以就是在[l - 1, r - 1]内找一个数s[i]，使得s[i] ^C最大。所以就是可持久化Trie树。</li><li>可持久化Trie树就是每次添加一条链，具体算法是p = root[now], q =root[now - 1]。然后p的所有子节点除了新链上的点，复制q的节点，然后p =t[p][k] = ++dex, q = t[q][k]。再递归进行直至把这条链添加进Trie树。</li></ul></li></ul><h3 id="模拟">模拟</h3><ul><li><a href="https://www.acwing.com/problem/content/1496/">1494.银行排队 - AcWing题库</a><ul><li>还行的一道模拟题，考虑时间轴，每个人要等的时间 = 到他的时间 -他到的时间。用一个优先队列维护正在办理业务的人，按照谁先结束排序。</li><li>通过这题可以学到priority_queue是可以自定义排序规则的，只需要重载&lt;号（类型一定要是结构体不能是pair）</li></ul></li><li><a href="https://www.acwing.com/problem/content/1559/">1557.说话方式 - AcWing题库</a><ul><li>坑点比较多，有可能有ab:cc/a:::bcc/a:aa:b...的情况。</li><li>通过这题可以学到map也是可以排序的。只需要vector&lt;PAIR&gt;vec(mp.begin(),mp.end())，即可把mp转换成一个vector。然后用sort对vector排序即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1488/">1486.排队等候 - AcWing题库</a><ul><li>跟“银行排队”那题比较像，这题多了一个“等待区”的概念，而且没有了具体的时间。所以不像上一题好写。所以学会自己给自己增加条件，用一个循环模拟时间线（因为17点下班所以复杂度不会很高）。然后对于当前第T秒，先把每个窗口办理完手续的人赶出去，然后再依次把人放进等待区，分配到对应的窗口。</li><li>这题坑点是即使一个人它开始办理业务的时间超过了17点，它也要分配到对应的窗口，因为对于他自己，是不知道前面的人需要多久的，所以他肯定会排进某个窗口的队里。</li></ul></li></ul><h3 id="dp">DP</h3><h4 id="背包">背包</h4><ul><li><p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题- AcWing题库</a></p><ul><li>01背包，复杂度O(n * m)，一维倒序</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/3/">3.完全背包问题 - AcWing题库</a></p><ul><li>完全背包，复杂度O(n * m)，一维正序</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/4/">4.多重背包问题 I - AcWing题库</a></p><ul><li>朴素多重背包，复杂度O(n * m * s)，当成01背包做</li></ul></li><li><p><ahref="https://www.acwing.com/problem/content/description/5/">5.多重背包问题 II - AcWing题库</a></p><ul><li>二进制优化多重背包，复杂度O(n * m * logs)</li><li>原理即用1、2、...、exp、s - exp凑出[1, s]总中任意一个数</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/6/">6.多重背包问题 III - AcWing题库</a></p><ul><li>单调队列优化多重背包，复杂度O(n * v_max),v_max为物品中最大的体积</li><li>先列出递推表达式，然后把j - v, j - 2v, ...r的表达式也一起列出来。然后画个数轴，发现是个滑动区间。</li></ul><p><img src="3.png" /></p><ul><li>那么三重循环，第一枚举物品，第二枚举余数（从0到v-1），第三从r枚举到m，每次+=v，同时开始滑动。</li><li>更新的时候注意w的数量，假设更新f[j]用到了f[k]，那么f[k]的w的数量就是(j- k) / v * w。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/9/">9.分组背包问题 - AcWing题库</a></p><ul><li>多重背包是看选0个、还是1个、2个。分组背包就是看选第1个、还是第2个。第一重枚举组，第二重枚举体积，第三重枚举组内物品。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/11/">11.背包问题求方案数 - AcWing题库</a></p><ul><li>这题不是求“恰好装满某容量的方案数”，如果是求前面这个问题的话用一个计数数组跑一遍01背包即可，g[0]= 1。</li><li>这题是求最优选法的方案，所以计数数组含义仍然不变，g[i]表示恰好装好容量为i的方案数，把f数组含义变一下，f[i]表示<strong>恰好</strong>用容量i的包装出的最优价值。这样的话，就需要memset(f,-0x3f, sizeof f), f[0] = 0。然后跑一遍01即可。最后统计的时候在f[1 ~m]中找出最优价值，然后再在g[1 ~ m]中统计最优价值的方案数之和。</li></ul></li><li><p><ahref="https://www.acwing.com/problem/content/description/12/">12.背包问题求具体方案 - AcWing题库</a></p><ul><li>求具体方案。用二维背包去求，先跑一遍二维01。再去逆推出方案。</li><li>注意因为字典序从小到大，所以做01时要倒着做，这样最后选的最后字典序最小的，逆推的时候就可以从最小的开始。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/1595/">1593.整数分解 - AcWing题库</a></p><ul><li>很巧的一道题。对于样例，背包体积容量169(m)，重量容量5(k)。物品个数是其约数个数n，每个物品的价值是约数的p次方，体积是约数的p次方，重量是1。按字典序大输出，即做完全背包时按约数从小到大，这样倒序找方案的时候就是从大到小。</li></ul></li></ul><h4 id="树形dp">树形dp</h4><ul><li><a href="https://www.acwing.com/problem/content/10/">10.有依赖的背包问题 - AcWing题库</a><ul><li>f(i,j)：i为根节点，容量为j时所能装出的最大方案。考虑如何划分，如果x是根节点，如果考虑x儿子节点内部的选择方式的话，方案太多，不好划分。所以考虑按照容量划分，即枚举给每个儿子节点分配多少的容量。</li><li>坑点1：俩重循环，第一重j从m -v[x]到0倒序，之所以倒序是因为对某儿子，容量只会分配给它一次。</li><li>坑点2：自己是必选的，而且只能选1次，所以要倒序枚举：<code>for (int i = m; i &gt;= v[x]; i--) f[x][i] = f[x][i - v[x]] + w[x];</code></li><li>坑点3：因为自己是必选的，如果自己不选，儿子选了也没用，所以要：<code>for (int i = 0; i &lt; v[x]; i++) f[x][i] = 0;</code></li></ul></li></ul><h3 id="图论">图论</h3><h4 id="最短路">最短路</h4><ul><li><a href="https://www.acwing.com/problem/content/1497/">1495.公共自行车管理 - AcWing题库</a><ul><li>题意稍长但不难懂，看完之后第一反应是多关键字最短路。但是除了距离可以在做dij时维护，“发送的自行车最小数量”和“带回车辆最小数量”是无法在dij的时候维护的。因为这两个量需要知道整段路径的信息后才可求出来，不具有最优子结构。</li><li>所以这题思路就是先dij，然后枚举所有最短路，找出符合条件最优的一条。</li><li>dfs过程中维护参数sum表示从起点走到x时路上所有站点需求变化量之和，这样直到到达终点前，每一步若<code>sum &lt; 0，min_carry = max(min_carry, -sum)</code>，到达终点即可求出“发送的自行车最小数量”。“带回车辆最小数量”= sum + 发送的自行车最小数量。</li></ul></li></ul><h4 id="树">树</h4><ul><li><a href="https://www.acwing.com/problem/content/1499/">1497.树的遍历 - AcWing题库</a><ul><li>经典题。给出中序和后序，后序的最后一个点肯定是root，所以在中序里找到root的位置，然后中序的左半边就是左子树，右半边就是右子树。（从而可算出左右子树节点数量）因为后序是左右根，所以后序序列的[起始,起始 + 左子树数量 - 1]是左子树，[起始 + 左子树数量 - 1 + 1,结束]是右子树。这样就分别在中序和后序序列中得到了左右字数，然后递归即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1529/">1527.判断二叉搜索树 - AcWing题库</a><ul><li>经典题。本质上和上一题一样，因为这题的树是二叉搜索树。而BST的中序遍历就是元素从小到大排序。所以它的中序遍历相当于已经告诉你了。然后它又告诉了你前序遍历。那么根据这俩序列，按照上一题的方法，就可以构造出树了。</li><li>跟上一题不同的是，这里的元素可能会重复。其实问题不大，因为题目中说“左子树上所有结点的值均小于它的根结点的值”，所以若x在中序遍历中出现多次，找最左边的即可。</li><li>然后这题让我们输出后序遍历，其实在构造的时候，在dfs的return前加一句ans[++dex]= root，即可得到后序遍历。</li><li>最后这题还有个翻转机制，翻转其实就是中序遍历reverse一下即可，然后找最左边的变成找最右边的，其余都一样。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;信息学竞赛刷题笔记&lt;/p&gt;</summary>
    
    
    
    <category term="3. 竞赛" scheme="http://example.com/categories/3-%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>FROST—Fast row-stochastic optimization with uncoordinated step-sizes</title>
    <link href="http://example.com/2023/12/04/FROST%E2%80%94Fast-row-stochastic-optimization-with-uncoordinated-step-sizes/"/>
    <id>http://example.com/2023/12/04/FROST%E2%80%94Fast-row-stochastic-optimization-with-uncoordinated-step-sizes/</id>
    <published>2023-12-04T11:49:40.000Z</published>
    <updated>2024-02-19T16:34:50.165Z</updated>
    
    <content type="html"><![CDATA[<p>中文翻译是：非协调步长行随机优化</p><p>个人认为在仔细研读了Distributed那篇文章后，再看这篇文章时，会对双随机、列随机、行随机的算法分别有哪些有一个很好的认识。</p><span id="more"></span><hr /><h3 id="abstract">Abstract</h3><p>本文讨论了构造不出双随机权值的有向图上的分布优化问题。</p><p>现有算法大多采用推和共识算法，利用列随机权值来克服这一问题。列随机权值的形成要求每个代理(至少)知道其输出度，这在诸如基于广播的通信协议中可能是不切实际的。</p><p>与此相反，我们描述了一种适用于不要求出度知识的有向图的快速行随机优化算法。</p><p>该方法的实现很简单，因为每个代理在本地为传入的信息分配权重，并在本地选择合适的步长。我们证明了对于光滑且强凸函数，在最大步长为正且足够小的前提下，算法线性收敛到最优解。</p><hr /><h3 id="introduction">1. Introduction</h3><p>第2节阐述了问题和假设。第3节回顾了使用双随机或列随机权值的相关算法，并展示了这些类型算法分析背后的直觉。在第4节中，我们提供了本文提出的主要算法FROST。在第5节中，我们发展了FROST的收敛性质。第6节给出了仿真结果，第7节总结了本文。</p><p>下面是Notation：</p><p>对于行随机矩阵<spanclass="math inline">\(\underline{A}\)</span>，<spanclass="math inline">\(\pi_r,1_n\)</span>分别是其左右Perron特征向量，满足<spanclass="math inline">\(\pi_r^T1_n = 1\)</span></p><p>对于列随机矩阵<span class="math inline">\(\underline{B}\)</span>，<span class="math inline">\(1_n,\pi_c\)</span>分别是其左右Perron特征向量，满足<spanclass="math inline">\(1_n^T\pi_c = 1\)</span></p><p><span class="math inline">\(\|\|_F\)</span>是Frobenius范数，<spanclass="math inline">\(\|\|_2\)</span>是欧几里得范数，<spanclass="math inline">\(\|\|\)</span>也是一个范数，具体含义看具体那部分的文章</p><p><span class="math inline">\({\otimes}\)</span>表示Kronecker积。</p><hr /><h3 id="problem-formulation">2. Problem formulation</h3><p>如果 j 连向 i ，则<span class="math inline">\((i, j) \in\mathcal{E}\)</span> 另外，目标是最小化总花费，即： <spanclass="math display">\[\min_{\mathbf{x}}F(\mathbf{x})\triangleq\frac{1}{n}\sum_{i=1}^{n}f_{i}(\mathbf{x})\]</span></p><h4 id="assumption-1">Assumption 1</h4><p>图G是无向联通图。</p><h4 id="assumption-2">Assumption 2</h4><p>图G是有向强连通图。</p><h4 id="assumption-3">Assumption 3</h4><p><spanclass="math inline">\(f_i\)</span>是凸函数，且具有有界次梯度。</p><h4 id="assumption-4">Assumption 4</h4><p><spanclass="math inline">\(f_i\)</span>是光滑，且强凸的。（光滑定义：具有连续的导数）</p><p>即满足以下式子： <span class="math display">\[\left\|\nabla f_i(\mathbf{x})-\nabla f_i(\mathbf{y})\right\|_2\leql\|\mathbf{x}-\mathbf{y}\|_2 \\f_i(\mathbf{y})\geq f_i(\mathbf{x})+\nablaf_i(\mathbf{x})^\top(\mathbf{y}-\mathbf{x})+\frac{\mu}{2}\|\mathbf{x}-\mathbf{y}\|_2^2\]</span> 第一个就是导数满足Lipschitz连续，所以<spanclass="math inline">\(f_i\)</span>肯定光滑。</p><p>第二个就是凸函数的定义，因为有不等号右边最后一项的存在，所以<spanclass="math inline">\(f_i\)</span>是个强凸函数。</p><h4 id="assumption-5">Assumption 5</h4><p>网络中的每个玩家都知道自己的编号。</p><h4 id="assumption-6">Assumption 6</h4><p>每个玩家知道它的出度。</p><hr /><h3 id="补充">补充</h3><p>看到这里。我想先停一下。来看一道题：假设每个玩家有一个初始值xi。如果他们都想知道所有玩家初始值的平均值是多少，应该怎么做？</p><p>如果图是平衡的，则用平均一致性算法即可。即类似于：<spanclass="math inline">\(\tilde{\sigma}_i^{k+1}=\sum_{j=1}^Na_{ij}\tilde{\sigma}_j^k\)</span>。</p><p>如果图不平衡，则采用推和算法。 <span class="math display">\[\begin{aligned}&amp;\nu_{k+1}^{i} =\sum_{j=1}^nb_{ij}\nu_k^j,  \\&amp;\mathbf{x}_{k+1}^{i} =\sum_{j=1}^nb_{ij}\mathbf{x}_k^j  \\&amp;\mathbf{z}_{k+1}^{i} =\frac{\mathbf{x}_{k+1}^i}{\nu_{k+1}^i},\end{aligned}\]</span> 每一个点维护两个值：x、v（都是一维的）。所谓推，就是点 j把值xj / 出度推给邻居，把权重vj / 出度推给邻居。所谓和，就是点 i把所有邻居 j 推来的值加一起得到vi，把所有邻居 j推来的权重加一起得到xi。</p><p>注意到，对于任意时刻k，有：<spanclass="math inline">\(\frac{\sum{x_i}}{\sum{v_i}} = \frac{x1 + x2 + ...+ xn}{n} = avg\)</span></p><p>当迭代的次数足够大时，信息已经在网络中充分流转。第 i 个点的<spanclass="math inline">\(x_i\)</span>会收敛到<spanclass="math inline">\(n[\boldsymbol{\pi}_c]_i * avg\)</span>，<spanclass="math inline">\(v_i\)</span>会收敛到<spanclass="math inline">\(n[\pi_c]_i\)</span>，所以<spanclass="math inline">\(\frac{x_i}{v_i} = avg\)</span>。（<spanclass="math inline">\(\pi_c\)</span>是列随机矩阵的右Perron特征向量）</p><p>即每个点的xi / vi都收敛到全局平均值。</p><p>这是一维的情况。</p><p>如果每个玩家的初始值是一个向量xi（权重vi仍然不变初始值为1），则一样的，经过推和算法后，每个玩家的zi都收敛到avg（此时avg就是一个向量）。</p><p>在推和共识上稍加改动，就可以得到下面这个算法： <spanclass="math display">\[\begin{aligned}&amp;\nu_{k+1}^{i} =\sum_{j=1}^nb_{ij}\nu_k^j,  \\&amp;\mathbf{x}_{k+1}^{i}=\sum_{j=1}^nb_{ij}\mathbf{x}_k^j-\alpha_k\nablaf_i\left(\mathbf{z}_k^i\right),  \\&amp;\mathbf{z}_{k+1} =\frac{\mathbf{x}_{k+1}^i}{\nu_{k+1}^i},\end{aligned}\]</span> 下面这个算法只在更新x时加了一个梯度项。</p><p>这样的话，当迭代次数足够多时，第 i 个点的<spanclass="math inline">\(x_i\)</span>会收敛到<spanclass="math inline">\([\boldsymbol{\pi}_c]_i * x^*\)</span>，<spanclass="math inline">\(v_i\)</span>会收敛到<spanclass="math inline">\(n[\pi_c]_i\)</span>，所以<spanclass="math inline">\(\frac{x_i}{v_i} = x^*\)</span>。</p><h3 id="personal-summary">Personal Summary</h3><p>首先是由推和协议衍生出来的算法，推和协议用列随机矩阵可以求出全局平均值（如果玩家动作是动态更新的话，更新sigma时记得+x[i]- xx[i]）。</p><p>因此套一个梯度下降就可以解决聚合游戏问题。</p><p>如果已知最优解都会收敛到一个值的话，可以直接在推和协议中修改加一个梯度项，使得收敛到最优解。为了加快速度，还可以将普通的梯度项改为考虑全局的梯度项。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;中文翻译是：非协调步长行随机优化&lt;/p&gt;
&lt;p&gt;个人认为在仔细研读了Distributed那篇文章后，再看这篇文章时，会对双随机、列随机、行随机的算法分别有哪些有一个很好的认识。&lt;/p&gt;</summary>
    
    
    
    <category term="1. 论文" scheme="http://example.com/categories/1-%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>5. 凸函数的定义</title>
    <link href="http://example.com/2023/11/19/5-%E5%87%B8%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    <id>http://example.com/2023/11/19/5-%E5%87%B8%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89/</id>
    <published>2023-11-19T10:03:32.000Z</published>
    <updated>2024-02-19T16:38:09.573Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了凸函数的四种定义：直接定义、降维定义、一阶可微下的定义、二阶可微下的定义。以及补充了若A为对称矩阵条件下，<spanclass="math inline">\(x^TAx \ge 0 \iff A \succeq 0\)</span>的证明。</p><span id="more"></span><p><img src="1.png" /></p><p><img src="2.png" /></p><p><img src="3.png" /></p><p><img src="4.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍了凸函数的四种定义：直接定义、降维定义、一阶可微下的定义、二阶可微下的定义。以及补充了若A为对称矩阵条件下，&lt;span
class=&quot;math inline&quot;&gt;&#92;(x^TAx &#92;ge 0 &#92;iff A &#92;succeq 0&#92;)&lt;/span&gt;的证明。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="凸优化" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>4. 保凸运算</title>
    <link href="http://example.com/2023/11/19/4-%E4%BF%9D%E5%87%B8%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2023/11/19/4-%E4%BF%9D%E5%87%B8%E8%BF%90%E7%AE%97/</id>
    <published>2023-11-19T10:03:11.000Z</published>
    <updated>2024-02-19T16:38:05.748Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了4种不改变集合凸性的运算：集合交、仿射函数、透视函数、线性分数函数。</p><span id="more"></span><p><img src="1.png" /></p><p><img src="2.png" /></p><p><img src="3.png" /></p><p><img src="4.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍了4种不改变集合凸性的运算：集合交、仿射函数、透视函数、线性分数函数。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="凸优化" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>ChatGPT4使用</title>
    <link href="http://example.com/2023/11/12/ChatGPT4%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/11/12/ChatGPT4%E4%BD%BF%E7%94%A8/</id>
    <published>2023-11-12T09:03:14.000Z</published>
    <updated>2023-11-12T09:54:42.453Z</updated>
    
    <content type="html"><![CDATA[<p>最近OpenAI开了发布会，ChatGPT4更新为GPT-4Turbo，还推出了一个GPTs功能，这使得人们可以自己定制化GPT，还可以使用人家的GPTs。</p><p>我猜未来GPTs应该跟国内小程序一样，将一定程度上改变app/网站的生态。</p><p>所以为了体验一下GPT-4Turbo，我去官网注册了OpenAI的账号并且购买了GPT4（一个月）。这篇博客内容是订阅方法以及基本使用GPT4的方法。</p><span id="more"></span><h3 id="如何订阅gpt4-plus">如何订阅GPT4 PLUS？</h3><ol type="1"><li>去<a href="https://chat.openai.com/">官网链接(openai.com)</a>注册一个OpenAI账号并登录（建议通过Google邮箱注册）</li><li>注册过程中，需要用到手机号验证，使用<ahref="https://sms-activate.org/cn">SMS-Activate</a>解决</li><li>1、2步完成后，就可以使用ChatGPT服务了，但是只能使用3.5而且有次数限制。点击升级，会看到一个支付界面，界面里要填银行卡相关信息。银行卡只能使用美国的。所以在<ahref="https://www.fomepay.com/">FOMEPay</a>上购买一张虚拟美国银行卡，往里充钱。然后将卡号信息填到刚才的界面中即可。</li><li>充值成功，可正常使用ChatGPT4</li></ol><p>（注意，充值过程一定要全程使用美国IP的梯子！）</p><h3 id="如何使用">如何使用？</h3><p>想怎么用怎么用，推荐几个插件：</p><ol type="1"><li>WebPilot：帮助ChatGPT联网搜索信息</li><li>Wolfram：科学计算，图标绘制</li><li>Tutory：可以帮你制定任意领域的学习路线</li><li>Ai Tool Hunt：找插件的插件</li><li>MixerBox Scholar：可以访问一些学术资源</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近OpenAI开了发布会，ChatGPT4更新为GPT-4
Turbo，还推出了一个GPTs功能，这使得人们可以自己定制化GPT，还可以使用人家的GPTs。&lt;/p&gt;
&lt;p&gt;我猜未来GPTs应该跟国内小程序一样，将一定程度上改变app/网站的生态。&lt;/p&gt;
&lt;p&gt;所以为了体验一下GPT-4
Turbo，我去官网注册了OpenAI的账号并且购买了GPT4（一个月）。这篇博客内容是订阅方法以及基本使用GPT4的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://example.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>数学知识补充</title>
    <link href="http://example.com/2023/10/31/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
    <id>http://example.com/2023/10/31/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</id>
    <published>2023-10-31T15:51:42.000Z</published>
    <updated>2024-02-19T16:35:25.898Z</updated>
    
    <content type="html"><![CDATA[<p>论文中涉及到许多基础数学知识，但是在论文里单独展开篇幅太长了。所以统一在这篇blog里记录。</p><span id="more"></span><h3 id="lipschitz连续">Lipschitz连续</h3><p>先看连续的定义：函数<spanclass="math inline">\(f(x)\)</span>在点<span class="math inline">\(x =x_0\)</span>连续<span class="math inline">\(\iff\)</span> <spanclass="math inline">\(\lim_{x \rightarrow x_0}f(x) = f(x_0) \iff \forall\varepsilon&gt;0, \exists\delta = \delta(\varepsilon)&gt;0\)</span>,使得当<span class="math inline">\(|x - x_0| &lt;\delta\)</span>时，有<span class="math inline">\(|f(x) - f(x_0)| &lt;\varepsilon\)</span></p><p>在此定义中，<span class="math inline">\(\delta\)</span>不仅与<spanclass="math inline">\(\varepsilon\)</span>有关，而且与<spanclass="math inline">\(x_0\)</span>有关，应记为<spanclass="math inline">\(\delta = \delta(x_0,\varepsilon)\)</span>。也就是说，对于同一个<spanclass="math inline">\(\varepsilon\)</span>，在不同的<spanclass="math inline">\(x_0\)</span>处，使<spanclass="math inline">\(|f(x) - f(x_0)| &lt;\varepsilon\)</span>的x取值范围可以差得很多。</p><p>所以我们自然会问，对于<span class="math inline">\(\forall \varepsilon&gt; 0\)</span>，是否存在只与<spanclass="math inline">\(\varepsilon\)</span>有关的<spanclass="math inline">\(\delta\)</span>，使得对于区间中任意两点<spanclass="math inline">\(x_1, x_2\)</span>，只要满足<spanclass="math inline">\(|x_1 - x_2| &lt; \delta\)</span>，就成立<spanclass="math inline">\(|f(x_1) - f(x_2)| &lt; \varepsilon\)</span>？</p><p>这就引出了一致连续的定义：设函数<spanclass="math inline">\(f(x)\)</span>在区间X上有定义，若<spanclass="math inline">\(\forall \varepsilon &gt; 0, \exists\delta =\delta(\varepsilon) &gt; 0\)</span>，使得对于区间X中的任意两点<spanclass="math inline">\(x_1, x_2\)</span>，只要满足<spanclass="math inline">\(|x_1 - x_2| &lt; \delta\)</span>，就成立<spanclass="math inline">\(|f(x_1) - f(x_2)| &lt;\varepsilon\)</span>，则称函数<spanclass="math inline">\(f(x)\)</span>在区间X上一致连续。</p><p>可以发现一致连续是比连续更强的一个条件。接下来要讲的Lipschitz连续，是比一致连续还要强的一个条件。</p><p>先给出Lipschitz连续的定义：设函数<spanclass="math inline">\(f(x)\)</span>在区间X上有定义，若存在<spanclass="math inline">\(L &gt; 0\)</span>，使得对于区间X中的任意两点<spanclass="math inline">\(x_1, x_2\)</span>，都满足<spanclass="math inline">\(|f(x_1) - f(x_2)| \le L|x_1 -x_2|\)</span>，则称<spanclass="math inline">\(f(x)\)</span>在区间X上是Lipschitz连续。</p><blockquote><p>下面证明Lipschitz连续是比一致连续更强的一个条件：</p><p>证明：<span class="math inline">\(\forall \varepsilon &gt;0\)</span>，取<span class="math inline">\(\delta = \frac{\varepsilon}{L}&gt; 0\)</span>，则<span class="math inline">\(\forall x_1, x_2 \inX\)</span>，当<span class="math inline">\(|x_1 - x_2| &lt;\delta\)</span>时，<span class="math inline">\(|f(x1) - f(x_2)| \leL|x_1 - x_2| &lt; L\delta = L \cdot \frac{\varepsilon}{L} =\varepsilon\)</span>，得证。</p></blockquote><h3 id="矩阵范数">矩阵范数</h3><h4 id="矩阵范数定义">1. 矩阵范数定义</h4><p>矩阵范数的定义如下：</p><p>若函数<span class="math inline">\(f: R^{n \times n} \rightarrowR\)</span>满足：</p><ol type="1"><li>正定性：<span class="math inline">\(f(A) \ge 0, \forall A \in R^{n\times n}\)</span>，等号当且仅当<span class="math inline">\(A =0\)</span>成立</li><li>齐次性：<span class="math inline">\(f(\alpha A) = |\alpha| \cdotf(A), \forall A \in R^{n \times n}, \alpha \in R​\)</span></li><li>三角不等式：<span class="math inline">\(f(A \pm B) \le f(A) + f(B),\forall A, B \in R^{n \times n}\)</span></li><li>相容性：<span class="math inline">\(f(AB) \le f(A) \cdot f(B),\forall A, B \in R^{n \times n}\)</span></li></ol><p>则将<span class="math inline">\(f(x)\)</span>称为<spanclass="math inline">\(R^{n \times n}\)</span>上的范数，记作<spanclass="math inline">\(\|\cdot\|\)</span></p><p>还有一条性质，有些矩阵范数也是满足的，即与向量的相容性：</p><p><span class="math inline">\(f(Ax) \le f(A) \cdot f(x), \forall A \inR^{n \times n}, x \in R^{n}\)</span></p><h4 id="算子从属范数">2. 算子(从属)范数</h4><p>矩阵范数跟向量范数一样，有很多种。但大多数情况都是用的算子(从属)范数中的二范数（谱范数）。</p><p>先来介绍一下算子范数</p><p>定义：设<span class="math inline">\(\|\cdot\|\)</span>是<spanclass="math inline">\(R^n\)</span>上的任意一个范数，若对<spanclass="math inline">\(\forall A \in R^{n \times n}\)</span>满足 <spanclass="math display">\[\|A\| = max_{x \ne 0} \frac{\|Ax\|}{\|x\|} = max_{\|x\| = 1} \|Ax\|\]</span> 则矩阵范数<spanclass="math inline">\(\|\cdot\|\)</span>称为从属于向量范数的矩阵范数。也叫由向量范数诱导出来的算子范数。</p><p>算子范数肯定是满足矩阵范数的四条定义的，而且它还满足与向量的相容性！（证明网上一大堆略）</p><p>另外，对于所有的矩阵算子范数，它们都是等价的。俩矩阵范数等价的定义如下：</p><p>俩矩阵范数<spanclass="math inline">\(\|\cdot\|_\alpha\)</span>与<spanclass="math inline">\(\|\cdot\|_\beta\)</span>等价，当且仅当存在两个正数<spanclass="math inline">\(d_1, d_2\)</span>，使得对于任意矩阵A，都有<spanclass="math inline">\(d_1\|A\|_\beta \le \|A\|_\alpha \led_2\|A\|_\beta\)</span></p><p>一般我们推导不常用范数的有界性时，先推容易算的范数的有界性，再用所有范数等价这条性质来放缩。</p><h4 id="矩阵二范数谱范数">3. 矩阵二范数（谱范数）</h4><p>如果算子范数角标取2，就变成了谱范数： <span class="math display">\[\|A\|_2 = max_{x \ne 0} \frac{\|Ax\|_2}{\|x\|_2} = max_{\|x\|_2 = 1}\|Ax\|_2\]</span>矩阵A的谱范数的实际意义是”矩阵A能将向量放大的最大倍数“。在数值上为矩阵A的最大奇异值（<spanclass="math inline">\(\sqrt{\lambda_{max}(A^TA)}\)</span>）。</p><p>那为啥要叫谱范数呢？它跟谱半径又有什么关系呢？</p><p>先回忆一下矩阵谱半径的定义：<spanclass="math inline">\(\rho(A)=\max\{|\lambda|:\lambda\in\lambda(A)\}\)</span></p><p>当<spanclass="math inline">\(A\)</span>为对称矩阵时，其特征值的绝对值就是它的奇异值。所以有<spanclass="math inline">\(\rho(A) = \sqrt{\lambda_{max}(A^TA)} =\|A\|_2\)</span></p><p>这就是为什么矩阵二范数别称叫谱范数的原因hhhh。</p><h4 id="几个与谱半径有关的定理">4. 几个与谱半径有关的定理</h4><h5 id="section">4.1</h5><p>定理：谱半径小于等于任意一种范数</p><p>证明：设<spanclass="math inline">\(\lambda\)</span>为A的特征值，则<spanclass="math inline">\(A\alpha =\lambda\alpha\)</span>，两边同时取范数得<spanclass="math inline">\(\|A\alpha\| = \|\lambda\alpha\|\)</span>。</p><p>由于算子范数满足与向量的相容性和齐次性，所以有：<spanclass="math inline">\(\|A\alpha\| = |\lambda|\|\alpha\| \le\|\alpha\|\|A\|\)</span></p><p>同除<span class="math inline">\(\|\alpha\|\)</span>，得：<spanclass="math inline">\(|\lambda| \le \|A\|\)</span></p><p>所以<span class="math inline">\(\rho(A) = |\lambda|_{max} \le\|A\|\)</span>，得证。</p><h5 id="section-1">4.2</h5><p>定理：<spanclass="math inline">\(\lim_{k\to\infty}A^k=0\Leftrightarrow\rho(A)&lt;1\)</span></p><p>充分性：因为<span class="math inline">\(\rho(A) &lt;1\)</span>，所以必然可以找到一个矩阵范数，s.t. <spanclass="math inline">\(\|A\| &lt; 1\)</span>。</p><p>所以<span class="math inline">\(\|A^k\| \le \|A\|^k\)</span>，当<spanclass="math inline">\(k \rightarrow \infty\)</span>时，<spanclass="math inline">\(\|A^k\| \le \|A\|^k \rightarrow 0\)</span>。</p><p>又因为矩阵范数满足正定性，所以<spanclass="math inline">\(\lim_{k\to\infty}A^k=0\)</span></p><p>必要性（反证法）：假设<span class="math inline">\(\rho(A) \ge1\)</span>，设<span class="math inline">\(\lambda\)</span>为满足<spanclass="math inline">\(|\lambda| \ge 1\)</span>的特征值，假设<spanclass="math inline">\(\alpha\)</span>为对应的特征向量，则有<spanclass="math inline">\(A^k\alpha = \lambda^k\alpha\)</span></p><p>两边取范数，得：<spanclass="math inline">\(\left\|A^k\alpha\right\|=\left\|\lambda^k\alpha\right\|=\left|\lambda^k\right|\left\|\alpha\right\|\geq\left\|\alpha\right\|\)</span></p><p>又因为<spanclass="math inline">\(\|A^k\alpha\|\leq\|A^k\|\|\alpha\|\)</span></p><p>所以<span class="math inline">\(\|A^k\|\|\alpha\| \ge\|\alpha\|\)</span></p><p>同除，得：<span class="math inline">\(\|A^k\| \ge 1\)</span></p><p>与<spanclass="math inline">\(\lim_{k\to\infty}A^k=0\)</span>矛盾，所以假设不成立，所以<spanclass="math inline">\(\rho(A) &lt; 1\)</span>，得证。</p><h5 id="section-2">4.3</h5><p>设<span class="math inline">\(A \in R^{n \timesn}\)</span>，则有：</p><ol type="1"><li><p><span class="math inline">\(\sum_{k=0}^{\infty}A^{k}\)</span>收敛可推出 <span class="math inline">\(\rho(A) &lt; 1\)</span></p></li><li><p>当<spanclass="math inline">\(\sum_{k=0}^{\infty}A^{k}\)</span>收敛时，它将收敛于：<span class="math display">\[\sum_{k=0}^{\infty}A^{k} = (I - A)^{-1}\]</span> 而且存在一种算子范数<spanclass="math inline">\(\|\cdot\|\)</span>，使得 <spanclass="math display">\[\|(I-A)^{-1}-\sum_{k=0}^mA^k\|\leq\frac{\|A\|^{m+1}}{1-\|A\|}, m \in\mathbb{N}\]</span></p></li></ol><p>证明：第一条很容易证明，当收敛时它的第无穷项肯定是收敛于0的，然后由4.2即可推出。</p><p>下面证明第二条：</p><p>因为<span class="math inline">\(\rho(A) &lt; 1\)</span>，所以<spanclass="math inline">\(I - A\)</span>的特征值<spanclass="math inline">\(1 - \lambda \ne 0\)</span>，因此<spanclass="math inline">\(|I - A| \ne 0\)</span>，所以<spanclass="math inline">\(I - A\)</span>可逆。</p><p>又因为<spanclass="math inline">\((I-A)(I+A+\ldots+A^k)=I-A^{k+1}\)</span></p><p>所以<spanclass="math inline">\((I+A+\ldots+A^k)=(I-A)^{-1}(I-A^{k+1})\)</span></p><p>又因为<span class="math inline">\(k \rightarrow 0\)</span>时，<spanclass="math inline">\(A^{k+1} \rightarrow 0\)</span></p><p>所以<spanclass="math inline">\((I+A+\ldots+A^k)=(I-A)^{-1}\)</span></p><p>即<spanclass="math inline">\(\sum_{k=0}^{\infty}A^k=(I-A)^{-1}\)</span></p><h4 id="总结">5. 总结</h4><p>介绍了矩阵范数。重点讲解了矩阵二范数（谱范数）。以及介绍了与谱半径相关的定理。</p><ol type="1"><li>定理1是将谱半径与矩阵范数联系起来</li><li>定理2讨论了矩阵阶乘收敛问题</li><li>定理3讨论了矩阵阶乘数列之和收敛问题</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;论文中涉及到许多基础数学知识，但是在论文里单独展开篇幅太长了。所以统一在这篇blog里记录。&lt;/p&gt;</summary>
    
    
    
    <category term="1. 论文" scheme="http://example.com/categories/1-%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Linear convergence in optimization over directed graphs with row-stochastic matrices</title>
    <link href="http://example.com/2023/10/31/Linear-convergence-in-optimization-over-directed-graphs-with-row-stochastic-matrices/"/>
    <id>http://example.com/2023/10/31/Linear-convergence-in-optimization-over-directed-graphs-with-row-stochastic-matrices/</id>
    <published>2023-10-31T15:26:13.000Z</published>
    <updated>2024-02-19T16:34:53.580Z</updated>
    
    <content type="html"><![CDATA[<p>标题：Linear convergence in optimization over directed graphs withrow-stochastic matrices</p><p>中文翻译：行随机矩阵有向图优化的线性收敛性</p><span id="more"></span><h3 id="abstract">Abstract</h3><p>本文研究的是一个多智能体网络（有向图）上的分布式优化问题，其中目标函数是每个玩家成本函数的总和。</p><p>现存的在有向图上的分布式优化算法都至少需要每个玩家知道其邻居的出度。但本文不需要。而且最佳收敛速度为<spanclass="math inline">\(O(\mu^{k}), 0 &lt; \mu &lt; 1, k\)</span> is thenumber of 迭代。</p><p>前提是目标函数为强凸函数，且具有Lipschitz连续梯度。</p><h3 id="introduction">1. Introduction</h3><p>近年来出现了许多分布式优化方法，最初的方法是基于梯度下降，这种方法直观且计算简单，但由于算法使用的步长逐渐减小，通常速度较慢。证明了任意凸函数的收敛速度为<spanclass="math inline">\(O(\frac{\lnk}{\sqrt{k}})\)</span>，强凸函数的收敛速度为<spanclass="math inline">\(O(\frac{\ln k}k)\)</span>。</p><p>后来，发展出基于拉格朗日对偶变量的方法，例如分布式对偶分解[15]、分布式实现交替方向乘法器[16- 18]。对于强凸函数收敛速度将达到<spanclass="math inline">\(O(\mu^k)\)</span>，缺点是计算代价比较高。</p><p>再后来，为了兼顾收敛速度和计算简易性，一些分布式算法在保持步长不变的前提下，不使用对偶变量。例如分布式Nesterov-based方法，对于任意满足有界和Lipschitz梯度的凸函数，收敛速度达到<spanclass="math inline">\(O(\frac{\ln k}{k^2})\)</span>。还例如[20],[21]中的方法，用固定步长和历史梯度信息实现了对一般凸函数<spanclass="math inline">\(O(\frac{1}{k})\)</span>，强凸函数<spanclass="math inline">\(O(\mu^k)\)</span>的收敛速度。</p><p>但是上面这些方法都是在基于无向图或者权重平衡图上考虑的。但是实际中更多的是权重不平衡有向图的情况，所以这篇论文就是来解决这个问题的。</p><p>怎么解决呢？一般分布式优化中通常需要双随机矩阵，可是有向图中得不到双随机矩阵，只能得到行随机矩阵或者列随机矩阵。本文提出的算法参考了[36]。</p><p>Notation：</p><ul><li><p>小写字母是标量，小写粗体是向量，大写字母是矩阵</p></li><li><p>The spectral radius of a matrix A is <spanclass="math inline">\(\rho(A)\)</span>。谱半径就是A的特征值绝对值的最大值</p></li><li><p><span class="math inline">\(\lambda_{i}(A)\)</span> denotes the<span class="math inline">\(i-th\)</span> largest eigenvalue ofA.</p></li><li><p>对于一个最简的行随机矩阵A，将其特征值1的右特征向量记为<spanclass="math inline">\(1_n\)</span>，左特征向量记为<spanclass="math inline">\(\pi ^T\)</span>，使得<spanclass="math inline">\(\pi ^T \cdot 1_n = 1\)</span>。</p></li><li><p><spanclass="math inline">\(\|\cdot\|\)</span>被定义为一个特殊的矩阵范数，在Lemma2中会讲到</p></li><li><p><spanclass="math inline">\(\|\cdot\|_2\)</span>就是普通的向量或者矩阵的二范数</p></li><li><p>有性质： <span class="math display">\[\begin{aligned}c&#39;\|\cdot\|\leq\|\cdot\|_2\leq c\|\cdot\|\\d&#39;\|\cdot\|_2\leq\|\cdot\|\leq d\|\cdot\|_2\end{aligned} \\c&#39;, c, d&#39;, d\,are\,some\,positive\,constants\]</span></p></li><li><p>更多关于向量和矩阵范数的知识，参考[37]</p></li></ul><h3 id="problem-assumptions-algorithm">2. Problem, Assumptions,Algorithm</h3><p>Problem：</p><p>把问题描述为一个强连通有n个玩家的有向图：<spanclass="math inline">\(\mathcal{G}=(\mathcal{V},\mathcal{E})\)</span>。注意若<spanclass="math inline">\((i, j) \in \mathcal{E}\)</span>，则<spanclass="math inline">\(j\)</span>可以发信息给<spanclass="math inline">\(i\)</span>。定义<spanclass="math inline">\(\mathcal{N}_i^{in}\)</span>为<spanclass="math inline">\(i\)</span>自己加上<spanclass="math inline">\(i\)</span>的邻居，这个集合也就是能发信息给<spanclass="math inline">\(i\)</span>的玩家集合。</p><p>我们要的目标函数是这个：<spanclass="math inline">\(min\,f(\mathbf{x})=\sum_{i=1}^nf_i(\mathbf{x})\)</span></p><p>需要注意<spanclass="math inline">\(f_i\)</span>是凸且可微的，并且只有玩家<spanclass="math inline">\(i\)</span>知道。</p><p>Assumption 1：有向图是强连通的。</p><p>Assumption 2：每个<spanclass="math inline">\(f_i\)</span>是可微且强凸的。且对x导数（梯度）具有Lipschitz连续。具体来说，<spanclass="math inline">\(f_i\)</span>满足如下两个定义：</p><blockquote><p><spanclass="math inline">\(f_i(\mathbf{x}_1)-f_i(\mathbf{x}_2)\leq\nablaf_i(\mathbf{x}_1)^\top(\mathbf{x}_1-\mathbf{x}_2)-\frac{s}{2}\|\mathbf{x}_1-\mathbf{x}_2\|_2^2\)</span>，s是正整数</p><p><span class="math inline">\(\|\nabla f_i(\mathbf{x}_1)-\nablaf_i(\mathbf{x}_2)\|_2\leql\|\mathbf{x}_1-\mathbf{x}_2\|_2\)</span>，l是正整数</p></blockquote><p>因为<span class="math inline">\(f\)</span>是所有<spanclass="math inline">\(f_i\)</span>之和，所以<spanclass="math inline">\(f\)</span>也是满足强凸和Lipschitz梯度连续的，也就是满足上面那俩式子。显然常数分别为<spanclass="math inline">\(ns, nl\)</span>。</p><p>Algorithm： <span class="math display">\[\begin{gathered}\mathbf{x}_{k+1,i}=\sum_{j=1}^{n}a_{ij}\mathbf{x}_{k,j}-\alpha\mathbf{z}_{k,i},\left.\left(\begin{matrix}{1}{\mathrm{a}}\\\end{matrix}\right.\right) \\\mathbf{y}_{k+1,i} =\sum_{j=1}^{n}a_{ij}\mathbf{y}_{k,j}, (1\mathrm{b})\\\mathbf{z}_{k+1,i} =\sum_{j=1}^{n}a_{ij}\mathbf{z}_{k,j}+{\frac{\nablaf_{i}(\mathbf{x}_{k+1,i})}{[\mathbf{y}_{k+1,i}]_{i}}}-{\frac{\nablaf_{i}(\mathbf{x}_{k,i})}{[\mathbf{y}_{k,i}]_{i}}}\left.\left(\begin{matrix}{1}{\mathrm{c}}\\\end{matrix}\right.\right)\end{gathered}\]</span> <span class="math inline">\(a_{ij}\)</span> 满足下面这个条件：<span class="math display">\[a_{ij}=\begin{cases}&amp;&gt;0,&amp;j\in\mathcal{N}_i^\mathrm{in},\\&amp;0,&amp;\mathrm{otw.},\end{cases}\quad\sum_{j=1}^na_{ij}=1,\foralli\]</span></p><p><span class="math inline">\(\alpha &gt; 0\)</span> is a constantstep-size</p><p><span class="math inline">\(\nablaf_{i}(\mathbf{x}_{k,i})\in\mathbb{R}^{p}\)</span> is the gradient of<span class="math inline">\(f_i\)</span> at <spanclass="math inline">\(x_{k, i}\)</span></p><p><span class="math inline">\(x_0\)</span> is arbitrary, <spanclass="math inline">\(\mathbf{y}_{0,i}=\mathbf{e}_i, \quad\mathbf{z}_{0,i}=\nabla f_i(\mathbf{x}_{0,i})\)</span></p><p>上面的算法中</p><p>根据[38]中的Perron-Frobenius定理，(1b)将收敛到矩阵A的左特征向量<spanclass="math inline">\(\pi ^T\)</span>。</p><p>(1c)使用(1b)来缩放梯度，从而消除了行随机矩阵引起的不平衡。</p><p>而且，为了简化证明，其实可以把<span class="math inline">\(x_{k, i},z_{k, i}, \nablaf_i(x_{k,i})\)</span>,$看成一维的。只要一维的得证了，后续套一个Kroneckerproduction notation就可以把p维的证出来了。</p><p>为了简化表达，我们定义下面式子： <span class="math display">\[\begin{aligned}\mathbf{x}_{k}&amp; =[x_{k,1},\cdots,x_{k,n}]^{\top},  \\\mathbf{Z}_{k}&amp; =[z_{k,1},\cdots,z_{k,n}]^{\top},  \\\nabla\mathbf{f}_{k}&amp; =\left[\nabla f_1(x_{k,1}),\cdots,\nablaf_n(x_{k,n})\right]^\top,  \\Y_{k}&amp; =[\mathbf{y}_{k,1},\cdots,\mathbf{y}_{k,n}]^\top,  \\\widetilde{Y}_{k}&amp; =\operatorname{diag}(Y_k).\end{aligned}\]</span> 则algorithm 1可以写成以下形式： <span class="math display">\[\begin{gathered}\mathbf{x}_{k+1}= A\mathbf{x}_{k}-\alpha\mathbf{z}_{k}, (2\mathrm{a}) \\Y_{k+1}= AY_{k}, (2\mathrm{b}) \\\mathbf{z}_{k+1}= A\mathbf{z}_{k}+\widetildeY_{k+1}^{-1}\nabla\mathbf{f}_{k+1}-\widetildeY_{k}^{-1}\nabla\mathbf{f}_{k}, \text{(2c)}\end{gathered}\]</span></p><h3 id="main-results">3. Main results</h3><p>定义：<spanclass="math inline">\(Y_\infty=\lim_{k\to\infty}Y_k\)</span></p><p>因为<span class="math inline">\(Y_k = AY_{k-1} = A^2Y_{k-2} =...\)</span></p><p>所以<spanclass="math inline">\(\operatorname*{lim}_{k\to\infty}Y_{k}=\operatorname*{lim}_{k\to\infty}A^{k}\)</span>（<spanclass="math inline">\(Y_1=I_n\)</span>）</p><p>又由[38]中的Perron-Frobenius定理，<spanclass="math inline">\(Y_k\)</span>将收敛到<spanclass="math inline">\(1_n\pi ^ T\)</span></p><p>即<spanclass="math inline">\(Y_\infty=\lim\limits_{k\to\infty}Y_k=\operatorname*{lim}\limits_{k\to\infty}A^k=1_n\pi^T\)</span>继续定义： <span class="math display">\[\begin{aligned}\mathbf{x}^{*}&amp; =x^{*}\mathbf{1}_{n},  \\\widehat{\mathbf{x}}_{k}&amp; =Y_{\infty}\mathbf{x}_{k},  \\\widehat{z}_{k}&amp; =Y_{\infty}\mathbf{z}_{k},  \\\nabla\mathbf{f}^{*}&amp; =[\nabla f_{1}(x^{*}),\cdots,\nablaf_{n}(x^{*})]^{\top},  \\\nabla\widehat{\mathbf{f}}_{k}&amp;=\frac{1}{n}\mathbf{1}_{n}\mathbf{1}_{n}^{\top}\left[\nablaf_{1}(\widehat{x}_{k}),...,\nabla f_{n}(\widehat{x}_{k})\right]^{\top},\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}&amp;\tau=\left\|A-I_{n}\right\|_{2}, \\&amp;\epsilon=\left\|I_{n}-Y_{\infty}\right\|_{2}, \\&amp;\eta=\operatorname*{max}\left(\left|1-\alphanl\right|,\left|1-\alpha ns\right|\right)\end{aligned}\]</span></p><p><span class="math inline">\(l, s\)</span>出自这： $$f_i(_1)-f_i(_2)f_i(_1)^(_1-_2)-|_1-_2|_2^2$，s是正整数 \</p>|f_i(_1)-f_i(_2)|_2l|_1-_2|_2$，l是正整数 <span class="math display">\[继续定义：\]</span><span class="math display">\[\begin{aligned}&amp;y=\operatorname*{sup}_{k}\left\|Y_{k}\right\|_{2}, \\&amp;\widetilde{y}=\operatorname*{sup}_{k}\left\|\widetilde{Y}_{k}^{-1}\right\|_{2}.\end{aligned}\]</span><p>$$</p><h4 id="lemma-1">Lemma 1</h4><p><span class="math inline">\(\left\|Y_k-Y_\infty\right\|_2\leqT\gamma_1^k,\quad\forall k.\quad(3) \\ 0 &lt; \gamma &lt; 1 \, and \, 0&lt; T &lt; \infty\)</span></p><p>推导参考[22]</p><h4 id="lemma-2">Lemma 2</h4><p>For any <span class="math inline">\(a \in \mathbb{R^n}\)</span>,define <spanclass="math inline">\(\widehat{\mathbf{a}}=Y_{\infty}\mathbf{a}\)</span>.Then there exists <span class="math inline">\(0&lt;\sigma&lt;1\)</span>such that <span class="math display">\[\left\|A\mathbf{a}-\widehat{\mathbf{a}}\right\|\leq\sigma\left\|\mathbf{a}-\widehat{\mathbf{a}}\right\|\qquad (4)\]</span> Proof:</p><p>由[38]中的Perron-Frobenius定理，得<spanclass="math inline">\(\rho(A)=1\)</span> and every eigenvalue of A otherthan 1 is strictly less than <spanclass="math inline">\(\rho(A)\)</span>。</p><p>We now have： <span class="math display">\[\begin{array}{rcl}AY_\infty&amp;=&amp;A\mathbf{1}_n\pi^\top&amp;=&amp;\mathbf{1}_n\pi^\top&amp;=&amp;Y_\infty,\\Y_\inftyY_\infty&amp;=&amp;\mathbf{1}_n\pi^\top\mathbf{1}_n\pi^\top&amp;=&amp;\mathbf{1}_n\pi^\top&amp;=&amp;Y_\infty,\end{array}\]</span> and thus <spanclass="math inline">\(AY_{\infty}-Y_{\infty}Y_{\infty}\)</span> is azero matrix. Therefore, <span class="math display">\[A\mathbf{a}-Y_\infty\mathbf{a}\quad=\quad(A-Y_\infty)(\mathbf{a}-Y_\infty\mathbf{a}).\]</span></p><blockquote><p>右边打开：Aa - AYa - Ya + Y^2a = Aa - AYa - Ya + Ya = Aa - AYa = Aa -Ya = 左边</p></blockquote><p>所以 <span class="math display">\[\left\|A\mathbf{a}-Y_\infty\mathbf{a}\right\|\quad\leq\quad\left\|A-Y_\infty\right\|\left\|\mathbf{a}-Y_\infty\mathbf{a}\right\|,\quad\left(5\right)\]</span> 又<span class="math inline">\(\|A - Y_\infty\| &lt; 1\)</span><strong><u>为啥</u></strong></p><p>所以</p><p><spanclass="math inline">\(\left\|A\mathbf{a}-\widehat{\mathbf{a}}\right\|\leq\sigma\left\|\mathbf{a}-\widehat{\mathbf{a}}\right\|\)</span>，<spanclass="math inline">\(\sigma=\left\|A-Y_{\infty}\right\|\)</span>，且<spanclass="math inline">\(0 &lt; \sigma &lt; 1\)</span></p><h4 id="lemma-3">Lemma 3</h4><p>There exists some constant <spanclass="math inline">\(\widetilde{T}\)</span> such that the followinginequalities hold for all k &gt;= 1 <span class="math display">\[(a)\left\|\widetilde{Y}_k^{-1}-\widetilde{Y}_\infty^{-1}\right\|_2\leq\widetilde{y}^2\widetilde{T}\gamma_1^k\\(b)\left\|\widetilde{Y}_{k+1}^{-1}-\widetilde{Y}_{k}^{-1}\right\|_{2}\leq2\widetilde{y}^{2}\widetilde{T}\gamma_{1}^{k}\]</span> Proof:</p><p>先推(a) <span class="math display">\[\begin{aligned}\left\|\tilde{Y}_{k}^{-1}-\tilde{Y}_{\infty}^{-1}\right\|_{2}&amp;\leq\left\|\tilde{Y}_{k}^{-1}\right\|_{2}\left\|\tilde{Y}_{k}-\tilde{Y}_{\infty}\right\|_{2}\left\|\tilde{Y}_{\infty}^{-1}\right\|_{2},  \\&amp;\leq\tilde{y}^{2}\widetilde{T}\gamma_{1}^{k},\end{aligned}\]</span> 第一个不等号推导见“Distributed Nash Equilibrium Seekingfor...”的Lemma 1证明</p><p>第二个不等号用了<spanclass="math inline">\(\widetilde{y}\)</span>的定义和Lemma 1</p><p>再推(b)，用推(a)一样的方法，先推出：</p><p><spanclass="math inline">\(\left\|\widetilde{Y}_{k+1}^{-1}-\widetilde{Y}_{k}^{-1}\right\|_2\le \|\widetilde{Y}_{k+1}\| \cdot \|\widetilde{Y}_{k}^{-1}\| \cdot\|\widetilde{Y}_{k+1} - \widetilde{Y}_k\| \le \widetilde{y}^2 \cdot\|\widetilde{Y}_{k+1} - \widetilde{Y}_k\|\)</span></p><p>又<span class="math inline">\(\|\widetilde{Y}_{k+1} -\widetilde{Y}_k\| = \|\widetilde{Y}_{k+1} - \widetilde{Y}_{\infty}\ -(\widetilde{Y}_{k} - \widetilde{Y}_{\infty})\| \le \|\widetilde{Y}_{k+1}- \widetilde{Y}_{\infty}\| + \|\widetilde{Y}_{k} -\widetilde{Y}_{\infty}\| \le 2\widetilde{T}\gamma_{1}^{k}\)</span></p><p>所以</p><p><spanclass="math inline">\(\left\|\widetilde{Y}_{k+1}^{-1}-\widetilde{Y}_{k}^{-1}\right\|_2\le 2\widetilde{y}^2\widetilde{T}\gamma_{1}^{k}\)</span>，得证。</p><p>剩下来的内容不继续看了，因为需要的知识已经找到了，就是Lemma 3</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;标题：Linear convergence in optimization over directed graphs with
row-stochastic matrices&lt;/p&gt;
&lt;p&gt;中文翻译：行随机矩阵有向图优化的线性收敛性&lt;/p&gt;</summary>
    
    
    
    <category term="1. 论文" scheme="http://example.com/categories/1-%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>数字逻辑实验笔记</title>
    <link href="http://example.com/2023/10/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-23T04:40:07.000Z</published>
    <updated>2024-02-19T16:39:28.220Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分主要是verilog语法，比较简单。</p><span id="more"></span><h3 id="两种声明方式">两种声明方式</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AND4(a, b, out);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">assign</span> out = a &amp; b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AND4(<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a, <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] b, <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] out);</span><br><span class="line">    <span class="keyword">assign</span> out = a &amp; b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="数据类型">数据类型</h3><p>掌握wire和reg即可。</p><p>wire就是对应着电路里的线。reg就是对应着电路里的寄存器。</p><p>常量用parameter定义，例如parameter width = 3;但是常量也可以重定义，例如下面这个例子：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder(a, b, sum);</span><br><span class="line">    <span class="keyword">parameter</span> time_delay = <span class="number">5</span>, time_count = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] a1, b1;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] sum1;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] a2, b2;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] sum2;</span><br><span class="line">    adder <span class="variable">#(4, 8) AD1(a1, b1, sum1)</span>;<span class="comment">//time_delay=4, time_count=8</span></span><br><span class="line">    adder <span class="variable">#(12) AD2(a2, b2, sum2)</span>;<span class="comment">//time_delay=12, time_count=10</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="数据的表达方式">数据的表达方式</h3><p><位宽>'<进制><数字>：4'b0101 / 4‘h5</p><p><进制><数字>：位宽一般默认是32位。h5</p><p><数字>：位宽默认32位，进制默认为十进制。5</p><h3 id="拼接运算符">拼接运算符</h3><p>{a, b[3:0], w, 3'b101} 等价于 {a, b[3], b[2], b[1], b[0], w, 1'b1,1'b0, 1'b1}</p><p>{4{w}} 等价于 {w, w, w, w}</p><p>{b, 3{a, b}} 等价于 {b, a, b, a, b, a, b}</p><h3 id="赋值语句">赋值语句</h3><p>assign只能对wire类型赋值。assign的作用通常就是把reg的结果用一个wire接收。</p><p>initial里对reg变量赋初值。</p><p>always里的=(阻塞赋值)/&lt;=(非阻塞赋值)对always块里的reg类型赋值。</p><p>always语句</p><p>always @ (clk) //只要clk发生变化就触发 always @ (posedge clk)//clk上升沿触发（从0-&gt;1触发）</p><p>always @ (negedge clk) //clk下降沿触发（从1-&gt;0触发）</p><p>always @ (*) //always块内任何输入信号变化了就触发</p><h3 id="条件语句">条件语句</h3><p>条件语句只能用于always或initial内部。只需要掌握if-else和case语句即可。</p><p>if-else语句：跟C++一样，只不过多条语句时将{}换成begin-end</p><p>case语句：有case/casex/casez可以选择。casex就是分支表达式中可以有?作为通配符。</p><h3 id="循环语句">循环语句</h3><p>一般循环语句都是用来写仿真文件的。因为循环次数不确定的循环语句是不能被综合的！</p><p>所以一般用循环语句来写源代码都是用for循环</p><hr /><p>接下来的内容就是实验了，实验代码自己手撸的。而且只学了基本语法就开干了，所以代码自我感觉很丑不优美。</p><h3 id="实验一">实验一</h3><p><img src="1.png" /></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> demo02_verilog #(<span class="keyword">parameter</span> W1 = <span class="number">1</span>, W2 = <span class="number">3</span>) (</span><br><span class="line">    <span class="keyword">input</span> [(W1 - <span class="number">1</span>) : <span class="number">0</span>] sw15, sw14,</span><br><span class="line">    <span class="keyword">input</span> [(W2 - <span class="number">1</span>) : <span class="number">0</span>] in1, in2, in3, in4,</span><br><span class="line">    <span class="keyword">output</span> [(W2 - <span class="number">1</span>) : <span class="number">0</span>] ld</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//错误代码：assign ld = (~sw15 &amp; ~sw14 &amp; in1) | (~sw15 &amp; sw14 &amp; in2) | (sw15 &amp; ~sw14 &amp; in3) | (sw15 &amp; sw14 &amp; in4);</span></span><br><span class="line">    <span class="keyword">assign</span> ld = sw15 ? (sw14 ? in4 : in3) : (sw14 ? in2 : in1);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="实验二">实验二</h3><p><img src="2.png" /></p><ul><li>top.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top(a, b, t, e, l1, l2, l3, clk, reset, an, led);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">output</span> t, e;</span><br><span class="line">    <span class="keyword">output</span> l1, l2, l3;  <span class="comment">//控制负数亮灯</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">input</span> clk, reset;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] an;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>] led;</span><br><span class="line">    </span><br><span class="line">    add <span class="variable">#(4) f1(.a(a), .b(b), .out(out), .t(t), .e(e))</span>;</span><br><span class="line">    show(<span class="variable">.clk</span>(clk), <span class="variable">.reset</span>(reset),</span><br><span class="line">         <span class="variable">.hex0</span>(out), <span class="variable">.hex2</span>(b), <span class="variable">.hex3</span>(a),</span><br><span class="line">         <span class="variable">.an</span>(an), <span class="variable">.sseg</span>(led), <span class="variable">.l1</span>(l1), <span class="variable">.l2</span>(l2), <span class="variable">.l3</span>(l3));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>add.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进位不影响补码运算的正确性，溢出影响正确性，溢出的本质就是超过了位宽能表达的范围</span></span><br><span class="line"><span class="keyword">module</span> add (a, b, out, t, e);</span><br><span class="line">    <span class="keyword">parameter</span> W = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">input</span> [W-<span class="number">1</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">output</span> [W-<span class="number">1</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">output</span> t, e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [W-<span class="number">1</span>:<span class="number">0</span>] a_, b_; <span class="comment">//补码</span></span><br><span class="line">    <span class="keyword">reg</span> [W-<span class="number">1</span>:<span class="number">0</span>] out_;   <span class="comment">//运算后的补码</span></span><br><span class="line">    <span class="keyword">reg</span> [W-<span class="number">1</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] i;</span><br><span class="line">    <span class="keyword">reg</span> t = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> @ (*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//都转为补码</span></span><br><span class="line">        a_ = a;</span><br><span class="line">        b_ = b;</span><br><span class="line">        <span class="keyword">if</span> (a_[W-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W - <span class="number">1</span>; i = i + <span class="number">1</span>) a_[i] = ~a[i];</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                    tt = a_[i];</span><br><span class="line">                    a_[i] = a_[i] ^ <span class="number">1</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">1</span>) | (t &amp; (tt | <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    tt = a_[i];</span><br><span class="line">                    a_[i] = a_[i] ^ <span class="number">0</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">0</span>) | (t &amp; (tt | <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (b_[W-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W - <span class="number">1</span>; i = i + <span class="number">1</span>) b_[i] = ~b[i];</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                    tt = b_[i];</span><br><span class="line">                    b_[i] = b_[i] ^ <span class="number">1</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">1</span>) | (t &amp; (tt | <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    tt = b_[i];</span><br><span class="line">                    b_[i] = b_[i] ^ <span class="number">0</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">0</span>) | (t &amp; (tt | <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">//俩补码运算</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            out_[i] = a_[i] ^ b_[i] ^ t;</span><br><span class="line">            t = (a_[i] &amp; b_[i]) | (t &amp; (a_[i] | b_[i]));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">//检测是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> (a_[W-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; b_[W-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; out_[W-<span class="number">1</span>] == <span class="number">1</span>) e = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a_[W-<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; b_[W-<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; out_[W-<span class="number">1</span>] == <span class="number">0</span>) e = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> e = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将补码转为原码</span></span><br><span class="line">        <span class="keyword">if</span> (out_[W-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//变反码</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                a_[i] = out_[i];</span><br><span class="line">                b_[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            tt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                out_[i] = a_[i] ^ b_[i] ^ tt;</span><br><span class="line">                tt = (a_[i] &amp; b_[i]) | (tt &amp; (a_[i] | b_[i]));</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">//变原码</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W - <span class="number">1</span>; i = i + <span class="number">1</span>) out_[i] = ~out_[i];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) out[i] = out_[i];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>show.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> show(clk, reset, hex0, hex1, hex2, hex3, an, sseg, l1, l2, l3);</span><br><span class="line">    <span class="keyword">input</span> clk, reset;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] hex0, hex1, hex2, hex3; <span class="comment">//分别存储4个灯要显示的数字（0-15）</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] an;                    <span class="comment">//控制每个灯是否工作，0为工作</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>] sseg;                  <span class="comment">//存储数字在数码管上的表示</span></span><br><span class="line">    <span class="keyword">output</span> l1, l2, l3;                  <span class="comment">//控制负数亮灯</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> l1 = hex3[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> l2 = hex2[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> l3 = hex0[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">localparam</span> N = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">reg</span> [N-<span class="number">1</span>:<span class="number">0</span>] regN;</span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(reset) regN &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> regN &lt;= regN + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] an;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] hex_in;   <span class="comment">//存储当前要展示的数字</span></span><br><span class="line">    <span class="keyword">always</span> @ (*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(regN[N-<span class="number">1</span> : N-<span class="number">2</span>])</span><br><span class="line">            <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b1110</span>; </span><br><span class="line">                hex_in = hex0;  </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b1101</span>; </span><br><span class="line">                hex_in = hex1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b1011</span>;</span><br><span class="line">                hex_in = hex2;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b0111</span>;</span><br><span class="line">                hex_in = hex3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] sseg;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(hex_in[<span class="number">2</span>:<span class="number">0</span>])</span><br><span class="line">            <span class="number">4&#x27;h0</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0000001</span>; </span><br><span class="line">            <span class="number">4&#x27;h1</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1001111</span>;</span><br><span class="line">            <span class="number">4&#x27;h2</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0010010</span>;</span><br><span class="line">            <span class="number">4&#x27;h3</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0000110</span>;</span><br><span class="line">            <span class="number">4&#x27;h4</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1001100</span>;</span><br><span class="line">            <span class="number">4&#x27;h5</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0100100</span>;</span><br><span class="line">            <span class="number">4&#x27;h6</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0100000</span>;</span><br><span class="line">            <span class="number">4&#x27;h7</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0001111</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="实验三">实验三</h3><p><img src="3.png" /></p><ul><li>top.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top(clk, A, B, sum, t);</span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] A, B;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] sum;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Lsm_d1;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Aup_d1, Bup_d1;</span><br><span class="line">    <span class="keyword">reg</span> Carry_d1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @ (clk) <span class="keyword">begin</span></span><br><span class="line">        &#123;Carry_d1, Lsm_d1&#125; = A[<span class="number">15</span>:<span class="number">0</span>] + B[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">        Aup_d1 = A[<span class="number">31</span>:<span class="number">16</span>];</span><br><span class="line">        Bup_d1 = B[<span class="number">31</span>:<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @ (clk) <span class="keyword">begin</span></span><br><span class="line">        sum[<span class="number">15</span>:<span class="number">0</span>] = Lsm_d1;</span><br><span class="line">        &#123;t, sum[<span class="number">31</span>:<span class="number">16</span>]&#125; = Aup_d1 + Bup_d1 + Carry_d1;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="实验四">实验四</h3><p><img src="4.png" /></p><ul><li>top.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// top 模块：整合时钟分频器和交通灯控制器</span></span><br><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">    <span class="keyword">input</span> clk,        <span class="comment">// 输入：主时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> rst_n,      <span class="comment">// 输入：复位信号</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] light_NS, <span class="comment">// 输出：南北方向交通灯状态</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] light_EW  <span class="comment">// 输出：东西方向交通灯状态</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> clk_out;  <span class="comment">// 内部线网：用于从时钟分频器传递分频后的时钟</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 实例化时钟分频器模块</span></span><br><span class="line">    clockdivider u1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">        <span class="variable">.clk_out</span>(clk_out)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 实例化交通灯控制模块</span></span><br><span class="line">    traffic_light u2(</span><br><span class="line">        <span class="variable">.clk</span>(clk_out),  <span class="comment">// 使用分频后的时钟</span></span><br><span class="line">        <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">        <span class="variable">.light_NS</span>(light_NS),  <span class="comment">// 南北方向交通灯状态</span></span><br><span class="line">        <span class="variable">.light_EW</span>(light_EW)   <span class="comment">// 东西方向交通灯状态</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>clockdivider.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clockdivider 模块：用于将输入时钟分频</span></span><br><span class="line"><span class="keyword">module</span> clockdivider(</span><br><span class="line">    <span class="keyword">input</span> clk,           <span class="comment">// 输入：原始的高频时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> rst_n,         <span class="comment">// 输入：复位信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk_out   <span class="comment">// 输出：分频后的时钟信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> DIVISOR = <span class="number">32&#x27;d1666_6667</span>; <span class="comment">// 分频因子</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] counter = <span class="number">32&#x27;d0</span>;        <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时钟分频逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst_n) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位时，重置计数器和输出时钟</span></span><br><span class="line">            counter &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">            clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 计数器达到分频因子时，翻转输出时钟并重置计数器</span></span><br><span class="line">            <span class="keyword">if</span> (counter == DIVISOR - <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                clk_out &lt;= ~clk_out;</span><br><span class="line">                counter &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 否则，计数器递增</span></span><br><span class="line">                counter &lt;= counter + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>traffic_light.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traffic_light 模块：控制交通灯状态</span></span><br><span class="line"><span class="keyword">module</span> traffic_light(</span><br><span class="line">    <span class="keyword">input</span> clk,           <span class="comment">// 输入：时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> rst_n,         <span class="comment">// 输入：复位信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] light_NS, <span class="comment">// 输出：南北方向交通灯状态</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] light_EW  <span class="comment">// 输出：东西方向交通灯状态</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态定义</span></span><br><span class="line">    <span class="keyword">parameter</span> [<span class="number">2</span>:<span class="number">0</span>] GREEN_NS_RED_EW   = <span class="number">3&#x27;b000</span>,</span><br><span class="line">                     YELLOW_NS_RED_EW  = <span class="number">3&#x27;b001</span>,</span><br><span class="line">                     RED_NS_RED_EW_1   = <span class="number">3&#x27;b010</span>,</span><br><span class="line">                     RED_NS_GREEN_EW   = <span class="number">3&#x27;b011</span>,</span><br><span class="line">                     RED_NS_YELLOW_EW  = <span class="number">3&#x27;b100</span>,</span><br><span class="line">                     RED_NS_RED_EW_2   = <span class="number">3&#x27;b101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state = GREEN_NS_RED_EW; <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] counter = <span class="number">4&#x27;b0000</span>;       <span class="comment">// 计时器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时钟边沿触发的逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst_n) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位逻辑</span></span><br><span class="line">            state &lt;= GREEN_NS_RED_EW;</span><br><span class="line">            counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 状态转换逻辑</span></span><br><span class="line">            <span class="keyword">case</span> (state)</span><br><span class="line">                GREEN_NS_RED_EW: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b1111</span>) <span class="keyword">begin</span> <span class="comment">// 15时钟周期</span></span><br><span class="line">                        state &lt;= YELLOW_NS_RED_EW;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                YELLOW_NS_RED_EW: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b0011</span>) <span class="keyword">begin</span> <span class="comment">// 3时钟周期</span></span><br><span class="line">                        state &lt;= RED_NS_RED_EW_1;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_RED_EW_1: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b0011</span>) <span class="keyword">begin</span> <span class="comment">// 3时钟周期，短暂的全红状态</span></span><br><span class="line">                        state &lt;= RED_NS_GREEN_EW;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_GREEN_EW: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b1111</span>) <span class="keyword">begin</span> <span class="comment">// 15时钟周期</span></span><br><span class="line">                        state &lt;= RED_NS_YELLOW_EW;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_YELLOW_EW: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b0011</span>) <span class="keyword">begin</span> <span class="comment">// 3时钟周期</span></span><br><span class="line">                        state &lt;= RED_NS_RED_EW_2;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_RED_EW_2: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b0011</span>) <span class="keyword">begin</span> <span class="comment">// 3时钟周期</span></span><br><span class="line">                        state &lt;= GREEN_NS_RED_EW;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计数器递增</span></span><br><span class="line">            counter &lt;= counter + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据当前状态更新交通灯输出</span></span><br><span class="line">            <span class="keyword">case</span> (state)</span><br><span class="line">                GREEN_NS_RED_EW: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b010</span>; <span class="comment">// 南北绿灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 东西红灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                YELLOW_NS_RED_EW: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b001</span>; <span class="comment">// 南北黄灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 东西红灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_RED_EW_1: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 南北红灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 东西红灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_GREEN_EW: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 南北红灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b010</span>; <span class="comment">// 东西绿灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_YELLOW_EW: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 南北红灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b001</span>; <span class="comment">// 东西黄灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_RED_EW_2: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 南北红灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 东西红灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="大作业">大作业</h3><p><img src="5.png" /></p><figure><img src="6.png" alt="1705202189606" /><figcaption aria-hidden="true">1705202189606</figcaption></figure><figure><img src="7.png" alt="1705202209567" /><figcaption aria-hidden="true">1705202209567</figcaption></figure><ul><li>top.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top(clk, reset, btn, an, sseg, current_floor, goal_floor);</span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">input</span> reset;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] an;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] sseg;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] hex_in;        <span class="comment">//存储要显示的楼层数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] btn;                 <span class="comment">// 按钮输入</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] current_floor;      <span class="comment">// 当前楼层（例如01000）</span></span><br><span class="line">    <span class="keyword">output</span>  [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] goal_floor;      <span class="comment">// 呼叫的楼层（例如01000）</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">localparam</span> N = <span class="number">18</span>;         <span class="comment">//分频系数(50MHZ/2^16)</span></span><br><span class="line"><span class="keyword">reg</span> [N-<span class="number">1</span>:<span class="number">0</span>] regN;          <span class="comment">//高两位作为控制信号，低16位为计数器，对时钟进行分频</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line"><span class="keyword">if</span>(reset) regN &lt;= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> regN &lt;= regN + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">solve</span> u1(<span class="variable">.clk</span>(clk),</span><br><span class="line">             <span class="variable">.rst</span>(reset),</span><br><span class="line">             <span class="variable">.btn</span>(btn),</span><br><span class="line">             <span class="variable">.key_pulse</span>(),</span><br><span class="line">             <span class="variable">.current_floor</span>(current_floor),</span><br><span class="line">             <span class="variable">.goal_floor</span>(goal_floor)</span><br><span class="line">             );</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ * <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">case</span>(regN[N-<span class="number">1</span> : N-<span class="number">2</span>])</span><br><span class="line">       <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">           an = <span class="number">4&#x27;b0111</span>; <span class="comment">//选中第1个数码管</span></span><br><span class="line">           hex_in = current_floor;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">       <span class="number">2&#x27;b11</span>:<span class="keyword">begin</span></span><br><span class="line">           an = <span class="number">4&#x27;b1110</span>;<span class="comment">//选中第四个数码管</span></span><br><span class="line">           hex_in =  goal_floor;</span><br><span class="line">       <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>@ * <span class="keyword">begin</span></span><br><span class="line">   <span class="keyword">case</span>(hex_in)</span><br><span class="line">       <span class="number">5&#x27;b00000</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0000001</span>;</span><br><span class="line">       <span class="number">5&#x27;b00001</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1001111</span>;</span><br><span class="line">       <span class="number">5&#x27;b00010</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0010010</span>;</span><br><span class="line">       <span class="number">5&#x27;b00100</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0000110</span>;</span><br><span class="line">       <span class="number">5&#x27;b01000</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1001100</span>;</span><br><span class="line">       <span class="number">5&#x27;b10000</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0100100</span>;</span><br><span class="line">       <span class="keyword">default</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1111111</span>;</span><br><span class="line">   <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>solve.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">solve</span>(clk, rst, btn, key_pulse, current_floor, goal_floor);</span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">input</span> rst;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] btn;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] current_floor;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] goal_floor; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] key_edge;         <span class="comment">// 按键松开时，其为1，使得cnt清零，产生延时</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] key_lat;           <span class="comment">// 存储上一个触发时的按键值</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] key_now;           <span class="comment">// 存储当前时刻触发的按键值</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">            key_now &lt;= &#123;<span class="number">5</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125;;</span><br><span class="line">            key_lat &lt;= &#123;<span class="number">5</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            key_now &lt;= btn;</span><br><span class="line">            key_lat &lt;= key_now;</span><br><span class="line">        <span class="keyword">end</span>    </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span>  key_edge = key_lat &amp; (~key_now);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//产生20ms延时，当检测到key_edge有效是计数器清零开始计数</span></span><br><span class="line">    <span class="keyword">reg</span>[<span class="number">17</span>:<span class="number">0</span>] cnt;    </span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst) cnt &lt;= <span class="number">18&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key_edge) cnt &lt;= <span class="number">18&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">else</span> cnt &lt;= cnt + <span class="number">1&#x27;h1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用f1、f2俩变量来控制实现&quot;只用按一次按钮就可以，不用一直按&quot;的效果</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] f1;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] f2;</span><br><span class="line">    <span class="comment">// 延时更新f1</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst) f1 &lt;= &#123;<span class="number">5</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;                </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt==<span class="number">18&#x27;h3ffff</span>) f1 &lt;= btn;  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// f2随时保持f1的节奏</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst) f2 &lt;= &#123;<span class="number">5</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">else</span> f2 &lt;= f1;             </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一开始俩都是0000，所以key_pulse不会改变</span></span><br><span class="line">    <span class="comment">// 一直按住某个按键的话，就会出现f2 = 0, f1 = 1的情况，此时key_pulse会翻转为1</span></span><br><span class="line">    <span class="comment">// 如果按住某个按键，然后松开的话，那么会使得cnt重新为0。也就是f1 = 1的情况会延时一段时间，此时f2趁机更新为1。</span></span><br><span class="line">    <span class="comment">// 从而延时这段时间，不会使得key_pulse翻转</span></span><br><span class="line">    <span class="comment">// 当延时到了，就会出现，key_sec更新为0，f2 = 1的情况。此时也不会使得key_pulse翻转</span></span><br><span class="line">    <span class="comment">// 然后重新回到俩都是0的情况</span></span><br><span class="line">    <span class="comment">// 当再按一次时，就会出现如上的情况，从而实现&quot;取消&quot;的功能</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] key_pulse;      <span class="comment">// 处理后的按键状态</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst) key_pulse &lt;= &#123;<span class="number">5</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span>                                              </span><br><span class="line">            <span class="keyword">if</span>(~f2[<span class="number">4</span>] &amp; f1[<span class="number">4</span>]) key_pulse[<span class="number">4</span>] &lt;= ~key_pulse[<span class="number">4</span>];    </span><br><span class="line">            <span class="keyword">if</span>(~f2[<span class="number">3</span>] &amp; f1[<span class="number">3</span>]) key_pulse[<span class="number">3</span>] &lt;= ~key_pulse[<span class="number">3</span>];   </span><br><span class="line">            <span class="keyword">if</span>(~f2[<span class="number">2</span>] &amp; f1[<span class="number">2</span>]) key_pulse[<span class="number">2</span>] &lt;= ~key_pulse[<span class="number">2</span>];    </span><br><span class="line">            <span class="keyword">if</span>(~f2[<span class="number">1</span>] &amp; f1[<span class="number">1</span>]) key_pulse[<span class="number">1</span>] &lt;= ~key_pulse[<span class="number">1</span>];  </span><br><span class="line">            <span class="keyword">if</span>(~f2[<span class="number">0</span>] &amp; f1[<span class="number">0</span>]) key_pulse[<span class="number">0</span>] &lt;= ~key_pulse[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    get_floor u2(<span class="variable">.clk</span>(clk),</span><br><span class="line">                 <span class="variable">.rst</span>(rst),</span><br><span class="line">                 <span class="variable">.key_pulse</span>(key_pulse),</span><br><span class="line">                 <span class="variable">.current_floor</span>(current_floor),</span><br><span class="line">                 <span class="variable">.goal_floor</span>(goal_floor)</span><br><span class="line">                 );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>get_floor.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> get_floor(clk, rst, key_pulse, current_floor, goal_floor);</span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">input</span> rst;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] key_pulse;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] current_floor;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] goal_floor; </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        goal_floor = <span class="number">5&#x27;b00001</span>;</span><br><span class="line">        current_floor = <span class="number">5&#x27;b00001</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 时钟分频器：每过1s，clk_out=~clk_out。实现&quot;每一秒钟，电梯移动一层&quot;</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">30</span>:<span class="number">0</span>] cnt = <span class="number">30&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">parameter</span> M = <span class="number">100000000</span>;  <span class="comment">//1s=1000000000ns</span></span><br><span class="line">    <span class="keyword">reg</span> clk_out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst) clk_out = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == M-<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            clk_out = ~clk_out;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            clk_out = <span class="number">0</span>;</span><br><span class="line">            cnt = cnt + <span class="number">1&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 更新goal_floor</span></span><br><span class="line">    <span class="keyword">always</span> @ (*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst) goal_floor = <span class="number">5&#x27;b00001</span>;</span><br><span class="line">        <span class="keyword">else</span> goal_floor = key_pulse;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 更新current_floor     </span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk_out <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst) current_floor = <span class="number">5&#x27;b00001</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(goal_floor != <span class="number">5&#x27;b00000</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(current_floor &lt; goal_floor)               <span class="comment">//电梯所在楼层低于目标楼层则上升</span></span><br><span class="line">                current_floor = &#123;current_floor[<span class="number">3</span>:<span class="number">0</span>], current_floor[<span class="number">4</span>]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(current_floor &gt; goal_floor)         <span class="comment">//电梯所在楼层高于目标楼层则下降</span></span><br><span class="line">                current_floor = &#123;current_floor[<span class="number">0</span>], current_floor[<span class="number">4</span>:<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">           </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一部分主要是verilog语法，比较简单。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数字逻辑" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库自学笔记</title>
    <link href="http://example.com/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-18T16:22:07.000Z</published>
    <updated>2024-02-23T10:18:17.783Z</updated>
    
    <content type="html"><![CDATA[<p>懒得解释了，反正之前没咋认真听过课（其实是去做数据库期末项目了）。今天终于有点时间了抽空看了一下之前的内容，做一下笔记记录一下免得以后忘了。学点东西顺便应付一下期末考试。</p><span id="more"></span><p>upd: (2024/1/14)：这门课满绩了，考试很简单，都是笔记里的东西。</p><hr /><h3 id="数据库基础概念相关">数据库基础概念相关</h3><ol type="1"><li><p>数据(Data)、数据库(DB)、数据库系统(DBS)、数据库管理系统(DBMS)数据定义</p><ol type="1"><li>数据是描述事物的符号记录。</li><li>数据库是指长期存储在计算机内的、有组织的、可共享的大量数据集合。</li><li>数据库系统是指在计算机系统中引入数据库后的系统构成，由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员(和用户)构成。</li><li>数据库管理系统是位于用户(应用程序)与操作系统之间的一层数据库管理软件。</li></ol></li><li><p>数据库系统的开发环节</p><p><img src="6.png" /></p><p>​概念设计：通常使用实体-关系模型（ER模型）来表示数据和数据间的关系。</p><p>​逻辑设计：通常是关系模型(还有层次/网状模型)，包括了表/列/数据类型、约束（如主键、外键）等。</p><p>​物理设计：确定如何在物理存储层面上存储数据，包括文件组织、索引结构、数据分布、存储分配等。</p></li><li><p>数据管理的四个发展阶段：手工阶段、程序阶段、文件阶段、数据库阶段</p></li><li><p>数据库、数据库系统、数据库管理系统的功能</p><ol type="1"><li>DB：存储、检索、维护数据</li><li>DBS：管理数据库以及环境、支持用户与数据库交互、控制数据库权限及安全</li><li>DBMS：提供数据定义(DDL)、数据操作(DML)、数据控制(DCL)语言，同时维护数据库，确保数据库的完整性、性能优化和恢复管理</li></ol></li><li><p>概念模型：是对现实世界的系统、概念或其他复杂对象的抽象表示。例如：层次模型(类似树)、网状模型(类似图)、关系模型(现在的数据库模型)、实体-联系模型(不是数据库模型，是一种用于数据库设计的高层次概念模型(ER图)</p></li><li><p>关系模型的完整性约束</p><ol type="1"><li>实体完整性：确保每个表的主键是唯一的，且不允许为NULL。</li><li>参照完整性：如果表A中的某个字段是表B中主键的外键，则表A中所有的外键值必须在表B中有相对应的主键值，或者是NULL。</li><li>域完整性：数据列中的每个值都必须是定义的数据域中的有效值。</li><li>用户定义完整性：是针对特定业务规则定制的约束条件。</li></ol></li><li><p>关系型数据库和非关系型数据库的主要区别是什么？并举出相应的软件产品</p><ul><li>关系数据库是基于关系模型的，数据以表格的形式组织，表格中的行表示记录，列表示属性。常见关系型数据库有MySql、PostgreSQL、SQLServer等；非关系型数据库采用不同的数据组织方式，如文档存储、键值对存储或图形数据库。常见的非关系型数据库有MongoDB、Hbase等。</li></ul></li><li><p>视图（Note：仅在少数简单视图上可以更新数据）</p></li></ol><ul><li>定义：是一种虚拟表，其内容由查询定义，但不在数据库中以存储数据的形式存在。</li><li>特点：<ul><li>虚拟性：视图不存储数据，它是一个查询的结果集。</li><li>逻辑独立性：可以更改底层数据表的结构而不影响视图。</li><li>安全性：可以仅展示用户需要或允许看到的数据。</li><li>简化复杂查询：可以创建视图来简化用户的操作。</li></ul></li></ul><h3 id="数据库范式相关">数据库范式相关</h3><h4id="函数依赖函数依赖集依赖的推导">函数依赖、函数依赖集、依赖的推导</h4><ul><li>函数依赖(FD)。</li></ul><p>假设在一张表中，任意挑俩元组i, j，若发现若<spanclass="math inline">\(A_i = A_j\)</span>，则<spanclass="math inline">\(B_i = B_j\)</span>，则说明属性A可推出B，写作<spanclass="math inline">\(A \rightarrow B\)</span>，称为B依赖于A。</p><ul><li>函数依赖集(FDs)。</li></ul><p>就是一个集合，里头的元素是函数依赖。</p><ul><li>依赖的推导</li></ul><p>三个公理（要记住。这个其实感性理解很好理解）：</p><ol type="1"><li>如果Y是X的子集，则<span class="math inline">\(X \rightarrowY\)</span></li><li>如果<span class="math inline">\(X \rightarrow Y\)</span>，则<spanclass="math inline">\(XZ \rightarrow YZ\)</span></li><li>如果<span class="math inline">\(X \rightarrow Y, Y \rightarrowZ\)</span>，则<span class="math inline">\(X \rightarrow Z\)</span></li></ol><p>两个定理</p><ol type="1"><li>若<span class="math inline">\(X \rightarrow Y, X \rightarrowZ\)</span>，则<span class="math inline">\(X \rightarrow YZ\)</span><ul><li>证明：因为<span class="math inline">\(X \rightarrowY\)</span>，所以<span class="math inline">\(XZ \rightarrowYZ\)</span></li><li>因为<span class="math inline">\(X \rightarrow Z\)</span>，所以<spanclass="math inline">\(X \rightarrow XZ\)</span></li><li>所以<span class="math inline">\(X \rightarrow XZ \rightarrowYZ\)</span></li></ul></li><li>若<span class="math inline">\(X \rightarrow YZ\)</span>，则<spanclass="math inline">\(X \rightarrow Y, X \rightarrow Z\)</span><ul><li>证明：因为Y, Z是YZ子集，所以<span class="math inline">\(YZ\rightarrow Y, YZ \rightarrow Z\)</span></li><li>所以<span class="math inline">\(X \rightarrow YZ \rightarrow Y, X\rightarrow YZ \rightarrow Z\)</span></li></ul></li></ol><p>任何的依赖推导用上面这五条性质一般都可以推出来了。</p><h4 id="候选码非主属性主属性超键">候选码、非主属性、主属性、超键</h4><ul><li>候选码：能唯一标识一个关系的属性集合且集合大小要保证最小<ul><li>注意，一个关系R中可能存在多个候选码</li></ul></li><li>非主属性：只要有一个属性，它不属于任何一个候选码的属性，它就是非主属性</li><li>主属性：只要有一个属性，它属于某一个候选码，它就是主属性</li><li>超键：能唯一标识一个关系的属性集合<ul><li>注意，跟候选码不同的是，候选码的要求是在能唯一标识的基础上，保证集合大小最小。但是超键则无所谓，多大都ok。</li><li>注意，一个关系R中可能存在多个超键</li></ul></li></ul><h4 id="函数依赖集的闭包属性的闭包">函数依赖集的闭包、属性的闭包</h4><p>一般关系都是R表示，关系的函数依赖集一般用F表示。函数依赖集的闭包用<spanclass="math inline">\(F^+\)</span>表示。</p><p>求<spanclass="math inline">\(F^+\)</span>就是用F中的依赖把所有能推出来的依赖都推出来（画树状图+用5条性质去推），就是<spanclass="math inline">\(F^+\)</span>。</p><p>假设有一个属性A，则属性A的闭包写作<spanclass="math inline">\(A^+\)</span>。推<spanclass="math inline">\(A^+\)</span>的方法用“背包材料”的理念。最初背包中只有A这一个材料，所以首先拿A去推，能推出来的东西都放入“背包”中。然后再用背包中的材料（材料可以组合）去推，依次类推。直到没有东西可以放入背包中。</p><p>属性闭包蛮有用的，具体作用有如下2条：</p><ol type="1"><li>判断<span class="math inline">\(X \rightarrow Y\)</span>是否在<spanclass="math inline">\(F^+\)</span>里。<ul><li>正常思路是先写出F+，然后就知道<span class="math inline">\(X\rightarrow Y\)</span>在不在F+里了。但其实可以先写出<spanclass="math inline">\(X^+\)</span>，只要<spanclass="math inline">\(X^+\)</span>里有Y，那么<spanclass="math inline">\(X \rightarrow Y\)</span>就在<spanclass="math inline">\(F^+\)</span>里。</li></ul></li><li>判断某个属性集合是否是超键<ul><li>假设属性集合叫S，那写出<spanclass="math inline">\(S^+\)</span>，如果<spanclass="math inline">\(S^+\)</span>里包含了所有属性，那么属性集合S就是超键。</li></ul></li></ol><p>补充：假定有关系R和函数依赖集F，如何推出候补码？</p><p>观察F，然后使用口诀：“只在左边的一定是，只在右边的一定不是，两边都在的试一试”</p><p>具体来说，如果属性A在F中只出现在箭头的左边，那么A一定属于任意一个候补码。如果属性A在F中只出现在箭头的右边，那么A一定不属于任意一个候补码（即非主属性）。如果在箭头左右都出现过，那就试一试，用属性的闭包去验证一下即可。</p><h4id="无损分解分解后是否保持函数依赖">无损分解、分解后是否保持函数依赖</h4><p>分解一个表有时是很有必要的。假设一个表有属性“学生等级”和“学生评价”。且我们知道，如果一个学生的等级是A、B、C，他的评价分别是优秀、良好、差。如果不分解的话每次记录都要把其等级和评价记下来。但是这显然没必要，只需要记录任意一个就好。因为他们俩只要知道其中一个，另外一个是可以推出来的。</p><p>所以可以将表分解成两张表，第一张记录了其它数据 +学生等级，第二张表记录学生等级 + 学生评价。</p><p>上面这个例子就是解释分解是什么个意思。接下来讨论无损分解。</p><p>无损分解就是说分解成的两个表经过自然连接后可以得到原表。不会有额外数据的增添。</p><p>先讲结论，如果讲表R分解为<span class="math inline">\(R_1,R_2\)</span>，如果​俩表之交能通过FDs推出任意其中一个表，则这必然是一个无损分解。</p><p>这很好感性理解，自然连接本质就是找到俩表相同的公共部分然后连接。所以如果俩表的公共部分可以推出其中一个表，就说明不会有额外数据的增添。看下面这个例子就很好理解。</p><p><img src="1.png" /></p><p>至于分解后是否保持函数依赖，要看F。</p><p>也就是F中的每一对依赖X、Y，必须出现在某个子表<spanclass="math inline">\(R_i\)</span>中。这样就分解后就保持函数依赖。</p><h4 id="bcnf">BCNF</h4><p>BCNF是3.5NF，如果一个关系是3.5NF，那么它必定是3NF。</p><p>如果一个关系R满足BCNF，那么这张表中就不存在“冗余”。所以BCNF是很棒的。</p><p>如果一个关系R不满足BCNF呢？那么就将R分解成若干个子表，使得每个子表都满足BCNF，这样也就不会有冗余了，这样也是很棒的。</p><p>所以问题的关键就是如何判断一个表是否满足BCNF？以及如果一个表不满足BCNF，如何将它分解成满足BCNF的子表？</p><p>先讲第一个问题，如何判断一个表是否满足BCNF。</p><p>假定现在有关系R，函数依赖集F。对于F中每一条关系<spanclass="math inline">\(X \rightarrowY\)</span>，必须满足下面任意一条，则R满足BCNF。</p><ol type="1"><li>X是超键</li><li>X包含Y</li></ol><p>下面讨论第二个问题，如何将一个不满足BCNF的表分解为满足BCNF的若干子表。</p><p>若<span class="math inline">\(X \rightarrowY\)</span>不满足2条规则中任意一条，则将R分解为<spanclass="math inline">\(R_1 = R - Y\)</span>与<spanclass="math inline">\(R_2 = X +Y\)</span>。显然，这是个无损分解（很容易证明，公共部分是X，且X可推出R2）。而且<spanclass="math inline">\(R_1, R_2\)</span>也是满足BCNF的。</p><p>如果有多个依赖不满足规则呢？那就依次分解即可（注意，不同分解顺序带来的结果并不相同不过都是对的）</p><p>综上，在设计自己的数据库时，我们要尽可能的使表都满足BCNF，这样就不会产生数据的冗余。但是BCNF有一个缺点，就是分解后不一定能保持函数的依赖。比如下面这个例子：</p><p><img src="2.png" /></p><p><span class="math inline">\(L \rightarrowK\)</span>不满足规则，所以将R分解为<span class="math inline">\(R_1 = (J,L), R_2 = (L,K)\)</span>。函数依赖有两个，第二个在R2中可得到保持，第一个在R1或R2都不能得到保持，所以分解后没能保持函数依赖。</p><p>这就是BCNF的一个缺点，所以接下来就要介绍3NF。3NF的优点就是它可以保持函数的依赖，但是它的缺点就是仍然会存在一些冗余。</p><h4 id="nf">3NF</h4><p>跟BCNF一样，3NF还是两个灵魂问题：（1）如何判断关系R是否满足3NF（2）如果R不满足3NF，如何将它分解为若干子表使得它们满足3NF</p><p>先来解决第一个问题。</p><p>假定现在有关系R，函数依赖集F。对于F中每一条关系<spanclass="math inline">\(X \rightarrowY\)</span>，必须满足下面任意一条，则R满足3NF。</p><ol type="1"><li>X是超键</li><li>Y被包含在X里</li><li>Y属于候补码（注意不是超键噢）（所以先要求出候补码）</li></ol><p>现在来解决第二个问题。</p><p>分为以下几步：</p><ol type="1"><li>求F最小覆盖集<span class="math inline">\(F_c\)</span><ol type="1"><li>从第一个检查到最后一个，把能用其它依赖推出来的依赖去掉</li><li>从第一个检查到最后一个，把左右边的变量尽量减少</li><li>回到第一步，若第一步去不掉则进入第四步</li><li>对于左边相同的，把右边合并起来</li></ol></li><li>将<spanclass="math inline">\(F_c\)</span>中每一个依赖拿出来组成新表</li><li>求候选码</li><li>看候选码在不在其中一个新表中，不在的话就新加一个表，表的属性就是候选码</li></ol><p>综上，3NF的好处就是可以保持函数依赖（而且也是无损分解），缺点就是会存在点冗余。</p><h4 id="范式总结nf">范式总结（NF）</h4><p>第三范式前面是用“规则”定义出来的，其实它还有另一种定义。</p><ul><li>第一范式（1NF）：每个属性都是原子属性，本质上所有关系的都满足第一范式。</li><li>第二范式（2NF）：在满足第一范式的前提下，满足所有非主属性必须依赖于整个候选码而不能依赖于候选码的部分属性。</li><li>第三范式（3NF）：在满足第二范式的前提下，满足F中不能有非主属性之间的依赖传递。</li></ul><h3 id="数据库存储相关">数据库存储相关</h3><ol type="1"><li><p>文件中记录的表示方式</p><ol type="1"><li>定长记录：每个记录的大小是固定的。每个字段（或属性）在记录中分配有固定数量的字节。这种方式简化了记录的定位和访问，因为可以直接计算出任何记录的位置。</li><li>变长记录：不同记录可能有不同的长度。需要额外的信息来确定记录的确切位置和长度。</li></ol></li><li><p>文件中记录集合的组织方式</p><ol type="1"><li>堆文件：记录在文件空间中任意放置</li><li>顺序文件：按一定的顺序在文件中组织记录</li><li>散列文件：按照散列函数计算值存放相应记录</li><li>多表簇集文件：不同关系表里的记录存放在同一个文件中</li></ol></li><li><p>元数据是指一个关系数据库系统需要维护关于关系的数据。元数据存储在称为“数据字典”或“系统目录”的结构中</p></li><li><p>数据库缓冲区管理器的工作原理</p><ul><li>大致可以概括为以下几个步骤</li></ul><ol type="1"><li>数据页的加载：当需要读取数据时，首先检查所需的数据页是否已经在缓冲区中。如果是，它就直接从缓冲区读取数据，反之则从硬盘上读取数据页，并将其加载到缓冲区中。</li><li>缓冲区的替换策略：由于缓冲区的大小是有限的，当缓冲区满时，缓冲区管理器必须决定哪些数据页被保留，哪些被替换。</li><li>脏页的写回：如果一个数据页在缓冲区中被修改，在它被替换出缓冲区之前，这些更改需要被写回到硬盘上以保持数据的持久性。</li><li>并发控制：缓冲区管理器还需要处理多个事务或操作同时访问同一数据页的情况。这通常涉及锁定机制或乐观并发控制来保证数据的完整性和一致性。</li></ol></li></ol><h3 id="数据库索引相关">数据库索引相关</h3><ol type="1"><li><p>索引分类</p><ol type="1"><li>顺序索引（按照排好的顺序储存搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。）<ol type="1"><li>主索引(聚集索引)</li><li>辅助索引(非聚集索引)(二级索引)</li></ol></li><li>B+树索引</li><li>散列索引（基于将值平均分布到若干桶中，一个值所属的桶由散列函数决定）<ol type="1"><li>静态索引：就是普通的桶</li><li>动态索引：就是用二进制实现的桶</li></ol></li></ol><ul><li><p>稠密索引就是每条记录都有一个索引指针会指向它，稀疏索引就是只有部分索引会指向它。</p></li><li><p>注意，稀疏索引必须是主索引，二级索引必须是稠密索引。因为主索引的顺序就是记录排列的顺序，所以主索引可以是稀疏索引。但是二级不行，因为二级的索引顺序不是记录排列的顺序，所以如果二级是稀疏索引的话，就有可能无法查到目标数据。所以二级索引必须是稠密索引，稀疏索引必须是主索引。</p></li><li><p>稀疏索引的优点是占用空间小，缺点是速度慢，精确率相对较低；稠密索引的优点是查找效率快，方面插入和删除。缺点是占用空间大。</p></li></ul></li></ol><h3 id="数据库查询有关">数据库查询有关</h3><ol type="1"><li>对于一条SQL语句，先经过<strong>语法分析器</strong>分析语法是否正确，然后经过<strong>翻译器</strong>被翻译为关系代数表达式，这个关系代数表达式再经过<strong>优化器</strong>，得到一个执行计划，最后通过<strong>执行引擎</strong>被执行。</li><li>两个表连接操作的几种实现方法：<ol type="1"><li>嵌套循环连接：<span class="math inline">\(O(n^2)\)</span></li><li>排序-合并连接：<span class="math inline">\(O(nlogn +n)\)</span></li><li>索引连接：<span class="math inline">\(O(nlogn)\)</span></li><li>Hash连接：最好情况下<span class="math inline">\(O(n)\)</span></li></ol></li><li>优化器要做的事：<ol type="1"><li>将关系代数表达式转换为查询树</li><li>对查询树做变换</li><li>生成执行计划</li></ol></li><li>代数优化就是先做选择操作、再做连接操作。物理优化就是优化器决定是采用全盘扫描还是索引扫描，如果采用索引扫描的话是用顺序索引还是B+树索引还是Hash索引。</li></ol><h3 id="数据库事务相关">数据库事务相关</h3><ol type="1"><li><p>事务的基本特性(ACID)（以银行转账为例）</p><ul><li>事务定义：事务是指构成单一逻辑单元的操作集合。</li></ul><ol type="1"><li>A：原子性：事务要么就不执行，那么就执行，不会执行到一半退出去。</li><li>C：一致性：事务的执行不会改变所有钱的总和。</li><li>I：隔离性：尽管可能存在多个事务同时并发执行的情况，但系统保证，每个事务都感觉不到中其它事务在并发的执行。</li><li>D：持久性：一旦事务完成，其对数据库的影响就是持久的。</li></ol></li><li><p>事务状态</p><ul><li><p>活动的：事务执行时的状态</p></li><li><p>部分提交的：最后一条语句执行后</p></li><li><p>提交的：成功完成后</p></li><li><p>失败的：发现不能执行后</p></li><li><p>中止的：事务回滚并且数据库已恢复到事务开始执行前的状态后</p></li><li><p>事务状态图：</p><p><img src="3.png" /></p></li></ul></li><li><p>调度</p><ol type="1"><li><p>调度分类</p><ol type="1"><li>串行调度：一个事务完成后再去执行下一个事务</li><li>并行调度：调度中多个事务的指令在时间上相互交叉地进行</li><li>可串行化调度：这个概念是针对于并行调度的。一个并行调度可能是可串行化调度，也可能不是。如果存在一个串行调度，使得其运行结果等于一个并行调度，则称这个并行调度为可串行化调度。</li></ol></li><li><p>冲突可串行化</p><ol type="1"><li>冲突操作：如果俩操作属于不同事务，且至少有一个wire操作，且作用于相同数据项，则这俩操作是冲突的。</li><li>注意，如果一个并行调度是可串行化调度，那么它就是冲突可串行化的。</li><li>冲突可串行化的判定方法：如果一个并行调度不存在死锁，则可以转换为一个串行调度，也就是这个并行调度是冲突可串行化的。</li><li>并行调度转换为串行调度的方法：先画出调度优先图，然后其拓扑序就是串行调度。</li></ol></li><li><p>调度优先图</p><ul><li><p>这个名字起的很烂，我愿意叫它“死锁图”。是一种用来检测事务调度中是否存在死锁的工具。</p></li><li><p>图中的每一个节点代表一个事务，如果事务A需要等待B释放资源才能进行，则A向B连一条边。如果图中存在环，则存在死锁。</p></li><li><p><img src="4.png" /></p></li><li><p>例如这个图，以数据Y举例，对于所有对Y的read/wire操作，若其时间后有其冲突操作，则俩事务之间连一条边。</p></li></ul></li><li><p>预防死锁的方法</p><ol type="1"><li>wait-die机制：当事务<spanclass="math inline">\(T_i\)</span>申请的数据项当前被<spanclass="math inline">\(T_j\)</span>持有，仅当<spanclass="math inline">\(T_i\)</span>的时间戳小于<spanclass="math inline">\(T_j\)</span>的时间戳时，允许<spanclass="math inline">\(T_i\)</span>等待。否则<spanclass="math inline">\(T_i\)</span>回滚。</li><li>wound-die机制：当事务<spanclass="math inline">\(T_i\)</span>申请的数据项当前被<spanclass="math inline">\(T_j\)</span>持有，仅当<spanclass="math inline">\(T_i\)</span>的时间戳大于<spanclass="math inline">\(T_j\)</span>的时间戳时，允许<spanclass="math inline">\(T_i\)</span>等待。否则，<spanclass="math inline">\(T_j\)</span>回滚。</li></ol></li><li><p>解决死锁的方法</p><ul><li>选择一个或多个事务进行回滚，释放它们所占用的资源。通常会选择代价最小的事务进行回滚，代价的衡量标准可能包括事务的执行时间、所占用资源数量、距离完成的远近等。为了改进，可以采用部分回滚，这要求需要更多的额外信息。</li></ul></li><li><p>可恢复调度 &amp; 无级联调度</p><ul><li>对于调度中的任意俩事务A, B，如果B read 了A之前 wire的同个数据，则事务A必须在事务B之前提交。</li><li>对于调度中的任意俩事务A, B，如果B read 了A之前 wire的同个数据，则事务A必须在事务B的read操作之前提交。</li></ul></li></ol></li><li><p>事务的隔离级别</p><ol type="1"><li><p>读未提交：允许事务read未被其它事务提交的更改</p></li><li><p>读提交：事务只能read已经被提交的更改（数据库的默认隔离级别）</p></li><li><p>可重复读：确保在事务执行期间，如果事务重新读取之前已读取的数据，则会看到相同的数据。</p><ul><li><p>脏读：一个事务读取了另一个事务尚未提交的数据时。</p></li><li><p>不可重复读：事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。因此产生了不可重复读。</p></li><li><p>幻读：与不可重复读类似，它发生在当一个事务T1读取了一系列符合特定条件的行，然后另一个并发事务T2插入或删除了一些符合T1搜索条件的新行并提交。当T1再次执行相同的查询时，它将“神奇地”看到之前不存在的新行（即“幻行”）。</p></li></ul></li><li><p>串行化：调度中事务只能串行运行</p></li></ol><p><img src="5.png" /></p></li></ol><h3 id="数据库锁相关">数据库锁相关</h3><p>为了保证数据的一致性(事务的隔离性)和提高系统的并发处理能力，或者说为了保证应用的有效性，所以引入锁。封锁协议定义了事务如何获取和释放锁的规则。</p><ol type="1"><li><p>锁</p><ol type="1"><li>共享锁(S)：当一个事务想要读取数据时，它会在相应的数据项上放置一个共享锁。共享锁的特点是它允许多个读取事务并发地访问同一个数据项，因为读取操作不会互相冲突。所以如果一个事务获得了数据项的共享锁，则它可read但不能wire该数据项。</li><li>排他锁(X)：当一个数据上了排他锁后，当某事务想要修改或读数据时，它会请求并获得排他锁。只有获得了排他锁，才能对其修改。而且注意，一旦一个数据的排他锁被拿了，那么其它事务就不能获得该数据的排他锁和共享锁，直至其排他锁被归还。</li></ol></li><li><p>封锁协议</p><ol type="1"><li><p>二阶段锁定协议</p><ul><li><p>最常用的就是二阶段锁定协议，即要求每个事务分两个阶段对数据进行锁定和解锁。增长阶段：事务可以获得锁，但不能释放锁。缩减阶段：事务可以释放锁，但不能获得新的锁。</p></li><li><p>二阶段锁定协议特点：</p><ol type="1"><li>把两个阶段的定义抄一遍</li><li>可以保证冲突可串行化：多个事务根据封锁点的顺序进行排序即是可串行化顺序。</li></ol></li><li><p>二阶段锁定协议保证了不会出现脏读的问题。但是不可重复读、死锁、活锁、级联回滚问题仍然可能会出现。另外，虽然两阶段封锁协议保证冲突可串行化，但是冲突可串行化未必符合两阶段封锁。</p></li></ul></li><li><p>严格两阶段封锁协议</p><ul><li>定义：在2PL的基础上，要求事务所持排他锁必须在事务提交后方可释放。这个要求保证了在提交前防止其它事务读这些数据。可以避免出现级联回滚。</li></ul></li><li><p>强两阶段封锁协议</p><ul><li>定义：要求事务提交之前不能释放任何锁。</li></ul></li><li><p>树形协议</p><ul><li>定义：树形协议是一种数据库并发控制机制，用于管理在树状数据结构（如B树索引）上的锁。它规定了事务在获得和释放锁的顺序，以确保在访问树形数据结构的不同部分时维护一致性和隔离性。事务必须按照从根节点到叶节点的顺序来获取锁，并且在向下遍历树时不能返回到已经释放锁的节点。这种方法避免了死锁的发生，因为它不允许事务在树结构中回溯并重新获取锁。</li><li>优点：保证了冲突可串行化；不会产生死锁，不需要回滚；可较早地释放锁，以减少事务间的等待时间，从而可增强调度的并发性。</li><li>缺点：不能保证事务的可恢复性；不能保证不发生级联回滚；可能会给那些根本不访问的数据项加锁，从而增加了锁的开销和额外的等待时间，使并发性降低。</li></ul></li><li><p>多粒度封锁协议</p><ul><li>规则：<ol type="1"><li>引入意向锁，并规定了与S/X锁的兼容性规则</li><li>事务必须首先在高级别上获取意向锁，然后才能在低级别上获取实际的共享或排他锁。</li><li>锁可以在事务的任何时候释放，但一旦释放，事务就不能再在那个级别或更低级别上获取新的锁。</li></ol></li><li>特点：<ol type="1"><li>事务可以根据需要锁定细粒度（如行）或粗粒度（如整个表）的数据，从而提高了系统的并发性。</li><li>通过允许在不同粒度上加锁，多粒度封锁减少了锁冲突的可能性，提高了并发访问的效率。</li></ol></li></ul></li><li><p>锁转换</p><ul><li>定义：允许一个事务在其执行过程中改变已经获得的锁的模式。锁转换分为两种情况：升级和降级。</li></ul></li><li><p>时间戳排序协议</p><ul><li>是数据库并发控制中使用的一种机制，用于在没有使用锁的情况下管理事务的并发执行。它通过为每个事务分配一个唯一的时间戳来确保数据库的一致性和隔离性。</li></ul><p><img src="9.png" /></p></li><li><p>快照隔离</p><ul><li>是数据库系统中一种并发控制方法，它允许事务看到数据库在某一特定时间点的一致性视图。这意味着即使其他事务对数据库进行了修改，一个在快照隔离级别下运行的事务也会看到它开始时数据库的状态，而不会看到这些修改。</li></ul></li></ol></li></ol><h3 id="数据库日志相关">数据库日志相关</h3><ol type="1"><li><p>故障种类</p><ol type="1"><li>事务故障<ol type="1"><li>逻辑错误：如非法输入、找不到数据、溢出或超出资源限制。</li><li>系统错误：系统进入一种不良状态（如死锁），结果事务无法正常执行。</li></ol></li><li>系统崩溃：硬件故障，或者是数据库软件或操作系统的漏洞，导致易失性存储器内容的丢失，并使得事务处理停止。</li><li>磁盘故障：在数据传送操作过程中由于磁头损坏或故障造成磁盘块上的内容丢失。</li></ol></li><li><p>什么是基于日志的恢复机制</p><ul><li>是DBMS中用来保证数据一致性和完整性的一种技术。这种机制依赖于日志文件，它记录了对数据库所做的所有修改。通过redo和undo操作，使得数据库能够在发生故障后恢复到一个一致的状态，保证了即使在系统崩溃后，也不会丢失已提交的数据，并且不会有未完成事务的残留影响。是实现持久性的关键机制。</li></ul></li><li><p>事务和日志的关系</p><ul><li>事务执行依赖于日志来记录和维护操作的历史，而日志则提供了必要的机制来保证事务的完整性和数据库的恢复能力。这种依赖关系是现代数据库系统实现高可靠性和数据一致性的基础。</li></ul></li><li><p>如何根据日志写出恢复日志（看图片+做题吧，懒得讲了）</p><p><img src="7.png" /></p><p><img src="8.png" /></p></li></ol><h3 id="数据库错题相关">数据库错题相关</h3><ol type="1"><li><p><img src="10.png" /></p></li><li><p><img src="11.png" /></p></li><li><p>ER图的时候，n对n中间要新开一张表，左右俩表的主键分别为外键，整体作为主键。</p></li><li><p>写关系代数/SQL的时候如果只是需要ID的话其实很多情况下不用与另一张表自然连接；注意有时候题目会强制让你写笛卡尔积的sql/关系代数；如果写关系代数没思路时，可以试试俩同样的表做自然连接或者groupby或者用“-”</p></li><li><p>3NF时如果被包含记得要删掉</p></li><li><p>求BCNF的俩例子</p></li></ol><p><img src="12.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;懒得解释了，反正之前没咋认真听过课（其实是去做数据库期末项目了）。今天终于有点时间了抽空看了一下之前的内容，做一下笔记记录一下免得以后忘了。学点东西顺便应付一下期末考试。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数据库" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Distributed Nash Equilibrium Seeking for...</title>
    <link href="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/"/>
    <id>http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/</id>
    <published>2023-10-16T06:45:10.000Z</published>
    <updated>2024-02-19T16:34:42.189Z</updated>
    
    <content type="html"><![CDATA[<p>标题全称为：Distributed Nash Equilibrium Seeking for AggregativeGames With Directed Communication Graphs</p><p>中文翻译为：在使用有向图结构的聚合博弈中寻找离散式纳什均衡</p><span id="more"></span><h3 id="abstract">Abstract</h3><p>在聚合博弈中寻找分布式纳什均衡的关键点就是聚合博弈采取什么样的图结构。</p><p>若采取无向图或者权衡平衡图结构，则这个问题已经被前人解决。</p><p>如果采取有向图，则这仍然是个无人解决的问题。</p><p>本文解决的是当图结构采取“固定有向图”或者“时变有向图”时的分布式NE寻找问题。</p><p>使用了两种算法来分别解决上面所提到的两种图结构时的分布式NE寻找问题。</p><p>创新点是受凸优化中重球法的启发，向玩家策略的更新规范中引入了“动量项”，使得加速了算法寻找NE的收敛速度。</p><p>对于强连通固定图和b强连通时变图，从理论上证明，如果代价函数和参与人的集合满足一定条件，在步长减小的情况下，参与人的行动将收敛到集合博弈的NE上。</p><p>本文最后将该算法运用于插电式混合动力汽车的能耗控制，检验了算法的正确性。</p><hr /><h3 id="section-1-introduction">Section 1: Introduction</h3><h4 id="研究背景">1-1: 研究背景</h4><ul><li><p>本文研究的是聚合游戏，也就是每个玩家的花费除了依赖自身动作还依赖所有玩家的聚合行为。在聚合游戏中寻找NE是个有挑战性的问题，因为每个玩家只能与自己的邻居通信。</p></li><li><p>在分布式通信计算领域，一些解决聚合游戏中NE寻找问题的分布式算法已经被提出。具体分为“分布式离散时间算法”[6],[7]和“分布式连续时间算法”[8]-[15]</p></li></ul><p>[6]：在这篇文章中，作者专注于研究有向图中的两种特殊的聚合游戏，分别叫做“networkaggregative games” 和 "average aggregative games"。使用"optimal responsestrategy"方法去研究的。而且，在图的加权邻接矩阵为双随机矩阵的条件下，<spanclass="math inline">\(\varepsilon-NE\)</span>在average aggregativegames的寻找得以被解决。</p><p>[7]：在这篇文章中，作者专注于研究无向图中的聚合游戏。并相应提出了几种分布式同步和异步算法。</p><p>[8]：在这篇文章中，作者专注于研究权重平衡有向图中的聚合游戏，其中玩家的dynamicswere described by disturbed first-order systems.为了寻找寻找外部干扰下具有coupled equalityconstraint的聚合游戏的NE，作者在文中提出了一种利用内部模型排斥外部干扰来找NE的分布式算法。同时利用dynamicaverage consensus来估计所有玩家的总和。</p><p>[9]：在这篇文章中，研究了玩家成本函数非光滑，同时玩家动作受到局部可行性约束和线性耦合约束时的情况。具体来说，作者利用微分包含和微分投影算子，提出了一种基于连续时间分布投影的算法来找权重平衡有向图上的非光滑聚合游戏的NE。</p><p>[10]：在这篇文章中，作者研究了无向连通图上具有耦合约束的聚合游戏。</p><p>[11]：结合projected gradient dynamics 和 consensus trackingdynamics，本文讨论了无向连通图上的聚合游戏。</p><p>[12]：结合projected gradient dynamics 和 consensus trackingdynamics，本文讨论了权重平衡有向图上的聚合游戏。</p><p>[13]：研究了存在对通信链路持续攻击的网络上的聚合游戏。其中玩家的动态是受未知时变干扰和未建模项影响的双积分器。</p><p>[14]：研究了聚合游戏在智能电网能耗控制中的运用。其中玩家采用平均共识协议来估计总能耗，并且表明玩家的行为以指数形式收敛于NE。</p><p>[15]：将PHEVs建模成一个无向连通图上的聚合游戏，并对NE的稳定性进行了分析。</p><ul><li>可以发现上面的文章大多都是在无向图或者权重平衡有向图上的工作。在一般有向图上利用分布式离散时间算法来寻找NE仍然是一个未解决的问题。因为难点就在于玩家之间的通信结构不平衡。</li><li>但是到目前为止，关于在不平衡有向图上的分布式优化问题已经被广泛研究。例如下面几篇文章：</li></ul><p>[16]：提出了一种连续时间算法来解决权重不平衡图上的聚合游戏的NE寻找问题。</p><p>[17]：通过结合(子)梯度下降和推和共识协议开发了分布式(子)梯度推算法，其中双随机矩阵的要求可被推广到列随机矩阵。</p><p>[18]：为了不需要提前知道列-随机矩阵的出度，这篇文章仅使用行-随机矩阵，通过估计行-随机矩阵的左Perron特征向量来求解具有不平衡有向图的分布无约束优化问题。</p><p>[19],[20]：通过估计行随机矩阵的左Perron特征向量，研究有向图的分布式约束优化问题。</p><ul><li>所以本文受到上述文章中处理不平衡有向图的方法启发，分别运用行随机矩阵（algorithm1）和列随机矩阵（algorithm2）来研究不平衡有向图上（两种算法分别对应fixed digraph和time-varyingdigraph）的聚合游戏。</li><li>具体来说，通过估计与拓扑相关的行随机矩阵的左特征向量，成功消除了这种拓扑相关行随机矩阵对所有玩家聚合行为估计的不平衡影响。此外，针对时变有向图下的聚集博弈，提出了一种基于推和协议的分布式算法来寻找NE。而且由于玩家的动作受到设定的约束，因此采用投影梯度法根据聚集的局部估计更新玩家的动作。</li><li>另一方面，考虑到步长恒定的投影梯度法只能在存在集合约束的情况下使玩家的动作收敛到NE的一个邻域，所以本文采用步长递减的方法来保证收敛到准确的NE，并且允许参与者采用不协调的步长。</li><li>然而，步长递减也带来了另一个挑战，即收敛速度慢。受到[21]中重球法的启发下，本文在玩家行为更新规律中引入动量项，以加快算法的收敛速度。证明了所提出的步长递减离散NE搜索算法能够保证收敛到精确NE。</li><li>此外，还分析了在步长递减时所提出的NE搜索算法的收敛速度。最后，将所提出的算法应用于有向图上的插电式混合动力汽车系统能耗博弈的求解，数值结果表明，动量项加速了算法的收敛速度。</li></ul><blockquote><p>看了上面的introduction，个人感觉其实就是说：</p><p>不平衡有向图上的聚合问题没人解决，因为玩家之间通信结构不平衡。</p><p>然后本文用[18] ~[20]“估计行随机矩阵左特征向量”的方法解决上面这个难点。</p><p>另外，本文还讨论了时变有向图下的聚集博弈，用的是[17]的方法，但是在他基础上把步长固定改为步长递减从而使NE收敛更精确。另外还加了一个[21]里的重球法中的动量项来加快收敛速度。</p></blockquote><h4 id="大致目录-基础公式">1-2: 大致目录 &amp; 基础公式</h4><p>Section 2：图论的基础结论、问题建模、算法引入</p><p>Section 3、4：算法的收敛性证明</p><p>Section 5：验证算法在插电式混合动力汽车能耗控制的正确性</p><ul><li><span class="math inline">\(\mathbb{R,N_+}\)</span>：分别是实数集和正整数集</li><li><span class="math inline">\(e_i ∈ \mathbb{R^n}\)</span>：n维列向量，其中第i项为1，其余项为0</li><li><span class="math inline">\(1_n ∈ \mathbb{R^n}\)</span>：n维列向量，每一项都是1</li><li><span class="math inline">\(I_n\)</span>：n维单位矩阵</li><li><span class="math inline">\(\|\cdot\|\)</span>：欧几里得范式</li><li><span class="math inline">\(\|x\|_H, H \in \mathbb{R^{n \timesn}}\)</span>：加权范数（weighed norm）（结果为一个常数），定义为：<spanclass="math inline">\(\|x\|_H = \sqrt{x^THx}\)</span></li><li><span class="math inline">\(\Omega \in\mathbb{R^n}\)</span>：n维的非空闭凸集，里面每个元素都是n维列向量</li><li><span class="math inline">\(P_{\Omega}[x]\)</span>: x(<spanclass="math inline">\(\Omega\)</span>外一点)在<spanclass="math inline">\(\Omega\)</span>上的投影点(结果为一个n维列向量),定义为: <span class="math inline">\(P_{\Omega}[x] = argmin_{y \in\Omega}\|x - y\| = y^*, y^* \in \Omega\)</span><ul><li>具有非扩张性，即：<spanclass="math inline">\(\|P_{\Omega}[x]-P_{\Omega}[z]\| \le\|x-z\|\)</span></li></ul></li><li><spanclass="math inline">\([x]_i\)</span>：x这个n维向量中的第i项</li><li><spanclass="math inline">\(H_{ij}\)</span>：矩阵H的i行j列那个元素</li></ul><hr /><h3 id="section-2-preliminary-knowledge">Section 2: Preliminaryknowledge</h3><h4 id="图理论">2-1: 图理论</h4><p><span class="math inline">\(\mathcal{N}=\{1, 2, ...,N\}\)</span>：玩家集合</p><p><span class="math inline">\(\varepsilon(k) \subseteq \{(i, j), i, j\in \mathcal{N}\}\)</span>：时刻为k时的边集 <spanclass="math inline">\((i, j) \in \varepsilon(k)\)</span> means thatplayer i can receive information from player j at time j.</p><p><span class="math inline">\(\mathcal{G}(k) = \{\mathcal{N},\varepsilon(k)\}\)</span>：时刻为k时的图</p><p><span class="math inline">\(N^{in}_{i}(k) = \{i\} \cup \{j | (j, i)\in \varepsilon(k)\}\)</span>：时刻为k时，点i的入点集合</p><p><span class="math inline">\(N^{out}_{i}(k) = \{i\} \cup \{j | (i, j)\in \varepsilon(k)\}\)</span>：时刻为k时，点i的出点集合</p><p><spanclass="math inline">\(d_i^k=|N^{out}_{i}(k)|\)</span>：时刻为k时，点i的出度</p><p>strongly connected fixed digraph：强连通有向图。即任意俩点可通</p><p>For the time-varying digraph <spanclass="math inline">\(\mathcal{G}(k), \{\mathcal{G}(k)\}\)</span> issaid to be B-strongly connected if there exists a <spanclass="math inline">\(B \in \mathbb{N_+}\)</span> such that the uniondigraph <spanclass="math inline">\(\cup_{t=kB}^{(k+1)B}\mathcal{G}(t)\)</span> isstrongly connected for any <span class="math inline">\(k \in\mathbb{N_+}\)</span>换句话说，如果一定时间段内的所有时变图的并（边并起来，边权不相加）为强连通，则这些时变图的集合是B-连通的。</p><p>后面依次类推。</p><h4 id="问题建模">2-2: 问题建模</h4><p>每个玩家的动作集合定义为<spanclass="math inline">\(\Omega_i\)</span>，动作定义为<spanclass="math inline">\(x_i\)</span>。每个玩家的花费函数定义为<spanclass="math inline">\(J_i(x), x = [x_1, x_2, ...,x_n]^T\)</span>，通过这个表达式可以看出来，每个玩家的花费函数跟所有玩家的动作相关。</p><p><span class="math inline">\(J_i(x)\)</span>还有几种等价的定义：</p><p>定义1：<span class="math display">\[J_i(x) = f_i(x_i, \sigma(x)), \\\sigma(x)=\sum_{j=1}^{N}\phi_{j}(x_j) \qquad (1)\]</span></p><p>定义2：<span class="math inline">\(J_i(x)=J_i(x_i, x_{-i}),x_{-i}=[x_1, ..., x_{i-1}, x_{i+1}, ..., x_n]\)</span></p><p>要解决的问题是最小化每一个玩家的花费函数，即：</p><p><span class="math inline">\(min \, f_i(x_i, \sigma(x)), \forall{i}\in \mathcal{N} \qquad (2)\)</span></p><p>实际上就是求一个纳什均衡问题，因为纳什均衡就是任何一个玩家改变它的动作都不能使得它的花费函数更小。如果纳什均衡的观点表达上面的式子，就是：</p><p>假如<span class="math inline">\(x^*\)</span>是NE，当且仅当<spanclass="math inline">\(J_i(x_i^*, x_{-i}^*) \le J_i(x_i, x_{-i}^*),\forall{x_i} \in \Omega_i, \forall{i} \in \mathcal{N}\)</span></p><blockquote><p>Note that the players in the considered game have no knowledge of theaggregation <span class="math inline">\(\sigma(x)\)</span> due to theprivacy of <span class="math inline">\(\phi_j(x_j), j \in\mathcal{N}\)</span>。</p><p>也就是说，<spanclass="math inline">\(\phi_i(x_i)\)</span>函数是每个人特有的，只有自己知道，别人不知道。但是可以通过有向图与邻居交换信息。</p></blockquote><p>下面是论文的几个假设，论文解决的问题都是基于这几个假设作为前提的。</p><h5 id="assumption-1">Assumption 1</h5><ul><li>论文讨论的图不是一般有向图，而是两类。分别是固定有向图（fixeddigraph）和时变有向图（time-varying digraph）。</li><li>而且fixed digraph一定满足强连通，time-varyingdigraph一定满足B-强连通。</li></ul><h5 id="assumption-2">Assumption 2</h5><ul><li><p>对于所有玩家的动作集合<spanclass="math inline">\(\Omega_{i}\)</span>，都是非空、紧致、凸的。</p></li><li><p>定义<span class="math inline">\(\Omega_{-i}=\Omega_{1} \times\Omega_{2} \times ... \times \Omega_{i-1} \times \Omega_{i+1} \times ...\times \Omega_{N}\)</span>。More over, for given <spanclass="math inline">\(x_{-i} \in \Omega_{-i}, J_i(x_i, x_{-i})\)</span>is convex about <span class="math inline">\(x_i\)</span> on <spanclass="math inline">\(\Omega_{i}\)</span></p></li><li><p><span class="math inline">\(J_i(x_i, x_{-i})\)</span>对<spanclass="math inline">\(x\)</span>连续可微，<spanclass="math inline">\(\phi_i(x_i)\)</span>对<spanclass="math inline">\(x_i\)</span>连续可微。</p><ul><li>定义<span class="math inline">\(\nabla_z{f(z,y)}\)</span>为对z求一阶偏导</li><li>按照此定义，将<span class="math inline">\(J_i(x_i,x_{-i})\)</span>对<spanclass="math inline">\(x_i\)</span>求导，将得到<spanclass="math inline">\(\nabla_{x_i}J_i(x_i, x_{-i}) =\nabla_{x_i}f_i(x_i,\sigma(x)) + \nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)\)</span>。这里实际上是有点歧义的，作者想表达的意思就是关注玩家i的动作对其花费函数的影响。</li><li>定义<span class="math inline">\(\Gamma(x)=[\nabla_{x_1}J_1(x_1,x_{-1}), ..., \nabla_{x_N}J_N(x_N,x_{-N})]^T\)</span>，即每个玩家花费函数对自身动作求导组成的一个列向量</li><li>定义<span class="math inline">\(G_i(x_i, \tilde{\sigma_i}) =\nabla_{x_i}f_i(x_i, \sigma(x))|_{\sigma(x)=\tilde{\sigma_i}} +\nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)|_{\sigma(x)=\tilde{\sigma_i}}\)</span>。不是把每个花费函数对动作求导嘛，这里就是把求导结果里的<spanclass="math inline">\(\sigma(x)\)</span>赋值为<spanclass="math inline">\(\tilde{\sigma_i}\)</span>了。</li></ul></li></ul><h5 id="assumption-3">Assumption 3</h5><ul><li><spanclass="math inline">\(\Gamma(x)\)</span>满足下列俩条件之一：</li><li><span class="math inline">\(\Gamma(x)\)</span>在<spanclass="math inline">\(\Omega\)</span>上是严格单调的，也就是说，<spanclass="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,\forall{x, x&#39;} \in \Omega, x \ne x&#39;\)</span></li><li><span class="math inline">\(\Gamma(x)\)</span>在<spanclass="math inline">\(\Omega\)</span>上是强单调的，也就是说，存在一个常数<spanclass="math inline">\(\mu &gt; 0\)</span>使得<spanclass="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) \ge\mu\|x-x&#39;\|^2, \forall{x, x&#39;} \in \Omega, x \nex&#39;\)</span></li></ul><h5 id="assumption-4">Assumption 4</h5><ul><li><p>The mapping <span class="math inline">\(G_i(x_i, \sigma) isL_1-Lipschitz\)</span> continuous with repect to <spanclass="math inline">\(\sigma \in \mathbb{R}\)</span> and <spanclass="math inline">\(\phi_i(x_i)\)</span> is <spanclass="math inline">\(L_2-Lipschitz\)</span> continuous with repect to<span class="math inline">\(x_i \in \Omega_i\)</span> for all <spanclass="math inline">\(i \in \mathcal{N}\)</span>, i.e.,</p></li><li><p>(<span class="math inline">\(L_1, L_2\)</span> are two positiveconstants) <span class="math display">\[\begin{aligned}\|G_i(x_i,\sigma_1)-G_i(x_i,\sigma_2)\|_2&amp;\leL_1\left\|\sigma_1-\sigma_2\right\|,&amp;\forall\sigma_1,\sigma_2\in\mathbb{R},\\\|\phi_i(z_1)-\phi_i(z_2)\|&amp;\leL_2\left\|z_1-z_2\right\|,&amp;\forall z_1,z_2\in\Omega_i,\end{aligned}\]</span></p></li></ul><h4 id="算法引入">2-3: 算法引入</h4><h5id="algorithm-1-ne-seeking-with-row-stochastic-adjacency-matrix">Algorithm1 NE Seeking With Row-Stochastic Adjacency Matrix</h5><ul><li>Initialization: <span class="math inline">\(x_i^0=x_i^1 \in\Omega_i, v_i^1=e_i, \tilde\sigma_i^1=\phi_i(x_i^1)\)</span></li><li>for <span class="math inline">\(k \in \mathbb{N}_+\)</span> do<ul><li>for each player <span class="math inline">\(i \in\mathcal{N}\)</span> do<ul><li><span class="math inline">\(x_i^{k+1}=P_{\Omega_i}[x_i^k -\alpha_i^kG_i(x_i^k, \tilde\sigma_i^k) + \lambda_i(x_i^k-x_i^{k-1})]\qquad (3a)\)</span></li><li><span class="math inline">\(v_i^{k+1}=\sum_{j=1}^Na_{ij}v_j^k \qquad(3b)\)</span></li><li><spanclass="math inline">\(\tilde{\sigma}_{i}^{k+1}=\sum_{j=1}^{N}a_{ij}\tilde{\sigma}_{j}^{k}+\frac{\phi_{i}\left(x_{i}^{k+1}\right)}{\left[v_{i}^{k+1}\right]_{i}}-\frac{\phi_{i}\left(x_{i}^{k}\right)}{\left[v_{i}^{k}\right]_{i}}\qquad (3c)\)</span></li></ul></li><li>end for</li></ul></li><li>end for</li></ul><p>行随机邻接矩阵记为<spanclass="math inline">\(A=[a_{ij}]\)</span>，其中<spanclass="math inline">\(a_{ii}&gt;0\)</span>，且若<spanclass="math inline">\((j, i) \in \varepsilon\)</span>则<spanclass="math inline">\(a_{ij}&gt;0\)</span>, 否则<spanclass="math inline">\(a_{ij}=0\)</span>。另外，行随机矩阵的特征就是每一行元素和为1。</p><p><spanclass="math inline">\(x_i^k\)</span>表示第i个玩家在时刻k的动作</p><p><span class="math inline">\(v_i^k \in\mathbb{R}^N\)</span>用来estimate the left eigenvector <spanclass="math inline">\(v\)</span> associated with eigenvalue <spanclass="math inline">\(1\)</span> of the matrix A.</p><p><span class="math inline">\(\tilde\sigma_i^k\)</span> be the playeri's estimate on the aggregation <spanclass="math inline">\(\sigma(x_k)\)</span> at iteration <spanclass="math inline">\(k\)</span>, <spanclass="math inline">\(x_k=[x_1^k, ..., x_N^k]^T\)</span></p><p><spanclass="math inline">\(\alpha_i^k\)</span>表示步长，它遵循下面三个限制：</p><ol type="1"><li>每个玩家在任意时刻的步长都是大于0的，且对于每个玩家，其<spanclass="math inline">\(\{\alpha_i^k\}\)</span>单调不增加</li><li><spanclass="math inline">\(\sum_{k=1}^{\infty}\alpha_{i}^{k}=\infty,\sum_{k=1}^{\infty}(\alpha_{i}^{k})^{2}&lt;\infty\)</span></li><li><spanclass="math inline">\(\sum\limits_{k=1}^{\infty}(\overline{\alpha}_{k}-\underline{\alpha}_{k})&lt;\infty,\text{where}\overline{\alpha}_{k}=\max\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\text{and}\underline{\alpha}_{k}=\min\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}.\)</span></li></ol><p>在algorithm 1中，玩家使用非精确梯度<spanclass="math inline">\(G_i(x_i^k,\tilde\sigma_i^k)\)</span>来更新自身动作。为了消除不精确梯度带来的误差，引入递减的步长而不是固定的步长，从而保证精确收敛到NE。另外，动量项<spanclass="math inline">\(\lambda_i(x_i^k-x_i^{k-1})]\)</span>可以加速算法的收敛，<spanclass="math inline">\(0&lt;\lambda_i&lt;1\)</span>是动量参数。以上就是对于(3a)的解释。</p><p>在(3c)中的第二项和第三项，其存在的目的是为了解决矩阵<spanclass="math inline">\(A\)</span>可能不是列随机的问题。</p><p>可以看出，(3b)和(3c)都用到了<spanclass="math inline">\(a_{ij}\)</span>，所以algorithm 1只适用于fixeddigraph。</p><h5id="algorithm-2-ne-seeking-with-column-stochastic-adjacency-matrix">Algorithm2 NE Seeking With Column-Stochastic Adjacency Matrix</h5><p>这个算法是针对time-varyingdigraph的。在算法2中，每个玩家需要知道自己在每次交流中的出度，因为不同时刻每个点的出度会变化。</p><ul><li>Initialization: <spanclass="math inline">\(x_{i}^{0}=x_{i}^{1}\in\Omega_{i},y_{i}^{1}=1,\tilde{\sigma}_{i}^{1}=\phi_{i}(x_{i}^{1})\)</span></li><li>for <span class="math inline">\(k \in \mathbb{N}_+\)</span> do<ul><li>for each player <span class="math inline">\(i \in\mathcal{N}\)</span> do<ul><li><span class="math inline">\(w_i^{k+1}=\sum_{j\inN_i^{in}(k)}\frac{\tilde{\sigma}_j^k}{d_j^k} \qquad (4a)\)</span></li><li><span class="math inline">\(y_i^{k+1}=\sum_{j\inN_i^{in}(k)}\frac{y_j^k}{d_j^k} \qquad (4b)\)</span></li><li><span class="math inline">\(z_i^{k+1}=\frac{w_i^{k+1}}{y_i^{k+1}}\qquad (4c)\)</span></li><li><spanclass="math inline">\(x_i^{k+1}=P_{\Omega_i}\left[x_i^k-\alpha_i^kG_i(x_i^k,Nz_i^{k+1})+\lambda_i(x_i^k-x_i^{k-1})\right]\qquad (4d)\)</span></li><li><spanclass="math inline">\(\tilde{\sigma}_i^{k+1}=w_i^{k+1}+\phi_i\left(x_i^{k+1}\right)-\phi_i\left(x_i^k\right)\qquad (4e)\)</span></li></ul></li><li>end for</li></ul></li><li>end for</li></ul><p>可以发现，这里求<spanclass="math inline">\(x_i^{k+1}\)</span>第二项<spanclass="math inline">\(G_i\)</span>中并没用<spanclass="math inline">\(\tilde\sigma_i^k\)</span>，而是用的<spanclass="math inline">\(Nz_i^{k+1}\)</span>。z是w跟y的比值，w与y又与点的入点和(入点的出度)有关。</p><blockquote><p>Note: 在algorithm 1中，若把"若<span class="math inline">\((j, i) \in\varepsilon\)</span>则<spanclass="math inline">\(a_{ij}&gt;0\)</span>"改为“若<spanclass="math inline">\((j, i) \in \varepsilon\)</span>则<spanclass="math inline">\(a_{ij}=\frac{1}{d_j^k}\)</span>”，则(3c)与(4e)等价</p></blockquote><hr /><h3 id="section-3-convergence-analysis-of-algorithm-1">Section 3:Convergence analysis of algorithm 1</h3><h4 id="theorem-1">3-1: Theorem 1</h4><p>条件：</p><ol type="1"><li><p>采用固定有向图结构</p></li><li><p><span class="math inline">\(\nabla_{x_i}J_i(x_i, x_{-i})=\nabla_{x_i}f_i(x_i, \sigma(x)) + \nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)\)</span></p><p><span class="math inline">\(\Gamma(x)=[\nabla_{x_1}J_1(x_1, x_{-1}),..., \nabla_{x_N}J_N(x_N, x_{-N})]^T\)</span></p><p><span class="math inline">\(G_i(x_i, \tilde{\sigma_i}) =\nabla_{x_i}f_i(x_i, \sigma(x))|_{\sigma(x)=\tilde{\sigma_i}} +\nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)|_{\sigma(x)=\tilde{\sigma_i}}\)</span></p></li><li><p><spanclass="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,\forall{x, x&#39;} \in \Omega, x \ne x&#39;\)</span></p></li><li><p><span class="math display">\[\begin{aligned}\|G_i(x_i,\sigma_1)-G_i(x_i,\sigma_2)\|_2&amp;\leL_1\left\|\sigma_1-\sigma_2\right\|,&amp;\forall\sigma_1,\sigma_2\in\mathbb{R},\\\|\phi_i(z_1)-\phi_i(z_2)\|&amp;\leL_2\left\|z_1-z_2\right\|,&amp;\forall z_1,z_2\in\Omega_i,\end{aligned}\]</span></p></li><li><p>对于<spanclass="math inline">\(\alpha\)</span>步长，满足下面三条性质(C1-C3)</p><ol type="1"><li><spanclass="math inline">\(\{\alpha_i^k\}\)</span>不严格递减，且<spanclass="math inline">\(\alpha_i^k&gt;0\)</span></li><li><spanclass="math inline">\(\sum_{k=1}^{\infty}\alpha_{i}^{k}=\infty,\sum_{k=1}^{\infty}(\alpha_{i}^{k})^{2}&lt;\infty\)</span></li><li><spanclass="math inline">\(\sum\limits_{k=1}^{\infty}(\overline{\alpha}_{k}-\underline{\alpha}_{k})&lt;\infty,\text{where}\overline{\alpha}_{k}=\max\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\text{and}\underline{\alpha}_{k}=\min\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}.\)</span></li></ol></li><li><p><spanclass="math inline">\(\begin{matrix}0&amp;&lt;&amp;\lambda_i&amp;&lt;&amp;\frac{\sqrt{2}}{2}\end{matrix}\)</span></p></li></ol><p>结论：all players' actions converge to the unique NE <spanclass="math inline">\(x^*\)</span> under algorithm 1.</p><h4 id="preliminary-analysis-about-algorithm-1">3-2: Preliminaryanalysis about algorithm 1</h4><p>先来求一下algorithm 1里的<spanclass="math inline">\(v_i^k\)</span></p><p>定义：<spanclass="math inline">\(\left.V_{k}=\left[\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\ldots,v_{N}^{k}}\end{array}\right.\right]^{T}\)</span></p><p>所以<span class="math inline">\(v_i^{k+1}=\sum_{j=1}^Na_{ij}v_j^k\qquad (3b)\)</span>等价于<spanclass="math inline">\(V_{k+1}=AV_{k}\qquad (5)\)</span></p><p>因为<span class="math inline">\(V_1 = [v_1, v_2, ..., v_N]^T =I_N\)</span>，即<span class="math inline">\(v_i =e_i\)</span>（条件）</p><p>所以<spanclass="math inline">\(\lim_{k\to\infty}V_k=\operatorname*{lim}_{k\to\infty}A^{k-1}V_1=\operatorname*{lim}_{k\to\infty}A^{k}\)</span></p><p>因为A是行随机矩阵，所以显然<spanclass="math inline">\(1_n\)</span>是特征值为1时的一个特征向量。</p><p>所以得出<spanclass="math inline">\(\operatorname*{lim}_{k\to\infty}A^{k}=1_Nv^T\)</span>（根据Perron-Frobenius定理）, where <spanclass="math inline">\(v\)</span> 是A关于特征值1的左特征向量且<spanclass="math inline">\(v\)</span>每一项大于0，且<spanclass="math inline">\(v^T1_N=1\)</span>。</p><p>所以<spanclass="math inline">\(\lim_{k\to\infty}\left.V_{k}=\left[\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\ldots,v_{N}^{k}}\end{array}\right.\right]^{T}= 1_Nv^T\)</span>。又<span class="math inline">\(1_Nv^T=[v, v, ...,v]^T\)</span>。</p><p>也就是说，当k趋近于无穷大时，每个玩家的<spanclass="math inline">\(v_i\)</span>都收敛于<spanclass="math inline">\(v\)</span>。</p><p>再来求一下algorithm 1里的<spanclass="math inline">\(\tilde{\sigma}_{i}^{k}\)</span></p><p>首先<spanclass="math inline">\(V_k\)</span>对角线上的元素都是正的，通过<spanclass="math inline">\(V_{k+1}=AV_{k}\)</span>可看出。首先<spanclass="math inline">\(V_1\)</span>是单位阵肯定对角线为正，然后A的对角线元素都是正的（这是algorithm1引入时提到的条件）。所以他俩乘出来的对角线也是正的。不断递推，对角线上都是正的。</p><p>所以现在我定义一个<spanclass="math inline">\(\left.\hat{V}_k=\operatorname{diag}\left(\begin{bmatrix}v_1^k\end{bmatrix}\right._1,\begin{bmatrix}v_2^k\end{bmatrix}_2,\ldots,\begin{bmatrix}v_N^k\end{bmatrix}_N\right)\)</span></p><p>上面这个<spanclass="math inline">\(\hat{V}_k\)</span>其实就是取了<spanclass="math inline">\(V_k\)</span>的对角线，其余地方都是0。</p><p>因为前面说了对角线都是正的嘛，所以<spanclass="math inline">\(\hat{V_k}\)</span>是满秩可逆的。而且我们知道最终<spanclass="math inline">\(V_k\)</span>是收敛的，所以<spanclass="math inline">\(\hat{V_k}\)</span>最终也是收敛的。</p><p>最后我再定义<spanclass="math inline">\(\tilde{\sigma}_{k}=\left[\tilde{\sigma}_{1}^{k},\tilde{\sigma}_{2}^{k},\ldots,\tilde{\sigma}_{N}^{k}\right]^{T}\)</span>和<spanclass="math inline">\(\phi_k =\left[\phi_{1}(x_{1}^{k}),\phi_{2}(x_{2}^{k}),\ldots,\phi_{N}(x_{N}^{k})\right]^{T}\)</span></p><p>则<spanclass="math inline">\(\tilde{\sigma}_{i}^{k+1}=\sum_{j=1}^{N}a_{ij}\tilde{\sigma}_{j}^{k}+\frac{\phi_{i}\left(x_{i}^{k+1}\right)}{\left[v_{i}^{k+1}\right]_{i}}-\frac{\phi_{i}\left(x_{i}^{k}\right)}{\left[v_{i}^{k}\right]_{i}}\qquad (3c)\)</span>可改写为：</p><p><spanclass="math inline">\(\tilde{\sigma}_{k+1}=A\tilde{\sigma}_k+\hat{V}_{k+1}^{-1}\Phi_{k+1}-\hat{V}_k^{-1}\Phi_k\qquad (6)\)</span></p><h4 id="lemmas">3-3: Lemmas</h4><p>为了接下来的叙述方便，定义<spanclass="math inline">\(V_{\infty}=\lim\limits_{k\to\infty}V_{k}=1_{N}v^{T}\)</span>和<spanclass="math inline">\(\hat{V}_{\infty}=\operatorname{diag}([v]_1,\ldots,[v]_N)\)</span></p><h5 id="lemma-1">Lemma 1</h5><p>因为<spanclass="math inline">\(\hat{V}_{k}\)</span>是收敛的，所以会有<spanclass="math inline">\(\|\hat{V}_{k}^{-1}\|\leq \varrho, \varrho &gt;0\)</span></p><blockquote><p>矩阵的二范式从几何意义上来说就是单位圆在经过矩阵变换后离原点最远的距离。假设要求<spanclass="math inline">\(\|A\|\)</span>，则先求<spanclass="math inline">\(A^TA\)</span>，然后再求<spanclass="math inline">\(A^TA\)</span>的特征值，取最大的特征值开方就是矩阵A的二范数</p></blockquote><p>引理1：<spanclass="math inline">\(\|\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1}\|\leq\varrho^{2}\gamma\theta^{k},k \in \mathbb{N_+}, \gamma &gt; 0, 0 &lt; \theta &lt; 1, \varrho &gt;0\)</span></p><p>证明：</p><p>因为<span class="math inline">\((\hat{V_k}^{-1})(\hat{V_k} -\hat{V}_\infty)(\hat{V}_\infty^{-1}) =(\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1})\)</span></p><p>两边取范数，得：<spanclass="math inline">\(\|\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1}\| =\|(\hat{V_k}^{-1})(\hat{V_k} - \hat{V}_\infty)(\hat{V}_\infty^{-1})\|\le \|\hat{V_k}^{-1}\|\|\hat{V_k} -\hat{V}_\infty\|\|\hat{V}_\infty^{-1}\|\)</span></p><p>定义<span class="math inline">\(\varrho ={sup}_{k}\left\|\widetilde{V}_{k}^{-1}\right\|_{2}\)</span>，则<spanclass="math inline">\(\|\hat{V_k}^{-1}\|\|\hat{V}_\infty^{-1}\| \le\varrho^2\)</span></p><p>又<span class="math inline">\(\|\hat{V}_k - \hat{V}_\infty\| \le\gamma\theta^{k}\)</span>, [17]。</p><p>所以<spanclass="math inline">\(\|\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1}\| \le\varrho^{2}\gamma\theta^{k}\)</span>，得证。</p><h5 id="lemma-2">Lemma 2</h5><p>引理2：<spanclass="math inline">\(V_{\infty}\tilde{\sigma}_{k}=V_{\infty}\hat{V}_{k}^{-1}\Phi_{k},k \in \mathbb{N_+}\)</span></p><p>证明如下：</p><p><img src="1.png" /></p><h5 id="lemma-3">Lemma 3</h5><p>先来点前置知识</p><p>因为<spanclass="math inline">\(\operatorname*{lim}_{k\to\infty}\left(A-1_{N}v^{T}\right)^{k}=\operatorname*{lim}_{k\to\infty}A^{k}-1_{N}v^{T}=0\)</span>（这个极限推导可以先放着不管），所以根据谱半径的知识，可以知道<spanclass="math inline">\(\rho(A-1_Nv^T)~&lt;~1\)</span></p><p>又因为<span class="math inline">\(\rho(A-1_Nv^T) \le \|A -1_Nv^T\|\)</span></p><p>所以必然存在一个矩阵范数<spanclass="math inline">\(\|\cdot\|_\epsilon\)</span>，使得<spanclass="math inline">\(\rho(A-1_{N}v^{T})\leq\|A-1_{N}v^{T}\|_{\epsilon}\leq\rho(A-1_{N}v^{T})+\epsilon&lt;1\)</span></p><p>另外，又因为所有的矩阵范式都是等价的，所以有：</p><p><span class="math inline">\(\|\cdot\|_{\epsilon}\leqc\|\cdot\|\)</span> and <span class="math inline">\(\|\cdot\|\leqd\|\cdot\|_{\epsilon}\)</span></p><p>接下来再定义两个东西</p><p><span class="math inline">\(\rho_1=\left\|A-1_Nv^T\right\|_\epsilon,\rho_1 &lt; 1 \qquad (7)\)</span></p><p><span class="math inline">\(\rho_2=\left\|I_N-1_Nv^T\right\| \qquad(8)\)</span></p><p>引理3：Under Assumption 1(a), 2 and 4, <spanclass="math inline">\(\|\tilde{\sigma}_i^k-v^T\tilde{\sigma}_k\|\)</span>is bounded, i.e., there exists a constant <spanclass="math inline">\(\hat{C} &gt; 0\)</span> such that <spanclass="math inline">\(\|\tilde{\sigma}_{i}^{k}-v^{T}\tilde{\sigma}_{k}\|\leq\hat{C}\)</span></p><p>证明如下：</p><p><img src="5.png" /></p><p><img src="6.png" /></p><h5 id="lemma-4">Lemma 4</h5><p>引理4：<spanclass="math inline">\(\|G_i\left(x_i^k,\sigma(x_k)\right)\|\le M,\|G_i(x_i^k, \tilde{\sigma}_i^k) \| \le M, M &gt; 0\)</span></p><p>证明如下：</p><p><img src="2.png" /></p><h5 id="lemma-5">Lemma 5</h5><p>定义<spanclass="math inline">\(\overline{\lambda}=\max_{j\in\mathcal{N}}\{\lambda_j\}\)</span>，若<spanclass="math inline">\(0&lt;\overline{\lambda}&lt;\frac{\sqrt{2}}2\)</span>，则下面三条性质将会满足：</p><ol type="a"><li><p><spanclass="math inline">\(\left\|x_{i}^{k+1}-x_{i}^{k}\right\|\leqM\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s},\forallk\in\mathbb{N}_{+}\)</span></p></li><li><p><spanclass="math inline">\(\lim\limits_{k\to\infty}\left\|x_{i}^{k+1}-x_{i}^{k}\right\|=0\)</span></p></li><li><p><spanclass="math inline">\(\sum_{k=1}^{\infty}\|x_{i}^{k+1}-x_{i}^{k}\|^{2}&lt;\infty\)</span></p></li></ol><p>where <span class="math inline">\(M\)</span> is given in Lemma 4, and<spanclass="math inline">\(\overline{\alpha}_{k}=\max_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\)</span></p><p>证明如下：</p><p><img src="3.png" /></p><p><img src="4.png" /></p><p>补充：因为所有动作<spanclass="math inline">\(x_i^k\)</span>都属于compact的<spanclass="math inline">\(\Omega_i\)</span>，所以<spanclass="math inline">\(\{x_k\}\)</span>是有界的，又由Lemma5(b)和柯西收敛准测可容易推出<spanclass="math inline">\(\{x_k\}​\)</span>是收敛的。</p><h5 id="lemma-6">Lemma 6</h5><ol type="a"><li><p>For any <span class="math inline">\(k \geq 2\)</span>, one has<spanclass="math display">\[\left\|\tilde{\sigma}_{k}-V_{\infty}\tilde{\sigma}_{k}\right\|\leqdc\rho_{1}^{k-1}\left\|\tilde{\sigma}_{1}-1_{N}v^{T}\tilde{\sigma}_{1}\right\|+D_1\sum_{l=1}^{k-1}\rho_1^{k-l-1}\beta_l+D_2\sum_{l=1}^{k-1}\rho_1^{k-l-1}\theta^l\qquad (9)\]</span>where <spanclass="math inline">\(D_{1}=dc\rho_{2}\varrhoL_{2}\sqrt{N}M,D_{2}=2dc\rho_{2}C\varrho^{2}\gamma,\beta_l=\sum_{s=1}^{l}\overline{\lambda}^{l-s}\overline{\alpha}_{s}\)</span>and<spanclass="math inline">\(0&lt;\theta&lt;1\)</span> is given in Lemma1.</p></li><li><p>For step-size sequence <spanclass="math inline">\(\{\alpha_i^k\}\)</span> satisfying conditionsC1-C3, one has <spanclass="math inline">\(\sum_{k=1}^{\infty}\overline{\alpha}_{k}\left\|\tilde{\sigma}_{k}-V_{\infty}\tilde{\sigma}_{k}\right\|&lt;\infty\)</span></p></li></ol><p>证明如下：</p><p><img src="7.png" /></p><p><img src="8.png" /></p><h4 id="proof-of-theorem-1">3-4: Proof of theorem 1</h4><p><img src="9.png" /></p><p><img src="10.png" /></p><p><img src="11.png" /></p><p><img src="12.png" /></p><p><img src="13.png" /></p><p><img src="14.png" /></p><p><img src="15.png" /></p><p><img src="16.png" /></p><h4 id="theorem-2">3-5: Theorem 2</h4><p>在满足Assumption 1(a), 2, 3(b) and 4的前提下。令<spanclass="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}=\alpha_{k}\)</span>。且<spanclass="math inline">\(0&lt;\lambda_i&lt;\frac{\sqrt{2}}{2}\)</span>，则<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速率为<spanclass="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span>。 <spanclass="math display">\[q_t=\frac{\sum\limits_{k=1}^t\alpha_k\|x_k-x^*\|^2}{\sum\limits_{k=1}^t\alpha_k}\]</span> 证明：暂略</p><h4 id="convergence-rate-analysis-of-algorithm-1">3-6: Convergence rateanalysis of algorithm 1</h4><p>如果<spanclass="math inline">\(\Gamma(x)\)</span>是强单调，且步长满足<spanclass="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}\)</span>。则可以分析algorithm1的收敛速率。</p><p>结论就是<span class="math inline">\(x_k\)</span>收敛到<spanclass="math inline">\(x^*\)</span>的速率与<spanclass="math inline">\(q_t\)</span>收敛到0的速率相同。证明如下：</p><p><img src="17.png" /></p><hr /><h3 id="section-4-convergence-analysis-of-algorithm-2">Section 4:Convergence analysis of algorithm 2</h3><p>对于之前的algorithm 2中的公式(4a) - (4c)，用矩阵表示如下： <spanclass="math display">\[\begin{aligned}&amp;w_{k+1} =A\left(k\right)\tilde{\sigma}_{k},  \\&amp;y_{k+1} =A\left(k\right)y_{k},  \\&amp;z_{i}^{k+1} =\frac{w_{i}^{k+1}}{y_{i}^{k+1}},\quad i=1,\ldots,N,&amp; (24)\end{aligned}\]</span> (4e)则可以表达为以下形式：</p><p><spanclass="math inline">\(\tilde{\sigma}_{k+1}=A\left(k\right)\tilde{\sigma}_{k}+\Phi_{k+1}-\Phi_{k},\quad(25)\)</span></p><p>其中A矩阵是一个列随机矩阵，如果点j连向i，则A(i, j) = 1 /(点j的出度)。如果j不连向i，则A(i, j) = 0。</p><p>定义<spanclass="math inline">\(\epsilon_{k}=[\epsilon_{1}^{k},\ldots,\epsilon_{N}^{k}]^{T}=\Phi_{k+1}-\Phi_{k}\)</span>，这个是。再定义<spanclass="math inline">\(\epsilon_{i}^{k}=\phi_{i}(x_{i}^{k+1})-\phi_{i}(x_{i}^{k})\)</span>。</p><p>因为A是列随机矩阵，所以<spanclass="math inline">\(1_{N}^{T}A({k})=1_{N}^{T}\)</span>。所以(25)左右同乘一个<spanclass="math inline">\(1_N^T\)</span>，然后移项得到递推式，通过递推式可得<spanclass="math inline">\(1_{N}^{T}\tilde{\sigma}_{k} - 1_N^T\phi_k =1_N^T\tilde{\sigma}_1 - 1_N^T\phi_1 = 0\)</span></p><p>所以<span class="math inline">\(1_N^T\tilde{\sigma}_k = 1_N^T\phi_k =\phi_1(x_1^k) + \phi_2(x_2^k) + ... + \phi_n(x_n^k) =\sigma(x_k)\)</span></p><h4 id="lemmas-1">4-1: Lemmas</h4><h5 id="lemma-7">Lemma 7</h5><p>定理：在满足Assumptions 1(b), 2, 4的前提下，there exists a constant<span class="math inline">\(\tilde{M} &gt; 0\)</span>, s.t, <spanclass="math inline">\(\|G_{i}(x_{i}^{k},\sigma(x_{k}))\|\leq\tilde{M}\)</span>and <spanclass="math inline">\(\|G_{i}(x_{i}^{k},Nz_{i}^{k+1})\|\leq\tilde{M}\)</span></p><p>证明：</p><p>Lemma 4已经证出了<spanclass="math inline">\(\left\|G_i\left(x_i^k,\sigma(x_k)\right)\right\|\leqM_1\)</span>，所以<spanclass="math inline">\(\|G_{i}(x_{i}^{k},\sigma(x_{k}))\|\leq\tilde{M}\)</span>就不用证了。主要证后面那个。</p><p><spanclass="math display">\[\begin{Vmatrix}G_i(x_i^k,Nz_i^{k+1})\end{Vmatrix}\le\begin{Vmatrix}G_i(x_i^k,Nz_i^{k+1})-G_i(x_i^k,1_N^T\tilde{\sigma}_k)\end{Vmatrix}+\left\|G_{i}(x_{i}^{k},1_{N}^{T}\tilde{\sigma}_{k})\right\|\\ \qquad \le L_{1}\left\VertNz_{i}^{k+1}-1_{N}^{T}\tilde{\sigma}_{k}\right\Vert+\left\VertG_{i}(x_{i}^{k},1_{N}^{T}\tilde{\sigma}_{k})\right\Vert \]</span></p><p>显然，<spanclass="math inline">\(\|G_{i}(x_{i}^{k},1_{N}^{T}\tilde{\sigma}_{k})\|\)</span>就是<spanclass="math inline">\(\|G_i(x_i^k,\sigma(x_k))\|\)</span>，所以其有界。</p><p>由[17, lemma 1(a)]可知，k &gt;=2 时，有：</p><p><spanclass="math inline">\(\left|z_{i}^{k+1}-\frac{1_{N}^{T}\tilde{\sigma}_{k}}{N}\right|\le\frac{8}{\delta}\Bigg(\iota^{k-1}\|\tilde{\sigma}_{1}\|_{1}+\sum_{s=1}^{k-1}\iota^{k-s-1}\|\epsilon_{s}\|_{1}\Bigg)\quad (26)\)</span></p><p>with <span class="math inline">\(\delta &gt; 0, 0 &lt; \iota &lt;1\)</span></p><p>因为<span class="math inline">\(\|\epsilon_{s}\|_{1}\leN\|\epsilon_{s}\|=N\|\Phi_{s+1}-\Phi_{s}\|\leq2NC\)</span></p><p>所以不难证出：<spanclass="math inline">\(L_{1}\left\|Nz_{i}^{k+1}-1_{N}^{T}\tilde{\sigma}_{k}\right\|\)</span>有界</p><p>所以<span class="math inline">\(\|G_i(x_i^k,Nz_i^{k+1})\|\)</span>有界，即<spanclass="math inline">\(\parallel G_i(x_i^k,Nz_i^{k+1})\parallel \le\tilde{M}_2\)</span></p><p>令<span class="math inline">\(\tilde{M} = max (M_1,\tilde{M}_2)\)</span>，得证。</p><blockquote><p>Note: 如果<spanclass="math inline">\(\overline{\lambda}=\operatorname*{max}_{j\in\mathcal{N}}\{\lambda_{j}\}\)</span>satisfies <span class="math inline">\(0 &lt; \overline{\lambda} &lt;\frac{\sqrt{2}}{2}\)</span>，则Lemma5中的结论和证明过程仍然成立，只需要将其中涉及到的M换成<spanclass="math inline">\(\tilde{M}\)</span></p></blockquote><h5 id="lemma-8">Lemma 8</h5><p>定理：如果<spanclass="math inline">\(\overline{\lambda}=\max_{j\in\mathcal{N}}\{\lambda_{j}\}\)</span>satisfies <span class="math inline">\(0 &lt; \overline{\lambda} &lt;\frac{\sqrt{2}}{2}\)</span>，且<spanclass="math inline">\(\alpha_i^k\)</span> satisfies conditionsC1-C3。则<spanclass="math inline">\(\lim_{k\rightarrow\infty}\epsilon_{i}^{k}=0\)</span>，且<spanclass="math inline">\(\sum_{k=1}^\infty\overline{\alpha}_k\|\epsilon_i^k\|&lt;\infty\)</span></p><p>证明：</p><p>由于上面的Note存在，所以Lemma 5的结论可以直接用于Lemma 8的证明。</p><p>先证第一个：</p><p>因为<span class="math inline">\(\phi_i(x_i)\)</span>是L2-Lipschitzcontinuous，所以<span class="math inline">\(\|\epsilon_{i}^{k}\|\leL_{2}\|x_{i}^{k+1}-x_{i}^{k}\|\)</span></p><p>而且由Lemma 5(b)知：<spanclass="math inline">\(\lim_{k\to\infty}\|x_{i}^{k+1}-x_{i}^{k}\|=0\)</span></p><p>所以<spanclass="math inline">\(\lim_{k\to\infty}\epsilon_{i}^{k}=0\)</span></p><p>再证第二个：</p><p>由Lemma 5(a)知：<spanclass="math inline">\(\left\|x_i^{k+1}-x_i^k\right\|\leqM\sum_{s=1}^k\overline{\lambda}^{k-s}\overline{\alpha}_s\)</span></p><p>所以：<span class="math inline">\(\overline{\alpha}_k||\epsilon_i^k||\le\overline{\alpha}_{k}L_{2}\tilde{M}\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s}\leL_{2}\tilde{M}\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s}^{2}\)</span></p><p>又根据[31 Lemma 3.1(b)]，可得到：<spanclass="math inline">\(\sum_{k=1}^{\infty}\overline{\alpha}_{k}||\epsilon_{i}^{k}||\leqL_{2}\tilde{M}\sum_{k=1}^{\infty}\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s}^{2}&lt;\infty\)</span></p><blockquote><p>Note：通过Lemma 8证明的这两个结论，通过[17 Lemma1]，可以进一步证明出：</p><p><spanclass="math inline">\(\lim\limits_{k\to\infty}\left\|z_i^{k+1}-\frac{1_N^T\tilde{\sigma}_k}{N}\right\|=0,\sum\limits_{k=1}^{\infty}\overline{\alpha}_k\left\|z_i^{k+1}-\frac{1_N^T\tilde{\sigma}_k}{N}\right\|&lt;\infty\)</span></p><p>因为<spanclass="math inline">\(1_{N}^{T}\tilde{\sigma}_{k}\)</span>就是<spanclass="math inline">\(\sigma\left(x_{k}\right)\)</span></p><p>所以<spanclass="math inline">\(\sum_{k=1}^{\infty}\overline{\alpha}_{k}\left\VertNz_{i}^{k+1}-\sigma(x_{k})\right\Vert &lt; \infty\)</span></p><p>上面这个公式在algorithm 2的收敛分析中有作用。</p></blockquote><h4 id="theorem-3">4-2: Theorem 3</h4><p>定理：在满足Assumptions 1(b), 2, 3(a), 4，以及<spanclass="math inline">\(0 &lt; \lambda_i &lt;\frac{\sqrt{2}}{2}\)</span>，以及C1-C3的条件下。所有玩家的动作最终会收敛到<spanclass="math inline">\(x^*\)</span></p><p>证明：</p><p><img src="18.png" /></p><p><img src="19.png" /></p><h4 id="theorem-4">4-3: Theorem 4</h4><p>定理：在Assumptions 1(b), 2, 3(b), 4 are satisfied 的前提下，令<spanclass="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}=\alpha_{k}\)</span>，且<spanclass="math inline">\(0 &lt; \lambda_i &lt;\frac{\sqrt{2}}{2}\)</span>。则<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速率为<spanclass="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span> <spanclass="math display">\[q_t=\frac{\sum\limits_{k=1}^t\alpha_k\|x_k-x^*\|^2}{\sum\limits_{k=1}^t\alpha_k}\]</span> 证明：需要参考[17 Corollary 3]和Theorem 2的证明。</p><blockquote><p>Note：如果<spanclass="math inline">\(\Gamma(x)\)</span>是强单调且步长满足<spanclass="math inline">\(\alpha_i^k=\frac1{\sqrt{k}}\)</span>，则可分析algorithm2的收敛速度。结论也是<span class="math inline">\(x_k\)</span>收敛到<spanclass="math inline">\(x^*\)</span>的速率与<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速率相同。</p></blockquote><hr /><h3 id="section-5-energy-consumption-control-of-phevs">Section 5: Energyconsumption control of PHEVs</h3><p>每个PHEV就是一个玩家。第 i 个PHEV的电量消耗为<spanclass="math inline">\(x_i, x_i \in [x_i^{min},x_i^{max}]\)</span>。每台车的成本函数<spanclass="math inline">\(J_i\)</span>定义为： <span class="math display">\[J_i(x_i,x_{-i})=x_i\left(a\sigma(x)+b\right)+p_o\left(\kappa_i\left(1-\frac{x_i}{x_i^{\max}}\right)^2+d_i\right)\qquad (30)\]</span> a &gt; 0，<spanclass="math inline">\(\sigma(x)=\sum_{i=1}^N{x_i}\)</span>，<spanclass="math inline">\(p_0\)</span>是油价，<spanclass="math inline">\(\kappa_{i}\)</span>是油价的换算系数，<spanclass="math inline">\(d_i\)</span>是第 i 台车所需的基本油量。</p><p>总结一下，按照我的理解，上面那个式子就是每台车的花费函数嘛。花费分为俩部分：电费、油费。电费不仅跟自己的耗电量有关，也跟所有人的耗电量有关，所以是第i台车的电费是两者相乘。对于油费，首先一台车的油量分为两部分，第一是<spanclass="math inline">\(x_i^{max} -x_i\)</span>剩下的用油来跑，第二是一台车最起码要存储的油量<spanclass="math inline">\(d_i\)</span>。分别就对应着上面括号里的两项。乘个油价就为油费了。</p><p>这个实际问题建模后显然满足Assumption 2,4。而且值得注意的是，其成本函数还具有一个势函数<spanclass="math inline">\(F(x)\)</span>： <span class="math display">\[\begin{aligned}F(x)&amp;=\frac12\sum_{i=1}^Nax_i\left(\sigma(x)-x_i\right)+\sum_{i=1}^N\left(ax_i^2+bx_i\right)\\&amp;+\sum_{i=1}^Np_o\left(\kappa_i\left(1-\frac{x_i}{x_i^{\max}}\right)^2+d_i\right)\qquad(31)\end{aligned}\]</span> （势函数就是指，对于所有i，有：<spanclass="math inline">\(\frac{\partial{J}_{i}(x)}{\partialx_{i}}=\frac{\partial{F}(x)}{\partial x_{i}}\)</span>）</p><p>接下来，来验证这个建模满足Assumption 3(a)。即<spanclass="math inline">\(\Gamma(x)\)</span>在<spanclass="math inline">\(\Omega\)</span>上是严格单调的。</p><h4 id="lemma-9">Lemma 9</h4><p>定理：如果<span class="math inline">\(N &gt; 3\)</span>且a满足：<span class="math display">\[a&lt;\min_{i\in\mathcal{N}}\frac{2p_{o}\kappa_{i}}{\left(N-3\right)\left(x_{i}^{\max}\right)^{2}}\]</span> 则势函数<spanclass="math inline">\(F(x)\)</span>是严格凸的。</p><p>证明：</p><p>先求<spanclass="math inline">\(\nabla^2F(x)\)</span>，不难求出，其对角元素为<spanclass="math inline">\(2a+\frac{2p_{o}\kappa_{i}}{(x_{i}^{\operatorname*{max}})^{2}}\)</span>，非对角元素为<spanclass="math inline">\(a\)</span>。因为<span class="math inline">\(N &gt;3\)</span>且a满足<spanclass="math inline">\(a&lt;\min_{i\in\mathcal{N}}\frac{2p_{o}\kappa_{i}}{\left(N-3\right)\left(x_{i}^{\max}\right)^{2}}\)</span>，所以<spanclass="math inline">\(\nabla^2F(x)\)</span>是一个严格对角占优矩阵（严格对角占有矩阵就是对于每一行其对角线上元素的绝对值大于该行中其它所有元素绝对值之和）。所以由[30]中的Gershgorin’sdisctheorem可知<spanclass="math inline">\(\nabla^2F(x)\)</span>是一个正定矩阵。那么凸函数的第四种定义即可知道<spanclass="math inline">\(F(x)\)</span>是一个严格凸函数。证毕。</p><p>所以，这个建模在满足<span class="math inline">\(N &gt; 3,a&lt;\min_{i\in\mathcal{N}}\frac{2p_{o}\kappa_{i}}{\left(N-3\right)\left(x_{i}^{\max}\right)^{2}}\)</span>的时候，就满足<spanclass="math inline">\(F(x)\)</span>是个凸函数，即：<spanclass="math inline">\((x-y)^{T}(\nabla F(x)-{\nabla F(y)})&gt;0, x \ney\)</span> 。又因为<spanclass="math inline">\(\frac{\partial{J}_{i}(x)}{\partialx_{i}}=\frac{\partial{F}(x)}{\partial x_{i}}\)</span>，所以Assumption3(a)满足（这里的<spanclass="math inline">\(F(x)\)</span>其实就是Assumption 3中的<spanclass="math inline">\(\Gamma(x)\)</span>）。</p><p>至此，满足了Assumption 1, 2, 3(a), 4。只要控制好动量系数满足<spanclass="math inline">\(0&lt;\lambda_i&lt;\frac{\sqrt{2}}2\)</span>，以及步长系数<spanclass="math inline">\(\lambda_i\)</span>满足C1-C3，那么这个建模就满足Algorithm1、2的使用条件了。</p><h4 id="numerical-simulations">Numerical simulations</h4><p>下面，分别通过两个实际的数值模拟来验证Algorithm 1、2。</p><p>考虑有8台车，5种不同类型的车分别用不同颜色表示。每台车的具体参数见下表：</p><p><img src="26.png" /></p><p>先来验证Algorithm 1。</p><p><img src="20.png" /></p><p>可以看到，这个图是强连通的且不是一个权重平衡图。通过计算，<spanclass="math inline">\(x^* =[17.6859,17.6859,15.5682,15.5682,12.5484,12.5484, 16.587,16.3481]\)</span>。</p><p>设置步长为<spanclass="math inline">\(\alpha_{i}^{k}=\frac{1}{k^{0.6}}+\frac{1}{k^{1.2}}\)</span>。</p><p>Fig 2是在不同<spanclass="math inline">\(\lambda_i\)</span>下，使用Algorithm 1收敛到<spanclass="math inline">\(x^*\)</span>的迭代次数。</p><p><img src="21.png" /></p><p>可以看到，加了动量项收敛速度确实会快一些。而且动量系数越大速度越快。而且虽然理论要求<spanclass="math inline">\(0&lt;\lambda_i&lt;\frac{\sqrt{2}}2\)</span>，但是<spanclass="math inline">\(\frac{\sqrt{2}}{2} &lt; \lambda_i &lt;1\)</span>时在数值仿真中仍然可以收敛。</p><p>再来验证Algorithm 2。</p><p><img src="22.png" /></p><p>如图Fig. 3，考虑车子的通信图周期性地在Fig. 3中的两个状态中切换。</p><p>Fig. 4是在不同<spanclass="math inline">\(\lambda_i\)</span>下，使用Algorithm 2收敛到<spanclass="math inline">\(x^*\)</span>的迭代次数。</p><p><img src="23.png" /></p><p>可以发现，加了动量项收敛速度确实会快一些。而且动量系数越大速度越快。而且<spanclass="math inline">\(\lambda_i\)</span>也是可以大于<spanclass="math inline">\(\frac{\sqrt{2}}{2}\)</span> ，小于1。</p><p>最后通过数值模拟证明一下<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速率为<spanclass="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span>。</p><p>下面两幅图就是分别用了Algorithm 1和2（<spanclass="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}, \lambda_i =0.6\)</span>）。其中<span class="math inline">\(c_t = \frac{\lnt}{\sqrt{t}}\)</span>。</p><p><img src="24.png" /></p><p><img src="25.png" /></p><p>可以发现，迭代次数越多的时候，<spanclass="math inline">\(q_t\)</span>与<spanclass="math inline">\(c_t\)</span>的比值越接近1。也就通过数值模拟证明了在Algorithm1或2下，它俩收敛到0的速度是一样的。</p><hr /><h3 id="section-6-conclusion">Section 6: Conclusion</h3><p>本文提出了两种算法分别解决固定有向图和时变有向图上的NE寻找问题（且图不需要权重平衡）。这俩算法分别是基于行随机矩阵左特征向量估计法、列随机矩阵推和法。</p><p>而且为了加速算法收敛，算法1、2中均加入了动量项。</p><p>但是算法中采用的是学习率递减到0的方式，这种方式会导致收敛速度较慢，这是本算法的不足。</p><p>最后，本文作者认为，进一步研究“在聚合游戏中采用分布式算法加速寻找NE”将是一件很有趣的课题。</p><hr /><h3 id="personal-summary">Personal summary</h3><h4 id="分布式发展历史">分布式发展历史</h4><p>这篇文章是我在分布式领域看的第一篇文章，所以在这里写点关于分布式算法优化领域的发展过程：</p><blockquote><p>1960s，Everett Dantzig, Wolfe and Benders思考了关于严格凸问题的拉格朗日松弛和线性规范的分解方法。（分解方法是为了将大型优化问题分解为小问题）</p><p>后来，拉格朗日松弛和Hestenes, Powell andMiele发展的增广拉格朗日技术相结合，解决了一些凸但非严格凸的问题。可以理解为现代ADMM算法的前身。</p><p>2000年初，出现了为了适应大规模数据的分布式算法，例如SGD（分布式随机梯度下降）。</p><p>2010年初，为了解决大规模机器学习问题，出现了ADMM（交替方向乘子法）等算法。</p><p>至今，分布式优化算法在算法效率、鲁棒性、以及适应动态和不确定环境方面取得了显著进展。出现了更加高效的分布式在线优化方法，以及能够适应网络拓扑变化和通信不确定性的算法。</p></blockquote><h4 id="文章总结">文章总结</h4><p>本文就是研究了一种特殊的博弈——聚合博弈。</p><p>每个玩家的花费不仅跟自身动作有关，还跟其他人的动作有关。</p><p>本论文设计了两种算法，在作者规定的特定条件下，可以使得每个人的花费尽可能低。分别用于固定有向图和时变有向图。</p><p>文章内容为：算法介绍、算法的正确性证明、收敛速度分析、在PHEVs上的应用。</p><h5 id="算法介绍">算法介绍</h5><p><strong>Algorithm 1</strong> <span class="math display">\[\begin{gathered}x_i^0=x_i^1\in\Omega_i,v_i^1=e_i,\tilde{\sigma}_i^1=\phi_i(x_i^1) \\x_{k+1}=P_{\Omega_{i}}[x_{k}-\alpha_{k}G_{i}(x_{k},\tilde{\sigma}_{k})+\lambda_{i}(x_{k}-x_{k-1})]\\V_{k+1}=AV_k \\\tilde{\sigma}_{k+1}=A\tilde{\sigma}_k+\hat{V}_{k+1}^{-1}\Phi_{k+1}-\hat{V}_{k}^{-1}\Phi_{k}\end{gathered}\]</span> 目的就是为了把<spanclass="math inline">\(x_k\)</span>收敛到<spanclass="math inline">\(x^*\)</span>。使得玩家动作为<spanclass="math inline">\(x^*\)</span>时，每个玩家的花费最少。</p><p>因为动作<span class="math inline">\(x_i\)</span>会对花费<spanclass="math inline">\(J_i\)</span>产生影响，故定义<spanclass="math inline">\(G_i\)</span>为<spanclass="math inline">\(J_i\)</span>对<spanclass="math inline">\(x_i\)</span>求导，用来评估<spanclass="math inline">\(x_i\)</span>对<spanclass="math inline">\(J_i\)</span>产生的影响。</p><p>那么<span class="math inline">\(x_i^{k+1}\)</span>就可以通过<spanclass="math inline">\(x_i^k\)</span>和<spanclass="math inline">\(G_i(x_i^k,\tilde{\sigma}_i^k)\)</span>来更新。</p><p><span class="math inline">\(\tilde{\sigma}_i^k\)</span>是什么？</p><p>需要注意的是，花费函数<spanclass="math inline">\(J_i\)</span>除了要知道<spanclass="math inline">\(i\)</span>玩家的动作<spanclass="math inline">\(x_i\)</span>，还需要知道所有玩家的输出函数<spanclass="math inline">\(\phi_i\)</span>。所以定义<spanclass="math inline">\(\sigma(x)\)</span>为所有玩家的输出函数之和。但是因为每个玩家没有上帝视角，所以<spanclass="math inline">\(\sigma(x)\)</span>是未知的，所以我们可以用<spanclass="math inline">\(\tilde\sigma_i\)</span>来代替<spanclass="math inline">\(\sigma(x)\)</span>。即每个玩家都有一个对<spanclass="math inline">\(\sigma(x)\)</span>的评估函数<spanclass="math inline">\(\tilde\sigma_i\)</span>（这个评估函数也是需要迭代更新的，最终要收敛于<spanclass="math inline">\(\sigma(x)\)</span>）</p><p>至于<spanclass="math inline">\(V_k\)</span>，个人目前觉得是一个辅助矩阵，在迭代更新<spanclass="math inline">\(\tilde\sigma_k\)</span>时会用到。</p><p>至于<spanclass="math inline">\(\lambda_i\)</span>，是动量项，加速收敛用的。</p><p><strong>Algorithm 2</strong> <span class="math display">\[\begin{gathered}\\x_i^0=x_i^1\in\Omega_i,y_i^1=1,\tilde{\sigma}_i^1=\phi_i(x_i^1) \\w_{k+1}=A\left(k\right)\tilde{\sigma}_{k} \\y_{k+1}=A\left(k\right)y_{k} \\z_i^{k+1}=\frac{w_i^{k+1}}{y_i^{k+1}} \\x_{k+1}=P_{\Omega_i}\left[x_k-\alpha_kG_i(x_k,Nz_{k+1})+\lambda_i(x_k-x_{k-1})\right]\\\begin{aligned}\tilde{\sigma}_{k+1}=w_{k+1}+\phi_i\left(x_{k+1}\right)-\phi_i\left(x_k\right)\end{aligned}\end{gathered}\]</span> w是多余的，可以把<spanclass="math inline">\(w_{k+1}\)</span>那里合并到最后一个公式。</p><p>本质就是推和协议。y是权重，<spanclass="math inline">\(\sigma\)</span>是基于权重的平均值。</p><p>经过迭代后，<span class="math inline">\(z =\frac{\sigma}{y}\)</span>就是<spanclass="math inline">\(\phi\)</span>的平均值。</p><p>但是因为<spanclass="math inline">\(\phi\)</span>初值不是定值，所以最后公式倒数俩项就是动态更新<spanclass="math inline">\(\sigma\)</span></p><h5 id="算法正确性证明">算法正确性证明</h5><p>本文大篇幅都是在证这个。</p><p>本质就是证<span class="math inline">\(x_k\)</span>最终收敛于<spanclass="math inline">\(x^*\)</span>。即<span class="math inline">\(\|x_k- x^*\|^2 \rightarrow 0\)</span>。</p><p>具体内容过多不好总结 ，具体看下文证明。</p><p>证明过程主要用到了：矩阵范数性质、范数的放缩、Cauchy-Schwarz。</p><h5 id="收敛速度分析">收敛速度分析</h5><p>在作者规定的更多特定条件下（条件比它提出的俩算法更严格），Algorithm1、2的收敛速度跟<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速度一样： <spanclass="math display">\[q_t=\frac{\sum\limits_{k=1}^t\alpha_k\|x_k-x^*\|^2}{\sum\limits_{k=1}^t\alpha_k}\]</span> 而<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速度经证明为：<spanclass="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span></p><h5 id="在phevs上的应用">在PHEVs上的应用</h5><p>这个部分论文中也没给出实现代码，只给出了数值模拟的结果和效果图。所以我自己复现了一遍论文的算法。</p><p><strong>Algorithm 1的数值仿真</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Algorithm 1的数值仿真</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">n = <span class="number">8</span></span><br><span class="line">x_best = [-<span class="number">1</span>, <span class="number">17.6859</span>, <span class="number">17.6859</span>, <span class="number">15.5682</span>, <span class="number">15.5682</span>, <span class="number">12.5484</span>, <span class="number">12.5484</span>, <span class="number">16.587</span>, <span class="number">16.3481</span>]</span><br><span class="line">x_min = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">x_max = [-<span class="number">1</span>, <span class="number">27.5</span>, <span class="number">27.5</span>, <span class="number">34.2</span>, <span class="number">34.2</span>, <span class="number">40.6</span>, <span class="number">40.6</span>, <span class="number">28.8</span>, <span class="number">35.7</span>]</span><br><span class="line">x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">p_0 = <span class="number">5.6</span></span><br><span class="line">a = <span class="number">0.004</span></span><br><span class="line">b = <span class="number">0.1</span></span><br><span class="line">k = [-<span class="number">1</span>, <span class="number">4.6</span>, <span class="number">4.6</span>, <span class="number">3.7</span>, <span class="number">3.7</span>, <span class="number">3.4</span>, <span class="number">3.4</span>, <span class="number">4.0</span>, <span class="number">3.9</span>]</span><br><span class="line">d = [-<span class="number">1</span>, <span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>]</span><br><span class="line">alpha = <span class="number">2</span></span><br><span class="line">A = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">3</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>]</span><br><span class="line">]   <span class="comment"># 这里因为论文中没明确指定具体的值，只说是行随机，所以对于每行有值的位置我直接平均分了</span></span><br><span class="line">v = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line">sigma = [-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    sigma.append(x[i])</span><br><span class="line"></span><br><span class="line">xx = copy.deepcopy(x)</span><br><span class="line">xxx = copy.deepcopy(x)</span><br><span class="line">vv = copy.deepcopy(v)</span><br><span class="line">ssigma = copy.deepcopy(sigma)</span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">i, x, sigma</span>):</span><br><span class="line">    <span class="keyword">return</span> a * (sigma + x) + b  - <span class="number">2</span> * p_0 * k[i] / x_max[i] * (<span class="number">1</span> - x / x_max[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_x</span>(<span class="params">i, vec</span>):</span><br><span class="line">    x[i] = xx[i] - alpha * G(i, xx[i], ssigma[i]) + vec * (xx[i] - xxx[i])</span><br><span class="line">    <span class="keyword">if</span> x[i] &lt; x_min[i]: x[i] = x_min[i]</span><br><span class="line">    <span class="keyword">if</span> x[i] &gt; x_max[i]: x[i] = x_max[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_v</span>(<span class="params">i</span>):</span><br><span class="line">    vvv = copy.deepcopy(vv)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            vvv[j][l] *= A[i][j]</span><br><span class="line">    res = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> += vvv[l][j]</span><br><span class="line">        res.append(<span class="built_in">sum</span>)</span><br><span class="line">    v[i] = res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_sigma</span>(<span class="params">i</span>):</span><br><span class="line">    add_1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        add_1 += ssigma[j] * A[i][j]</span><br><span class="line">    add_2 = x[i] / v[i][i]</span><br><span class="line">    add_3 = xx[i] / vv[i][i]</span><br><span class="line">    sigma[i] = add_1 + add_2 - add_3</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    <span class="keyword">global</span> x, alpha, v, sigma, xx, xxx, vv, ssigma</span><br><span class="line">    x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">    alpha = <span class="number">2</span></span><br><span class="line">    v = [</span><br><span class="line">        [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    ]</span><br><span class="line">    sigma = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        sigma.append(x[i])</span><br><span class="line">    xx = copy.deepcopy(x)</span><br><span class="line">    xxx = copy.deepcopy(x)</span><br><span class="line">    vv = copy.deepcopy(v)</span><br><span class="line">    ssigma = copy.deepcopy(sigma)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm_1</span>(<span class="params">iter_num, vec</span>):</span><br><span class="line">    <span class="keyword">global</span> xx, xxx, vv, ssigma, alpha</span><br><span class="line">    init()</span><br><span class="line">    res = []</span><br><span class="line">    sum_1 = <span class="number">0</span></span><br><span class="line">    sum_2 = <span class="number">0</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 计算差距值</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> += (x[i] - x_best[i]) ** <span class="number">2</span></span><br><span class="line">        res.append(<span class="built_in">sum</span> ** <span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># 计算qt的分子（这里的alpha注意步长设置为1/sqrt(j)）</span></span><br><span class="line">        sum_1 += (<span class="number">1</span> / j ** <span class="number">0.5</span>) * <span class="built_in">sum</span></span><br><span class="line">        sum_2 += (<span class="number">1</span> / j ** <span class="number">0.5</span>)</span><br><span class="line">        q.append(sum_1 / sum_2)</span><br><span class="line">        <span class="comment"># Algorithm 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            upd_x(i, vec)</span><br><span class="line">            upd_v(i)</span><br><span class="line">            upd_sigma(i)</span><br><span class="line">        xxx = copy.deepcopy(xx)</span><br><span class="line">        xx = copy.deepcopy(x)</span><br><span class="line">        vv = copy.deepcopy(v)</span><br><span class="line">        ssigma = copy.deepcopy(sigma)</span><br><span class="line">        alpha = <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">0.6</span> + <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">1.2</span></span><br><span class="line">    <span class="keyword">return</span> res, q</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results</span>(<span class="params">iter_num, vecs, vecs_name</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, iter_num):</span><br><span class="line">        x.append(i)</span><br><span class="line">        y.append(i)</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(vecs)):</span><br><span class="line">        y = algorithm_1(iter_num, vecs[T])[<span class="number">0</span>]</span><br><span class="line">        plt.plot(x, y, label=vecs_name[T])</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;Iterations k&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;||xk - x*||&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        <span class="built_in">print</span>(vecs_name[T], end=<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span>%y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">vecs = [<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>]</span><br><span class="line">vecs_name = [<span class="string">&#x27;vec=0.0&#x27;</span>, <span class="string">&#x27;vec=0.2&#x27;</span>, <span class="string">&#x27;vec=0.4&#x27;</span>, <span class="string">&#x27;vec=0.6&#x27;</span>, <span class="string">&#x27;vec=0.8&#x27;</span>]</span><br><span class="line">plot_results(<span class="number">1000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">2000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">3000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">4000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">5000</span>, vecs, vecs_name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results_convergence_1</span>(<span class="params">iter_num</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    z = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, iter_num + <span class="number">1</span> + <span class="number">1</span>): <span class="comment"># 第一项ct是0，所以从第二项开始</span></span><br><span class="line">        x.append(i)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        z.append(math.log(i) / (i ** <span class="number">0.5</span>))</span><br><span class="line">    y = algorithm_1(iter_num, <span class="number">0.6</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># qt的图像</span></span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        经过调整参数为(x_min + x_max) / 2, 初始差距值已经比论文还低一些</span></span><br><span class="line"><span class="string">        但是qt始终无法收敛到0, 这是为什么呢?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        当迭代次数很大时, 分子中的差距值已经很小, 所以导致分子比分母小许多, 所以假设论文中的迭代次数是8w次, 我比它多10倍,</span></span><br><span class="line"><span class="string">        比它多那么多后, 即使我刚开始迭代时的分子很大, 分子也会被后面10倍迭代次数的分母追上来。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这是用来画qt / ct的图像</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num):</span><br><span class="line">        y[i] = y[i] / z[i]</span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x[<span class="number">1</span>:], y[<span class="number">1</span>:])</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;qt / ct&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_results_convergence_1(<span class="number">80000</span>)</span><br></pre></td></tr></table></figure><p>效果图如下：（最后一张图，第一行数字是qt的收敛值，第二行数字是qt/ct的收敛值）</p><p><img src="27.png" /></p><p><strong>Algorithm 2的数值仿真</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Algorithm 2的数值仿真</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">n = <span class="number">8</span></span><br><span class="line">x_best = [-<span class="number">1</span>, <span class="number">17.68591179305579</span>, <span class="number">17.68591178894396</span>, <span class="number">15.568177079669734</span>, <span class="number">15.568176869116588</span>,</span><br><span class="line">            <span class="number">12.54841009221712</span>, <span class="number">12.548433755340588</span>, <span class="number">16.50869895275612</span>, <span class="number">16.348072510972873</span>]</span><br><span class="line">x_min = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">x_max = [-<span class="number">1</span>, <span class="number">27.5</span>, <span class="number">27.5</span>, <span class="number">34.2</span>, <span class="number">34.2</span>, <span class="number">40.6</span>, <span class="number">40.6</span>, <span class="number">28.8</span>, <span class="number">35.7</span>]</span><br><span class="line">x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">p_0 = <span class="number">5.6</span></span><br><span class="line">a = <span class="number">0.004</span></span><br><span class="line">b = <span class="number">0.1</span></span><br><span class="line">k = [-<span class="number">1</span>, <span class="number">4.6</span>, <span class="number">4.6</span>, <span class="number">3.7</span>, <span class="number">3.7</span>, <span class="number">3.4</span>, <span class="number">3.4</span>, <span class="number">4.0</span>, <span class="number">3.9</span>]</span><br><span class="line">d = [-<span class="number">1</span>, <span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>]</span><br><span class="line">alpha = <span class="number">2</span></span><br><span class="line">A_1 = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">]</span><br><span class="line">A_2 = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">]</span><br><span class="line">A = copy.deepcopy(A_1)</span><br><span class="line">sigma = [-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    sigma.append(x[i])</span><br><span class="line">w = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">y = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">z = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">xx = copy.deepcopy(x)</span><br><span class="line">xxx = copy.deepcopy(x)</span><br><span class="line">ssigma = copy.deepcopy(sigma)</span><br><span class="line">yy = copy.deepcopy(y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    <span class="keyword">global</span> x, alpha, sigma, w, y, z, xx, xxx, ssigma, yy</span><br><span class="line">    x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">    alpha = <span class="number">2</span></span><br><span class="line">    sigma = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        sigma.append(x[i])</span><br><span class="line">    w = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    y = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">    z = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    xx = copy.deepcopy(x)</span><br><span class="line">    xxx = copy.deepcopy(x)</span><br><span class="line">    ssigma = copy.deepcopy(sigma)</span><br><span class="line">    yy = copy.deepcopy(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_w</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">sum</span> += A[i][j] * ssigma[j]</span><br><span class="line">    w[i] = <span class="built_in">sum</span>    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_y</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">sum</span> += A[i][j] * yy[j]</span><br><span class="line">    y[i] = <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_z</span>(<span class="params">i</span>):</span><br><span class="line">    z[i] = w[i] / y[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">i, x, sigma</span>):</span><br><span class="line">    <span class="keyword">return</span> a * (sigma + x) + b  - <span class="number">2</span> * p_0 * k[i] / x_max[i] * (<span class="number">1</span> - x / x_max[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_x</span>(<span class="params">i, vec</span>):</span><br><span class="line">    x[i] = xx[i] - alpha * G(i, xx[i], n * z[i]) + vec * (xx[i] - xxx[i])</span><br><span class="line">    <span class="keyword">if</span> x[i] &lt; x_min[i]: x[i] = x_min[i]</span><br><span class="line">    <span class="keyword">if</span> x[i] &gt; x_max[i]: x[i] = x_max[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_sigma</span>(<span class="params">i</span>):</span><br><span class="line">    sigma[i] = w[i] + x[i] - xx[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm_2</span>(<span class="params">iter_num, vec</span>):</span><br><span class="line">    <span class="keyword">global</span> A, A_1, A_2, w, ssigma, y, yy, z, x, xx, alpha, xxx, sigma</span><br><span class="line">    init()</span><br><span class="line">    res = []</span><br><span class="line">    sum_1 = <span class="number">0</span></span><br><span class="line">    sum_2 = <span class="number">0</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 计算差距</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> += (x[i] - x_best[i]) ** <span class="number">2</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> ** (<span class="number">0.5</span>)</span><br><span class="line">        res.append(<span class="built_in">sum</span>)</span><br><span class="line">        <span class="comment"># 计算qt的分子（这里的alpha注意步长设置为1/sqrt(j)）</span></span><br><span class="line">        sum_1 += (<span class="number">1</span> / j ** <span class="number">0.5</span>) * <span class="built_in">sum</span> * <span class="built_in">sum</span></span><br><span class="line">        sum_2 += (<span class="number">1</span> / j ** <span class="number">0.5</span>)</span><br><span class="line">        q.append(sum_1 / sum_2)</span><br><span class="line">        <span class="comment"># 选择矩阵</span></span><br><span class="line">        <span class="keyword">if</span> j % <span class="number">2</span>: A = copy.deepcopy(A_1)</span><br><span class="line">        <span class="keyword">else</span>: A = copy.deepcopy(A_2)</span><br><span class="line">        <span class="comment"># Algorithm 2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            upd_w(i)</span><br><span class="line">            upd_y(i)</span><br><span class="line">            upd_z(i)</span><br><span class="line">            upd_x(i, vec)</span><br><span class="line">            upd_sigma(i)</span><br><span class="line">        <span class="comment"># 更新状态</span></span><br><span class="line">        xxx = copy.deepcopy(xx)</span><br><span class="line">        xx = copy.deepcopy(x)</span><br><span class="line">        yy = copy.deepcopy(y)</span><br><span class="line">        ssigma = copy.deepcopy(sigma)</span><br><span class="line">        alpha = <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">0.6</span> + <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">1.2</span></span><br><span class="line">    <span class="keyword">return</span> res, q</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results</span>(<span class="params">iter_num, vecs, vecs_name</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, iter_num):</span><br><span class="line">        x.append(i)</span><br><span class="line">        y.append(i)</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(vecs)):</span><br><span class="line">        y = algorithm_2(iter_num, vecs[T])[<span class="number">0</span>]</span><br><span class="line">        plt.plot(x, y, label=vecs_name[T])</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;Iterations k&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;||xk - x*||&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        <span class="built_in">print</span>(vecs_name[T], end=<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span>%y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">vecs = [<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>]</span><br><span class="line">vecs_name = [<span class="string">&#x27;vec=0.0&#x27;</span>, <span class="string">&#x27;vec=0.2&#x27;</span>, <span class="string">&#x27;vec=0.4&#x27;</span>, <span class="string">&#x27;vec=0.6&#x27;</span>, <span class="string">&#x27;vec=0.8&#x27;</span>]</span><br><span class="line">plot_results(<span class="number">1000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">2000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">3000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">4000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">5000</span>, vecs, vecs_name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results_convergence_2</span>(<span class="params">iter_num</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    z = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, iter_num + <span class="number">1</span> + <span class="number">1</span>): <span class="comment"># 第一项ct是0，所以从第二项开始</span></span><br><span class="line">        x.append(i)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        z.append(math.log(i) / (i ** <span class="number">0.5</span>))</span><br><span class="line">    y = algorithm_2(iter_num, <span class="number">0.6</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># qt的图像</span></span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        经过调整参数为(x_min + x_max) / 2, 初始差距值已经比论文还低一些</span></span><br><span class="line"><span class="string">        但是qt始终无法收敛到0, 这是为什么呢?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        当迭代次数很大时, 分子中的差距值已经很小, 所以导致分子比分母小许多, 所以假设论文中的迭代次数是8w次, 我比它多10倍,</span></span><br><span class="line"><span class="string">        比它多那么多后, 即使我刚开始迭代时的分子很大, 分子也会被后面10倍迭代次数的分母追上来。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这是用来画qt / ct的图像</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num):</span><br><span class="line">        y[i] = y[i] / z[i]</span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x[<span class="number">1</span>:], y[<span class="number">1</span>:])</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;qt / ct&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_results_convergence_2(<span class="number">80000</span>)</span><br></pre></td></tr></table></figure><p>效果图如下：（最后一张图，第一行数字是qt的收敛值，第二行数字是qt/ct的收敛值）</p><p><img src="28.png" /></p><hr /><p>这篇blog发表于2023.10.16，现在是2023.12.4，看了2个月，目前算是告一段落了。</p><p>分布式领域读的第一篇论文，挺有趣的，算是跨过了一道入门槛。</p><p>接下来阅读论文的速度就要加快了。同时要去原理上去思考为什么这样做以及还可以怎样去优化。</p><p>假如您正在阅读这篇blog，如发现错误，恳请在评论区中指出。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;标题全称为：Distributed Nash Equilibrium Seeking for Aggregative
Games With Directed Communication Graphs&lt;/p&gt;
&lt;p&gt;中文翻译为：在使用有向图结构的聚合博弈中寻找离散式纳什均衡&lt;/p&gt;</summary>
    
    
    
    <category term="1. 论文" scheme="http://example.com/categories/1-%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>1. 深度强化学习导论</title>
    <link href="http://example.com/2023/10/15/1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/"/>
    <id>http://example.com/2023/10/15/1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/</id>
    <published>2023-10-15T03:04:35.000Z</published>
    <updated>2024-02-19T16:36:45.336Z</updated>
    
    <content type="html"><![CDATA[<p>以下面这张图和一个例子来说明RL的基本逻辑</p><span id="more"></span><p><img src="1.png" /></p><p>假设智能体是一个刚出生的机器人，我们的目的是想训练它学会站起来行走。</p><p>那么它的动作有很多，比如脚摆动10°/20°，手摆动5°/2°，balablabla。</p><p>环境就是一个简单的笔直的通道，从机器人出生点到终点，只不过这条直道上有许多很矮的障碍。</p><p>奖励就是机器人离终点越近，它每走一个单位距离所能获得的奖励值就增加。并且规定如果机器人长时间没有前进，将会扣除奖励值。并且规定如果机器人被绊倒了，将会大大扣除奖励值。</p><p>状态就是智能体通过与环境交互后每一时刻的状态。比如时刻1它到达了某个点是一个状态，时刻2它在某个点被绊倒了也是一个状态。</p><p>通过设计这么一个机制，机器人为了得到最大奖励值，他就会逐渐学会站起来，并且走到终点。这就是深度强化学习（RL）。</p><blockquote><p>强化学习与监督学习的区别</p><p>监督学习里，都是有标签的，网络可以通过正确的标签来修正自己的预测。但是强化学习里没有，它只能通过与环境不断交互来优化自己的策略。</p></blockquote><p>下面通过一个实验，通过实际写代码，来加深对RL的理解：</p><p><img src="2.png" /></p><p>首先对问题进行建模，动作就是每个拉杆选择拉 /不拉。奖励就是拉下每个拉杆所获得奖励（中了得1分，没中得0分）。玩家就是我们自己。目标是在T次拉杆后，使得获得的奖励最大。</p><p>作为一个没头脑的人，我们可能随便拉，这样子显然不会使最大奖励收敛。</p><p>作为一个有一点头脑的人，他会这样做：拿出10%的机会去“冒险”，即随机拉一个杆，剩下90%机会去拉已经拉过的杆中获益估值最高的杆。</p><p>作为一个更聪明的人，他随着拉杆次数的增加，拿去“冒险”的机会比例会逐渐降低。因为他知道，随着拉杆次数的增加，他对每根杆的获益估值越来越准确，所以此时更优的方法是去拉已知估值最高的，而不是拿去随机冒险浪费次数。</p><p>通过上面这3个人的想法，我们其实已经可以有点感觉到本质了。“冒险”其实就是去探测每个拉杆的获奖概率值，“冒险”次数越多，拟合出来的每个拉杆的获奖概率值就越准。“不冒险”就是在自己拟合出来的每个拉杆概率下，选最优的。</p><p>好的，思路知道了，代码开搞。文中附有注释：</p><p>代码中有一点要解释一下，就是代码中的“懊悔”和“获益函数”。作为上帝视角的我们，肯定要评测不同策略（普通人、聪明人、更聪明的人）的表现。所以我们需要衡量标准。所以用“累计懊悔”来充当这个衡量标准。每次懊悔的计算公式很简单，即是(拉杆中最大获奖概率- 当前拉杆的获奖概率)。</p><p>然后是“获益函数”，获益函数就是上面所说的我们拟合的每个拉杆的获奖概率值的平均值。他的计算公式为：<span class="math inline">\(E_k = E_k +\frac{r_t - E_k}{N_k}\)</span>，k是第k个拉杆，<spanclass="math inline">\(r_t\)</span>是在时刻t时拉下拉杆k所获得的收益，<spanclass="math inline">\(N_k\)</span>是第k根拉杆被拉下的次数。</p><p>上面这个公式其实是这样推导的： <span class="math display">\[E_k = \frac{\sum_{t=1}^{N_t}r_t}{N_k} = \frac{\sum_{t=1}^{N_k-1}r_t +r_{N_k}}{N_k} = \frac{(N_k-1)E_{k-1}+r_{N_k}}{N_k} = E_{k-1} +\frac{r_{N_k}-E_{k-1}}{N_k}\]</span> 这样就得到了<spanclass="math inline">\(E_k\)</span>的递推公式，需要注意的是，代码中给<spanclass="math inline">\(E_k, k∈[1,K]\)</span>赋了初值1。因为这样能保证至少先把每个拉杆都拉一遍。</p><p>如果赋初值为0的话，那么真正只有“冒险”的时候才有几率去拉新杆了。这样的话新杆很难有机会拉到。</p><p>所以我们希望先把全部杆至少拉一遍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="comment"># 老虎机类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, K</span>):</span><br><span class="line">        self.K = K <span class="comment"># 拉杆数量</span></span><br><span class="line">        self.probs = np.random.uniform(low=<span class="number">0</span>, high=<span class="number">1</span>, size=K) <span class="comment"># 生成K个0~1的值作为每根拉杆的获奖概率</span></span><br><span class="line">        self.best_id = np.argmax(self.probs) <span class="comment"># 返回self.probs最大元素的下标值</span></span><br><span class="line">        self.best_prob = self.probs[self.best_id] <span class="comment"># 最大获奖概率</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self, k</span>): <span class="comment"># 模拟拉杆</span></span><br><span class="line">        <span class="keyword">if</span> np.random.random() &lt; self.probs[k]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.random.seed(1) # 设定随机种子，不然每次的随机数值都不一样</span></span><br><span class="line">K = <span class="number">10</span></span><br><span class="line">a = A(K) <span class="comment"># 实例化老虎机</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;生成了一个拉杆为%d个的老虎机&#x27;</span> % K)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;%d号拉杆的获奖概率最大，是%.4f&#x27;</span> % (a.best_id, a.best_prob))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solver</span>: <span class="comment"># 主实现函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a</span>):</span><br><span class="line">        self.a = a <span class="comment"># self.a就是老虎机实例化的一个对象</span></span><br><span class="line">        self.counts = np.zeros(a.K) <span class="comment"># 用来计算每根拉杆的尝试次数</span></span><br><span class="line">        self.regret = <span class="number">0</span> <span class="comment"># 当前步的累计懊悔</span></span><br><span class="line">        self.actions = [] <span class="comment"># 记录每一步的动作</span></span><br><span class="line">        self.regrets = [] <span class="comment"># 记录每一步的累计懊悔</span></span><br><span class="line">        self.T = <span class="number">0</span> <span class="comment"># 记录run的次数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_one_step</span>(<span class="params">self</span>): <span class="comment"># 返回当前这一步应该拉哪一根拉杆，具体由不同策略实现</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, num_steps</span>):</span><br><span class="line">        self.T = num_steps</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_steps):</span><br><span class="line">            k = self.run_one_step()</span><br><span class="line">            <span class="comment"># 更新第k根杆的拉动次数</span></span><br><span class="line">            self.counts[k] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新动作</span></span><br><span class="line">            self.actions.append(k)</span><br><span class="line">            <span class="comment"># 更新懊悔</span></span><br><span class="line">            self.regret += self.a.best_prob - self.a.probs[k]</span><br><span class="line">            self.regrets.append(self.regret)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EpsilonGreedy</span>(<span class="title class_ inherited__">Solver</span>): <span class="comment"># epsilon贪心算法，继承Solver类（聪明人的策略）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, epsilon=<span class="number">0.01</span></span>): <span class="comment"># 构造函数</span></span><br><span class="line">        <span class="built_in">super</span>(EpsilonGreedy, self).__init__(a) <span class="comment"># 先对它的父类做一遍构造</span></span><br><span class="line">        <span class="comment"># 初始化探索率</span></span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">        <span class="comment"># 初始化所有拉杆的预期估值</span></span><br><span class="line">        self.estimates = np.array([<span class="number">1.0</span>] * a.K)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_one_step</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> np.random.random() &lt; self.epsilon:</span><br><span class="line">            k = np.random.randint(<span class="number">0</span>, a.K) <span class="comment"># 随机选择一根拉杆</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = np.argmax(self.estimates) <span class="comment"># 选择期望估值最高的拉杆</span></span><br><span class="line">        r = self.a.play(k) <span class="comment"># 拉动</span></span><br><span class="line">        <span class="comment"># 更新预期估值</span></span><br><span class="line">        self.estimates[k] += <span class="number">1</span> / (self.counts[k] + <span class="number">1</span>) * (r - self.estimates[k])</span><br><span class="line">        <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results</span>(<span class="params">solvers, solver_name</span>): <span class="comment"># 画图函数，solvers是策略列表，solver_name是策略的名字</span></span><br><span class="line">    <span class="keyword">for</span> idx, solver <span class="keyword">in</span> <span class="built_in">enumerate</span>(solvers):</span><br><span class="line">        x = <span class="built_in">range</span>(<span class="built_in">len</span>(solver.actions))</span><br><span class="line">        plt.plot(x, solver.regrets, label=solver_name[idx])</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;Time steps&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;Cumulative regrets&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;%d-bandit / Use method %s&#x27;</span> % (solver.a.K, solver_name[idx]))</span><br><span class="line">        plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建不同的epsilon值</span></span><br><span class="line">epsilons = [<span class="number">1e-4</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">0.25</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="comment"># 实例化EpsilonGreedy对象</span></span><br><span class="line">epsilon_greedy_solvers = [EpsilonGreedy(a, epsilon=e) <span class="keyword">for</span> e <span class="keyword">in</span> epsilons]</span><br><span class="line">epsilon_greedy_solvers_name = [<span class="string">&#x27;EpsilonGreedy(epsilon=&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(e) <span class="keyword">for</span> e <span class="keyword">in</span> epsilons]</span><br><span class="line"><span class="comment"># 开始run</span></span><br><span class="line"><span class="keyword">for</span> idx, solver <span class="keyword">in</span> <span class="built_in">enumerate</span>(epsilon_greedy_solvers):</span><br><span class="line">    solver.run(<span class="number">5000</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The cumulative regrets of %s is %.4lf&#x27;</span> % (epsilon_greedy_solvers_name[idx], solver.regret))</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plot_results(epsilon_greedy_solvers, epsilon_greedy_solvers_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecayingEpsilonGreedy</span>(<span class="title class_ inherited__">EpsilonGreedy</span>): <span class="comment"># 更聪明的人的策略</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, epsilon=<span class="number">0.1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(DecayingEpsilonGreedy, self).__init__(a, epsilon=epsilon)</span><br><span class="line">        self.count = -<span class="number">1</span></span><br><span class="line">        self.epsilon2 = self.epsilon</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_one_step</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 让epsilon随着拉杆次数增加线性递减到0</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        self.epsilon =(-<span class="number">1</span> * self.epsilon2 / self.T) * self.count + self.epsilon2</span><br><span class="line">        <span class="keyword">if</span> np.random.random() &lt; self.epsilon:</span><br><span class="line">            k = np.random.randint(<span class="number">0</span>, a.K) <span class="comment"># 随机选择一根拉杆</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = np.argmax(self.estimates) <span class="comment"># 选择期望估值最高的拉杆</span></span><br><span class="line">        r = self.a.play(k) <span class="comment"># 拉动</span></span><br><span class="line">        <span class="comment"># 更新预期估值</span></span><br><span class="line">        self.estimates[k] += <span class="number">1</span> / (self.counts[k] + <span class="number">1</span>) * (r - self.estimates[k])</span><br><span class="line">        <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">epsilons = [<span class="number">1e-4</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">0.25</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="comment"># 实例化DecayingEpsilonGreedy对象</span></span><br><span class="line">decaying_epsilon_greedy_solvers = [DecayingEpsilonGreedy(a, epsilon=e) <span class="keyword">for</span> e <span class="keyword">in</span> epsilons]</span><br><span class="line">decaying_epsilon_greedy_solvers_name = [<span class="string">&#x27;DecayingEpsilonGreedy(epsilon=&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(e) <span class="keyword">for</span> e <span class="keyword">in</span> epsilons]</span><br><span class="line"><span class="comment"># 开始run</span></span><br><span class="line"><span class="keyword">for</span> idx, solver <span class="keyword">in</span> <span class="built_in">enumerate</span>(decaying_epsilon_greedy_solvers):</span><br><span class="line">    solver.run(<span class="number">5000</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;The cumulative regrets of %s is %.4lf&#x27;</span> % (decaying_epsilon_greedy_solvers_name[idx], solver.regret))</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plot_results(decaying_epsilon_greedy_solvers, decaying_epsilon_greedy_solvers_name)</span><br></pre></td></tr></table></figure><p>让我们来看一下代码的运行结果：</p><p><img src="3.png" /></p><p><img src="4.png" /></p><p><img src="5.png" /></p><p><img src="6.png" /></p><p><img src="7.png" /></p><p>（俩图的标题的epsilon那错了懒得改了不影响）</p><p>对于图中这次生成的数据来说，“冒险”概率越低效果越好（曲线几乎不增长）。当然我自己在本地测试各种生成数据后总结发现冒险概率=0.01/0.1时表现最优。</p><p>然后使用DecayingEpsilonGreedy策略后表现更优了一些，对那些初始冒险率越大的优化效果越好。</p><p>通过这个案例，已经可以对RL有一个初步理解了。老虎机这个案例除了用Epsilon-Greedy，还可以用<strong>上置信界算法</strong>、<strong>汤普森采样算法</strong>方法去解决。这三种方法是解决绝大多数RL的基本思想。</p><p>但是老虎机这个案例是<strong>无状态强化学习</strong>，因为每一次与老虎机交互的结果和以往的动作无关。那有状态的强化学习怎么办呢？下一节将会对马尔可夫决策过程进行讲解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下面这张图和一个例子来说明RL的基本逻辑&lt;/p&gt;</summary>
    
    
    
    <category term="2. 技能栈" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/"/>
    
    <category term="多智能体强化学习" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>0. 从博弈论到多智能体强化学习</title>
    <link href="http://example.com/2023/10/15/0-%E4%BB%8E%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%88%B0%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/10/15/0-%E4%BB%8E%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%88%B0%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-10-14T17:53:28.000Z</published>
    <updated>2024-02-19T16:36:39.113Z</updated>
    
    <content type="html"><![CDATA[<p>什么是多智能体强化学习？比如快递工厂里的一个个快递机器，或者王者荣耀人机模式里的每个小兵，异或是现在自动驾驶中的每一辆车，都可以定义为智能体。让智能体进行强化学习是为了他们做出更好的决策。</p><span id="more"></span><h3 id="博弈论基本概念">博弈论基本概念</h3><ul><li>玩家集合：<ul><li><span class="math inline">\(N = \{1, 2, ..., n\}\)</span></li></ul></li><li>策略集合<ul><li><span class="math inline">\(A_1, A_2, A_3, ..., A_n\)</span></li></ul></li><li>收益函数<ul><li><span class="math inline">\(r_1=f_1(A_1, A_2, ...,A_n)\)</span></li><li><span class="math inline">\(r_2=f_2(A_1, A_2, ...,A_n)\)</span></li><li>... ...</li><li><span class="math inline">\(r_n=f_n(A_1, A_2, ...,A_n)\)</span></li></ul></li></ul><p>用“囚徒困境”这个例子来进一步理解：</p><p><img src="1.png" /></p><p>如图是两个玩家，玩家一是绿色的，玩家二是红色的。每个人选择坦白 /抵赖所获得的分数如图。</p><p>若玩家1选择坦白，则玩家2必然选择坦白，因为比起0分1，1分显然更好。</p><p>若玩家1选择抵赖，则玩家2也是选择坦白。</p><p>所以不管玩家1选什么，玩家2都会选择坦白，坦白是玩家2的<strong>占优策略</strong>。</p><p>同样的，不管玩家2选什么，玩家1也都会选择坦白，坦白也是玩家1的<strong>占优策略</strong>。</p><p>所以博弈结果必然就是俩人都选择坦白。</p><p>假如修改一下游戏规则呢？</p><p><img src="2.png" /></p><p>此时若玩家2的占优策略仍然是坦白。</p><p>但是若玩家2选择坦白，则玩家1会选择坦白。若玩家2选择坦白，则玩家1会选择抵赖。此时坦白就不是玩家1的占优策略了。</p><p>那么玩家1应该如何做决策呢？</p><p>因为俩玩家都是绝顶聪明，所以玩家1肯定知道玩家2做出了它的占优策略——坦白。所以玩家1既然知道玩家2选坦白，他也就只能选坦白。此时坦白是玩家1的<strong>最佳应对</strong>。</p><p>通过这个例子，我们感受了一下博弈论，还学到俩新名词，<strong>占优策略</strong>和<strong>最佳应对</strong>。</p><p>下面我们来看博弈论的解：</p><p>正如同上面的囚徒困境，一些博弈问题是存在解的：解 =即任何玩家都不能通过独自改变策略而获益时的策略组合，换句话说，解 =所有玩家处于最佳应对时的策略组合。</p><p>数学定义如下：</p><ul><li><p>给定一个策略组合 <spanclass="math inline">\(a=(a_1,a_2,...,a_n)\in A_1\timesA_2\times...\times A_n,\)</span></p></li><li><p>若 <span class="math display">\[r_1(a_1,a_2,...,a_n)\geq r_1(a_1^{\prime},a_2,...,a_n), \foralla_1^{\prime}\in A_1 \\r_2(a_1,a_2,...,a_n)\geq r_{1}(a_{1},a_{2}^{\prime},...,a_{n}),\foralla_{2}^{\prime}\in A_{2} \\... ... \\r_n(a_1,a_2,...,a_n)\geq r_n(a_1,a_2,...,a_n^{\prime}),\foralla_n^{\prime}\in A_n\]</span></p></li><li><p>那么策略组合<spanclass="math inline">\(a\)</span>是一个纳什均衡。</p></li><li><p>下面介绍另一种博弈情况（混合策略）下的解——混合纳什均衡。</p><ul><li>混合策略：每个玩家都有一个概率分布<span class="math inline">\((p_1,p_2, ..., p_n), p_i\)</span>为玩家选择动作i的概率。</li><li>混合纳什均衡：等于一个混合策略组合。s.t.任何玩家都不能通过独自改变自身混合策略来提高自己的期望收益。</li><li>定理：任意一个博弈，必然存在一个混合策略纳什均衡。</li></ul></li><li><p>例如下面这个例子，此博弈的混合策略纳什均衡就是每个人的混合策略都为<spanclass="math inline">\(\frac{1}{3}, \frac{1}{3},\frac{1}{3}\)</span>。</p></li></ul><p><img src="3.png" /></p><ul><li>当然博弈还有许多种均衡，上面只是介绍了最基础的纳什均衡和混合策略纳什均衡。博弈也有很多种博弈（只要加上不同的限定条件），比如所有人收益都是一样的就叫合作博弈，所有人收益之和是一个定值就叫竞争博弈。</li></ul><h3 id="从博弈论走到多智能体强化学习">从博弈论走到多智能体强化学习</h3><p>现实中，博弈玩家、玩家策略的数量都很大很大，而且玩家自身的收益函数可能并不知道，需要一点一点与环境交互才知道。所以用简单的博弈论模型去描述现实问题会比较困难。</p><p>所以下面引入一个新的博弈模型——马尔科夫博弈</p><ul><li><p>玩家集合</p><ul><li><span class="math inline">\(N = \{1, 2, ..., n\}\)</span></li></ul></li><li><p>策略集合</p><ul><li><span class="math inline">\(A_1, A_2, A_3, ..., A_n \\ A = A_1\times A_2 \times ... \times A_n\)</span></li></ul></li><li><p>状态集合</p><ul><li><span class="math inline">\(S = \{s_1, s_2, ..., s_n\}\)</span></li></ul></li><li><p>转移函数</p><ul><li>如果已知当前状态<span class="math inline">\(s_i\)</span>,和当前策略<span class="math inline">\(a_i\)</span>,有概率得到下一个状态<span class="math inline">\(s_i&#39;\)</span>。</li><li>概率函数就是描述上面这个过程的概率是多少。</li><li><span class="math inline">\(f(s_i, a_i, s_i&#39;)\)</span></li></ul></li><li><p>收益函数</p><ul><li><span class="math inline">\(r_i\)</span>由S和A确定</li></ul></li></ul><p>上面这个博弈模型就可以描述现实生活中绝大多数博弈模型。</p><p>那强化学习跟博弈论又有什么学习呢？</p><p>强化学习也分好几种，第一种叫状态价值学习，即有一个状态价值函数<spanclass="math inline">\(Q(s,a)\)</span>，表示在s状态下采取a动作所能获得的期望累积收益。通过神经网络拟合Q函数，不断学习来使得它收敛。这是状态价值学习。</p><p>那放到多智能体中，在当前状态S下，每个玩家都可以通过强化学习得出自己的<spanclass="math inline">\(Q_{max}(s_i, a_i), a_i∈A_i\)</span>，拿前面囚徒困境去类比的话，就是<spanclass="math inline">\(a_1\)</span>为坦白，<spanclass="math inline">\(a_2\)</span>为抵赖。也就是此时就可以建模出一个简单的博弈论模型。</p><p>当多智能体们通过博弈后，又得到了下一个状态S'。于是再用强化学习算出在状态S'下，每个玩家的<spanclass="math inline">\(Q_{max}\)</span>，循环往复以此类推。最后就可以收敛于最优解。</p><h3 id="总结">总结</h3><p>上面所讲的知识的目的皆在引入博弈论和多智能体强化学习两个概念。所以许多地方为了方便理解没有很严谨，有许多漏洞之处。但作为一个刚入门的小白（比如我），已经可以给我一个大概的理解和感受了，这就是此篇blog的目的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是多智能体强化学习？比如快递工厂里的一个个快递机器，或者王者荣耀人机模式里的每个小兵，异或是现在自动驾驶中的每一辆车，都可以定义为智能体。让智能体进行强化学习是为了他们做出更好的决策。&lt;/p&gt;</summary>
    
    
    
    <category term="2. 技能栈" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/"/>
    
    <category term="多智能体强化学习" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
</feed>
