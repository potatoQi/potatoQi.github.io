<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Error_666</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-10-31T16:20:52.428Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Error_666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数学知识补充</title>
    <link href="http://example.com/2023/10/31/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
    <id>http://example.com/2023/10/31/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</id>
    <published>2023-10-31T15:51:42.000Z</published>
    <updated>2023-10-31T16:20:52.428Z</updated>
    
    <content type="html"><![CDATA[<p>论文中涉及到许多基础数学知识，但是在论文里单独展开篇幅太长了。所以统一在这篇blog里记录。</p><span id="more"></span><h3 id="lipschitz连续">Lipschitz连续</h3><p>先看连续的定义：函数<spanclass="math inline">\(f(x)\)</span>在点<span class="math inline">\(x =x_0\)</span>连续<span class="math inline">\(\iff\)</span> <spanclass="math inline">\(\lim_{x \rightarrow x_0}f(x) = f(x_0) \iff \forall\varepsilon&gt;0, \exists\delta = \delta(\varepsilon)&gt;0\)</span>,使得当<span class="math inline">\(|x - x_0| &lt;\delta\)</span>时，有<span class="math inline">\(|f(x) - f(x_0)| &lt;\varepsilon\)</span></p><p>在此定义中，<span class="math inline">\(\delta\)</span>不仅与<spanclass="math inline">\(\varepsilon\)</span>有关，而且与<spanclass="math inline">\(x_0\)</span>有关，应记为<spanclass="math inline">\(\delta = \delta(x_0,\varepsilon)\)</span>。也就是说，对于同一个<spanclass="math inline">\(\varepsilon\)</span>，在不同的<spanclass="math inline">\(x_0\)</span>处，使<spanclass="math inline">\(|f(x) - f(x_0)| &lt;\varepsilon\)</span>的x取值范围可以差得很多。</p><p>所以我们自然会问，对于<span class="math inline">\(\forall \varepsilon&gt; 0\)</span>，是否存在只与<spanclass="math inline">\(\varepsilon\)</span>有关的<spanclass="math inline">\(\delta\)</span>，使得对于区间中任意两点<spanclass="math inline">\(x_1, x_2\)</span>，只要满足<spanclass="math inline">\(|x_1 - x_2| &lt; \delta\)</span>，就成立<spanclass="math inline">\(|f(x_1) - f(x_2)| &lt; \varepsilon\)</span>？</p><p>这就引出了一致连续的定义：设函数<spanclass="math inline">\(f(x)\)</span>在区间X上有定义，若<spanclass="math inline">\(\forall \varepsilon &gt; 0, \exists\delta =\delta(\varepsilon) &gt; 0\)</span>，使得对于区间X中的任意两点<spanclass="math inline">\(x_1, x_2\)</span>，只要满足<spanclass="math inline">\(|x_1 - x_2| &lt; \delta\)</span>，就成立<spanclass="math inline">\(|f(x_1) - f(x_2)| &lt;\varepsilon\)</span>，则称函数<spanclass="math inline">\(f(x)\)</span>在区间X上一致连续。</p><p>可以发现一致连续是比连续更强的一个条件。接下来要讲的Lipschitz连续，是比一致连续还要强的一个条件。</p><p>先给出Lipschitz连续的定义：设函数<spanclass="math inline">\(f(x)\)</span>在区间X上有定义，若存在<spanclass="math inline">\(L &gt; 0\)</span>，使得对于区间X中的任意两点<spanclass="math inline">\(x_1, x_2\)</span>，都满足<spanclass="math inline">\(|f(x_1) - f(x_2)| \le L|x_1 -x_2|\)</span>，则称<spanclass="math inline">\(f(x)\)</span>在区间X上是Lipschitz连续。</p><blockquote><p>下面证明Lipschitz连续是比一致连续更强的一个条件：</p><p>证明：<span class="math inline">\(\forall \varepsilon &gt;0\)</span>，取<span class="math inline">\(\delta = \frac{\varepsilon}{L}&gt; 0\)</span>，则<span class="math inline">\(\forall x_1, x_2 \inX\)</span>，当<span class="math inline">\(|x_1 - x_2| &lt;\delta\)</span>时，<span class="math inline">\(|f(x1) - f(x_2)| \leL|x_1 - x_2| &lt; L\delta = L \cdot \frac{\varepsilon}{L} =\varepsilon\)</span>，得证。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;论文中涉及到许多基础数学知识，但是在论文里单独展开篇幅太长了。所以统一在这篇blog里记录。&lt;/p&gt;</summary>
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Linear convergence in optimization over directed graphs with row-stochastic matrices</title>
    <link href="http://example.com/2023/10/31/Linear-convergence-in-optimization-over-directed-graphs-with-row-stochastic-matrices/"/>
    <id>http://example.com/2023/10/31/Linear-convergence-in-optimization-over-directed-graphs-with-row-stochastic-matrices/</id>
    <published>2023-10-31T15:26:13.000Z</published>
    <updated>2023-11-02T16:43:14.726Z</updated>
    
    <content type="html"><![CDATA[<p>标题：Linear convergence in optimization over directed graphs withrow-stochastic matrices</p><p>中文翻译：行随机矩阵有向图优化的线性收敛性</p><span id="more"></span><h3 id="abstract">Abstract</h3><p>本文研究的是一个多智能体网络（有向图）上的分布式优化问题，其中目标函数是每个玩家成本函数的总和。</p><p>现存的在有向图上的分布式优化算法都至少需要每个玩家知道其邻居的出度。但本文不需要。而且最佳收敛速度为<spanclass="math inline">\(O(\mu^{k}), 0 &lt; \mu &lt; 1, k\)</span> is thenumber of 迭代。</p><p>前提是目标函数为强凸函数，且具有Lipschitz连续梯度。</p><h3 id="introduction">1. Introduction</h3><p>近年来出现了许多分布式优化方法，最初的方法是基于梯度下降，这种方法直观且计算简单，但由于算法使用的步长逐渐减小，通常速度较慢。证明了任意凸函数的收敛速度为<spanclass="math inline">\(O(\frac{\lnk}{\sqrt{k}})\)</span>，强凸函数的收敛速度为<spanclass="math inline">\(O(\frac{\ln k}k)\)</span>。</p><p>后来，发展出基于拉格朗日对偶变量的方法，例如分布式对偶分解[15]、分布式实现交替方向乘法器[16- 18]。对于强凸函数收敛速度将达到<spanclass="math inline">\(O(\mu^k)\)</span>，缺点是计算代价比较高。</p><p>再后来，为了兼顾收敛速度和计算简易性，一些分布式算法在保持步长不变的前提下，不使用对偶变量。例如分布式Nesterov-based方法，对于任意满足有界和Lipschitz梯度的凸函数，收敛速度达到<spanclass="math inline">\(O(\frac{\ln k}{k^2})\)</span>。还例如[20],[21]中的方法，用固定步长和历史梯度信息实现了对一般凸函数<spanclass="math inline">\(O(\frac{1}{k})\)</span>，强凸函数<spanclass="math inline">\(O(\mu^k)\)</span>的收敛速度。</p><p>但是上面这些方法都是在基于无向图或者权重平衡图上考虑的。但是实际中更多的是权重不平衡有向图的情况，所以这篇论文就是来解决这个问题的。</p><p>怎么解决呢？一般分布式优化中通常需要双随机矩阵，可是有向图中得不到双随机矩阵，只能得到行随机矩阵或者列随机矩阵。本文提出的算法参考了[36]。</p><p>Notation：</p><ul><li><p>小写字母是标量，小写粗体是向量，大写字母是矩阵</p></li><li><p>The spectral radius of a matrix A is <spanclass="math inline">\(\rho(A)\)</span>。谱半径就是A的特征值绝对值的最大值</p></li><li><p><span class="math inline">\(\lambda_{i}(A)\)</span> denotes the<span class="math inline">\(i-th\)</span> largest eigenvalue ofA.</p></li><li><p>对于一个最简的行随机矩阵A，将其特征值1的右特征向量记为<spanclass="math inline">\(1_n\)</span>，左特征向量记为<spanclass="math inline">\(\pi ^T\)</span>，使得<spanclass="math inline">\(\pi ^T \cdot 1_n = 1\)</span>。</p></li><li><p><spanclass="math inline">\(\|\cdot\|\)</span>被定义为一个特殊的矩阵范数，在Lemma2中会讲到</p></li><li><p><spanclass="math inline">\(\|\cdot\|_2\)</span>就是普通的向量或者矩阵的二范数</p></li><li><p>有性质： <span class="math display">\[\begin{aligned}c&#39;\|\cdot\|\leq\|\cdot\|_2\leq c\|\cdot\|\\d&#39;\|\cdot\|_2\leq\|\cdot\|\leq d\|\cdot\|_2\end{aligned} \\c&#39;, c, d&#39;, d\,are\,some\,positive\,constants\]</span></p></li><li><p>更多关于向量和矩阵范数的知识，参考[37]</p></li></ul><h3 id="problem-assumptions-algorithm">2. Problem, Assumptions,Algorithm</h3><p>Problem：</p><p>把问题描述为一个强连通有n个玩家的有向图：<spanclass="math inline">\(\mathcal{G}=(\mathcal{V},\mathcal{E})\)</span>。注意若<spanclass="math inline">\((i, j) \in \mathcal{E}\)</span>，则<spanclass="math inline">\(j\)</span>可以发信息给<spanclass="math inline">\(i\)</span>。定义<spanclass="math inline">\(\mathcal{N}_i^{in}\)</span>为<spanclass="math inline">\(i\)</span>自己加上<spanclass="math inline">\(i\)</span>的邻居，这个集合也就是能发信息给<spanclass="math inline">\(i\)</span>的玩家集合。</p><p>我们要的目标函数是这个：<spanclass="math inline">\(min\,f(\mathbf{x})=\sum_{i=1}^nf_i(\mathbf{x})\)</span></p><p>需要注意<spanclass="math inline">\(f_i\)</span>是凸且可微的，并且只有玩家<spanclass="math inline">\(i\)</span>知道。</p><p>Assumption 1：有向图是强连通的。</p><p>Assumption 2：每个<spanclass="math inline">\(f_i\)</span>是可微且强凸的。且对x导数（梯度）具有Lipschitz连续。具体来说，<spanclass="math inline">\(f_i\)</span>满足如下两个定义：</p><blockquote><p><spanclass="math inline">\(f_i(\mathbf{x}_1)-f_i(\mathbf{x}_2)\leq\nablaf_i(\mathbf{x}_1)^\top(\mathbf{x}_1-\mathbf{x}_2)-\frac{s}{2}\|\mathbf{x}_1-\mathbf{x}_2\|_2^2\)</span>，s是正整数</p><p><span class="math inline">\(\|\nabla f_i(\mathbf{x}_1)-\nablaf_i(\mathbf{x}_2)\|_2\leql\|\mathbf{x}_1-\mathbf{x}_2\|_2\)</span>，l是正整数</p></blockquote><p>因为<span class="math inline">\(f\)</span>是所有<spanclass="math inline">\(f_i\)</span>之和，所以<spanclass="math inline">\(f\)</span>也是满足强凸和Lipschitz梯度连续的，也就是满足上面那俩式子。显然常数分别为<spanclass="math inline">\(ns, nl\)</span>。</p><p>Algorithm： <span class="math display">\[\begin{gathered}\mathbf{x}_{k+1,i}=\sum_{j=1}^{n}a_{ij}\mathbf{x}_{k,j}-\alpha\mathbf{z}_{k,i},\left.\left(\begin{matrix}{1}{\mathrm{a}}\\\end{matrix}\right.\right) \\\mathbf{y}_{k+1,i} =\sum_{j=1}^{n}a_{ij}\mathbf{y}_{k,j}, (1\mathrm{b})\\\mathbf{z}_{k+1,i} =\sum_{j=1}^{n}a_{ij}\mathbf{z}_{k,j}+{\frac{\nablaf_{i}(\mathbf{x}_{k+1,i})}{[\mathbf{y}_{k+1,i}]_{i}}}-{\frac{\nablaf_{i}(\mathbf{x}_{k,i})}{[\mathbf{y}_{k,i}]_{i}}}\left.\left(\begin{matrix}{1}{\mathrm{c}}\\\end{matrix}\right.\right)\end{gathered}\]</span> <span class="math inline">\(a_{ij}\)</span> 满足下面这个条件：<span class="math display">\[a_{ij}=\begin{cases}&amp;&gt;0,&amp;j\in\mathcal{N}_i^\mathrm{in},\\&amp;0,&amp;\mathrm{otw.},\end{cases}\quad\sum_{j=1}^na_{ij}=1,\foralli\]</span></p><p><span class="math inline">\(\alpha &gt; 0\)</span> is a constantstep-size</p><p><span class="math inline">\(\nablaf_{i}(\mathbf{x}_{k,i})\in\mathbb{R}^{p}\)</span> is the gradient of<span class="math inline">\(f_i\)</span> at <spanclass="math inline">\(x_{k, i}\)</span></p><p><span class="math inline">\(x_0\)</span> is arbitrary, <spanclass="math inline">\(\mathbf{y}_{0,i}=\mathbf{e}_i, \quad\mathbf{z}_{0,i}=\nabla f_i(\mathbf{x}_{0,i})\)</span></p><p>上面的算法中</p><p>根据[38]中的Perron-Frobenius定理，(1b)将收敛到矩阵A的左特征向量<spanclass="math inline">\(\pi^T\)</span>。<strong><u>（有空拿计算机验证一下）</u></strong></p><p>(1c)使用(1b)来缩放梯度，从而消除了行随机矩阵引起的不平衡。</p><p>而且，为了简化证明，其实可以把<span class="math inline">\(x_{k, i},z_{k, i}, \nablaf_i(x_{k,i})\)</span>,$看成一维的。只要一维的得证了，后续套一个Kroneckerproduction notation就可以把p维的证出来了。</p><p>为了简化表达，我们定义下面式子： <span class="math display">\[\begin{aligned}\mathbf{x}_{k}&amp; =[x_{k,1},\cdots,x_{k,n}]^{\top},  \\\mathbf{Z}_{k}&amp; =[z_{k,1},\cdots,z_{k,n}]^{\top},  \\\nabla\mathbf{f}_{k}&amp; =\left[\nabla f_1(x_{k,1}),\cdots,\nablaf_n(x_{k,n})\right]^\top,  \\Y_{k}&amp; =[\mathbf{y}_{k,1},\cdots,\mathbf{y}_{k,n}]^\top,  \\\widetilde{Y}_{k}&amp; =\operatorname{diag}(Y_k).\end{aligned}\]</span> 则algorithm 1可以写成以下形式： <span class="math display">\[\begin{gathered}\mathbf{x}_{k+1}= A\mathbf{x}_{k}-\alpha\mathbf{z}_{k}, (2\mathrm{a}) \\Y_{k+1}= AY_{k}, (2\mathrm{b}) \\\mathbf{z}_{k+1}= A\mathbf{z}_{k}+\widetildeY_{k+1}^{-1}\nabla\mathbf{f}_{k+1}-\widetildeY_{k}^{-1}\nabla\mathbf{f}_{k}, \text{(2c)}\end{gathered}\]</span></p><h3 id="main-results">3. Main results</h3><p>定义：<spanclass="math inline">\(Y_\infty=\lim_{k\to\infty}Y_k\)</span></p><p>因为<span class="math inline">\(Y_k = AY_{k-1} = A^2Y_{k-2} =...\)</span></p><p>所以<spanclass="math inline">\(\operatorname*{lim}_{k\to\infty}Y_{k}=\operatorname*{lim}_{k\to\infty}A^{k}\)</span>（<spanclass="math inline">\(Y_1=I_n\)</span>）</p><p>又由[38]中的Perron-Frobenius定理，<spanclass="math inline">\(Y_k\)</span>将收敛到<spanclass="math inline">\(1_n\pi ^ T\)</span></p><p>即<spanclass="math inline">\(Y_\infty=\lim\limits_{k\to\infty}Y_k=\operatorname*{lim}\limits_{k\to\infty}A^k=1_n\pi^T\)</span>继续定义： <span class="math display">\[\begin{aligned}\mathbf{x}^{*}&amp; =x^{*}\mathbf{1}_{n},  \\\widehat{\mathbf{x}}_{k}&amp; =Y_{\infty}\mathbf{x}_{k},  \\\widehat{z}_{k}&amp; =Y_{\infty}\mathbf{z}_{k},  \\\nabla\mathbf{f}^{*}&amp; =[\nabla f_{1}(x^{*}),\cdots,\nablaf_{n}(x^{*})]^{\top},  \\\nabla\widehat{\mathbf{f}}_{k}&amp;=\frac{1}{n}\mathbf{1}_{n}\mathbf{1}_{n}^{\top}\left[\nablaf_{1}(\widehat{x}_{k}),...,\nabla f_{n}(\widehat{x}_{k})\right]^{\top},\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}&amp;\tau=\left\|A-I_{n}\right\|_{2}, \\&amp;\epsilon=\left\|I_{n}-Y_{\infty}\right\|_{2}, \\&amp;\eta=\operatorname*{max}\left(\left|1-\alphanl\right|,\left|1-\alpha ns\right|\right)\end{aligned}\]</span></p><p><span class="math inline">\(l, s\)</span>出自这： $$f_i(_1)-f_i(_2)f_i(_1)^(_1-_2)-|_1-_2|_2^2$，s是正整数 \</p>|f_i(_1)-f_i(_2)|_2l|_1-_2|_2$，l是正整数 <span class="math display">\[继续定义：\]</span><span class="math display">\[\begin{aligned}&amp;y=\operatorname*{sup}_{k}\left\|Y_{k}\right\|_{2}, \\&amp;\widetilde{y}=\operatorname*{sup}_{k}\left\|\widetilde{Y}_{k}^{-1}\right\|_{2}.\end{aligned}\]</span><p>$$</p><h4 id="lemma-1">Lemma 1</h4><p><span class="math inline">\(\left\|Y_k-Y_\infty\right\|_2\leqT\gamma_1^k,\quad\forall k.\quad(3) \\ 0 &lt; \gamma &lt; 1 \, and \, 0&lt; T &lt; \infty\)</span></p><p>推导参考[22]</p><h4 id="lemma-2">Lemma 2</h4><p>For any <span class="math inline">\(a \in \mathbb{R^n}\)</span>,define <spanclass="math inline">\(\widehat{\mathbf{a}}=Y_{\infty}\mathbf{a}\)</span>.Then there exists <span class="math inline">\(0&lt;\sigma&lt;1\)</span>such that <span class="math display">\[\left\|A\mathbf{a}-\widehat{\mathbf{a}}\right\|\leq\sigma\left\|\mathbf{a}-\widehat{\mathbf{a}}\right\|\qquad (4)\]</span> Proof:</p><p>由[38]中的Perron-Frobenius定理，得<spanclass="math inline">\(\rho(A)=1\)</span> and every eigenvalue of A otherthan 1 is strictly less than <spanclass="math inline">\(\rho(A)\)</span>。</p><p>We now have： <span class="math display">\[\begin{array}{rcl}AY_\infty&amp;=&amp;A\mathbf{1}_n\pi^\top&amp;=&amp;\mathbf{1}_n\pi^\top&amp;=&amp;Y_\infty,\\Y_\inftyY_\infty&amp;=&amp;\mathbf{1}_n\pi^\top\mathbf{1}_n\pi^\top&amp;=&amp;\mathbf{1}_n\pi^\top&amp;=&amp;Y_\infty,\end{array}\]</span> and thus <spanclass="math inline">\(AY_{\infty}-Y_{\infty}Y_{\infty}\)</span> is azero matrix. Therefore, <span class="math display">\[A\mathbf{a}-Y_\infty\mathbf{a}\quad=\quad(A-Y_\infty)(\mathbf{a}-Y_\infty\mathbf{a}).\]</span></p><blockquote><p>右边打开：Aa - AYa - Ya + Y^2a = Aa - AYa - Ya + Ya = Aa - AYa = Aa -Ya = 左边</p></blockquote><p>因为<spanclass="math inline">\(\left\|A-Y_{\infty}\right\|&lt;1\)</span><strong><u>（不会证）</u></strong></p><p>所以 <span class="math display">\[\left\|A\mathbf{a}-Y_\infty\mathbf{a}\right\|\quad\leq\quad\left\|A-Y_\infty\right\|\left\|\mathbf{a}-Y_\infty\mathbf{a}\right\|,\quad\left(5\right)\]</span> 所以</p><p><spanclass="math inline">\(\left\|A\mathbf{a}-\widehat{\mathbf{a}}\right\|\leq\sigma\left\|\mathbf{a}-\widehat{\mathbf{a}}\right\|\)</span>，<spanclass="math inline">\(\sigma=\left\|A-Y_{\infty}\right\|\)</span>，且<spanclass="math inline">\(0 &lt; \sigma &lt; 1\)</span></p><h4 id="lemma-3">Lemma 3</h4><p>There exists some constant <spanclass="math inline">\(\widetilde{T}\)</span> such that the followinginequalities hold for all k &gt;= 1 <span class="math display">\[(a)\left\|\widetilde{Y}_k^{-1}-\widetilde{Y}_\infty^{-1}\right\|_2\leq\widetilde{y}^2\widetilde{T}\gamma_1^k\\(b)\left\|\widetilde{Y}_{k+1}^{-1}-\widetilde{Y}_{k}^{-1}\right\|_{2}\leq2\widetilde{y}^{2}\widetilde{T}\gamma_{1}^{k}\]</span> Proof:</p><p>先推(a) <span class="math display">\[\begin{aligned}\left\|\tilde{Y}_{k}^{-1}-\tilde{Y}_{\infty}^{-1}\right\|_{2}&amp;\leq\left\|\tilde{Y}_{k}^{-1}\right\|_{2}\left\|\tilde{Y}_{k}-\tilde{Y}_{\infty}\right\|_{2}\left\|\tilde{Y}_{\infty}^{-1}\right\|_{2},  \\&amp;\leq\tilde{y}^{2}\widetilde{T}\gamma_{1}^{k},\end{aligned}\]</span> <strong><u>第一个不等号咋推的</u></strong></p><p>第二个不等号用了<spanclass="math inline">\(\widetilde{y}\)</span>的定义和Lemma 1</p><p>再推(b)</p><p><strong><u>不会，感觉我要去学点矩阵论的东西了</u></strong></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;标题：Linear convergence in optimization over directed graphs with
row-stochastic matrices&lt;/p&gt;
&lt;p&gt;中文翻译：行随机矩阵有向图优化的线性收敛性&lt;/p&gt;</summary>
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>数字逻辑实验笔记</title>
    <link href="http://example.com/2023/10/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-23T04:40:07.000Z</published>
    <updated>2023-10-27T04:45:32.028Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分主要是verilog语法，比较简单。</p><span id="more"></span><h3 id="两种声明方式">两种声明方式</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AND4(a, b, out);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">assign</span> out = a &amp; b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AND4(<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a, <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] b, <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] out);</span><br><span class="line">    <span class="keyword">assign</span> out = a &amp; b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="数据类型">数据类型</h3><p>掌握wire和reg即可。</p><p>wire就是对应着电路里的线。reg就是对应着电路里的寄存器。</p><p>常量用parameter定义，例如parameter width = 3;但是常量也可以重定义，例如下面这个例子：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder(a, b, sum);</span><br><span class="line">    <span class="keyword">parameter</span> time_delay = <span class="number">5</span>, time_count = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] a1, b1;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] sum1;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] a2, b2;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] sum2;</span><br><span class="line">    adder <span class="variable">#(4, 8) AD1(a1, b1, sum1)</span>;<span class="comment">//time_delay=4, time_count=8</span></span><br><span class="line">    adder <span class="variable">#(12) AD2(a2, b2, sum2)</span>;<span class="comment">//time_delay=12, time_count=10</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="数据的表达方式">数据的表达方式</h3><p><位宽>'<进制><数字>：4'b0101 / 4‘h5</p><p><进制><数字>：位宽一般默认是32位。h5</p><p><数字>：位宽默认32位，进制默认为十进制。5</p><h3 id="拼接运算符">拼接运算符</h3><p>{a, b[3:0], w, 3'b101} 等价于 {a, b[3], b[2], b[1], b[0], w, 1'b1,1'b0, 1'b1}</p><p>{4{w}} 等价于 {w, w, w, w}</p><p>{b, 3{a, b}} 等价于 {b, a, b, a, b, a, b}</p><h3 id="赋值语句">赋值语句</h3><p>assign只能对wire类型赋值。assign的作用通常就是把reg的结果用一个wire接收。</p><p>initial里对reg变量赋初值。</p><p>always里的=(阻塞赋值)/&lt;=(非阻塞赋值)对always块里的reg类型赋值。</p><p>always语句</p><p>always @ (clk) //只要clk发生变化就触发 always @ (posedge clk)//clk上升沿触发（从0-&gt;1触发）</p><p>always @ (negedge clk) //clk下降沿触发（从1-&gt;0触发）</p><p>always @ (*) //always块内任何输入信号变化了就触发</p><h3 id="条件语句">条件语句</h3><p>条件语句只能用于always或initial内部。只需要掌握if-else和case语句即可。</p><p>if-else语句：跟C++一样，只不过多条语句时将{}换成begin-end</p><p>case语句：有case/casex/casez可以选择。casex就是分支表达式中可以有?作为通配符。</p><h3 id="循环语句">循环语句</h3><p>一般循环语句都是用来写仿真文件的。因为循环次数不确定的循环语句是不能被综合的！</p><p>所以一般用循环语句来写源代码都是用for循环</p><hr /><p>接下来的内容就是实验了，实验代码自己手撸的。而且只学了基本语法就开干了，所以代码自我感觉很丑不优美。</p><h3 id="实验一">实验一</h3><p><img src="1.png" /></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> demo02_verilog #(<span class="keyword">parameter</span> W1 = <span class="number">1</span>, W2 = <span class="number">3</span>) (</span><br><span class="line">    <span class="keyword">input</span> [(W1 - <span class="number">1</span>) : <span class="number">0</span>] sw15, sw14,</span><br><span class="line">    <span class="keyword">input</span> [(W2 - <span class="number">1</span>) : <span class="number">0</span>] in1, in2, in3, in4,</span><br><span class="line">    <span class="keyword">output</span> [(W2 - <span class="number">1</span>) : <span class="number">0</span>] ld</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//错误代码：assign ld = (~sw15 &amp; ~sw14 &amp; in1) | (~sw15 &amp; sw14 &amp; in2) | (sw15 &amp; ~sw14 &amp; in3) | (sw15 &amp; sw14 &amp; in4);</span></span><br><span class="line">    <span class="keyword">assign</span> ld = sw15 ? (sw14 ? in4 : in3) : (sw14 ? in2 : in1);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="实验二">实验二</h3><p><img src="2.png" /></p><ul><li>top.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top(a, b, t, e, l1, l2, l3, clk, reset, an, led);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">output</span> t, e;</span><br><span class="line">    <span class="keyword">output</span> l1, l2, l3;  <span class="comment">//控制负数亮灯</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">input</span> clk, reset;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] an;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>] led;</span><br><span class="line">    </span><br><span class="line">    add <span class="variable">#(4) f1(.a(a), .b(b), .out(out), .t(t), .e(e))</span>;</span><br><span class="line">    show(<span class="variable">.clk</span>(clk), <span class="variable">.reset</span>(reset),</span><br><span class="line">         <span class="variable">.hex0</span>(out), <span class="variable">.hex2</span>(b), <span class="variable">.hex3</span>(a),</span><br><span class="line">         <span class="variable">.an</span>(an), <span class="variable">.sseg</span>(led), <span class="variable">.l1</span>(l1), <span class="variable">.l2</span>(l2), <span class="variable">.l3</span>(l3));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>add.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进位不影响补码运算的正确性，溢出影响正确性，溢出的本质就是超过了位宽能表达的范围</span></span><br><span class="line"><span class="keyword">module</span> add (a, b, out, t, e);</span><br><span class="line">    <span class="keyword">parameter</span> W = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">input</span> [W-<span class="number">1</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">output</span> [W-<span class="number">1</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">output</span> t, e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [W-<span class="number">1</span>:<span class="number">0</span>] a_, b_; <span class="comment">//补码</span></span><br><span class="line">    <span class="keyword">reg</span> [W-<span class="number">1</span>:<span class="number">0</span>] out_;   <span class="comment">//运算后的补码</span></span><br><span class="line">    <span class="keyword">reg</span> [W-<span class="number">1</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] i;</span><br><span class="line">    <span class="keyword">reg</span> t = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> @ (*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//都转为补码</span></span><br><span class="line">        a_ = a;</span><br><span class="line">        b_ = b;</span><br><span class="line">        <span class="keyword">if</span> (a_[W-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W - <span class="number">1</span>; i = i + <span class="number">1</span>) a_[i] = ~a[i];</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                    tt = a_[i];</span><br><span class="line">                    a_[i] = a_[i] ^ <span class="number">1</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">1</span>) | (t &amp; (tt | <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    tt = a_[i];</span><br><span class="line">                    a_[i] = a_[i] ^ <span class="number">0</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">0</span>) | (t &amp; (tt | <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (b_[W-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W - <span class="number">1</span>; i = i + <span class="number">1</span>) b_[i] = ~b[i];</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                    tt = b_[i];</span><br><span class="line">                    b_[i] = b_[i] ^ <span class="number">1</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">1</span>) | (t &amp; (tt | <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    tt = b_[i];</span><br><span class="line">                    b_[i] = b_[i] ^ <span class="number">0</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">0</span>) | (t &amp; (tt | <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">//俩补码运算</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            out_[i] = a_[i] ^ b_[i] ^ t;</span><br><span class="line">            t = (a_[i] &amp; b_[i]) | (t &amp; (a_[i] | b_[i]));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">//检测是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> (a_[W-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; b_[W-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; out_[W-<span class="number">1</span>] == <span class="number">1</span>) e = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a_[W-<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; b_[W-<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; out_[W-<span class="number">1</span>] == <span class="number">0</span>) e = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> e = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将补码转为原码</span></span><br><span class="line">        <span class="keyword">if</span> (out_[W-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//变反码</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                a_[i] = out_[i];</span><br><span class="line">                b_[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            tt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                out_[i] = a_[i] ^ b_[i] ^ tt;</span><br><span class="line">                tt = (a_[i] &amp; b_[i]) | (tt &amp; (a_[i] | b_[i]));</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">//变原码</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W - <span class="number">1</span>; i = i + <span class="number">1</span>) out_[i] = ~out_[i];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) out[i] = out_[i];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>show.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> show(clk, reset, hex0, hex1, hex2, hex3, an, sseg, l1, l2, l3);</span><br><span class="line">    <span class="keyword">input</span> clk, reset;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] hex0, hex1, hex2, hex3; <span class="comment">//分别存储4个灯要显示的数字（0-15）</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] an;                    <span class="comment">//控制每个灯是否工作，0为工作</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>] sseg;                  <span class="comment">//存储数字在数码管上的表示</span></span><br><span class="line">    <span class="keyword">output</span> l1, l2, l3;                  <span class="comment">//控制负数亮灯</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> l1 = hex3[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> l2 = hex2[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> l3 = hex0[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">localparam</span> N = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">reg</span> [N-<span class="number">1</span>:<span class="number">0</span>] regN;</span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(reset) regN &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> regN &lt;= regN + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] an;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] hex_in;   <span class="comment">//存储当前要展示的数字</span></span><br><span class="line">    <span class="keyword">always</span> @ (*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(regN[N-<span class="number">1</span> : N-<span class="number">2</span>])</span><br><span class="line">            <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b1110</span>; </span><br><span class="line">                hex_in = hex0;  </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b1101</span>; </span><br><span class="line">                hex_in = hex1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b1011</span>;</span><br><span class="line">                hex_in = hex2;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b0111</span>;</span><br><span class="line">                hex_in = hex3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] sseg;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(hex_in[<span class="number">2</span>:<span class="number">0</span>])</span><br><span class="line">            <span class="number">4&#x27;h0</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0000001</span>; </span><br><span class="line">            <span class="number">4&#x27;h1</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1001111</span>;</span><br><span class="line">            <span class="number">4&#x27;h2</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0010010</span>;</span><br><span class="line">            <span class="number">4&#x27;h3</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0000110</span>;</span><br><span class="line">            <span class="number">4&#x27;h4</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1001100</span>;</span><br><span class="line">            <span class="number">4&#x27;h5</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0100100</span>;</span><br><span class="line">            <span class="number">4&#x27;h6</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0100000</span>;</span><br><span class="line">            <span class="number">4&#x27;h7</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0001111</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="实验三">实验三</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一部分主要是verilog语法，比较简单。&lt;/p&gt;</summary>
    
    
    
    <category term="大学" scheme="http://example.com/categories/%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数字逻辑" scheme="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库自学笔记</title>
    <link href="http://example.com/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-18T16:22:07.000Z</published>
    <updated>2023-10-19T14:21:26.148Z</updated>
    
    <content type="html"><![CDATA[<p>懒得解释了，反正之前没咋认真听过课（其实是去做数据库期末项目了）。今天终于有点时间了抽空看了一下之前的内容，做一下笔记记录一下免得以后忘了。</p><span id="more"></span><h3id="函数依赖函数依赖集依赖的推导">函数依赖、函数依赖集、依赖的推导</h3><ul><li>函数依赖(FD)。</li></ul><p>假设在一张表中，任意挑俩元组i, j，若发现若<spanclass="math inline">\(A_i = A_j\)</span>，则<spanclass="math inline">\(B_i = B_j\)</span>，则说明属性A可推出B，写作<spanclass="math inline">\(A \rightarrow B\)</span>，称为B依赖于A。</p><ul><li>函数依赖集(FDs)。</li></ul><p>就是一个集合，里头的元素是函数依赖。</p><ul><li>依赖的推导</li></ul><p>三个公理（要记住。这个其实感性理解很好理解）：</p><ol type="1"><li>如果Y是X的子集，则<span class="math inline">\(X \rightarrowY\)</span></li><li>如果<span class="math inline">\(X \rightarrow Y\)</span>，则<spanclass="math inline">\(XZ \rightarrow YZ\)</span></li><li>如果<span class="math inline">\(X \rightarrow Y, Y \rightarrowZ\)</span>，则<span class="math inline">\(X \rightarrow Z\)</span></li></ol><p>两个定理</p><ol type="1"><li>若<span class="math inline">\(X \rightarrow Y, X \rightarrowZ\)</span>，则<span class="math inline">\(X \rightarrow YZ\)</span><ul><li>证明：因为<span class="math inline">\(X \rightarrowY\)</span>，所以<span class="math inline">\(XZ \rightarrowYZ\)</span></li><li>因为<span class="math inline">\(X \rightarrow Z\)</span>，所以<spanclass="math inline">\(X \rightarrow XZ\)</span></li><li>所以<span class="math inline">\(X \rightarrow XZ \rightarrowYZ\)</span></li></ul></li><li>若<span class="math inline">\(X \rightarrow YZ\)</span>，则<spanclass="math inline">\(X \rightarrow Y, X \rightarrow Z\)</span><ul><li>证明：因为Y, Z是YZ子集，所以<span class="math inline">\(YZ\rightarrow Y, YZ \rightarrow Z\)</span></li><li>所以<span class="math inline">\(X \rightarrow YZ \rightarrow Y, X\rightarrow YZ \rightarrow Z\)</span></li></ul></li></ol><p>任何的依赖推导用上面这五条性质一般都可以推出来了。</p><h3 id="候选码非主属性主属性超键">候选码、非主属性、主属性、超键</h3><ul><li>候选码：能唯一标识一个关系的属性集合且集合大小要保证最小<ul><li>注意，一个关系R中可能存在多个候选码</li></ul></li><li>非主属性：只要有一个属性，它不属于任何一个候选码的属性，它就是非主属性</li><li>主属性：只要有一个属性，它属于某一个候选码，它就是主属性</li><li>超键：能唯一标识一个关系的属性集合<ul><li>注意，跟候选码不同的是，候选码的要求是在能唯一标识的基础上，保证集合大小最小。但是超键则无所谓，多大都ok。</li><li>注意，一个关系R中可能存在多个超键</li></ul></li></ul><h3 id="函数依赖集的闭包属性的闭包">函数依赖集的闭包、属性的闭包</h3><p>一般关系都是R表示，关系的函数依赖集一般用F表示。函数依赖集的闭包用<spanclass="math inline">\(F^+\)</span>表示。</p><p>求<spanclass="math inline">\(F^+\)</span>就是用F中的依赖把所有能推出来的依赖都推出来（画树状图+用5条性质去推），就是<spanclass="math inline">\(F^+\)</span>。</p><p>假设有一个属性A，则属性A的闭包写作<spanclass="math inline">\(A^+\)</span>。推<spanclass="math inline">\(A^+\)</span>的方法用“背包材料”的理念。最初背包中只有A这一个材料，所以首先拿A去推，能推出来的东西都放入“背包”中。然后再用背包中的材料（材料可以组合）去推，依次类推。直到没有东西可以放入背包中。</p><p>属性闭包蛮有用的，具体作用有如下2条：</p><ol type="1"><li>判断<span class="math inline">\(X \rightarrow Y\)</span>是否在<spanclass="math inline">\(F^+\)</span>里。<ul><li>正常思路是先写出F+，然后就知道<span class="math inline">\(X\rightarrow Y\)</span>在不在F+里了。但其实可以先写出<spanclass="math inline">\(X^+\)</span>，只要<spanclass="math inline">\(X^+\)</span>里有Y，那么<spanclass="math inline">\(X \rightarrow Y\)</span>就在<spanclass="math inline">\(F^+\)</span>里。</li></ul></li><li>判断某个属性集合是否是超键<ul><li>假设属性集合叫S，那写出<spanclass="math inline">\(S^+\)</span>，如果<spanclass="math inline">\(S^+\)</span>里包含了所有属性，那么属性集合S就是超键。</li></ul></li></ol><p>补充：假定有关系R和函数依赖集F，如何推出候补码？</p><p>观察F，然后使用口诀：“只在左边的一定是，只在右边的一定不是，两边都在的试一试”</p><p>具体来说，如果属性A在F中只出现在箭头的左边，那么A一定属于任意一个候补码。如果属性A在F中只出现在箭头的右边，那么A一定不属于任意一个候补码（即非主属性）。如果在箭头左右都出现过，那就试一试，用属性的闭包去验证一下即可。</p><h3id="无损分解分解后是否保持函数依赖">无损分解、分解后是否保持函数依赖</h3><p>分解一个表有时是很有必要的。假设一个表有属性“学生等级”和“学生评价”。且我们知道，如果一个学生的等级是A、B、C，他的评价分别是优秀、良好、差。如果不分解的话每次记录都要把其等级和评价记下来。但是这显然没必要，只需要记录任意一个就好。因为他们俩只要知道其中一个，另外一个是可以推出来的。</p><p>所以可以将表分解成两张表，第一张记录了其它数据 +学生等级，第二张表记录学生等级 + 学生评价。</p><p>上面这个例子就是解释分解是什么个意思。接下来讨论无损分解。</p><p>无损分解就是说分解成的两个表经过自然连接后可以得到原表。不会有额外数据的增添。</p><p>先讲结论，如果讲表R分解为<span class="math inline">\(R_1,R_2\)</span>，如果<span class="math inline">\(R_1 \cap R_2 \rightarrowR_1\)</span>或者<span class="math inline">\(R_1 \cap R_2 \rightarrowR_2\)</span>，则这必然是一个无损分解。</p><p>这很好感性理解，自然连接本质就是找到俩表相同的公共部分然后连接。所以如果俩表的公共部分可以推出其中一个表，就说明不会有额外数据的增添。看下面这个例子就很好理解。</p><p><img src="1.png" /></p><p>至于分解后是否保持函数依赖，要看F。</p><p>也就是F中的每一对依赖X、Y，必须出现在某个子表<spanclass="math inline">\(R_i\)</span>中。这样就分解后就保持函数依赖。</p><h3 id="bcnf">BCNF</h3><p>BCNF是3.5NF，如果一个关系是3.5NF，那么它必定是3NF。</p><p>如果一个关系R满足BCNF，那么这张表中就不存在“冗余”。所以BCNF是很棒的。</p><p>如果一个关系R不满足BCNF呢？那么就将R分解成若干个子表，使得每个子表都满足BCNF，这样也就不会有冗余了，这样也是很棒的。</p><p>所以问题的关键就是如何判断一个表是否满足BCNF？以及如果一个表不满足BCNF，如何将它分解成满足BCNF的子表？</p><p>先讲第一个问题，如何判断一个表是否满足BCNF。</p><p>假定现在有关系R，函数依赖集F。对于F中每一条关系<spanclass="math inline">\(X \rightarrowY\)</span>，必须满足下面任意一条，则R满足BCNF。</p><ol type="1"><li>X是超键</li><li>X包含Y</li></ol><p>下面讨论第二个问题，如何将一个不满足BCNF的表分解为满足BCNF的若干子表。</p><p>若<span class="math inline">\(X \rightarrowY\)</span>不满足2条规则中任意一条，则将R分解为<spanclass="math inline">\(R_1 = R - Y\)</span>与<spanclass="math inline">\(R_2 = X +Y\)</span>。显然，这是个无损分解（很容易证明，公共部分是X，且X可推出R2）。而且<spanclass="math inline">\(R_1, R_2\)</span>也是满足BCNF的。</p><p>如果有多个依赖不满足规则呢？那就依次分解即可（注意，不同分解顺序带来的结果并不相同不过都是对的）</p><p>综上，在设计自己的数据库时，我们要尽可能的使表都满足BCNF，这样就不会产生数据的冗余。但是BCNF有一个缺点，就是分解后不一定能保持函数的依赖。比如下面这个例子：</p><p><img src="2.png" /></p><p><span class="math inline">\(L \rightarrowK\)</span>不满足规则，所以将R分解为<span class="math inline">\(R_1 = (J,L), R_2 = (L,K)\)</span>。函数依赖有两个，第二个在R2中可得到保持，第一个在R1或R2都不能得到保持，所以分解后没能保持函数依赖。</p><p>这就是BCNF的一个缺点，所以接下来就要介绍3NF。3NF的优点就是它可以保持函数的依赖，但是它的缺点就是仍然会存在一些冗余。</p><h3 id="nf">3NF</h3><p>跟BCNF一样，3NF还是两个灵魂问题：（1）如何判断关系R是否满足3NF（2）如果R不满足3NF，如何将它分解为若干子表使得它们满足3NF</p><p>先来解决第一个问题。</p><p>假定现在有关系R，函数依赖集F。对于F中每一条关系<spanclass="math inline">\(X \rightarrowY\)</span>，必须满足下面任意一条，则R满足BCNF。</p><ol type="1"><li>X是超键</li><li>Y被包含在X里</li><li>Y属于候补码（注意不是超键噢）（所以先要求出候补码）</li></ol><p>现在来解决第二个问题。</p><p>分为以下几步：</p><ol type="1"><li>求F最小覆盖集<span class="math inline">\(F_c\)</span><ol type="1"><li>尝试将F中每一项依赖去掉，看能不能用其它的依赖推导出来，能就删掉</li><li>在剩下的依赖中，一推一的不动，一堆多或者多推一的尝试将多的那边化简，在多的那边看多个属性能不能互推，尽量减少属性个数</li><li>将一对一的，能合并就合并</li><li>结束</li></ol></li><li>将<spanclass="math inline">\(F_c\)</span>中每一个依赖拿出来组成新表</li><li>求候选码</li><li>看候选码在不在其中一个新表中，不在的话就新加一个表，表的属性就是候选码</li></ol><p>综上，3NF的好处就是可以保持函数依赖（而且也是无损分解），缺点就是会存在点冗余。</p><h3 id="范式总结nf">范式总结（NF）</h3><p>第三范式前面是用“规则”定义出来的，其实它还有另一种定义。</p><ul><li>第一范式（1NF）：每个属性都是原子属性，本质上所有关系的都满足第一范式。</li><li>第二范式（2NF）：在满足第一范式的前提下，满足所有非主属性必须依赖于整个候选码而不能依赖于候选码的部分属性。</li><li>第三范式（3NF）：在满足第二范式的前提下，满足F中不能有非主属性之间的依赖传递。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;懒得解释了，反正之前没咋认真听过课（其实是去做数据库期末项目了）。今天终于有点时间了抽空看了一下之前的内容，做一下笔记记录一下免得以后忘了。&lt;/p&gt;</summary>
    
    
    
    <category term="大学" scheme="http://example.com/categories/%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数据库" scheme="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Distributed Nash Equilibrium Seeking for...</title>
    <link href="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/"/>
    <id>http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/</id>
    <published>2023-10-16T06:45:10.000Z</published>
    <updated>2023-11-02T17:20:16.242Z</updated>
    
    <content type="html"><![CDATA[<p>标题全称为：Distributed Nash Equilibrium Seeking for AggregativeGames With Directed Communication Graphs</p><p>中文翻译为：在使用有向图结构的聚合博弈中寻找离散式纳什均衡</p><hr /><p>本周成果：</p><ol type="1"><li>为了解决Lemma1去看了[18]，发现这个领域大家的总体大方向都差不多。有许多共同之处。对本文的架构理解更加清晰了一些。</li><li>看了Introduction，对这个领域前人是怎么发展过来的有了一个大致的了解。也知道了本篇论文重点是参考哪几篇论文写出来的。</li></ol><p>本周问题：</p><ol type="1"><li>Lemma 1的黑字解决一下</li><li>Lemma 3的第一个黑字尽量解决一下，解决不了也最好找到一条路</li><li>Lemma 4图片的证明我觉得很不严谨，最好敲定下来不要留模糊</li><li>有时间的话把Lemma 5图片中黑字解决一下</li></ol><span id="more"></span><h3 id="abstract">Abstract</h3><p>在聚合博弈中寻找分布式纳什均衡的关键点就是聚合博弈采取什么样的图结构。</p><p>若采取无向图或者权衡平衡图结构，则这个问题已经被前人解决。</p><p>如果采取有向图，则这仍然是个无人解决的问题。</p><p>本文解决的是当图结构采取“固定有向图”或者“时变有向图”时的分布式NE寻找问题。</p><p>使用了两种算法来分别解决上面所提到的两种图结构时的分布式NE寻找问题。</p><p>创新点是受凸优化中重球法的启发，向玩家策略的更新规范中引入了“动量项”，使得加速了算法寻找NE的收敛速度。</p><p>对于强连通固定图和b强连通时变图，从理论上证明，如果代价函数和参与人的集合满足一定条件，在步长减小的情况下，参与人的行动将收敛到集合博弈的NE上。</p><p>本文最后将该算法运用于插电式混合动力汽车的能耗控制，检验了算法的正确性。</p><h3 id="section-1-introduction">Section 1: Introduction</h3><h4 id="研究背景">1-1: 研究背景</h4><ul><li><p>本文研究的是聚合游戏，也就是每个玩家的花费除了依赖自身动作还依赖所有玩家的聚合行为。在聚合游戏中寻找NE是个有挑战性的问题，因为每个玩家只能与自己的邻居通信。</p></li><li><p>在分布式通信计算领域，一些解决聚合游戏中NE寻找问题的分布式算法已经被提出。具体分为“分布式离散时间算法”[6],[7]和“分布式连续时间算法”[8]-[15]</p></li></ul><p>[6]：在这篇文章中，作者专注于研究有向图中的两种特殊的聚合游戏，分别叫做“networkaggregative games” 和 "average aggregative games"。使用"optimal responsestrategy"方法去研究的。而且，在图的加权邻接矩阵为双随机矩阵的条件下，<spanclass="math inline">\(\varepsilon-NE\)</span>在average aggregativegames的寻找得以被解决。</p><p>[7]：在这篇文章中，作者专注于研究无向图中的聚合游戏。并相应提出了几种分布式同步和异步算法。</p><p>[8]：在这篇文章中，作者专注于研究权重平衡有向图中的聚合游戏，其中玩家的dynamicswere described by disturbed first-order systems.为了寻找寻找外部干扰下具有coupled equalityconstraint的聚合游戏的NE，作者在文中提出了一种利用内部模型排斥外部干扰来找NE的分布式算法。同时利用dynamicaverage consensus来估计所有玩家的总和。</p><p>[9]：在这篇文章中，研究了玩家成本函数非光滑，同时玩家动作受到局部可行性约束和线性耦合约束时的情况。具体来说，作者利用微分包含和微分投影算子，提出了一种基于连续时间分布投影的算法来找权重平衡有向图上的非光滑聚合游戏的NE。</p><p>[10]：在这篇文章中，作者研究了无向连通图上具有耦合约束的聚合游戏。</p><p>[11]：结合projected gradient dynamics 和 consensus trackingdynamics，本文讨论了无向连通图上的聚合游戏。</p><p>[12]：结合projected gradient dynamics 和 consensus trackingdynamics，本文讨论了权重平衡有向图上的聚合游戏。</p><p>[13]：研究了存在对通信链路持续攻击的网络上的聚合游戏。其中玩家的动态是受未知时变干扰和未建模项影响的双积分器。</p><p>[14]：研究了聚合游戏在智能电网能耗控制中的运用。其中玩家采用平均共识协议来估计总能耗，并且表明玩家的行为以指数形式收敛于NE。</p><p>[15]：将PHEVs建模成一个无向连通图上的聚合游戏，并对NE的稳定性进行了分析。</p><ul><li>可以发现上面的文章大多都是在无向图或者权重平衡有向图上的工作。在一般有向图上利用分布式离散时间算法来寻找NE仍然是一个未解决的问题。因为难点就在于玩家之间的通信结构不平衡。</li><li>但是到目前为止，关于在不平衡有向图上的分布式优化问题已经被广泛研究。例如下面几篇文章：</li></ul><p>[16]：提出了一种连续时间算法来解决权重不平衡图上的聚合游戏的NE寻找问题。</p><p>[17]：通过结合(子)梯度下降和推和共识协议开发了分布式(子)梯度推算法，其中双随机矩阵的要求可被推广到列随机矩阵。</p><p>[18]：为了不需要提前知道列-随机矩阵的出度，这篇文章仅使用行-随机矩阵，通过估计行-随机矩阵的左Perron特征向量来求解具有不平衡有向图的分布无约束优化问题。</p><p>[19],[20]：通过估计行随机矩阵的左Perron特征向量，研究有向图的分布式约束优化问题。</p><ul><li>所以本文受到上述文章中处理不平衡有向图的方法启发，分别运用行随机矩阵（algorithm1）和列随机矩阵（algorithm2）来研究不平衡有向图上（两种算法分别对应fixed digraph和time-varyingdigraph）的聚合游戏。</li><li>具体来说，通过估计与拓扑相关的行随机矩阵的左特征向量，成功消除了这种拓扑相关行随机矩阵对所有玩家聚合行为估计的不平衡影响。此外，针对时变有向图下的聚集博弈，提出了一种基于推和协议的分布式算法来寻找NE。而且由于玩家的动作受到设定的约束，因此采用投影梯度法根据聚集的局部估计更新玩家的动作。</li><li>另一方面，考虑到步长恒定的投影梯度法只能在存在集合约束的情况下使玩家的动作收敛到NE的一个邻域，所以本文采用步长递减的方法来保证收敛到准确的NE，并且允许参与者采用不协调的步长。</li><li>然而，步长递减也带来了另一个挑战，即收敛速度慢。受到[21]中重球法的启发下，本文在玩家行为更新规律中引入动量项，以加快算法的收敛速度。证明了所提出的步长递减离散NE搜索算法能够保证收敛到精确NE。</li><li>此外，还分析了在步长递减时所提出的NE搜索算法的收敛速度。最后，将所提出的算法应用于有向图上的插电式混合动力汽车系统能耗博弈的求解，数值结果表明，动量项加速了算法的收敛速度。</li></ul><blockquote><p>看了上面的introduction，个人感觉其实就是说：</p><p>不平衡有向图上的聚合问题没人解决，因为玩家之间通信结构不平衡。</p><p>然后本文用[18] ~[20]“估计行随机矩阵左特征向量”的方法解决上面这个难点。</p><p>另外，本文还讨论了时变有向图下的聚集博弈，用的是[17]的方法，但是在他基础上把步长固定改为步长递减从而使NE收敛更精确。另外还加了一个[21]里的重球法中的动量项来加快收敛速度。</p></blockquote><h4 id="大致目录-基础公式">1-2: 大致目录 &amp; 基础公式</h4><p>Section 2：图论的基础结论、问题建模、算法引入</p><p>Section 3、4：算法的收敛性证明</p><p>Section 5：验证算法在插电式混合动力汽车能耗控制的正确性</p><ul><li><span class="math inline">\(\mathbb{R,N_+}\)</span>：分别是实数集和正整数集</li><li><span class="math inline">\(e_i ∈ \mathbb{R^n}\)</span>：n维列向量，其中第i项为1，其余项为0</li><li><span class="math inline">\(1_n ∈ \mathbb{R^n}\)</span>：n维列向量，每一项都是1</li><li><span class="math inline">\(I_n\)</span>：n维单位矩阵</li><li><span class="math inline">\(\|\cdot\|\)</span>：欧几里得范式</li><li><span class="math inline">\(\|x\|_H, H \in \mathbb{R^{n \timesn}}\)</span>：加权范数（weighed norm）（结果为一个常数），定义为：<spanclass="math inline">\(\|x\|_H = \sqrt{x^THx}\)</span></li><li><span class="math inline">\(\Omega \in\mathbb{R^n}\)</span>：n维的非空闭凸集，里面每个元素都是n维列向量</li><li><span class="math inline">\(P_{\Omega}[x]\)</span>: x(<spanclass="math inline">\(\Omega\)</span>外一点)在<spanclass="math inline">\(\Omega\)</span>上的投影点(结果为一个n维列向量),定义为: <span class="math inline">\(P_{\Omega}[x] = argmin_{y \in\Omega}\|x - y\| = y^*, y^* \in \Omega\)</span><ul><li>具有非扩张性，即：<spanclass="math inline">\(\|P_{\Omega}[x]-P_{\Omega}[z]\| \le\|x-z\|\)</span></li></ul></li><li><spanclass="math inline">\([x]_i\)</span>：x这个n维向量中的第i项</li><li><spanclass="math inline">\(H_{ij}\)</span>：矩阵H的i行j列那个元素</li></ul><h3 id="section-2-preliminary-knowledge">Section 2: Preliminaryknowledge</h3><h4 id="图理论">2-1: 图理论</h4><p><span class="math inline">\(\mathcal{N}=\{1, 2, ...,N\}\)</span>：玩家集合</p><p><span class="math inline">\(\varepsilon(k) \subseteq \{(i, j), i, j\in \mathcal{N}\}\)</span>：时刻为k时的边集 <spanclass="math inline">\((i, j) \in \varepsilon(k)\)</span> means thatplayer i can receive information from player j at time j.</p><p><span class="math inline">\(\mathcal{G}(k) = \{\mathcal{N},\varepsilon(k)\}\)</span>：时刻为k时的图</p><p><span class="math inline">\(N^{in}_{i}(k) = \{i\} \cup \{j | (j, i)\in \varepsilon(k)\}\)</span>：时刻为k时，点i的入点集合</p><p><span class="math inline">\(N^{out}_{i}(k) = \{i\} \cup \{j | (i, j)\in \varepsilon(k)\}\)</span>：时刻为k时，点i的出点集合</p><p><spanclass="math inline">\(d_i^k=|N^{out}_{i}(k)|\)</span>：时刻为k时，点i的出度</p><p>strongly connected fixed digraph：强连通有向图。即任意俩点可通</p><p>For the time-varying digraph <spanclass="math inline">\(\mathcal{G}(k), \{\mathcal{G}(k)\}\)</span> issaid to be B-strongly connected if there exists a <spanclass="math inline">\(B \in \mathbb{N_+}\)</span> such that the uniondigraph <spanclass="math inline">\(\cup_{t=kB}^{(k+1)B}\mathcal{G}(t)\)</span> isstrongly connected for any <span class="math inline">\(k \in\mathbb{N_+}\)</span>换句话说，如果一定时间段内的所有时变图的并（边并起来，边权不相加）为强连通，则这些时变图的集合是B-连通的。</p><p>后面依次类推。</p><h4 id="问题建模">2-2: 问题建模</h4><p>每个玩家的动作集合定义为<spanclass="math inline">\(\Omega_i\)</span>，动作定义为<spanclass="math inline">\(x_i\)</span>。每个玩家的花费函数定义为<spanclass="math inline">\(J_i(x), x = [x_1, x_2, ...,x_n]^T\)</span>，通过这个表达式可以看出来，每个玩家的花费函数跟所有玩家的动作相关。</p><p><span class="math inline">\(J_i(x)\)</span>还有几种等价的定义：</p><p>定义1：<span class="math display">\[J_i(x) = f_i(x_i, \sigma(x)), \\\sigma(x)=\sum_{j=1}^{N}\phi_{j}(x_j) \qquad (1)\]</span></p><p>定义2：<span class="math inline">\(J_i(x)=J_i(x_i, x_{-i}),x_{-i}=[x_1, ..., x_{i-1}, x_{i+1}, ..., x_n]\)</span></p><p>要解决的问题是最小化每一个玩家的花费函数，即：</p><p><span class="math inline">\(min \, f_i(x_i, \sigma(x)), \forall{i}\in \mathcal{N} \qquad (2)\)</span></p><p>实际上就是求一个纳什均衡问题，因为纳什均衡就是任何一个玩家改变它的动作都不能使得它的花费函数更小。如果纳什均衡的观点表达上面的式子，就是：</p><p>假如<span class="math inline">\(x^*\)</span>是NE，当且仅当<spanclass="math inline">\(J_i(x_i^*, x_{-i}^*) \le J_i(x_i, x_{-i}^*),\forall{x_i} \in \Omega_i, \forall{i} \in \mathcal{N}\)</span></p><blockquote><p>Note that the players in the considered game have no knowledge of theaggregation <span class="math inline">\(\sigma(x)\)</span> due to theprivacy of <span class="math inline">\(\phi_j(x_j), j \in\mathcal{N}\)</span>。</p><p>也就是说，<spanclass="math inline">\(\phi_i(x_i)\)</span>函数是每个人特有的，只有自己知道，别人不知道。但是可以通过有向图与邻居交换信息。</p></blockquote><p>下面是论文的几个假设，论文解决的问题都是基于这几个假设作为前提的。</p><h5 id="assumption-1">Assumption 1</h5><ul><li>论文讨论的图不是一般有向图，而是两类。分别是固定有向图（fixeddigraph）和时变有向图（time-varying digraph）。</li><li>而且fixed digraph一定满足强连通，time-varyingdigraph一定满足B-强连通。</li></ul><h5 id="assumption-2">Assumption 2</h5><ul><li><p>对于所有玩家的动作集合<spanclass="math inline">\(\Omega_{i}\)</span>，都是非空、紧致、凸的。</p></li><li><p>定义<span class="math inline">\(\Omega_{-i}=\Omega_{1} \times\Omega_{2} \times ... \times \Omega_{i-1} \times \Omega_{i+1} \times ...\times \Omega_{N}\)</span>。More over, for given <spanclass="math inline">\(x_{-i} \in \Omega_{-i}, J_i(x_i, x_{-i})\)</span>is convex about <span class="math inline">\(x_i\)</span> on <spanclass="math inline">\(\Omega_{i}\)</span></p></li><li><p><span class="math inline">\(J_i(x_i, x_{-i})\)</span>对<spanclass="math inline">\(x\)</span>连续可微，<spanclass="math inline">\(\phi_i(x_i)\)</span>对<spanclass="math inline">\(x_i\)</span>连续可微。</p><ul><li>定义<span class="math inline">\(\nabla_z{f(z,y)}\)</span>为对z求一阶偏导</li><li>按照此定义，将<span class="math inline">\(J_i(x_i,x_{-i})\)</span>对<spanclass="math inline">\(x_i\)</span>求导，将得到<spanclass="math inline">\(\nabla_{x_i}J_i(x_i, x_{-i}) =\nabla_{x_i}f_i(x_i,\sigma(x)) + \nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)\)</span>。这里实际上是有点歧义的，作者想表达的意思就是关注玩家i的动作对其花费函数的影响。</li><li>定义<span class="math inline">\(\Gamma(x)=[\nabla_{x_1}J_1(x_1,x_{-1}), ..., \nabla_{x_N}J_N(x_N,x_{-N})]^T\)</span>，即每个玩家花费函数对自身动作求导组成的一个列向量</li><li>定义<span class="math inline">\(G_i(x_i, \tilde{\sigma_i}) =\nabla_{x_i}f_i(x_i, \sigma(x))|_{\sigma(x)=\tilde{\sigma_i}} +\nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)|_{\sigma(x)=\tilde{\sigma_i}}\)</span>。不是把每个花费函数对动作求导嘛，这里就是把求导结果里的<spanclass="math inline">\(\sigma(x)\)</span>赋值为<spanclass="math inline">\(\tilde{\sigma_i}\)</span>了。</li></ul></li></ul><h5 id="assumption-3">Assumption 3</h5><ul><li><spanclass="math inline">\(\Gamma(x)\)</span>满足下列俩条件之一：</li><li><span class="math inline">\(\Gamma(x)\)</span>在<spanclass="math inline">\(\Omega\)</span>上是严格单调的，也就是说，<spanclass="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,\forall{x, x&#39;} \in \Omega, x \ne x&#39;\)</span></li><li><span class="math inline">\(\Gamma(x)\)</span>在<spanclass="math inline">\(\Omega\)</span>上是强单调的，也就是说，存在一个常数<spanclass="math inline">\(\mu &gt; 0\)</span>使得<spanclass="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) \ge\mu\|x-x&#39;\|^2, \forall{x, x&#39;} \in \Omega, x \nex&#39;\)</span></li></ul><h5 id="assumption-4">Assumption 4</h5><ul><li><p>The mapping <span class="math inline">\(G_i(x_i, \sigma) isL_1-Lipschitz\)</span> continuous with repect to <spanclass="math inline">\(\sigma \in \mathbb{R}\)</span> and <spanclass="math inline">\(\phi_i(x_i)\)</span> is <spanclass="math inline">\(L_2-Lipschitz\)</span> continuous with repect to<span class="math inline">\(x_i \in \Omega_i\)</span> for all <spanclass="math inline">\(i \in \mathcal{N}\)</span>, i.e.,</p></li><li><p>(<span class="math inline">\(L_1, L_2\)</span> are two positiveconstants) <span class="math display">\[\begin{aligned}\|G_i(x_i,\sigma_1)-G_i(x_i,\sigma_2)\|_2&amp;\leL_1\left\|\sigma_1-\sigma_2\right\|,&amp;\forall\sigma_1,\sigma_2\in\mathbb{R},\\\|\phi_i(z_1)-\phi_i(z_2)\|&amp;\leL_2\left\|z_1-z_2\right\|,&amp;\forall z_1,z_2\in\Omega_i,\end{aligned}\]</span></p></li></ul><h4 id="算法引入">2-3: 算法引入</h4><h5id="algorithm-1-ne-seeking-with-row-stochastic-adjacency-matrix">Algorithm1 NE Seeking With Row-Stochastic Adjacency Matrix</h5><ul><li>Initialization: <span class="math inline">\(x_i^0=x_i^1 \in\Omega_i, v_i^1=e_i, \tilde\sigma_i^1=\phi_i(x_i^1)\)</span></li><li>for <span class="math inline">\(k \in \mathbb{N}_+\)</span> do<ul><li>for each player <span class="math inline">\(i \in\mathcal{N}\)</span> do<ul><li><span class="math inline">\(x_i^{k+1}=P_{\Omega_i}[x_i^k -\alpha_i^kG_i(x_i^k, \tilde\sigma_i^k) + \lambda_i(x_i^k-x_i^{k-1})]\qquad (3a)\)</span></li><li><span class="math inline">\(v_i^{k+1}=\sum_{j=1}^Na_{ij}v_j^k \qquad(3b)\)</span></li><li><spanclass="math inline">\(\tilde{\sigma}_{i}^{k+1}=\sum_{j=1}^{N}a_{ij}\tilde{\sigma}_{j}^{k}+\frac{\phi_{i}\left(x_{i}^{k+1}\right)}{\left[v_{i}^{k+1}\right]_{i}}-\frac{\phi_{i}\left(x_{i}^{k}\right)}{\left[v_{i}^{k}\right]_{i}}\qquad (3c)\)</span></li></ul></li><li>end for</li></ul></li><li>end for</li></ul><p>行随机邻接矩阵记为<spanclass="math inline">\(A=[a_{ij}]\)</span>，其中<spanclass="math inline">\(a_{ii}&gt;0\)</span>，且若<spanclass="math inline">\((j, i) \in \varepsilon\)</span>则<spanclass="math inline">\(a_{ij}&gt;0\)</span>, 否则<spanclass="math inline">\(a_{ij}=0\)</span>。另外，行随机矩阵的特征就是每一行元素和为1。</p><p><spanclass="math inline">\(x_i^k\)</span>表示第i个玩家在时刻k的动作</p><p><span class="math inline">\(v_i^k \in\mathbb{R}^N\)</span>用来estimate the left eigenvector <spanclass="math inline">\(v\)</span> associated with eigenvalue <spanclass="math inline">\(1\)</span> of the matrix A.</p><p><span class="math inline">\(\tilde\sigma_i^k\)</span> be the playeri's estimate on the aggregation <spanclass="math inline">\(\sigma(x_k)\)</span> at iteration <spanclass="math inline">\(k\)</span>, <spanclass="math inline">\(x_k=[x_1^k, ..., x_N^k]^T\)</span></p><p><spanclass="math inline">\(\alpha_i^k\)</span>表示步长，它遵循下面三个限制：</p><ol type="1"><li>每个玩家在任意时刻的步长都是大于0的，且对于每个玩家，其<spanclass="math inline">\(\{\alpha_i^k\}\)</span>单调不增加</li><li><spanclass="math inline">\(\sum_{k=1}^{\infty}\alpha_{i}^{k}=\infty,\sum_{k=1}^{\infty}(\alpha_{i}^{k})^{2}&lt;\infty\)</span></li><li><spanclass="math inline">\(\sum\limits_{k=1}^{\infty}(\overline{\alpha}_{k}-\underline{\alpha}_{k})&lt;\infty,\text{where}\overline{\alpha}_{k}=\max\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\text{and}\underline{\alpha}_{k}=\min\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}.\)</span></li></ol><p>在algorithm 1中，玩家使用非精确梯度<spanclass="math inline">\(G_i(x_i^k,\tilde\sigma_i^k)\)</span>来更新自身动作。为了消除不精确梯度带来的误差，引入递减的步长而不是固定的步长，从而保证精确收敛到NE。另外，动量项<spanclass="math inline">\(\lambda_i(x_i^k-x_i^{k-1})]\)</span>可以加速算法的收敛，<spanclass="math inline">\(0&lt;\lambda_i&lt;1\)</span>是动量参数。以上就是对于(3a)的解释。</p><p>在(3c)中的第二项和第三项，其存在的目的是为了解决矩阵<spanclass="math inline">\(A\)</span>可能不是列随机的问题。</p><p>可以看出，(3b)和(3c)都用到了<spanclass="math inline">\(a_{ij}\)</span>，所以algorithm 1只适用于fixeddigraph。</p><h5id="algorithm-2-ne-seeking-with-column-stochastic-adjacency-matrix">Algorithm2 NE Seeking With Column-Stochastic Adjacency Matrix</h5><p>这个算法是针对time-varyingdigraph的。在算法2中，每个玩家需要知道自己在每次交流中的出度，因为不同时刻每个点的出度会变化。</p><ul><li>Initialization: <spanclass="math inline">\(x_{i}^{0}=x_{i}^{1}\in\Omega_{i},y_{i}^{1}=1,\tilde{\sigma}_{i}^{1}=\phi_{i}(x_{i}^{1})\)</span></li><li>for <span class="math inline">\(k \in \mathbb{N}_+\)</span> do<ul><li>for each player <span class="math inline">\(i \in\mathcal{N}\)</span> do<ul><li><span class="math inline">\(w_i^{k+1}=\sum_{j\inN_i^{in}(k)}\frac{\tilde{\sigma}_j^k}{d_j^k} \qquad (4a)\)</span></li><li><span class="math inline">\(y_i^{k+1}=\sum_{j\inN_i^{in}(k)}\frac{y_j^k}{d_j^k} \qquad (4b)\)</span></li><li><span class="math inline">\(z_i^{k+1}=\frac{w_i^{k+1}}{y_i^{k+1}}\qquad (4c)\)</span></li><li><spanclass="math inline">\(x_i^{k+1}=P_{\Omega_i}\left[x_i^k-\alpha_i^kG_i(x_i^k,Nz_i^{k+1})+\lambda_i(x_i^k-x_i^{k-1})\right]\qquad (4d)\)</span></li><li><spanclass="math inline">\(\tilde{\sigma}_i^{k+1}=w_i^{k+1}+\phi_i\left(x_i^{k+1}\right)-\phi_i\left(x_i^k\right)\qquad (4e)\)</span></li></ul></li><li>end for</li></ul></li><li>end for</li></ul><p>可以发现，这里求<spanclass="math inline">\(x_i^{k+1}\)</span>第二项<spanclass="math inline">\(G_i\)</span>中并没用<spanclass="math inline">\(\tilde\sigma_i^k\)</span>，而是用的<spanclass="math inline">\(Nz_i^{k+1}\)</span>。z是w跟y的比值，w与y又与点的入点和(入点的出度)有关。</p><blockquote><p>Note: 在algorithm 1中，若把"若<span class="math inline">\((j, i) \in\varepsilon\)</span>则<spanclass="math inline">\(a_{ij}&gt;0\)</span>"改为“若<spanclass="math inline">\((j, i) \in \varepsilon\)</span>则<spanclass="math inline">\(a_{ij}=\frac{1}{d_j^k}\)</span>”，则(3c)与(4e)等价</p></blockquote><h3 id="section-3-convergence-analysis-of-algorithm-1">Section 3:Convergence analysis of algorithm 1</h3><h4 id="theorem-1">3-0: Theorem 1</h4><p>条件：</p><ol type="1"><li><p>采用固定有向图结构</p></li><li><p><span class="math inline">\(\nabla_{x_i}J_i(x_i, x_{-i})=\nabla_{x_i}f_i(x_i, \sigma(x)) + \nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)\)</span></p><p><span class="math inline">\(\Gamma(x)=[\nabla_{x_1}J_1(x_1, x_{-1}),..., \nabla_{x_N}J_N(x_N, x_{-N})]^T\)</span></p><p><span class="math inline">\(G_i(x_i, \tilde{\sigma_i}) =\nabla_{x_i}f_i(x_i, \sigma(x))|_{\sigma(x)=\tilde{\sigma_i}} +\nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)|_{\sigma(x)=\tilde{\sigma_i}}\)</span></p></li><li><p><spanclass="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,\forall{x, x&#39;} \in \Omega, x \ne x&#39;\)</span></p></li><li><p><span class="math display">\[\begin{aligned}\|G_i(x_i,\sigma_1)-G_i(x_i,\sigma_2)\|_2&amp;\leL_1\left\|\sigma_1-\sigma_2\right\|,&amp;\forall\sigma_1,\sigma_2\in\mathbb{R},\\\|\phi_i(z_1)-\phi_i(z_2)\|&amp;\leL_2\left\|z_1-z_2\right\|,&amp;\forall z_1,z_2\in\Omega_i,\end{aligned}\]</span></p></li><li><p>对于<spanclass="math inline">\(\alpha\)</span>步长，满足下面三条性质(C1-C3)</p><ol type="1"><li><spanclass="math inline">\(\{\alpha_i^k\}\)</span>不严格递减，且<spanclass="math inline">\(\alpha_i^k&gt;0\)</span></li><li><spanclass="math inline">\(\sum_{k=1}^{\infty}\alpha_{i}^{k}=\infty,\sum_{k=1}^{\infty}(\alpha_{i}^{k})^{2}&lt;\infty\)</span></li><li><spanclass="math inline">\(\sum\limits_{k=1}^{\infty}(\overline{\alpha}_{k}-\underline{\alpha}_{k})&lt;\infty,\text{where}\overline{\alpha}_{k}=\max\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\text{and}\underline{\alpha}_{k}=\min\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}.\)</span></li></ol></li><li><p><spanclass="math inline">\(\begin{matrix}0&amp;&lt;&amp;\lambda_i&amp;&lt;&amp;\frac{\sqrt{2}}{2}\end{matrix}\)</span></p></li></ol><p>结论：all players' actions converge to the unique NE <spanclass="math inline">\(x^*\)</span> under algorithm 1.</p><h4 id="preliminary-analysis-about-algorithm-1">3-1: Preliminaryanalysis about algorithm 1</h4><p>先来求一下algorithm 1里的<spanclass="math inline">\(v_i^k\)</span></p><p>定义：<spanclass="math inline">\(\left.V_{k}=\left[\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\ldots,v_{N}^{k}}\end{array}\right.\right]^{T}\)</span></p><p>所以<span class="math inline">\(v_i^{k+1}=\sum_{j=1}^Na_{ij}v_j^k\qquad (3b)\)</span>等价于<spanclass="math inline">\(V_{k+1}=AV_{k}\qquad (5)\)</span></p><p>因为<span class="math inline">\(V_1 = [v_1, v_2, ..., v_N]^T =I_N\)</span>，即<span class="math inline">\(v_i =e_i\)</span>（条件）</p><p>所以<spanclass="math inline">\(\lim_{k\to\infty}V_k=\operatorname*{lim}_{k\to\infty}A^{k-1}V_1=\operatorname*{lim}_{k\to\infty}A^{k}\)</span></p><p>因为A是行随机矩阵，所以显然<spanclass="math inline">\(1_n\)</span>是特征值为1时的一个特征向量。</p><p>所以得出<spanclass="math inline">\(\operatorname*{lim}_{k\to\infty}A^{k}=1_Nv^T\)</span>,where <span class="math inline">\(v\)</span>是A关于特征值1的左特征向量且<spanclass="math inline">\(v\)</span>每一项大于0，且<spanclass="math inline">\(v^T1_N=1\)</span>。（根据Perron-Frobenius定理）</p><p>所以<spanclass="math inline">\(\lim_{k\to\infty}\left.V_{k}=\left[\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\ldots,v_{N}^{k}}\end{array}\right.\right]^{T}= 1_Nv^T\)</span>。又<span class="math inline">\(1_Nv^T=[v, v, ...,v]^T\)</span>。</p><p>也就是说，当k趋近于无穷大时，每个玩家的<spanclass="math inline">\(v_i\)</span>都收敛于<spanclass="math inline">\(v\)</span>。</p><p>再来求一下algorithm 1里的<spanclass="math inline">\(\tilde{\sigma}_{i}^{k}\)</span></p><p>首先<spanclass="math inline">\(V_k\)</span>对角线上的元素都是正的，通过<spanclass="math inline">\(V_{k+1}=AV_{k}\)</span>可看出。首先<spanclass="math inline">\(V_1\)</span>是单位阵肯定对角线为正，然后A的对角线元素都是正的（这是algorithm1引入时提到的条件）。所以他俩乘出来的对角线也是正的。不断递推，对角线上都是正的。</p><p>所以现在我定义一个<spanclass="math inline">\(\left.\hat{V}_k=\operatorname{diag}\left(\begin{bmatrix}v_1^k\end{bmatrix}\right._1,\begin{bmatrix}v_2^k\end{bmatrix}_2,\ldots,\begin{bmatrix}v_N^k\end{bmatrix}_N\right)\)</span></p><p>上面这个<spanclass="math inline">\(\hat{V}_k\)</span>其实就是取了<spanclass="math inline">\(V_k\)</span>的对角线，其余地方都是0。</p><p>因为前面说了对角线都是正的嘛，所以<spanclass="math inline">\(\hat{V_k}\)</span>是满秩可逆的。而且我们知道最终<spanclass="math inline">\(V_k\)</span>是收敛的，所以<spanclass="math inline">\(\hat{V_k}\)</span>最终也是收敛的。</p><p>最后我再定义<spanclass="math inline">\(\tilde{\sigma}_{k}=\left[\tilde{\sigma}_{1}^{k},\tilde{\sigma}_{2}^{k},\ldots,\tilde{\sigma}_{N}^{k}\right]^{T}\)</span>和<spanclass="math inline">\(\phi_k =\left[\phi_{1}(x_{1}^{k}),\phi_{2}(x_{2}^{k}),\ldots,\phi_{N}(x_{N}^{k})\right]^{T}\)</span></p><p>则<spanclass="math inline">\(\tilde{\sigma}_{i}^{k+1}=\sum_{j=1}^{N}a_{ij}\tilde{\sigma}_{j}^{k}+\frac{\phi_{i}\left(x_{i}^{k+1}\right)}{\left[v_{i}^{k+1}\right]_{i}}-\frac{\phi_{i}\left(x_{i}^{k}\right)}{\left[v_{i}^{k}\right]_{i}}\qquad (3c)\)</span>可改写为：</p><p><spanclass="math inline">\(\tilde{\sigma}_{k+1}=A\tilde{\sigma}_k+\hat{V}_{k+1}^{-1}\Phi_{k+1}-\hat{V}_k^{-1}\Phi_k\qquad (6)\)</span></p><h4 id="lemmas">3-2: Lemmas</h4><p>为了接下来的叙述方便，定义<spanclass="math inline">\(V_{\infty}=\lim\limits_{k\to\infty}V_{k}=1_{N}v^{T}\)</span>和<spanclass="math inline">\(\hat{V}_{\infty}=\operatorname{diag}([v]_1,\ldots,[v]_N)\)</span></p><h5 id="lemma-1">Lemma 1</h5><p>因为<spanclass="math inline">\(\hat{V}_{k}\)</span>是收敛的，所以会有<spanclass="math inline">\(\|\hat{V}_{k}^{-1}\|\leq \varrho, \varrho &gt;0\)</span></p><blockquote><p>矩阵的二范式从几何意义上来说就是单位圆在经过矩阵变换后离原点最远的距离。假设要求<spanclass="math inline">\(\|A\|\)</span>，则先求<spanclass="math inline">\(A^TA\)</span>，然后再求<spanclass="math inline">\(A^TA\)</span>的特征值，取最大的特征值开方就是矩阵A的二范数</p></blockquote><p>引理1：<spanclass="math inline">\(\|\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1}\|\leq\varrho^{2}\gamma\theta^{k},k \in \mathbb{N_+}, \gamma &gt; 0, 0 &lt; \theta &lt; 1, \varrho &gt;0\)</span></p><p>证明：</p><p><spanclass="math inline">\(\|\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1}\| \le\|\hat{V}_k^{-1}\| \, \|\hat{V}_k - \hat{V}_\infty\| \,\|\hat{V}_\infty^{-1}\| \le \varrho^2 \cdot\gamma\theta^{k}\)</span></p><p><strong><u>第一个不等式不会证，可能跟矩阵论有关？</u></strong></p><p><span class="math inline">\(\varrho ={sup}_{k}\left\|\widetilde{V}_{k}^{-1}\right\|_{2}\)</span>。因为<spanclass="math inline">\(\hat{V}^{-1}\)</span>最终会收敛的，所以它的二范数必然是存在上确界。</p><p><span class="math inline">\(\|\hat{V}_k - \hat{V}_\infty\| \le\gamma\theta^{k}\)</span>是一个定理，详细参考[17]。</p><h5 id="lemma-2">Lemma 2</h5><p>引理2：<spanclass="math inline">\(V_{\infty}\tilde{\sigma}_{k}=V_{\infty}\hat{V}_{k}^{-1}\Phi_{k},k \in \mathbb{N_+}\)</span></p><p>证明如下：</p><p><img src="1.png" /></p><h5 id="lemma-3">Lemma 3</h5><p>先来点前置知识</p><p>According to the definition of <span class="math inline">\(v\)</span>and the fact that <spanclass="math inline">\(\operatorname*{lim}_{k\to\infty}A^{k}=1_{N}v^{T}\)</span>under Assumption 1(a), one can verify that <spanclass="math inline">\(\operatorname*{lim}_{k\to\infty}\left(A-1_{N}v^{T}\right)^{k}=\operatorname*{lim}_{k\to\infty}A^{k}-1_{N}v^{T}=0\)</span>, which is equivalent to <spanclass="math inline">\(\rho(A-1_Nv^T)~&lt;~1\)</span> [30]. It is knownthat for small enough <span class="math inline">\(\epsilon &gt;0\)</span>, there is at least one matrix norm denoted by <spanclass="math inline">\(\|\cdot\|_\epsilon\)</span> such that <spanclass="math inline">\(\rho(A-1_{N}v^{T})\leq\|A-1_{N}v^{T}\|_{\epsilon}\leq\rho(A-1_{N}v^{T})+\epsilon&lt;1\)</span> [30]. Moreover, there existpositive constants <span class="math inline">\(c\)</span> and <spanclass="math inline">\(d\)</span> such that <spanclass="math inline">\(\|\cdot\|_{\epsilon}\leq c\|\cdot\|\)</span> and<span class="math inline">\(\|\cdot\|\leqd\|\cdot\|_{\epsilon}\)</span></p><p><strong><u>上面这一段极限推导那没搞懂以及矩阵范数那不是很懂它在说啥</u></strong></p><p>再定义两个东西</p><p><span class="math inline">\(\rho_1=\left\|A-1_Nv^T\right\|_\epsilon,\rho_1 &lt; 1 \qquad (7)\)</span></p><p><span class="math inline">\(\rho_2=\left\|I_N-1_Nv^T\right\| \qquad(8)\)</span></p><p>引理3：Under Assumption 1(a), 2 and 4, <spanclass="math inline">\(\|\tilde{\sigma}_i^k-v^T\tilde{\sigma}_k\|\)</span>is bounded, i.e., there exists a constant <spanclass="math inline">\(\hat{C} &gt; 0\)</span> such that <spanclass="math inline">\(\|\tilde{\sigma}_{i}^{k}-v^{T}\tilde{\sigma}_{k}\|\leq\tilde{C}\)</span></p><p>证明如下：</p><p><strong><u>涉及到矩阵范数的运算，先略过</u></strong></p><h5 id="lemma-4">Lemma 4</h5><p>引理4：<spanclass="math inline">\(\|G_i\left(x_i^k,\sigma(x_k)\right)\|\le M, M &gt;0\)</span></p><p>证明如下：</p><p><img src="2.png" /></p><h5 id="lemma-5">Lemma 5</h5><p>定义<spanclass="math inline">\(\overline{\lambda}=\max_{j\in\mathcal{N}}\{\lambda_j\}\)</span>，若<spanclass="math inline">\(0&lt;\overline{\lambda}&lt;\frac{\sqrt{2}}2\)</span>，则下面三条性质将会满足：</p><ol type="a"><li><p><spanclass="math inline">\(\left\|x_{i}^{k+1}-x_{i}^{k}\right\|\leqM\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s},\forallk\in\mathbb{N}_{+}\)</span></p></li><li><p><spanclass="math inline">\(\lim\limits_{k\to\infty}\left\|x_{i}^{k+1}-x_{i}^{k}\right\|=0\)</span></p></li><li><p><spanclass="math inline">\(\sum_{k=1}^{\infty}\|x_{i}^{k+1}-x_{i}^{k}\|^{2}&lt;\infty\)</span></p></li></ol><p>where <span class="math inline">\(M\)</span> is given in Lemma 4, and<spanclass="math inline">\(\overline{\alpha}_{k}=\max_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\)</span></p><p>证明如下：</p><p><img src="3.png" /></p><p><img src="4.png" /></p><p>补充：因为所有动作<spanclass="math inline">\(x_i^k\)</span>都属于compact的<spanclass="math inline">\(\Omega_i\)</span>，所以<spanclass="math inline">\(\{x_k\}\)</span>是有界的，又由Lemma5(b)，可以知道<span class="math inline">\(\{x_k\}\)</span>是收敛的。</p><h5 id="lemma-6">Lemma 6</h5><ol type="a"><li><p>For any <span class="math inline">\(k \geq 2\)</span>, one has<spanclass="math display">\[\left\|\tilde{\sigma}_{k}-V_{\infty}\tilde{\sigma}_{k}\right\|\leqdc\rho_{1}^{k-1}\left\|\tilde{\sigma}_{1}-1_{N}v^{T}\tilde{\sigma}_{1}\right\|+D_1\sum_{l=1}^{k-1}\rho_1^{k-l-1}\beta_l+D_2\sum_{l=1}^{k-1}\rho_1^{k-l-1}\theta^l\qquad (9)\]</span>where <spanclass="math inline">\(D_{1}=dc\rho_{2}\varrhoL_{2}\sqrt{N}M,D_{2}=2dc\rho_{2}C\varrho^{2}\gamma,\beta_l=\sum_{s=1}^{l}\overline{\lambda}^{l-s}\overline{\alpha}_{s}\)</span>and<spanclass="math inline">\(0&lt;\theta&lt;1\)</span> is given in Lemma1.</p></li><li><p>For step-size sequence <spanclass="math inline">\(\{\alpha_i^k\}\)</span> satisfying conditionsC1-C3, one has <spanclass="math inline">\(\sum_{k=1}^{\infty}\overline{\alpha}_{k}\left\|\tilde{\sigma}_{k}-V_{\infty}\tilde{\sigma}_{k}\right\|&lt;\infty\)</span></p></li></ol><p>证明如下：<strong><u>dc是啥？Lemma6与Lemma1联动了，但是Lemma1还没搞懂</u></strong></p><h4 id="proof-of-theorem-1">3-3: Proof of theorem 1</h4><h4 id="convergence-rate-analysis-of-algorithm-1">3-4: Convergence rateanalysis of algorithm 1</h4><hr /><h3 id="formulas">Formulas</h3><p><span class="math inline">\(\sigma(x)=\sum_{j=1}^{N}\phi_{j}(x_j)\qquad (1)\)</span></p><p><span class="math inline">\(min \, f_i(x_i, \sigma(x)), \forall{i}\in \mathcal{N} \qquad (2)\)</span></p><p><span class="math inline">\(x_i^{k+1}=P_{\Omega_i}[x_i^k -\alpha_i^kG_i(x_i^k, \tilde\sigma_i^k) + \lambda_i(x_i^k-x_i^{k-1})]\qquad (3a)\)</span></p><p><span class="math inline">\(v_i^{k+1}=\sum_{j=1}^Na_{ij}v_j^k \qquad(3b)\)</span></p><p><spanclass="math inline">\(\tilde{\sigma}_{i}^{k+1}=\sum_{j=1}^{N}a_{ij}\tilde{\sigma}_{j}^{k}+\frac{\phi_{i}\left(x_{i}^{k+1}\right)}{\left[v_{i}^{k+1}\right]_{i}}-\frac{\phi_{i}\left(x_{i}^{k}\right)}{\left[v_{i}^{k}\right]_{i}}\qquad (3c)\)</span></p><p><span class="math inline">\(w_i^{k+1}=\sum_{j\inN_i^{in}(k)}\frac{\tilde{\sigma}_j^k}{d_j^k} \qquad (4a)\)</span></p><p><span class="math inline">\(y_i^{k+1}=\sum_{j\inN_i^{in}(k)}\frac{y_j^k}{d_j^k} \qquad (4b)\)</span></p><p><span class="math inline">\(z_i^{k+1}=\frac{w_i^{k+1}}{y_i^{k+1}}\qquad (4c)\)</span></p><p><spanclass="math inline">\(x_i^{k+1}=P_{\Omega_i}\left[x_i^k-\alpha_i^kG_i(x_i^k,Nz_i^{k+1})+\lambda_i(x_i^k-x_i^{k-1})\right]\qquad (4d)\)</span></p><p><spanclass="math inline">\(\tilde{\sigma}_i^{k+1}=w_i^{k+1}+\phi_i\left(x_i^{k+1}\right)-\phi_i\left(x_i^k\right)\qquad (4e)\)</span></p><p><span class="math inline">\(V_{k+1}=AV_{k}\qquad (5)\)</span></p><p><spanclass="math inline">\(\tilde{\sigma}_{k+1}=A\tilde{\sigma}_k+\hat{V}_{k+1}^{-1}\Phi_{k+1}-\hat{V}_k^{-1}\Phi_k\qquad (6)\)</span></p><p><span class="math inline">\(\rho_1=\left\|A-1_Nv^T\right\|_\epsilon,\rho_1 &lt; 1 \qquad (7)\)</span></p><p><span class="math inline">\(\rho_2=\left\|I_N-1_Nv^T\right\| \qquad(8)\)</span></p><p><spanclass="math inline">\(\left\|\tilde{\sigma}_{k}-V_{\infty}\tilde{\sigma}_{k}\right\|\leqdc\rho_{1}^{k-1}\left\|\tilde{\sigma}_{1}-1_{N}v^{T}\tilde{\sigma}_{1}\right\|+D_1\sum_{l=1}^{k-1}\rho_1^{k-l-1}\beta_l+D_2\sum_{l=1}^{k-1}\rho_1^{k-l-1}\theta^l\qquad (9)\)</span></p><p><spanclass="math inline">\(\begin{Vmatrix}x_i^{k+1}-x_i^k\end{Vmatrix} \leM\sum_{s=1}^{\kappa}\overline{\lambda}^{k-s}\overline{\alpha}_{s} \qquad(41)\)</span></p><p><span class="math inline">\(\left\|x_i^{k+1}-x_i^k\right\|^2 \le2M^{2}\sum_{s=1}^{k}\left(2\overline{\lambda}^{2}\right)^{k-s}\overline{\alpha}_{s}{}^{2}\qquad (42)\)</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;标题全称为：Distributed Nash Equilibrium Seeking for Aggregative
Games With Directed Communication Graphs&lt;/p&gt;
&lt;p&gt;中文翻译为：在使用有向图结构的聚合博弈中寻找离散式纳什均衡&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;本周成果：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;为了解决Lemma
1去看了[18]，发现这个领域大家的总体大方向都差不多。有许多共同之处。
对本文的架构理解更加清晰了一些。&lt;/li&gt;
&lt;li&gt;看了Introduction，对这个领域前人是怎么发展过来的有了一个大致的了解。也知道了本篇论文重点是参考哪几篇论文写出来的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本周问题：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Lemma 1的黑字解决一下&lt;/li&gt;
&lt;li&gt;Lemma 3的第一个黑字尽量解决一下，解决不了也最好找到一条路&lt;/li&gt;
&lt;li&gt;Lemma 4图片的证明我觉得很不严谨，最好敲定下来不要留模糊&lt;/li&gt;
&lt;li&gt;有时间的话把Lemma 5图片中黑字解决一下&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="论文" scheme="http://example.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>2. python急救包</title>
    <link href="http://example.com/2023/10/16/2-python%E6%80%A5%E6%95%91%E5%8C%85/"/>
    <id>http://example.com/2023/10/16/2-python%E6%80%A5%E6%95%91%E5%8C%85/</id>
    <published>2023-10-15T17:56:11.000Z</published>
    <updated>2023-10-30T13:56:23.480Z</updated>
    
    <content type="html"><![CDATA[<p>许多代码都是用python实现的，我的python基础一般，所以在实践中学咯。下面记录一些python常用的基础语法。</p><span id="more"></span><h3 id="numpy相关">numpy相关</h3><h4 id="随机数">随机数</h4><p>np.random.random()：生成一个[0, 1)的随机数</p><p>np.random.uniform(low=, high=, size=)：生成size个[low,high)的随机数</p><p>np.random.randint(x, y)：生成一个[x, y]的整数</p><p>np.random.seed(可填数字)：不填就是随机数。填不同的数字就代表不同的世界线。处于同一个世界线的随机数们都是固定的</p><h4 id="创建数组">创建数组</h4><p>np.zeros(k)：生成一个有k个元素，初始值为0的数组</p><p>np.array(val * num)：生成一个有num个元素，初始值为val的数组</p><h4 id="数组操作">数组操作</h4><p>np.argmax(数组)：返回数组中最大值的下标</p><h3 id="python基本语法相关">python基本语法相关</h3><ul><li>a.append()：列表追加元素</li><li>for idx, x inenumerate(solvers)：使用enumerate方法可以下标和元素本身表示出来很方便</li><li>a = range(num)：产生一个[0, 1, 2, ..., num]的数组</li><li>epsilons = [1, 2, 3, 4], a = [fun(e) for e inepsilons]：很方便的定义一个列表，列表里的元素就是拿每个epsilons的元素丢进fun里返回来的东西</li><li>print ("啦啦啦%d，噜噜噜%s，嘻嘻嘻%.4lf" % (a, b,c))：格式化输出</li><li>‘啦啦啦{0}噜噜噜{1}’.format(a, b)：也是格式化输出，可以这样使用a =['abc is {}'.format(e) for e in epsilons]</li><li>Python写一个类记得要写构造函数def __init__(self):若需参数自己加</li><li>Python也可以写类，继承很简单，比如类A继承B，就写class A(B):即可</li><li>class A继承B的话，记得在A的构造函数里第一句加一个super(A,self).__init__(B的构造函数的参数)。这一步就是在填父类的构造函数</li></ul><h3 id="matplotlib.pyplot相关">matplotlib.pyplot相关</h3><p>plt.plot(x, y,label=)：x是一个列表，代表x轴的数据；y是一个列表，代表y轴的数据；label也是一个列表，代表不同线的名字（绘制多条线时使用）</p><p>plt.xlabel('xxx')：给x轴起名字</p><p>plt.ylabel('xxx')：给y轴起名字</p><p>plt.title('xxx')：起标题</p><p>plt.legend()：显示图例，要配合plt.plot中的label使用</p><p>plt.show()：把图画出来</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;许多代码都是用python实现的，我的python基础一般，所以在实践中学咯。下面记录一些
python常用的基础语法。&lt;/p&gt;</summary>
    
    
    
    <category term="多智能体强化学习" scheme="http://example.com/categories/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>1. 深度强化学习导论</title>
    <link href="http://example.com/2023/10/15/1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/"/>
    <id>http://example.com/2023/10/15/1-%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/</id>
    <published>2023-10-15T03:04:35.000Z</published>
    <updated>2023-10-30T13:56:19.224Z</updated>
    
    <content type="html"><![CDATA[<p>以下面这张图和一个例子来说明RL的基本逻辑</p><span id="more"></span><p><img src="1.png" /></p><p>假设智能体是一个刚出生的机器人，我们的目的是想训练它学会站起来行走。</p><p>那么它的动作有很多，比如脚摆动10°/20°，手摆动5°/2°，balablabla。</p><p>环境就是一个简单的笔直的通道，从机器人出生点到终点，只不过这条直道上有许多很矮的障碍。</p><p>奖励就是机器人离终点越近，它每走一个单位距离所能获得的奖励值就增加。并且规定如果机器人长时间没有前进，将会扣除奖励值。并且规定如果机器人被绊倒了，将会大大扣除奖励值。</p><p>状态就是智能体通过与环境交互后每一时刻的状态。比如时刻1它到达了某个点是一个状态，时刻2它在某个点被绊倒了也是一个状态。</p><p>通过设计这么一个机制，机器人为了得到最大奖励值，他就会逐渐学会站起来，并且走到终点。这就是深度强化学习（RL）。</p><blockquote><p>强化学习与监督学习的区别</p><p>监督学习里，都是有标签的，网络可以通过正确的标签来修正自己的预测。但是强化学习里没有，它只能通过与环境不断交互来优化自己的策略。</p></blockquote><p>下面通过一个实验，通过实际写代码，来加深对RL的理解：</p><p><img src="2.png" /></p><p>首先对问题进行建模，动作就是每个拉杆选择拉 /不拉。奖励就是拉下每个拉杆所获得奖励（中了得1分，没中得0分）。玩家就是我们自己。目标是在T次拉杆后，使得获得的奖励最大。</p><p>作为一个没头脑的人，我们可能随便拉，这样子显然不会使最大奖励收敛。</p><p>作为一个有一点头脑的人，他会这样做：拿出10%的机会去“冒险”，即随机拉一个杆，剩下90%机会去拉已经拉过的杆中获益估值最高的杆。</p><p>作为一个更聪明的人，他随着拉杆次数的增加，拿去“冒险”的机会比例会逐渐降低。因为他知道，随着拉杆次数的增加，他对每根杆的获益估值越来越准确，所以此时更优的方法是去拉已知估值最高的，而不是拿去随机冒险浪费次数。</p><p>通过上面这3个人的想法，我们其实已经可以有点感觉到本质了。“冒险”其实就是去探测每个拉杆的获奖概率值，“冒险”次数越多，拟合出来的每个拉杆的获奖概率值就越准。“不冒险”就是在自己拟合出来的每个拉杆概率下，选最优的。</p><p>好的，思路知道了，代码开搞。文中附有注释：</p><p>代码中有一点要解释一下，就是代码中的“懊悔”和“获益函数”。作为上帝视角的我们，肯定要评测不同策略（普通人、聪明人、更聪明的人）的表现。所以我们需要衡量标准。所以用“累计懊悔”来充当这个衡量标准。每次懊悔的计算公式很简单，即是(拉杆中最大获奖概率- 当前拉杆的获奖概率)。</p><p>然后是“获益函数”，获益函数就是上面所说的我们拟合的每个拉杆的获奖概率值的平均值。他的计算公式为：<span class="math inline">\(E_k = E_k +\frac{r_t - E_k}{N_k}\)</span>，k是第k个拉杆，<spanclass="math inline">\(r_t\)</span>是在时刻t时拉下拉杆k所获得的收益，<spanclass="math inline">\(N_k\)</span>是第k根拉杆被拉下的次数。</p><p>上面这个公式其实是这样推导的： <span class="math display">\[E_k = \frac{\sum_{t=1}^{N_t}r_t}{N_k} = \frac{\sum_{t=1}^{N_k-1}r_t +r_{N_k}}{N_k} = \frac{(N_k-1)E_{k-1}+r_{N_k}}{N_k} = E_{k-1} +\frac{r_{N_k}-E_{k-1}}{N_k}\]</span> 这样就得到了<spanclass="math inline">\(E_k\)</span>的递推公式，需要注意的是，代码中给<spanclass="math inline">\(E_k, k∈[1,K]\)</span>赋了初值1。因为这样能保证至少先把每个拉杆都拉一遍。</p><p>如果赋初值为0的话，那么真正只有“冒险”的时候才有几率去拉新杆了。这样的话新杆很难有机会拉到。</p><p>所以我们希望先把全部杆至少拉一遍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="comment"># 老虎机类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, K</span>):</span><br><span class="line">        self.K = K <span class="comment"># 拉杆数量</span></span><br><span class="line">        self.probs = np.random.uniform(low=<span class="number">0</span>, high=<span class="number">1</span>, size=K) <span class="comment"># 生成K个0~1的值作为每根拉杆的获奖概率</span></span><br><span class="line">        self.best_id = np.argmax(self.probs) <span class="comment"># 返回self.probs最大元素的下标值</span></span><br><span class="line">        self.best_prob = self.probs[self.best_id] <span class="comment"># 最大获奖概率</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">play</span>(<span class="params">self, k</span>): <span class="comment"># 模拟拉杆</span></span><br><span class="line">        <span class="keyword">if</span> np.random.random() &lt; self.probs[k]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.random.seed(1) # 设定随机种子，不然每次的随机数值都不一样</span></span><br><span class="line">K = <span class="number">10</span></span><br><span class="line">a = A(K) <span class="comment"># 实例化老虎机</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;生成了一个拉杆为%d个的老虎机&#x27;</span> % K)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;%d号拉杆的获奖概率最大，是%.4f&#x27;</span> % (a.best_id, a.best_prob))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solver</span>: <span class="comment"># 主实现函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a</span>):</span><br><span class="line">        self.a = a <span class="comment"># self.a就是老虎机实例化的一个对象</span></span><br><span class="line">        self.counts = np.zeros(a.K) <span class="comment"># 用来计算每根拉杆的尝试次数</span></span><br><span class="line">        self.regret = <span class="number">0</span> <span class="comment"># 当前步的累计懊悔</span></span><br><span class="line">        self.actions = [] <span class="comment"># 记录每一步的动作</span></span><br><span class="line">        self.regrets = [] <span class="comment"># 记录每一步的累计懊悔</span></span><br><span class="line">        self.T = <span class="number">0</span> <span class="comment"># 记录run的次数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_one_step</span>(<span class="params">self</span>): <span class="comment"># 返回当前这一步应该拉哪一根拉杆，具体由不同策略实现</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, num_steps</span>):</span><br><span class="line">        self.T = num_steps</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_steps):</span><br><span class="line">            k = self.run_one_step()</span><br><span class="line">            <span class="comment"># 更新第k根杆的拉动次数</span></span><br><span class="line">            self.counts[k] += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 更新动作</span></span><br><span class="line">            self.actions.append(k)</span><br><span class="line">            <span class="comment"># 更新懊悔</span></span><br><span class="line">            self.regret += self.a.best_prob - self.a.probs[k]</span><br><span class="line">            self.regrets.append(self.regret)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EpsilonGreedy</span>(<span class="title class_ inherited__">Solver</span>): <span class="comment"># epsilon贪心算法，继承Solver类（聪明人的策略）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, epsilon=<span class="number">0.01</span></span>): <span class="comment"># 构造函数</span></span><br><span class="line">        <span class="built_in">super</span>(EpsilonGreedy, self).__init__(a) <span class="comment"># 先对它的父类做一遍构造</span></span><br><span class="line">        <span class="comment"># 初始化探索率</span></span><br><span class="line">        self.epsilon = epsilon</span><br><span class="line">        <span class="comment"># 初始化所有拉杆的预期估值</span></span><br><span class="line">        self.estimates = np.array([<span class="number">1.0</span>] * a.K)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_one_step</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> np.random.random() &lt; self.epsilon:</span><br><span class="line">            k = np.random.randint(<span class="number">0</span>, a.K) <span class="comment"># 随机选择一根拉杆</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = np.argmax(self.estimates) <span class="comment"># 选择期望估值最高的拉杆</span></span><br><span class="line">        r = self.a.play(k) <span class="comment"># 拉动</span></span><br><span class="line">        <span class="comment"># 更新预期估值</span></span><br><span class="line">        self.estimates[k] += <span class="number">1</span> / (self.counts[k] + <span class="number">1</span>) * (r - self.estimates[k])</span><br><span class="line">        <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results</span>(<span class="params">solvers, solver_name</span>): <span class="comment"># 画图函数，solvers是策略列表，solver_name是策略的名字</span></span><br><span class="line">    <span class="keyword">for</span> idx, solver <span class="keyword">in</span> <span class="built_in">enumerate</span>(solvers):</span><br><span class="line">        x = <span class="built_in">range</span>(<span class="built_in">len</span>(solver.actions))</span><br><span class="line">        plt.plot(x, solver.regrets, label=solver_name[idx])</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;Time steps&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;Cumulative regrets&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;%d-bandit / Use method %s&#x27;</span> % (solver.a.K, solver_name[idx]))</span><br><span class="line">        plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建不同的epsilon值</span></span><br><span class="line">epsilons = [<span class="number">1e-4</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">0.25</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="comment"># 实例化EpsilonGreedy对象</span></span><br><span class="line">epsilon_greedy_solvers = [EpsilonGreedy(a, epsilon=e) <span class="keyword">for</span> e <span class="keyword">in</span> epsilons]</span><br><span class="line">epsilon_greedy_solvers_name = [<span class="string">&#x27;EpsilonGreedy(epsilon=&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(e) <span class="keyword">for</span> e <span class="keyword">in</span> epsilons]</span><br><span class="line"><span class="comment"># 开始run</span></span><br><span class="line"><span class="keyword">for</span> idx, solver <span class="keyword">in</span> <span class="built_in">enumerate</span>(epsilon_greedy_solvers):</span><br><span class="line">    solver.run(<span class="number">5000</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The cumulative regrets of %s is %.4lf&#x27;</span> % (epsilon_greedy_solvers_name[idx], solver.regret))</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plot_results(epsilon_greedy_solvers, epsilon_greedy_solvers_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DecayingEpsilonGreedy</span>(<span class="title class_ inherited__">EpsilonGreedy</span>): <span class="comment"># 更聪明的人的策略</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, a, epsilon=<span class="number">0.1</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(DecayingEpsilonGreedy, self).__init__(a, epsilon=epsilon)</span><br><span class="line">        self.count = -<span class="number">1</span></span><br><span class="line">        self.epsilon2 = self.epsilon</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run_one_step</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 让epsilon随着拉杆次数增加线性递减到0</span></span><br><span class="line">        self.count += <span class="number">1</span></span><br><span class="line">        self.epsilon =(-<span class="number">1</span> * self.epsilon2 / self.T) * self.count + self.epsilon2</span><br><span class="line">        <span class="keyword">if</span> np.random.random() &lt; self.epsilon:</span><br><span class="line">            k = np.random.randint(<span class="number">0</span>, a.K) <span class="comment"># 随机选择一根拉杆</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = np.argmax(self.estimates) <span class="comment"># 选择期望估值最高的拉杆</span></span><br><span class="line">        r = self.a.play(k) <span class="comment"># 拉动</span></span><br><span class="line">        <span class="comment"># 更新预期估值</span></span><br><span class="line">        self.estimates[k] += <span class="number">1</span> / (self.counts[k] + <span class="number">1</span>) * (r - self.estimates[k])</span><br><span class="line">        <span class="keyword">return</span> k</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">epsilons = [<span class="number">1e-4</span>, <span class="number">0.01</span>, <span class="number">0.1</span>, <span class="number">0.25</span>, <span class="number">0.5</span>]</span><br><span class="line"><span class="comment"># 实例化DecayingEpsilonGreedy对象</span></span><br><span class="line">decaying_epsilon_greedy_solvers = [DecayingEpsilonGreedy(a, epsilon=e) <span class="keyword">for</span> e <span class="keyword">in</span> epsilons]</span><br><span class="line">decaying_epsilon_greedy_solvers_name = [<span class="string">&#x27;DecayingEpsilonGreedy(epsilon=&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(e) <span class="keyword">for</span> e <span class="keyword">in</span> epsilons]</span><br><span class="line"><span class="comment"># 开始run</span></span><br><span class="line"><span class="keyword">for</span> idx, solver <span class="keyword">in</span> <span class="built_in">enumerate</span>(decaying_epsilon_greedy_solvers):</span><br><span class="line">    solver.run(<span class="number">5000</span>)</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&#x27;The cumulative regrets of %s is %.4lf&#x27;</span> % (decaying_epsilon_greedy_solvers_name[idx], solver.regret))</span><br><span class="line"><span class="comment"># 画图</span></span><br><span class="line">plot_results(decaying_epsilon_greedy_solvers, decaying_epsilon_greedy_solvers_name)</span><br></pre></td></tr></table></figure><p>让我们来看一下代码的运行结果：</p><p><img src="3.png" /></p><p><img src="4.png" /></p><p><img src="5.png" /></p><p><img src="6.png" /></p><p><img src="7.png" /></p><p>（俩图的标题的epsilon那错了懒得改了不影响）</p><p>对于图中这次生成的数据来说，“冒险”概率越低效果越好（曲线几乎不增长）。当然我自己在本地测试各种生成数据后总结发现冒险概率=0.01/0.1时表现最优。</p><p>然后使用DecayingEpsilonGreedy策略后表现更优了一些，对那些初始冒险率越大的优化效果越好。</p><p>通过这个案例，已经可以对RL有一个初步理解了。老虎机这个案例除了用Epsilon-Greedy，还可以用<strong>上置信界算法</strong>、<strong>汤普森采样算法</strong>方法去解决。这三种方法是解决绝大多数RL的基本思想。</p><p>但是老虎机这个案例是<strong>无状态强化学习</strong>，因为每一次与老虎机交互的结果和以往的动作无关。那有状态的强化学习怎么办呢？下一节将会对马尔可夫决策过程进行讲解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以下面这张图和一个例子来说明RL的基本逻辑&lt;/p&gt;</summary>
    
    
    
    <category term="多智能体强化学习" scheme="http://example.com/categories/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>0. 从博弈论到多智能体强化学习</title>
    <link href="http://example.com/2023/10/15/0-%E4%BB%8E%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%88%B0%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/10/15/0-%E4%BB%8E%E5%8D%9A%E5%BC%88%E8%AE%BA%E5%88%B0%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-10-14T17:53:28.000Z</published>
    <updated>2023-10-30T13:56:13.222Z</updated>
    
    <content type="html"><![CDATA[<p>什么是多智能体强化学习？比如快递工厂里的一个个快递机器，或者王者荣耀人机模式里的每个小兵，异或是现在自动驾驶中的每一辆车，都可以定义为智能体。让智能体进行强化学习是为了他们做出更好的决策。</p><span id="more"></span><h3 id="博弈论基本概念">博弈论基本概念</h3><ul><li>玩家集合：<ul><li><span class="math inline">\(N = \{1, 2, ..., n\}\)</span></li></ul></li><li>策略集合<ul><li><span class="math inline">\(A_1, A_2, A_3, ..., A_n\)</span></li></ul></li><li>收益函数<ul><li><span class="math inline">\(r_1=f_1(A_1, A_2, ...,A_n)\)</span></li><li><span class="math inline">\(r_2=f_2(A_1, A_2, ...,A_n)\)</span></li><li>... ...</li><li><span class="math inline">\(r_n=f_n(A_1, A_2, ...,A_n)\)</span></li></ul></li></ul><p>用“囚徒困境”这个例子来进一步理解：</p><p><img src="1.png" /></p><p>如图是两个玩家，玩家一是绿色的，玩家二是红色的。每个人选择坦白 /抵赖所获得的分数如图。</p><p>若玩家1选择坦白，则玩家2必然选择坦白，因为比起0分1，1分显然更好。</p><p>若玩家1选择抵赖，则玩家2也是选择坦白。</p><p>所以不管玩家1选什么，玩家2都会选择坦白，坦白是玩家2的<strong>占优策略</strong>。</p><p>同样的，不管玩家2选什么，玩家1也都会选择坦白，坦白也是玩家1的<strong>占优策略</strong>。</p><p>所以博弈结果必然就是俩人都选择坦白。</p><p>假如修改一下游戏规则呢？</p><p><img src="2.png" /></p><p>此时若玩家2的占优策略仍然是坦白。</p><p>但是若玩家2选择坦白，则玩家1会选择坦白。若玩家2选择坦白，则玩家1会选择抵赖。此时坦白就不是玩家1的占优策略了。</p><p>那么玩家1应该如何做决策呢？</p><p>因为俩玩家都是绝顶聪明，所以玩家1肯定知道玩家2做出了它的占优策略——坦白。所以玩家1既然知道玩家2选坦白，他也就只能选坦白。此时坦白是玩家1的<strong>最佳应对</strong>。</p><p>通过这个例子，我们感受了一下博弈论，还学到俩新名词，<strong>占优策略</strong>和<strong>最佳应对</strong>。</p><p>下面我们来看博弈论的解：</p><p>正如同上面的囚徒困境，一些博弈问题是存在解的：解 =即任何玩家都不能通过独自改变策略而获益时的策略组合，换句话说，解 =所有玩家处于最佳应对时的策略组合。</p><p>数学定义如下：</p><ul><li><p>给定一个策略组合 <spanclass="math inline">\(a=(a_1,a_2,...,a_n)\in A_1\timesA_2\times...\times A_n,\)</span></p></li><li><p>若 <span class="math display">\[r_1(a_1,a_2,...,a_n)\geq r_1(a_1^{\prime},a_2,...,a_n), \foralla_1^{\prime}\in A_1 \\r_2(a_1,a_2,...,a_n)\geq r_{1}(a_{1},a_{2}^{\prime},...,a_{n}),\foralla_{2}^{\prime}\in A_{2} \\... ... \\r_n(a_1,a_2,...,a_n)\geq r_n(a_1,a_2,...,a_n^{\prime}),\foralla_n^{\prime}\in A_n\]</span></p></li><li><p>那么策略组合<spanclass="math inline">\(a\)</span>是一个纳什均衡。</p></li><li><p>下面介绍另一种博弈情况（混合策略）下的解——混合纳什均衡。</p><ul><li>混合策略：每个玩家都有一个概率分布<span class="math inline">\((p_1,p_2, ..., p_n), p_i\)</span>为玩家选择动作i的概率。</li><li>混合纳什均衡：等于一个混合策略组合。s.t.任何玩家都不能通过独自改变自身混合策略来提高自己的期望收益。</li><li>定理：任意一个博弈，必然存在一个混合策略纳什均衡。</li></ul></li><li><p>例如下面这个例子，此博弈的混合策略纳什均衡就是每个人的混合策略都为<spanclass="math inline">\(\frac{1}{3}, \frac{1}{3},\frac{1}{3}\)</span>。</p></li></ul><p><img src="3.png" /></p><ul><li>当然博弈还有许多种均衡，上面只是介绍了最基础的纳什均衡和混合策略纳什均衡。博弈也有很多种博弈（只要加上不同的限定条件），比如所有人收益都是一样的就叫合作博弈，所有人收益之和是一个定值就叫竞争博弈。</li></ul><h3 id="从博弈论走到多智能体强化学习">从博弈论走到多智能体强化学习</h3><p>现实中，博弈玩家、玩家策略的数量都很大很大，而且玩家自身的收益函数可能并不知道，需要一点一点与环境交互才知道。所以用简单的博弈论模型去描述现实问题会比较困难。</p><p>所以下面引入一个新的博弈模型——马尔科夫博弈</p><ul><li><p>玩家集合</p><ul><li><span class="math inline">\(N = \{1, 2, ..., n\}\)</span></li></ul></li><li><p>策略集合</p><ul><li><span class="math inline">\(A_1, A_2, A_3, ..., A_n \\ A = A_1\times A_2 \times ... \times A_n\)</span></li></ul></li><li><p>状态集合</p><ul><li><span class="math inline">\(S = \{s_1, s_2, ..., s_n\}\)</span></li></ul></li><li><p>转移函数</p><ul><li>如果已知当前状态<span class="math inline">\(s_i\)</span>,和当前策略<span class="math inline">\(a_i\)</span>,有概率得到下一个状态<span class="math inline">\(s_i&#39;\)</span>。</li><li>概率函数就是描述上面这个过程的概率是多少。</li><li><span class="math inline">\(f(s_i, a_i, s_i&#39;)\)</span></li></ul></li><li><p>收益函数</p><ul><li><span class="math inline">\(r_i\)</span>由S和A确定</li></ul></li></ul><p>上面这个博弈模型就可以描述现实生活中绝大多数博弈模型。</p><p>那强化学习跟博弈论又有什么学习呢？</p><p>强化学习也分好几种，第一种叫状态价值学习，即有一个状态价值函数<spanclass="math inline">\(Q(s,a)\)</span>，表示在s状态下采取a动作所能获得的期望累积收益。通过神经网络拟合Q函数，不断学习来使得它收敛。这是状态价值学习。</p><p>那放到多智能体中，在当前状态S下，每个玩家都可以通过强化学习得出自己的<spanclass="math inline">\(Q_{max}(s_i, a_i), a_i∈A_i\)</span>，拿前面囚徒困境去类比的话，就是<spanclass="math inline">\(a_1\)</span>为坦白，<spanclass="math inline">\(a_2\)</span>为抵赖。也就是此时就可以建模出一个简单的博弈论模型。</p><p>当多智能体们通过博弈后，又得到了下一个状态S'。于是再用强化学习算出在状态S'下，每个玩家的<spanclass="math inline">\(Q_{max}\)</span>，循环往复以此类推。最后就可以收敛于最优解。</p><h3 id="总结">总结</h3><p>上面所讲的知识的目的皆在引入博弈论和多智能体强化学习两个概念。所以许多地方为了方便理解没有很严谨，有许多漏洞之处。但作为一个刚入门的小白（比如我），已经可以给我一个大概的理解和感受了，这就是此篇blog的目的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么是多智能体强化学习？比如快递工厂里的一个个快递机器，或者王者荣耀人机模式里的每个小兵，异或是现在自动驾驶中的每一辆车，都可以定义为智能体。让智能体进行强化学习是为了他们做出更好的决策。&lt;/p&gt;</summary>
    
    
    
    <category term="多智能体强化学习" scheme="http://example.com/categories/%E5%A4%9A%E6%99%BA%E8%83%BD%E4%BD%93%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="http://example.com/2023/10/14/Linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/10/14/Linux%E5%9F%BA%E7%A1%80/</id>
    <published>2023-10-14T10:08:55.000Z</published>
    <updated>2023-10-14T10:14:20.306Z</updated>
    
    <content type="html"><![CDATA[<p>大二学数据库这门课的时候接触到了Linux，因为期末大作业是在Linux环境下进行的。涉及到Linux系统编程函数的一些调用。所以学习Linux的基本使用就十分必要。</p><span id="more"></span><h3 id="前言">前言</h3><p>在Windows上想使用Linux系统可以用虚拟机（VM /Hyper-V）或者wsl或者docker。如果使用虚拟机的话建议装一个Finalshell，这样就不用频繁的在虚拟机和win界面里切换了。</p><h3 id="linux系统目录">Linux系统目录</h3><p>Linux下一切皆文件，所以了解Linux的一些系统目录是干啥的就很重要：</p><p>/dev：与本机设备（比如鼠标）有关的目录</p><p>/etc：配置文件信息</p><p>/home：用户目录</p><p>/lib：库目录（比如C库、python库）</p><p>/media、/mnt：磁盘挂载目录</p><p>/opt、/proc：进程目录</p><p>/usr：Unix Software Resource，软件目录，比如第三方安装的qq</p><p>/bin：存放二进制可执行文件</p><p>/boot：存放开机启动程序</p><p>一般/etc和/home是经常用的，如果你是用wsl的话/mnt也比较常用。</p><p>前面提到Linux下一切皆文件，但是Linux里对文件的命名比较不规范。文件名可以随便自己起，所以你可以起一个名为test.mp3的文件，然后在里面只写一点文本。</p><p>所以使用file 文件名 命令可以知道这个文件到底是属于啥文件。</p><p>在Linux下的文件类型如下：</p><ol type="1"><li>普通文件：-</li><li>目录文件：d</li><li>软链接：l</li><li>字符设备文件：c</li><li>块设备文件：b</li><li>管道文件：p</li><li>套接字：s</li></ol><p>一般前三种我比较常见。</p><h3 id="linux基础命令">Linux基础命令</h3><h4 id="快捷键相关">快捷键相关</h4><p>ctrl + c：强制中断当前进程</p><p>ctrl + l：清屏</p><p>ctrl + a：跳转到行首</p><p>ctrl + e：跳转到行尾</p><p>ctrl + ←：往左跳一个单词</p><p>ctrl + →：往右跳一个单词</p><p>ctrl + r：进入命令搜索模式</p><h4 id="用户相关">用户相关</h4><p>sudo - username：切换用户</p><p>sudo 命令：以root用户的权限执行这条命令</p><p>chmod 777 filename：修改文件的权限（三个数字分别对应user, group,others）</p><h4 id="查看文件相关">查看文件相关</h4><p>cat filename：查看文件</p><p>more filename：分屏查看文件</p><p>head filename：查看文件开头几行</p><p>tail filename：查看文件后面几行</p><p>tree：以树目录形式展现当前目录（需apt install tree）</p><p>ls -l / -h /-a：查看文件详细信息，以列表/以人类形式(可以看文件占多少M)/显示隐藏文件</p><h4 id="文件操作相关">文件操作相关</h4><p>mkdir dirname：创建文件夹</p><p>touch filename：创建文件</p><p>cp path1 path2 [-r]：将path1的东西复制到path2那</p><p>mv path1 path2：将path1的东西移动到path2那</p><p>rm [-r] path：删除path处的东西</p><p>ln -s path链接：将path处的东西创建软链接（path处要写绝对路径，因为本质就是每次访问链接的时候都是去访问path）</p><p>ln path 链接：将path处的东西创建硬链接，形成铁索连环的效果</p><p>find path -name/-type/-size 条件 -exec rm {} ; ：批量删除文件</p><h4 id="查找相关">查找相关</h4><ul><li>文件—基本查找（看文件路径在哪）</li></ul><p>find path -name 'xxx'：按文件名字来找</p><p>find path -type 'xxx'：按文件类型来找</p><p>find path -size +/-(num)k/M/G：按文件大小来找</p><ul><li>文件—详细查找</li></ul><p>find ... ... | xargs ls -l -h</p><ul><li>内容查找</li></ul><p>grep 'xxx' path [-r][-n]：-n是显示行号，如果path为文件夹则需要加-r</p><p>ls -l | grep 'xxx' -n 或 cat filename | grep 'xxx' -n 或 ps aux |grep 'xxx' -n 或 lsof -u username | grep 'xxx'-n：在某些输出内容中找特定内容</p><h4 id="软件包解压缩相关">软件包，解压缩相关</h4><p>apt install xxx：安装软件包</p><p>apt remove xxx：删除软件包</p><p>dpkg -i xxx.deb：安装.deb软件包</p><p>源码安装（具体方法看每个源码中的README.md）：</p><ol type="1"><li>解压源代码包</li><li>cd dir（源代码包）</li><li>运行./configure（这一步是检测文件是否缺失以及创建Makefile以及检测编译环境）</li><li>运行make（这一步是在编译源码、生成库和可执行程序）</li><li>运行make install（这一步是把库和可执行程序安装到系统路径下）</li></ol><p>tar -zcvf 压缩包名 压缩材料：压缩</p><p>tar -zxvf 压缩包名：解压</p><h4 id="其它常用指令">其它常用指令</h4><p>alias别名='指令'：给指令起别名，只能临时生效（永久生效将alias语句写入~/.bashrc，然后source~/.bashrc）</p><p>ps aux：查看进程</p><p>lsof -u username：查看user打开的文件</p><p>gcc filename -o 输出名字：编译c程序（需apt install gcc）</p><p>g++ filename -o 输出名字：编译c++程序（需apt install g++）</p><p>man -k 函数名：查看Linux函数在man手册中的章节</p><p>man 章节 函数：查看Linux函数在man手册中的讲解</p><h4 id="vim相关">vim相关</h4><p>适应不了vim可以用nano。</p><p>ESC：返回命令模式</p><p>a/i：进入编辑模式</p><p>冒号：进行底栏模式</p><p>:wq：保存并退出</p><p>:set nu：显示行号</p><p>hjkl：上下左右</p><p>0：移动到行首</p><p>$：移动到行尾</p><p>gg：移动到文件开头</p><p>G：移动到文件结尾</p><p>数字 + G：移动到指定行</p><p>x：删除单个字符</p><p>dd：删除当前行</p><p>d0：删除光标到行首</p><p>d$：删除光标到行尾</p><p>v + hjkl + d：删除选定内容</p><p>v + hjkl + y：复制选定内容</p><p>p：粘贴</p><p>u：撤销</p><p>ctrl + u：反向撤销</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;大二学数据库这门课的时候接触到了Linux，因为期末大作业是在Linux环境下进行的。涉及到Linux系统编程函数的一些调用。所以学习Linux的基本使用就十分必要。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>期末Lab1 存储管理</title>
    <link href="http://example.com/2023/10/09/%E6%9C%9F%E6%9C%ABLab1-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2023/10/09/%E6%9C%9F%E6%9C%ABLab1-%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</id>
    <published>2023-10-09T13:03:39.000Z</published>
    <updated>2023-10-12T05:46:40.560Z</updated>
    
    <content type="html"><![CDATA[<p>今天突然就上强度了。实验课是让我们设计一个简单的RDBMS原型系统。（本质上就是参考的CMU15-445课程和StanfordCS346的课程）我觉得还是蛮有趣的，开一个系列来记录实验过程。</p><p>本篇是Lab 1，存储管理部分的内容。</p><span id="more"></span><p>课程目标：</p><p><img src="1.png" /></p><h3 id="一.-安装docker以及基本操作">一. 安装Docker以及基本操作</h3><p>为了简化实验过程，尽可能的避免复杂的环境配置过程。助教推荐我们使用Docker，这样直接就能使用他配置好的环境。</p><h4 id="docker是什么">1. Docker是什么</h4><p>根据我浅薄的理解，Docker就是虚拟机。装一个Docker，下载网上的镜像，然后把实例化为一个容器。此时容器就是一台虚拟机了。</p><h4 id="如何安装docker">2. 如何安装Docker</h4><p>先安装wsl，wsl是在window下的linux子系统功能。本人Win11电脑，先在“启动或关闭Windows功能”里打开“虚拟机平台”和“适用于Linux的Windows子系统”，然后终端里输入wslupdate，更新完后再输入wsl --install -dUbuntu，设置好Ubuntu用户名和密码后退出即可。</p><p>然后下载DockerDesktop，下载好后不要安装。因为默认路径是C盘，后续可能会很占空间。通过软链接的方法把Docker装到D盘，终端里输入（记得用管理员权限）：mklink/j "C:\Program Files\Docker""D:\app\Docker"（如果报错没找到文件夹则在目标路径下自己新建文件夹后再执行）。</p><p>点击安装包，一路Next。安装好后在Docker设置里的DockerEnginel里改变源：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;debug&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>至此，Docker就安装好了。</p><h4 id="docker的基本操作">3. Docker的基本操作</h4><p>Docker里有三种东西，镜像、容器、仓库。</p><p>镜像(image)是类似模板的东西，是一个只读文件。可以用来创建容器。</p><p>容器(container)就是我们操作的“虚拟机”，它需要根据镜像实例化出来。</p><p>仓库(repository)就是存储镜像的地方，我们通常可以从三个地方获得镜像：官方仓库、第三方仓库、本地</p><p>基本操作如下：</p><ol type="1"><li><p>列出本地的所有镜像</p><ul><li>docker image ls</li></ul></li><li><p>拉取镜像到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 拉取官方镜像</span><br><span class="line">docker pull 镜像名称</span><br><span class="line">例：docker pull ubuntu</span><br><span class="line"></span><br><span class="line"># 拉取个人镜像</span><br><span class="line">docker pull 仓库名称/镜像名称</span><br><span class="line">例：docker pull xunmi/django</span><br><span class="line"></span><br><span class="line"># 第三方仓库拉取</span><br><span class="line">docker pull 第三方仓库地址/仓库名称/镜像名称</span><br><span class="line">例：docker pull hub.c.163.com/library/mysql:latest</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p><ul><li>docker rmi 镜像名</li><li>注意删镜像时需保证此时没有容器以该镜像为模板进行实例化。</li></ul></li><li><p>删除容器</p><ul><li>docker rm 容器名</li><li>注意删除容器时需保证该容器没有在运行。</li></ul></li><li><p>关于管理镜像 &amp; 容器</p><ul><li>可以在Docker Desktop的Dashboard里进行管理。</li></ul></li></ol><h3 id="二.-docker在本实验中的运用">二. Docker在本实验中的运用</h3><p>本实验要实现一个RDBMS，所以代码基本框架可以从助教发布的GitHub上clone到本地。但是当你完善了代码，如何知道自己对不对呢？肯定要测评嘛，以及编译这个RDBMS应该怎么办呢？比如代码用到了C++17的特性但是本地编译不了就很尴尬。所以需要Docker，助教发给我们一个镜像文件，我们把它实例化一个容器到本地。然后将刚刚clone下来的项目文件夹同步到容器中（也就是实现文件共享）。这样子我们就可以在本地编写程序，文件自动就会同步到容器中，编写完成后。通过Docker进入容器中，编译程序并进行测评，查看自己编写的程序是否正确。</p><h4 id="初次配置流程">1. 初次配置流程：</h4><ol type="1"><li>下载助教发的base-env.img镜像文件到本地，cd到img所在文件夹，在终端里输入dockerimage load --input ./base-env.img拉取镜像到Docker中。（或者直接dockerpull cc0de/base-env:1.0）</li><li>将助教上传到GitHub的项目文件夹clone到本地，我自己的路径是：D:/Projects/dbProjects/lab1/UniBase(UniBase是clone下来的文件夹)</li><li>cd到lab1下，在终端里输入docker run -itd -v .\UniBase:/mnt/UniBase--name unibase-envbase-env。这句话的意思就是将名为base-env的镜像文件实例化为一个容器到本地，名字起为unibase-env。并且将当前目录下的UniBase文件夹同步到unibase-env容器中/mnt下的UniBase文件夹。（mnt文件夹是wsl子系统与宿主系统进行文件交互的文件夹）</li><li>cd到UniBase下，输入git submodule init和git submoduleupdate来拉取子模块(google test)</li><li>如果需要进容器，输入docker exec -it unibase-env/bin/bash。如果退出，输入exit。</li></ol><h4 id="编写流程">2. 编写流程：</h4><ol type="1"><li>先在本地，用vscode写好程序</li><li>开docker desktop，然后进容器docker exec -it unibase-env/bin/bash（建议为了了方便可以在win下的powershell里写一个alias，我把这段命令起别名为dockerC1了），进UniBase里，新建一个build文件夹，在里面运行：cmake..-DCMAKE_BUILD_TYPE=Debug（我把这段代码起别名ccmake了），就可以生成整个项目的编译文件，然后make某个module，比如makedisk_manager_test，就会编译这个模块并在/build/bin里生成可执行文件，进入bin里运行它就可以看到评测信息。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天突然就上强度了。实验课是让我们设计一个简单的RDBMS原型系统。（本质上就是参考的CMU15-445课程和StanfordCS346的课程）我觉得还是蛮有趣的，开一个系列来记录实验过程。&lt;/p&gt;
&lt;p&gt;本篇是Lab 1，存储管理部分的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="大学" scheme="http://example.com/categories/%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数据库" scheme="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>数字逻辑自学笔记</title>
    <link href="http://example.com/2023/10/06/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/06/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-06T08:57:58.000Z</published>
    <updated>2023-10-29T13:00:19.677Z</updated>
    
    <content type="html"><![CDATA[<p>写于2023/10/6，这门课其实还是有点意思的。但是上个月身体原因一直在关心我自己的身体，所以这门课我全翘掉了，一点没听。现在马上就要实验课了，于是打算在国庆的末尾把这门课学了。目的是能做出几个组合逻辑电路的实验项目。</p><p>自学参考的内容为老师ppt、各种网上博客。</p><p>学完后打算去刷题巩固一下，刷题打算在一个up主视频里刷：<ahref="https://www.bilibili.com/video/BV1H54y1k7kM?p=1&amp;vd_source=2501060da9b4bef86e2b8ec8a8d880b5">传送门</a></p><p>最后，如果有朋友打算认真看这篇Blog进行学习的话，为了更好的阅读体验建议开梯子，因为本文有许多图片和一个视频。（存储在github中）</p><span id="more"></span><p>先放一张各种门的符号图，后面忘了的话可以参考：</p><p><img src="1.png" /></p><p><img src="2.png" /></p><h3 id="一.-组合逻辑电路1">一. 组合逻辑电路(1)</h3><h4 id="概述">1.1. 概述</h4><p>电路分为组合逻辑电路和时序逻辑电路。差别就是组合逻辑电路无记忆功能，时序逻辑电路有。</p><p>描述电路的逻辑功能有以下几种形式：</p><ol type="1"><li>语言描述</li><li>电路图</li><li>逻辑表达式，即y = f(a1, a2, a3, ..., an)</li><li>真值表</li><li>卡诺图</li><li>波形图</li></ol><h4 id="组合逻辑电路的分析-和-逻辑函数的设计方法">1.2.组合逻辑电路的分析 和 逻辑函数的设计方法</h4><ul><li><p><strong>分析</strong>：</p><ul><li><p>即给你一个电路，让你告诉我这个电路是干啥用的。</p></li><li><p>分析一个组合逻辑电路的固定套路很简单：</p><ol type="1"><li>一层一层写出逻辑表达式</li><li>对最后得到的逻辑表达式进行化简<ul><li>化简手段1：卡诺图</li><li>化简手段2：<span class="math inline">\(A + A \cdot B = A 或 A \cdot(A + B) = A\)</span></li><li>化简手段3：<span class="math inline">\(A + \overline{A}B = A + B 或A \cdot (\overline{A} + B) = A \cdot B\)</span></li><li>化简手段4：<span class="math inline">\(\overline{A}\overline{C} +A\overline{B} + \overline{B}\overline{C} = \overline{A}\overline{C} +A\overline{B}\)</span>（对于<spanclass="math inline">\(\overline{B}\overline{C}\)</span>添项即可证明）</li><li>化简手段5：<span class="math inline">\(A \oplus B = \overline{A}B +A\overline{B}\)</span></li><li>化简手段6：<span class="math inline">\(A \odot B = (\overline{A} +B)(A + \overline{B})\)</span></li></ul></li><li>对化简后的逻辑表达式列真值表，观察真值表，观察出此电路的功能</li></ol></li><li><p>例子：</p><p><img src="3.png" /></p><ul><li>T1是个与门，T2是个或门，第一层剩下都是与门，第二层一个或门，第三层一个非门，第四层一个与门，最后一层一个或门。最后通过真值表很容易看出ABC三个输入变量但有两个输出变量。不难想到是一个全加器。A、B是两个加数，C是上一位的进位，F1是当前位，F2是进位。</li><li>还有许多功能电路啦......比如半加器（2输入2输出）、投票表决器（多输入1输出）、奇校验电路（多输入1输出）、一致性电路（多输入1输出）</li></ul></li></ul></li><li><p><strong>设计</strong>：</p><ul><li><p>告诉你一个功能，让你设计出一个电路来实现它。</p></li><li><p>也是有固定套路的：</p><ol type="1"><li><p>分析功能，确定输入输出变量</p><ul><li>确定输入输出变量还是有点讲究的，有时候设计的好了可以大大减少运算量和电路的复杂程度。比如下面两个功能，换做是你，你会怎样设计？</li></ul><p><img src="4.png" /> <img src="5.png" /></p><ul><li>设计的关键其实是做到尽可能的<strong>复用</strong>，即对于不同对象的同一属性，尽量用一个变量表达出来。</li></ul></li><li><p>根据题意，直接构造出电路。或者写出真值表然后写出主析取范式然后再用卡诺图化简后得到最终逻辑表达式</p></li><li><p>根据逻辑表达式，选取一种门电路，画出电路图</p></li></ol></li></ul></li></ul><hr /><h3 id="二.-组合逻辑电路2">二. 组合逻辑电路(2)</h3><p>上一节我们已经可以设计出逻辑表达式。但是具体选用哪一种门电路呢？每一种门电路应该如何设计呢？这一节我们就来学习。</p><h4 id="单输出电路设计">2.1. 单输出电路设计</h4><h5 id="用与非门设计电路">2.1.1. 用与非门设计电路</h5><p>对于逻辑表达式F = ...中的 + 全部换成 <spanclass="math inline">\(\cdot\)</span> 就好了，按照这个思路，只要在 +的头上画两根取反号就行了，最上面那根保留，下面那根负责把 + 换成 <spanclass="math inline">\(\cdot\)</span> 。</p><p>但这样得到的实际电路可能耗材过多，实际中有些式子通过观察还能发现可以化的更简，比如下面这个例子：</p><p><span class="math inline">\(F = A\overline{B} + B\overline{C} +C\overline{D} + D\overline{A} = \overline{\overline{A\overline{B}} \cdot\overline{B\overline{C}} \cdot \overline{C\overline{D}} \cdot\overline{D\overline{A}}}\)</span></p><p>按理说这样就好了，但是还可以化简的。</p><p><span class="math inline">\(\overline{A\overline{B}} \cdot\overline{B\overline{C}} \cdot \overline{C\overline{D}} \cdot\overline{D\overline{A}} = (\overline{A} + B)(\overline{B} +C)(\overline{C} + D)(\overline{D} + A)\)</span></p><p>上面这个东西，学过二项式定理吗？假如我第一项如果挑B，则第二项不能挑<spanclass="math inline">\(\overline{B}\)</span>，只能挑C，那么第三项也只能挑D，依次类推，第四项只能挑A，得到ABCD。同理，如果我第一项挑<spanclass="math inline">\(\overline{A}\)</span>，那么我只能得到<spanclass="math inline">\(\overline{A}\overline{B}\overline{C}\overline{D}\)</span>。</p><p>即：<span class="math inline">\((\overline{A} + B)(\overline{B} +C)(\overline{C} + D)(\overline{D} + A) = ABCD +\overline{A}\overline{B}\overline{C}\overline{D}\)</span></p><p>对上面那玩意再求两次反，得到<spanclass="math inline">\(\overline{\overline{ABCD} \cdot\overline{\overline{A}\overline{B}\overline{C}\overline{D}}}\)</span></p><p>这样子，就得到<span class="math inline">\(F =\overline{\overline{\overline{ABCD} \cdot\overline{\overline{A}\overline{B}\overline{C}\overline{D}}}}\)</span></p><p>总结下来这个第二种方法就是在第一种方法的基础上把内部通过二项式定理进一步化简。</p><h5 id="用或非门设计电路">2.1.2. 用或非门设计电路</h5><p>对于逻辑表达式F = ...中的 <span class="math inline">\(\cdot\)</span>全部换成 + 就好了，按照这个思路，只要在 <spanclass="math inline">\(\cdot\)</span>的头上画两根取反号就行了，最上面那根保留，下面那根负责把 <spanclass="math inline">\(\cdot\)</span> 换成 + 。</p><p>还有第二种通用的方法，就是将F先求对偶，得到<spanclass="math inline">\(F_d\)</span>，这样F就由(xxx) + (xxx) +(xxx)的形式变为(x + x)(x + x)(x +x)的形式了。学过二项式定理吗？同理将<spanclass="math inline">\(F_d\)</span>化简，得到最简“与-或”式(yyy) +(yyy)。再在头上加两根取反，最顶上保留，下面那根为了把 + 变成 <spanclass="math inline">\(\cdot\)</span> ，最后再对偶回去即可。</p><p>上面那段文字是具体过程，流程总结下来如下：</p><ol type="1"><li>对F求对偶<span class="math inline">\(F_d\)</span></li><li>对<spanclass="math inline">\(F_d\)</span>展开，利用二项式原理或者卡诺图，得到最简"与-或"式<spanclass="math inline">\(F_d&#39;\)</span></li><li>对<spanclass="math inline">\(F_d&#39;\)</span>取两次反，最上面保留，下面那根化开，得到<spanclass="math inline">\(F_d&#39;&#39;\)</span></li><li>对<span class="math inline">\(F_d&#39;&#39;\)</span>对偶回去</li></ol><h5 id="用与或非门设计电路">2.1.3. 用与或非门设计电路</h5><p>这个就更简单了，因为给出的函数表达式都是形如F = xyz + xyz +xyz，所以只需要在F头上加两条杠就好了。</p><p>第二种思路就是跟用与非门设计电路的第二种方法一样。加两条杠，最上面不动，下面那个把xyz+ xyz +xyz变成()()()型，然后二项式定理展开即可。（如果是与非门第二种设计思路还要将展开的东西再取两次反）</p><h4 id="多输出电路设计">2.2. 多输出电路设计</h4><p>啊，最直接的想法就是分别把每个输出对应的电路设计出来就好了。但是这样比较憨，当我们化简得到了每个输出对应的逻辑表达式的时候，我们应该能尽可能使每一项<strong>复用</strong>。看下面这个例子：</p><p><img src="6.png" /></p><p>可以发现原<span class="math inline">\(F_1\)</span>中的<spanclass="math inline">\(A\overline{B}\)</span>可以变成<spanclass="math inline">\(A\overline{B}\overline{C}\)</span>，这样就跟<spanclass="math inline">\(F_2\)</span>中的<spanclass="math inline">\(A\overline{B}\overline{C}\)</span>一样了，做到了复用。</p><h4 id="包含无关项的电路设计">2.3. 包含无关项的电路设计</h4><p>其实很简单，看下面这个例子就懂了。</p><p><img src="7.png" /></p><p><img src="8.png" /></p><p>首先我们知道余3码是在8421码的基础上+3得到，因为8421码只有10位，所以余3码也只有10位。而且8421码最小是0000，所以余3码最小是0011（对应十进制数1）。所以这就在输出F中产生了许多无关项d。在画卡诺图时，若不考虑无关项，则把d全置为0；考虑无关项则把d全置为1。最后得到化简后的函数表达式。然后再将这个函数表达式用与非门设计。</p><h4 id="考虑级数的电路设计">2.4. 考虑级数的电路设计</h4><p>也是看一道例题就可以理解了。</p><p><img src="9.png" /></p><p>先用最直接的方法，与或非门直接加两条杠结束。与非门直接加两条杠，下面那条杠化开结束。</p><p>但是这样设计级数会不会多呢？</p><p>如果我们用"与或非门设计电路"中第二种化简方法，试一下：</p><p><span class="math inline">\(F = \overline{\overline{AB +\overline{A}C}} = \overline{\overline{AB} \cdot\overline{\overline{A}C}} = \overline{(\overline{A} + \overline{B})(A +\overline{C})} = \overline{\overline{A}\overline{C} + A\overline{B} +\overline{B}\overline{C}} = \overline{\overline{A}\overline{C} +A\overline{B}}\)</span></p><p>可以发现，这样设计只有3层。但是原来那样直接加两条杠是4层。所以当考虑电路的级数时，在用与或非门设计电路时，可以考虑进一步化简优化电路的级数。</p><p>如果用与非门，就不需要考虑进一步化简了。因为在与非门进一步化简后，还需要再内部再添加两条杠。级数肯定比不继续化简多。</p><h4 id="综合题">2.5. 综合题</h4><ul><li>设计一个组合电路，将8421BCD码变换为余3码。</li></ul><p>先确定输入输出变量，因为8421BCD码是用四个二进制数表示十进制数0~9，所以有四个输入A、B、C、D代表四个二进制数。同理四个输出W、X、Y、Z代表变换后的余3码。</p><p>然后列出真值表，因为BCD只能表示十进制0~9，所以注意表中有无关项d。</p><p><img src="10.png" /></p><p>这里不考虑无关项，所以在后续画卡诺图时都将d置为0。</p><p>因为是四个输出，所以属于多输出电路。所以先画四个卡诺图得到四个逻辑表达式（其实对于Z，发现其很有规律不用画卡诺图都可以知道它就是<spanclass="math inline">\(\overline{D}\)</span>）</p><p>画卡诺图过程省略，得到四个逻辑表达式： <span class="math display">\[W = A + BC + BD \\X = \overline{B}C + \overline{B}D + B\overline{C}\overline{D} \\Y = CD + \overline{C}\overline{D} \\Z = \overline{D}\]</span>此时我们需要思考，是否能做到项的<strong>复用</strong>呢？乍一看没发现能复用的，所以先不考虑复用，继续将式子进一步化简先。先从简单的开始画：</p><p><span class="math inline">\(Z = \overline{D}\)</span></p><p><span class="math inline">\(Y = \overline{C} \oplus D\)</span></p><p><span class="math inline">\(X = \overline{B}(C + D) + B\overline{(C +D)} = B \oplus (C + D) = B \oplus\overline{\overline{C}\overline{D}}\)</span></p><p><span class="math inline">\(W = A + B(C + D) = A +B\overline{\overline{C}\overline{D}}\)</span></p><p>化简后可以发现，<spanclass="math inline">\(\overline{\overline{C}\overline{D}}\)</span>这个东西可以做到复用，真不错。</p><p>接下来就是选择门电路来设计电路了。这里我选择最常用的与非门 +异或门设计电路。根据上面的逻辑表达式直接设计即可（W还需化简一下：<spanclass="math inline">\(W = \overline{\overline{A} \cdot\overline{B\overline{\overline{C}\overline{D}}}}\)</span>）</p><p>最后画出电路：</p><p><img src="11.png" /></p><hr /><h3 id="三.-组合逻辑电路3">三. 组合逻辑电路(3)</h3><h4 id="编码器">3.1 编码器</h4><p>按照我的理解，就是把数字变成二进制数。比如把0 ~8变成3位二进制数，或者0 ~ 15变成4位二进制数。</p><p>编码器分为普通编码器 和 优先编码器。</p><ul><li><strong>普通编码器</strong></li></ul><p>特点：任何时刻只允许输入一个编码信号。</p><p>最常见的普通编码器为8线-3线编码器，如下图：</p><p><img src="12.png" /></p><p>它的真值表如下：</p><p><img src="13.png" /></p><p>可以看出，假如我<spanclass="math inline">\(I_7\)</span>为高电平，则输出111，就是7的二进制。</p><p>那内部电路如何设计呢？根据真值表得出逻辑表达式然后化简，再选用与非门实现即可。</p><p>上面这个是8线-3线普通编码器，那如何实现8421-BCD普通编码器呢？</p><p>很简单，10个输入，4个输出。列出真值表，发现会有无关项。不考虑无关项，根据真值表得出4个输出的逻辑表达式，然后根据卡诺图化简。最后选用与非门实现即可。</p><ul><li><strong>优先编码器</strong></li></ul><p>特点：允许同时输入多个编码信号，只对其中优先权最高的一个进行编码。</p><p>最常见的优先编码器是74148优先编码器，长下面这个样子，需要掌握：</p><p><img src="14.png" /></p><p>这个图有两个要注意的地方，首先就是所有的<spanclass="math inline">\(I\)</span>上面都是有一个取反号的，只是这个图比较小可能看不清晰，然后所有的<spanclass="math inline">\(Y、S\)</span>上面也有取反号。还有就是看到红色箭头的地方了吗？这跟前面的8线-3线普通编码器不一样，这代表低电平有效。</p><p><spanclass="math inline">\(\overline{S}\)</span>为选通输入端，只有当<spanclass="math inline">\(\overline{S} = 0\)</span>时才能正常工作，当<spanclass="math inline">\(\overline{S} =1\)</span>时所有输出端为封锁为高电平。</p><p>​ <img src="15.png" /></p><p><spanclass="math inline">\(\overline{Y_s}\)</span>为选通输出端，当<spanclass="math inline">\(\overline{Y_s} =0\)</span>说明电路正常工作且无编码信号输入（<spanclass="math inline">\(\overline{S} = 0 且所有\overline{I} =1\)</span>）</p><p>​ <img src="16.png" /></p><p><spanclass="math inline">\(\overline{Y_{EX}}\)</span>为扩展端，当<spanclass="math inline">\(\overline{Y_{EX}} =0\)</span>说明电路正常工作且有编码信号输入（<spanclass="math inline">\(\overline{S} = 0\)</span>且存在<spanclass="math inline">\(\overline{I} = 0\)</span>）</p><p>​ <img src="17.png" /></p><p>知道了每个端口的作用，如何只通过输出端判断此时编码器处于什么状态呢？</p><ol type="1"><li><span class="math inline">\(\overline{Y_s} =0\)</span>：电路正常工作且无编码信号输入。（此时<spanclass="math inline">\(\overline{Y_{EX}}\)</span>必为1）</li><li><span class="math inline">\(\overline{Y_{EX}} =0\)</span>：电路正常工作且有编码信号输入。（此时<spanclass="math inline">\(\overline{Y_s}\)</span>必为1）</li><li><span class="math inline">\(\overline{Y_s} = \overline{Y_{EX}} =1\)</span>：电路被阻塞（此时<spanclass="math inline">\(\overline{S}\)</span>必为1）</li></ol><p>最后，74148优先编码器的真值表贴上来，上面所有可能你觉得有困惑的点都可以在这张表中得到解答。</p><p><img src="18.png" /></p><ul><li><strong>练习</strong></li></ul><p>学了上面普通编码器和优先编码器的知识，来写一道题吧！</p><blockquote><p>请用两片74148接成16线-4线优先编码器，将16个低电平输入信号<spanclass="math inline">\(\overline{A_0} \sim\overline{A_{15}}\)</span>编为'0000' ~ '1111'，其中<spanclass="math inline">\(\overline{A_{15}}\)</span>的优先级最高。</p></blockquote><p>首先如果是0 ~7就直接用一片就好了。思考一下，如果是大于7怎么办？可以这样思考：</p><p>15 = 8 + 7</p><p>14 = 8 + 6</p><p>13 = 8 + 5</p><p>12 = 8 + 4</p><p>11 = 8 + 3</p><p>10 = 8 + 2</p><p>9 = 8 + 1</p><p>8 = 8 + 0</p><p>发现规律了吗？如果是0 ~ 7直接用一片就好了，如果是8 ~15就肯定需要用到第二片，但是第二片同样能表达的范围只有0 ~ 7，所以就将8 ~15进行数字拆分。</p><p>如果输入8，则点亮第四位输出（8421中的8），剩下3位二进制输入0</p><p>如果输入9，则点亮第四位输出，剩下3位二进制输入1</p><p>如果输入10，则点亮第四位输出，剩下3位二进制输入2</p><p>... ...</p><p>如果输入15，则点亮第四位输出，剩下3位二进制输入7</p><p>思路就是这样，还有一些小细节我在放答案过后再解释：</p><p><img src="19.png" /></p><p>可以看到<spanclass="math inline">\(G_0、G_1、G_2\)</span>门都采用了与非门的设计，因为两片74148必定只会用到一片的输出（0~ 7用右边那片，8 ~ 15用左边那片）。</p><p>但是如果使得一片工作另一片就停止工作呢？注意左边那片的<spanclass="math inline">\(\overline{Y_s}\)</span>端口，左边那片正常工作且有信号输入时输出1，使得右边那片<spanclass="math inline">\(\overline{S} =1\)</span>，所以右边那片直接被堵塞了。如果左边那片正常工作但没信号输入时输出0，使得右边那片被激活。这样就实现了两片中只能有一片在工作。</p><p>然后<spanclass="math inline">\(Z_3\)</span>就是第四个二进制输出。只要用到左边那片，就输出1。刚好<spanclass="math inline">\(\overline{Y_{EX}}\)</span>就可以实现这个功能，只要电路正常工作并且有信号输入<spanclass="math inline">\(\overline{Y_{EX}}\)</span>就为0，经过一个与非门之后就变成了1。</p><h4 id="译码器">3.2 译码器</h4><p>译码器就是编码器的逆过程。编码器是给它一个数字，输出二进制。译码器就是给它一个二进制，输出一个数字。</p><p>译码器分为二进制译码器（最小项译码器）、二—十进制译码器、显示译码器。其中二进制译码器需要掌握74138译码器。</p><ul><li><strong>二进制译码器（只讲74138译码器）</strong></li></ul><p>74138译码器长这个样子：</p><p><img src="20.png" /></p><p>注意，跟74148解码器不同，这里的三个输入端<spanclass="math inline">\(A\)</span>都是高电平有效，输出端<spanclass="math inline">\(\overline{Y}\)</span>是低电平有效。这里的<spanclass="math inline">\(S、\overline{S}\)</span>是控制芯片是否工作的。</p><p>具体来说，只有当<span class="math inline">\(S_1 = 1 且 \overline{S_2}=0 且 \overline{S_3} =0\)</span>时，电路才处于正常工作状态。其余情况电路都处于被堵塞的状态。</p><p>​ <img src="21.png" /></p><p>74138解码器的真值表如下：</p><p><img src="22.png" /></p><ul><li><strong>二—十进制译码器（只讲7442译码器）</strong></li></ul><p>我觉得二—十进制译码器就是二进制译码器啊......搞不懂为啥还要专门分个类出来。二—十译码器就是说将4个二进制数变成十进制0~ 9。</p><p>二—十进制译码器最常见的就是7442译码器，它的真值表如下：</p><p><img src="23.png" /></p><p>可以看到有伪码的存在，这是为什么呢？因为4个二进制数可以表达0 ~15，但是因为是BCD码，所以我们得到的数范围是0 ~9。所以有一部分的二进制状态没有用到，没用到的地方就称为伪码。</p><ul><li><strong>显示译码器</strong></li></ul><p>啊就是能直观的显示出翻译后信息的译码器。看下面俩图就知道它是什么东西了。</p><p><img src="24.png" /><img src="25.png" /></p><ul><li><strong>练习</strong></li></ul><blockquote><p>试用两片74138组成4线-16线译码器。将输入的4位二进制代码<spanclass="math inline">\(D_3D_2D_1D_0\)</span>译成16个独立的低电平信号<spanclass="math inline">\(\overline{Z_0} \sim\overline{Z_{15}}\)</span>。</p></blockquote><p>有了前面用两块74148组成16线-4线编码器的经验，这题的思考方式是一样的。首先如果只用一块板的话，3个二进制数，可以得到0~ 7。如果大于7怎么办呢？观察一下： <span class="math display">\[(8)_d = (1000)_b \leftrightarrow (0)_d = (000)_b \\(9)_d = (1001)_b \leftrightarrow (1)_d = (001)_b \\(10)_d = (1010)_b \leftrightarrow (2)_d = (010)_b \\..... \leftrightarrow ...\]</span> 发现规律了没？</p><p>只要四位二进制中第四位为0，将剩下3位二进制传给第一块板的三个输入接口。如果第四位二进制为1，那么堵塞第一块版，将剩下3位二进制传给第二块版的三个输入接口。答案如下：</p><p><img src="26.png" /></p><h4 id="用译码器实现逻辑函数">3.3 用译码器实现逻辑函数</h4><p>因为任何逻辑函数均可化成最小项之和的形式。所以可以用译码器实现逻辑函数的电路，很牛逼。看下面这个例子你就懂了。</p><p><img src="27.png" /></p><p>首先先将F化成主析取范式：<span class="math inline">\(F = ABC+AB\overline{C} + A\overline{B}C + \overline{A}BC = m_7 + m_6 + m_5 +m_3\)</span></p><p>意思是说，只要三输入变量按照7、6、5、3的二进制输入，F就是1。否则F就是0。</p><p>好，那我们在74138输出端将<spanclass="math inline">\(\overline{Y_7}、\overline{Y_6}、\overline{Y_5}、\overline{Y_3}\)</span>用与非门连接起来。只要三输入变量输入7、6、5、3二进制其中的一个，那么<spanclass="math inline">\(\overline{Y_7}、\overline{Y_6}、\overline{Y_5}、\overline{Y_3}\)</span>就有一个是0，与非后就得到1。如果三输入变量不属于7、6、5、3二进制中的任何一个，则<spanclass="math inline">\(\overline{Y_7}、\overline{Y_6}、\overline{Y_5}、\overline{Y_3}\)</span>都为1，与非后就得到0。</p><hr /><h3 id="四.-组合逻辑电路4">四. 组合逻辑电路(4)</h3><h4 id="数据分配器">4.1 数据分配器</h4><p>定义：数据传输过程中，有时需要将数据分配到不同的数据通道上。数据分配器也叫多路分配器，简称DEMUX。</p><p>示意图：通过A端口来选择数据输出通道。</p><p><img src="28.png" /></p><p>电路图：</p><p><img src="29.png" /></p><p>这个电路还是蛮简单的。</p><p>提一嘴，前面学到的74138译码器就可以用来作1路-8路数据分配器。内部电路图ppt没给，但是我觉得就跟上面DEMUX的电路图差不多。</p><p><img src="30.png" /></p><h4 id="数据选择器">4.2 数据选择器</h4><p>定义：能够实现从多路数据中选择一路进行传输的电路叫做数据选择器。也叫多路选择器、多路调制器，简称MUX。常见的类型有二选一、四选一、八选一、十六选一。</p><p><img src="31.png" /></p><ul><li><strong>二选一多路选择器</strong></li></ul><p><img src="32.png" /></p><p>w0和w1分别是两路的数据源，然后s是控制器。先看右边的电路图，假设s是0，则f= w0，假设s是1，则f = w1。左边就是二选一MUX的图形符号。</p><ul><li><strong>四选一多路选择器</strong></li></ul><p>先看真值表，根据真值表就可以直接设计电路了。</p><p><img src="33.png" /></p><p>所以根据上面的真值表可以写出逻辑表达式：</p><p><span class="math inline">\(f = w_0\overline{s_1}\overline{s_0} +w_1\overline{s_1}s_0 + w_2s_1\overline{s_0} + w_3s_1s_0\)</span></p><p>下面右图是用非门 + 与门 +或门来实现上面的逻辑表达式，左图是四选一MUX的图形符号</p><p><img src="34.png" /></p><ul><li><strong>更大规模的多路选择器</strong></li></ul><p>可以直接列真值表然后直接构建，也可以用小规模的多路选择器去构建。</p><p>看一个由2选1多路选择器构建的4选1多路选择器，就知道如何构建了。</p><p><img src="35.png" /></p><p>先将w俩俩分组，然后用s0去筛，一下筛掉一半，再用s1去筛，又筛掉一半，最后就选择出来了一路数据。</p><h4 id="数据选择器的运用">4.3 数据选择器的运用</h4><ol type="1"><li><p>2x2纵横开关（是否交换数据传输通道）</p><p><img src="36.png" /></p><ul><li>看图，s是选择器。如果s=0，则y1 = x1, y2 = x2。如果s=1，则y1 = x2，y2= x1。</li></ul></li><li><p>实现逻辑函数</p><ul><li><p>最暴力的想法就是列真值表，输入变量A、B、C就是选择器s。每一行的输出就是数据输入通道，输出通道就是f。例如函数<spanclass="math inline">\(f = \overline{w_1}w_2 +w_1\overline{w_2}\)</span>，用四选一多路选择器的实现如下：</p><p><img src="38.png" /></p></li><li><p>但在暴力的基础上其实可以优化：可以对真值表做一个改动：</p><p><img src="39.png" /></p></li><li><p>这样子输入变量只有一个w1了，它就是选择器。数据输入通道有两个，分别是<spanclass="math inline">\(w_2\)</span>和<spanclass="math inline">\(\overline{w_2}\)</span>，数据输出通道一个为f。用二选一多路选择器实现如下：</p><p><img src="40.png" /></p></li></ul></li><li><p>实现3输入表决器</p><ul><li><p>先列出真值表</p><p><img src="41.png" /></p></li><li><p>对真值表进行优化</p><p><img src="42.png" /></p></li><li><p>此时输入变量两个w1、w2为选择器，数据输入通道4个分别是0、w3、w3、1，数据输出通道1个为f。用4选1多路选择器实现如下：</p><p><img src="43.png" /></p></li></ul></li><li><p>实现3位异或运算</p><ul><li><p>先列出真值表，并优化</p><p><img src="44.png" /></p></li><li><p>此时输入变量两个w1、w2为选择器，数据输入通道4个分别是<spanclass="math inline">\(w_3、\overline{w_3}、\overline{w_3}、w_3\)</span>，数据输出通道一个为f。用4选1多路选择器实现如下：</p><p><img src="45.png" /></p></li></ul></li></ol><hr /><h3 id="五.-组合逻辑电路5">五. 组合逻辑电路(5)</h3><p>这一节比较杂，主要是对第（4）内容的一个补充。具体来说，讲了如下内容：</p><ol type="1"><li>用香农展开定理搭配多路选择器实现逻辑函数</li><li>八选一数据选择器74151</li><li>双四选一数据选择器74153</li><li>数据选择器的更多运用</li></ol><h4 id="用香农展开定理搭配多路选择器实现逻辑函数">5.1用香农展开定理搭配多路选择器实现逻辑函数</h4><ul><li><p>香农展开定理：</p><ul><li><p><span class="math inline">\(f\left(w_{1}, w_{2}, \ldots . .w_{\mathrm{n}}\right)=\overline{w_{1}} f\left(0, w_{2}, \ldots . .w_{\mathrm{n}}\right)+w_{1} f\left(1, w_{2}, \ldots . .w_{\mathrm{n}}\right)\)</span></p><ul><li><p>↑展开一个变量</p></li><li><p>在香农表达式中<spanclass="math inline">\(f\left(0,w_{2}....w_{\mathrm{n}}\right)\)</span>项称为对应于<spanclass="math inline">\(\bar{w}_{\mathrm{1}}\)</span>的<spanclass="math inline">\(f\)</span>的余因子式, 简写做<spanclass="math inline">\(f_{\overline{w}_1}\)</span>。 同样的,<spanclass="math inline">\(f(1,w_2.....w_n)\)</span> 项称为对应于<spanclass="math inline">\(w_{_1}\)</span>的<spanclass="math inline">\(f\)</span>的余因子式,简写做<spanclass="math inline">\(f_{_{w_1}}\)</span>。所以香农展开定理可以简写成：<span class="math display">\[f=\overline{w}_{1}f_{\overline{w}_{1}}+w_{1}f_{w_{1}}\]</span></p></li></ul></li><li><p><span class="math inline">\(f(w_1,w_2,....,w_n)=\\\overline{w_1}\overline{w_2}f(0,0,w_3....w_n)+\overline{w_1}w_2f(0,1,w_3,.....w_n)+w_1\overline{w_2}f(1,0,w_3,.....w_n)+\\ w_1w_2f(1,1,w_3,.....w_n)\)</span></p><ul><li>↑展开多个变量</li></ul></li></ul></li></ul><p>那如何用香农展开定理实现逻辑函数呢？举个例子，比如<spanclass="math inline">\(f=\overline{w}_{1}\overline{w}_{3}+w_{1}w_{2}+w_{1}w_{3}\)</span></p><p>将f以w1用香农展开定理展开，得到<spanclass="math inline">\(f=\overline{w}_1f_{\overline{w}_1}+w_1f_{w_1}=\overline{w}_1(\overline{w}_3)+w_1(w_2+w_3)\)</span></p><p>然后选用二路选择器，w1是选择器，数据输入通道2个分别是<spanclass="math inline">\(\overline{w_3}\)</span>和<spanclass="math inline">\(w_2 +w_3\)</span>，数据输出通道一个为f。实现电路图如下：</p><p><img src="46.png" /></p><p>同理，如果用香农展开定理展开两个变量，则搭配一个四路选择器也可以实现上述函数f。</p><h4 id="八选一数据选择器74151">5.2 八选一数据选择器74151</h4><p>74151MUX的样子和真值表如下图</p><p><img src="47.png" /></p><h4 id="双四选一数据选择器74153">5.3 双四选一数据选择器74153</h4><p>就是俩独立的四路选择器放一起，如图。（个人觉得左图很不直观，下面练习中的74153比较直观）</p><p><img src="48.png" /></p><blockquote><p>练习：如何用74153构建一个74151？</p></blockquote><p>很简单，跟以前练习题一样的套路。只要保证两个四选一板子有且只能有一块板子在工作就行了。看答案吧，很简单。</p><p><img src="49.png" /></p><p>A2还有G1就是为了实现”只能有一个四选一“板子在工作我们自己加上去的电路。</p><h4 id="小补充">5.4 小补充</h4><p>感觉代号多了有点乱了。让我来梳理一下。</p><p>74148是最常见的8线-3线优先编码器。</p><p>74138是最常见的二进制译码器。（3个输入、8个输出）</p><p>数据分配器DEMUX可用74138实现。</p><p>数据选择器MUX有74151（八路）、74153（俩独立四路放一起）</p><h4 id="数据选择器的更多运用">5.5 数据选择器的更多运用</h4><ol type="1"><li><p>与DEMUX实现多路信号分时传送</p><p><img src="50.png" /></p></li><li><p>实现逻辑函数</p><ul><li><p>用MUX实现逻辑函数的方法有许多。</p><ol type="1"><li>直接列真值表实现</li><li>列完真值表，对真值表优化后实现</li><li>用香农展开公式后实现</li><li>列引入变量的卡诺图实现</li></ol></li><li><p>前三种方法前面都介绍过了，这里放一个用第四种方法的例题。</p><p><img src="51.png" /></p></li><li><p>因为74151是八位选择器，所以只能有3个选择变量。所以画卡诺图引入了一个变量。然后8个信号输入端口就输入0/1/D/<spanclass="math inline">\(\overline{D}\)</span>即可。</p></li><li><blockquote><p>练习：请用一片74151实现逻辑函数<spanclass="math inline">\(F(A,B,C,D,E)=A\overline{B}C\overline{D}E+AB\overline{C}\overline{D}\overline{E}+A\overline{B}C\overline{D}\overline{E}+\overline{A}\overline{B}\overline{C}DE+\overline{A}B\overline{C}\overline{D}\overline{E}\)</span></p></blockquote></li><li><p>74151是八路选择器，所以要有三个选择变量。但是这里F有5个，所以第一想法是用香农展开定理展开3个变量，但是这样太麻烦了。所以用第四种方法，引入两个变量进卡诺图即可。</p><p><img src="52.png" /></p></li></ul></li><li><p>数据选择器的扩展</p><ul><li><p>很好理解，看图即可。</p><p><img src="53.png" /></p></li></ul></li></ol><hr /><h3 id="六.-组合逻辑电路6">六. 组合逻辑电路(6)</h3><h4 id="数值比较器">6.1 数值比较器</h4><ul><li><strong>一位数值比较器</strong></li></ul><p>两个1位二进制数A,B相比的情况有以下几种: 1. A&gt;B，则<spanclass="math inline">\(A\overline{B}=1\)</span>，所以可用<spanclass="math inline">\(A\overline{B}\)</span>作为A&gt;B的输出信号<spanclass="math inline">\({Y}_{(A&gt;B)}\)</span> 。<br />2. 同理可用 <span class="math inline">\(\overline{AB}\)</span>作为A&lt;B的输出信号 <span class="math inline">\({Y}_{(A&lt;B)}\)</span>。 3. 同理可用<span class="math inline">\(A \odot B\)</span>作为A=B的输出信号 <span class="math inline">\(Y_{A=B}\)</span></p><p>于是可以设计出如下电路（注意是低电平有效）</p><p><img src="54.png" /></p><ul><li><strong>多位数值比较器</strong></li></ul><p>多位数值比较器的原理就是从高位到低位逐位比较，最常见的是4位比较器14585，下面是其逻辑函数和电路图：</p><p><img src="55.png" /></p><p><img src="56.png" /></p><p>这个图有4个要注意的地方，首先看蓝色箭头的地方，为啥这个地方用与非门呢？很简单，将上面的逻辑表达式进行进一步化简：<span class="math display">\[Y_{A&lt;B} = \overline{\overline{\overline{A_3}B_3} \cdot\overline{\overline{A_3 \oplus B_3}\overline{A_2}B_2} \cdot ...} \,\cdot I_{A&lt;B}  \\= \overline{\overline{\overline{A_3}B_3} \cdot ((A_3 \oplus B_3) +\overline{\overline{A_2}B_2}) \cdot \, ...} \, \cdot I_{A&lt;B}\]</span> 现在知道蓝色箭头为啥用与非门了吧=w=。</p><p>那为啥绿色箭头那要用或门呢？还是看上面化简的式子，注意看第二项，第二项就是或门=w=。</p><p>那为啥棕色箭头用或非门呢？还是化简上面的式子： <spanclass="math display">\[Y_{A=B} = \overline{(A_3 \oplus B_3) + (A_2 \oplus B_2) + (略) + (略)}\, \cdot I_{A=B}\]</span>很清楚吧=w=，就是一个或非门，每一项这里用异或表达了，其实就是图中判断是否每一项是否相等的那个逻辑门。</p><p>那为啥红箭箭头那要用或非门呢？还是化简上面的式子： <spanclass="math display">\[Y_{A&gt;B} = \overline{(Y_{A&lt;B} + Y_{A=B}) + \overline{I_{A&gt;B}}}\]</span> easy。</p><p>还剩一个问题，那三个<spanclass="math inline">\(I\)</span>是干啥的。其实就是用来接收低位上的结果的。这样两块14585就能实现8位数字的比较。如下图：</p><p><img src="57.png" /></p><p>有个问题，为啥左边的<spanclass="math inline">\(Y_{A&gt;B}\)</span>为啥不能连到右边的<spanclass="math inline">\(I_{A=B}\)</span>？</p><p>其实可以，但是图中这样连也没问题。还是用逻辑表达式去解释：<spanclass="math inline">\(Y_{A&gt;B} = \overline{(Y_{A&lt;B} + Y_{A=B}) +\overline{I_{A&gt;B}}}\)</span>，可以发现必须要三者都是0才会使得<spanclass="math inline">\(Y_{A&gt;B}=1\)</span>，所以默认给<spanclass="math inline">\(I_{A&gt;B}\)</span>置为1不影响结果。</p><h4 id="加法器">6.2 加法器</h4><ul><li><strong>半加器</strong></li></ul><p>很简单，真值表、逻辑表达式、图形符号如下图：</p><p><img src="58.png" /></p><ul><li><strong>全加器</strong></li></ul><p>加了一个考虑上一位进位而已，也很简单，真值表、逻辑表达式、图形符号如下：</p><p><img src="59.png" /></p><p>这里解释一下逻辑表达式，因为异或是不进位加法，所以S等于三者异或很合理。然后CO用或连接也很合理，无非就是A、B都是1可以进位，或者CI为1，A、B里任意一个为1也可以进位。</p><ul><li><strong>串行进位加法器</strong></li></ul><p>有了全加器之后，只需要将多个全加器串联起来就可以得到任意多位的加法器了。如下图：</p><p><img src="60.png" /></p><p>虽然这样逻辑和电路都很简单，但是存在一个问题，就是速度过慢，如何解决呢？</p><p>速度关键是慢在进行信号逐级传递的过程，所以要优化这个过程。不难发现，要想知道<spanclass="math inline">\(CI_i\)</span>，只需要知道<spanclass="math inline">\(A_{i-1}A_{i-2}...A_0\)</span>和<spanclass="math inline">\(B_{i-1}B_{i-2}...B_0\)</span>即可。</p><p>个人觉得，这种优化思路就很像把递归函数展开来写了笑死。也有点像并查集路径压缩。</p><ul><li><strong>超前进位加法器</strong></li></ul><p>用上面提到的优化方法做成的加法器就叫做超前进位加法器。下图是74283的超前进位加法器电路图：</p><p><img src="61.png" /></p><p>可以发现光4位加法器电路就那么复杂了，这或许就是空间换时间吧（笑）</p><p>所以当我们需要更多位加法器的时候，可以拿74283超前进位加法器去串联做成一个多位的串行进位加法器。</p><blockquote><p>练习：用一片74283设计将BCD8421码转换成余3码的电路</p></blockquote><p>太简单啦！直接上图：</p><p><img src="62.png" /></p><h4 id="竞争-冒险现象">6.3 竞争-冒险现象</h4><p>啊我懒得打很多字了，这里我放一个up主的视频，看完这道例题就知道什么是竞争-冒险现象了：（up主：海蓬莱）</p><video src="video.mp4" controls="controls"></video><p>视频中的险象就是这里的冒险。官方定义如下 ：</p><p>竞争：一个逻辑门的两个输入端的信号同时向相反方向变化，而变化的时间有差异的现象。</p><p>冒险：由于竞争而使电路输出发生瞬时错误</p><p>注意，有竞争不一定会冒险（如视频中提到的非临界竞争）</p><p>冒险分为两类：</p><ol type="1"><li>0型冒险：即本来是1的变成了0<ul><li>当表达式在一定条件下能化成<span class="math inline">\(F = A +\overline{A}\)</span>时，就会出现0型冒险</li></ul></li><li>1型冒险：即本来是0的变成了1<ul><li>当表达式在一定条件下能化成<span class="math inline">\(F = A \cdot\overline{A}\)</span>时，就会出现1型冒险</li></ul></li></ol><p>如何能消除竞争-冒险现象呢？ppt上给出了三种解决方案：</p><ol type="1"><li><p>接入滤波电容</p></li><li><p>引入选通脉冲</p></li><li><p>修改逻辑表达式</p><ul><li>前俩个反正我是没看懂，这里举个例子说一下第三种方法。比如有逻辑函数<spanclass="math inline">\(F = AB + \overline{A}C\)</span>，当B = C =1时会出现0型冒险。所以可以修改一下逻辑表达式为：<spanclass="math inline">\(F = AB + \overline{A}C +BC\)</span>，这样就不会出现0型冒险了。（为什么要这么修改呢？看下面的卡诺图你就知道了）</li></ul><p><img src="63.png" /></p></li></ol><hr /><h3 id="七.-vivado的基本使用">七. Vivado的基本使用</h3><p>先来了解一下EDA技术：即电子设计自动化，其依赖功能强大的计算机，在EDA工具软件平台上，对以硬件描述语言(HDL)为系统逻辑描述手段完成的设计文件，自动地完成逻辑编译、逻辑化简、逻辑分割、逻辑综合、布局布线，以及逻辑优化和仿真测试，直至物理实现既定的电子设计系统功能。</p><p>以我浅薄的理解，EDA = IDE，Verilog =C++，hhhhh，FPGA是可编程逻辑器件。</p><h4 id="用verilog-hdl设计电路">7.1 用Verilog HDL设计电路</h4><p>写一个模块大致分为以下几步：</p><ol type="1"><li>打开Vivado，创建一个项目（根据自己开发板选型号，我的是xc7a35tcpg236-1）</li><li>新建一个design文件，在里头写程序</li><li>新建一个sim文件，在里头写仿真程序（初始化 + 实例化 +仿真过程代码）</li><li>运行仿真，观察仿真结果是否跟设想一样</li><li>封装IP核，以便此模块以后可被其它项目使用</li></ol><h4 id="用block-design设计电路">7.2 用Block Design设计电路</h4><ol type="1"><li>打开Vivado，创建一个项目</li><li>左侧新建一个Block Design项目</li><li>引入IP核，开始画图</li><li>新建一个sim文件，写仿真程序</li><li>运行仿真，观察仿真结果是否跟设想一样</li></ol><h4 id="用rtl看电路图">7.3 用RTL看电路图</h4><p>点左侧RTL分析即可生成。</p><h4 id="下板">7.4 下板</h4><ol type="1"><li>写好constraint文件（我直接用的老师给的模板文件上修改）</li><li>运行左侧Synthesis</li><li>运行Implementation（记得勾选第二项产生二进制文件，然后选择OpenHardware Manager）</li><li>通过USB连上FPGA</li><li>点击Auto Connect，连接成功后选择ProgramDevice下载刚才的二进制文件</li><li>可以愉快的用板子观察程序结果啦~</li></ol><p>但是断电后程序就会丢失，为了解决这个问题，需要把程序烧录进ROM里：</p><ol type="1"><li>生成bin文件，Tools -&gt; Settings -&gt; Bitstream -&gt;勾选-bin-file* -&gt; OK，左侧GenerateBitstream重新生成bit文件（此时就会生成bin文件）</li><li>右键芯片选择Add Configuration Memory Device，选择合适的闪存型号</li></ol><h4 id="总结">7.5 总结</h4><p>Vivado这个软件其实蛮简单使用的。首先不考虑板子的话，只在电脑上设计电路有两种方法，第一种就是直接创建design文件写，第二种就是用BlockDesign（若某个模块想封装成IP核必须要仿真过先）。然后想看设计的对不对，就创建仿真文件来看。另外，用RTL可以看设计好的电路。</p><p>下板的话就需要通过constraint文件指定管脚，然后左侧Synthesis +Implementation + 生成二进制文件 + 连板子 + Auto Connect + ProgramDevice就可以在板子上观察了。</p><hr /><p>现在是2023/10/28，又准备要做时序逻辑电路的实验了。所以继续把这个自学笔记写完吧hhhh</p><h3 id="八.-触发器">八. 触发器</h3><p>定义：触发器是具有记忆功能的基本逻辑单元，一个触发器可以存储一个二值信号。</p><h4 id="rs触发器">8.1 RS触发器</h4><p><img src="64.png" /></p><p>首先需要知道与非门的特点，对于与非门，如果有一端为0，那么输出就为1。如果两端都为1，那么输出才为0。所以对于上图，如果S=0,R=1，那么Q = 1, Q反馈回去得到<spanclass="math inline">\(\overline{Q}\)</span>=0。如果R=0, Q=1，那么<spanclass="math inline">\(\overline{Q}\)</span>=1，反馈回去得到Q=0。</p><p>其实S为set，R为reset，Q为输出。而且S、R都是低电平有效。所以S=0,R=1的时候，输出将置位为1。R=0,S=1时，输出将reset为0。</p><p>如果S = R = 1呢？按照感性理解就是set和reset都不起效，也就是Q和<spanclass="math inline">\(\overline{Q}\)</span>维持上一个状态。让我们来验证一下，假设Q=0，则反馈回去<spanclass="math inline">\(\overline{Q}\)</span>=1，再反馈回来Q=0。假设Q=1，则反馈回去<spanclass="math inline">\(\overline{Q}\)</span>=0，再反馈回来Q=1。没有问题，就是维持上一个状态。</p><p>如果S = R =0呢？按照感性理解就是set和reset都起效，那必然会存在一个“竞争”问题。也就是存在不唯一性。让我们来验证一下，假设S= R = 0，那么Q和<spanclass="math inline">\(\overline{Q}\)</span>都将会为1。好，假设下一个时刻S= R = 1, 按照上面的分析应该维持原状对吧。但是假如Q先传回去，则<spanclass="math inline">\(\overline{Q}\)</span>=0，再传回来Q=1，新状态Q=1,<span class="math inline">\(\overline{Q}\)</span>=0；假如<spanclass="math inline">\(\overline{Q}\)</span>先传回去，则Q=0,再传回来<span class="math inline">\(\overline{Q}\)</span>=1，新状态Q=0,<spanclass="math inline">\(\overline{Q}=1\)</span>。所以我们是要禁止出现S = R= 0的情况的！因为下一个时刻就会出现<strong>“不唯一性”</strong>。</p><p>经过上面的分析，下面的真值表就十分清楚了：</p><p><img src="65.png" /></p><p>用逻辑表达式<span class="math inline">\(Q^{n+1}=\overline{S} + R(Q^n)\quad ,R + S = 1,\)</span>也可以表示上面的真值表（用卡诺图推）</p><h4 id="钟控触发器">8.2 钟控触发器</h4><p>钟控触发器是在普通触发器上的一个改进。因为有时候我们只希望在某一个信号到来的时候，Q才随R和S改变。而其余时候，都希望Q维持原状，也就是这个触发器被“锁”起来。那么钟控触发器就可以实现这个功能。</p><p>钟控触发器也分为几种：可控R-S触发器、主从式J-K触发器、D型触发器、T型触发器。</p><ul><li><strong>可控R-S触发器</strong></li></ul><p>先来看它的电路图和装置图：</p><p><img src="66.png" /></p><p>可以发现，可控R-S触发器无非就是在R-S触发器的前面加了俩与非门。因为我们知道对于与非门，只要有一端是0，输出就为1。所以当cp为0时，Q将维持原状，触发器被“锁”住。当cp为1时，R、S的输入就可以影响到Q。可是注意，因为多了俩与非门的存在，所以本来对于R、S是低电平有效，现在变成了高电平有效了。也就是S= 1, R = 0时，Q = 1；S = 0, R = 1时，Q = 0；S = R = 0时维持原状；S = R =1时为不稳定态。</p><p>总结来说，cp=0时锁触发器，cp=1时激活触发器，但是会变为高电平有效。</p><p>逻辑表达式为：<span class="math inline">\(Q^{n+1} = S +\overline{R}Q^n \quad ,R \cdot S = 0, CP = 1\)</span></p><ul><li><strong>主从式J-K触发器</strong></li></ul><p>J-K触发器是可控R-S触发器的一个升级版，它的J、K分别对应R、S，而且允许J和K同时取1。同时取1的时候不会引入“竞争”，而是会翻转输出Q的结果。</p><p>具体来说，当cp=0时，触发器被锁住。当cp=1时，触发器激活，J、K高电平有效。J= 1, K = 0时Q = 1；J = 0, K = 1时Q = 0；J = K = 0时保持原状；J = K =1时翻转Q。</p><p>下面是它的逻辑表达式和电路图：</p><p><span class="math inline">\(Q^{n+1}=J\overline{Q^n}+\overline{K}Q^n\quad ,CP = 1\)</span></p><p><img src="67.png" /></p><ul><li><strong>D型触发器</strong></li></ul><p>这个触发器最直观，只有两个输入端：cp和D。D输出什么，这个触发器就存储什么（我已经预感到实验会大量使用到这个触发器了hhhh）。</p><p>详细来说，cp=0时，触发器被锁住。cp=1时，若D = 0，则Q = 0；若D =1，则Q = 1。</p><p>它的电路图如下：（其实所有触发器都是在R-S触发器的基础上在输入端进行改动）</p><p><img src="68.png" /></p><p>这个公式推导挺有趣的。R-S基础触发器的公式是：<spanclass="math inline">\(Q^{n+1}=\overline{S} + R(Q^n)\)</span>。</p><p>然后由图中可以推出，<span class="math inline">\(R = \overline{CP\cdot (\overline{CP \cdot D})} = \overline{CP \cdot \overline{D}} \quad, S = \overline{CP \cdot D}\)</span>。</p><p>将上面的R、S带入原始公式：<span class="math inline">\(Q^{n+1} = CP\cdot D + (\overline{CP} + D)Q^n = D(CP + Q^n) +\overline{CP}Q^n\)</span></p><p><span class="math inline">\(CP=0\)</span>时，<spanclass="math inline">\(Q^{n+1} = DQ^n + Q^n = Q^n\)</span></p><p><span class="math inline">\(CP = 1\)</span>时，<spanclass="math inline">\(Q^{n+1} = D\)</span></p><ul><li><strong>T型触发器</strong></li></ul><p>这个触发器也是只有两个输入端：cp和T。cp=0时，触发器被锁住。cp=1时，T=0时维持原态，T=1时翻转输出。</p><p>它的电路图如下：</p><p><img src="69.png" /></p><p>可以看出，T触发器就是在J-K触发器的基础上，把J和K变成一个接口T了。所以J-K触发器的公式：<spanclass="math inline">\(Q^{n+1}=J\overline{Q^n}+\overline{K}Q^n\)</span>就应该改为<spanclass="math inline">\(Q^{n+1} = T \oplus Q^n\)</span>。</p><h4 id="总结-1">8.3 总结</h4><p>触发器这块，R-S触发器是最经典的，后续所有的钟控触发器都是由R-S触发器修改得到。所以R-S触发器的公式和电路图要记住：<spanclass="math inline">\(Q^{n+1} = \overline{S} +RQ^n\)</span>。然后它是低电平有效，后续的钟控触发器都是高电平有效。它有两个缺点：</p><ol type="1"><li>没有时钟控制</li><li>R、S不能同时为0</li></ol><p>可控R-S触发器就是在R-S的基础上加了两个与非门，多连了一个CP。公式为<spanclass="math inline">\(Q^{n+1} = S +\overline{R}Q^n\)</span>。解决了缺点2。</p><p>J-K触发器就是在可控R-S触发器的基础上将两个输出连接到J、K输入端，公式为<spanclass="math inline">\(Q^{n+1}=J\overline{Q^n}+\overline{K}Q^n\)</span>。又解决了缺点1。</p><p>D触发器和T触发器背一下就好了，不要求掌握其电路图。D触发器就是CP=1时D是什么，Q就是什么。T触发器就是CP=1时T=0为维持原状，T=1为翻转输出，公式为<spanclass="math inline">\(Q^{n+1} = T \oplus Q^n\)</span></p><hr /><h3 id="九.-时序逻辑电路1">九. 时序逻辑电路(1)</h3><h4 id="概述-1">9.1 概述</h4><p>时序电路一般都是由两个部分构成的：组合电路和存储电路。</p><p>存储电路的输出必须反馈到组合电路的输入端，从而与输入信号一起决定组合电路的输出。</p><p>下面这两张图能很好的解释时序逻辑电路的特点：</p><p><img src="70.png" /></p><p><img src="71.png" /></p><p>时序逻辑电路分类的话有两种分类方式：</p><ul><li><p>按触发器的动作特点分类</p><ol type="1"><li>同步时序逻辑电路（有统一的CP）</li><li>异步时序逻辑电路（无统一的CP）</li></ol></li><li><p>按输出信号的特点分类</p><ol type="1"><li><p>米利型（输出跟输入变量和存储电路有关）</p><p><img src="72.png" /></p></li><li><p>莫尔型（输出只跟存储电路有关）</p><p><img src="73.png" /></p></li></ol></li></ul><h4 id="时序逻辑电路的描述方法">9.2 时序逻辑电路的描述方法</h4><p>从理论上：输出方程(通过输入和现态算输出) + 驱动方程 +状态方程(通过现态算次态)</p><p>从图表上：状态转换表、状态转换图、时序图</p><ul><li><strong>状态转换表</strong></li></ul><p>若将任何一组输入变量及电路初态的取值代入状态方程和输出方程，即可算出电路的次态和现态下的输出值。如此继续下去，把全部的计算结果列成真值表的形式，就得到了状态转换表。</p><p>通过下面这个例子就很容易看懂。左边第一、二个是状态方程，第三个是输出方程。右边是状态转换表。</p><p><img src="74.png" /></p><ul><li><strong>状态转换图</strong></li></ul><p>就是状态转换表形象化的表示。以小圆圈表示电路的各个状态，圆圈中填入存储单元的状态值，圆圈之间用箭头表示状态转换的方向，在箭头旁注明状态转换前的输入变量取值和输出值。</p><p>下面这张图就是上面那个状态转换表的状态转换图，很容易理解。</p><p><img src="75.png" /></p><ul><li><strong>时序图</strong></li></ul><p>就是波形图。</p><hr /><h3 id="十.-时序逻辑电路2">十. 时序逻辑电路(2)</h3><h4 id="同步时序逻辑电路的分析">10.1 同步时序逻辑电路的分析</h4><p>跟分析组合逻辑电路一样，也是画出真值表（状态转换表），然后观察得出功能。</p><p>具体来说，分为下面几步：</p><ol type="1"><li>写出输出方程</li><li>写出驱动方程</li><li>写出状态方程</li><li>根据方程画出状态转换表</li></ol><p>下面用一道例题来感受：</p><p><img src="76.png" /></p><p>输出方程：<span class="math inline">\(Y = Q_0^nQ_2^n\)</span></p><p>驱动方程： <span class="math display">\[J_0 = K_0 = 1 \\J_1 = K_1 = \overline{Q_2^n}Q_0^n \\J_2 = Q_1^nQ_0^n, K_2 = Q_0^n\]</span> 状态方程： <span class="math display">\[Q_0^{n+1} = J_0\overline{Q_0^n} + \overline{K_0}Q_0^n = \overline{Q_0^n}\\Q_1^{n+1} = J_1\overline{Q_1^n} + \overline{K_1}Q_1^n =\overline{Q_2^n}Q_0^n \oplus Q_1^n \\Q_2^{n+1} = J_2\overline{Q_2^n} + K_2Q_2^n = Q_1^nQ_0^n\overline{Q_2^n}+ \overline{Q_0^n}Q_2^n\]</span> 根据状态方程和输出方程写出状态转换表：</p><p>设电路初始状态为<span class="math inline">\(Q_2Q_1Q_0 =000\)</span>，则</p><p><img src="77.png" /></p><p>（注意，当出现循环（红圈）时，即可停下）。</p><p>若有需要，还可以根据状态转换表画出状态转换图和时序图：</p><p><img src="78.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写于2023/10/6，这门课其实还是有点意思的。但是上个月身体原因一直在关心我自己的身体，所以这门课我全翘掉了，一点没听。现在马上就要实验课了，于是打算在国庆的末尾把这门课学了。目的是能做出几个组合逻辑电路的实验项目。&lt;/p&gt;
&lt;p&gt;自学参考的内容为老师ppt、各种网上博客。&lt;/p&gt;
&lt;p&gt;学完后打算去刷题巩固一下，刷题打算在一个up主视频里刷：&lt;a
href=&quot;https://www.bilibili.com/video/BV1H54y1k7kM?p=1&amp;amp;vd_source=2501060da9b4bef86e2b8ec8a8d880b5&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，如果有朋友打算认真看这篇Blog进行学习的话，为了更好的阅读体验建议开梯子，因为本文有许多图片和一个视频。（存储在github中）&lt;/p&gt;</summary>
    
    
    
    <category term="大学" scheme="http://example.com/categories/%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数字逻辑" scheme="http://example.com/categories/%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    
  </entry>
  
  <entry>
    <title>3. 几种重要的凸集-下</title>
    <link href="http://example.com/2023/10/05/3-%E5%87%A0%E7%A7%8D%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%B8%E9%9B%86-%E4%B8%8B/"/>
    <id>http://example.com/2023/10/05/3-%E5%87%A0%E7%A7%8D%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%B8%E9%9B%86-%E4%B8%8B/</id>
    <published>2023-10-05T06:30:39.000Z</published>
    <updated>2023-10-30T13:56:04.695Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了多面体、单纯形、多面体与单纯形的关系、对称矩阵集合、对称半正定矩阵集合、对称正定矩阵集合。</p><span id="more"></span><p><img src="1.jpg" /></p><p><img src="2.jpg" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍了多面体、单纯形、多面体与单纯形的关系、对称矩阵集合、对称半正定矩阵集合、对称正定矩阵集合。&lt;/p&gt;</summary>
    
    
    
    <category term="凸优化" scheme="http://example.com/categories/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>2. 几种重要的凸集-上</title>
    <link href="http://example.com/2023/10/05/2-%E5%87%A0%E7%A7%8D%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%B8%E9%9B%86-%E4%B8%8A/"/>
    <id>http://example.com/2023/10/05/2-%E5%87%A0%E7%A7%8D%E9%87%8D%E8%A6%81%E7%9A%84%E5%87%B8%E9%9B%86-%E4%B8%8A/</id>
    <published>2023-10-05T06:30:21.000Z</published>
    <updated>2023-10-30T13:56:01.181Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了一个点、空集、超平面、半空间、球、椭球。</p><span id="more"></span><p><img src="1.jpg" /></p><p><img src="2.jpg" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍了一个点、空集、超平面、半空间、球、椭球。&lt;/p&gt;</summary>
    
    
    
    <category term="凸优化" scheme="http://example.com/categories/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>1. 仿射集/凸集/凸锥</title>
    <link href="http://example.com/2023/10/05/1-%E4%BB%BF%E5%B0%84%E9%9B%86-%E5%87%B8%E9%9B%86-%E5%87%B8%E9%94%A5/"/>
    <id>http://example.com/2023/10/05/1-%E4%BB%BF%E5%B0%84%E9%9B%86-%E5%87%B8%E9%9B%86-%E5%87%B8%E9%94%A5/</id>
    <published>2023-10-05T06:30:01.000Z</published>
    <updated>2023-10-30T13:55:56.095Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了仿射集、凸集、凸锥的概念，以及三者之间的联系。</p><span id="more"></span><p><img src="1.jpg" /></p><p><img src="2.jpg" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍了仿射集、凸集、凸锥的概念，以及三者之间的联系。&lt;/p&gt;</summary>
    
    
    
    <category term="凸优化" scheme="http://example.com/categories/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>0. 引言</title>
    <link href="http://example.com/2023/10/05/0-%E5%BC%95%E8%A8%80/"/>
    <id>http://example.com/2023/10/05/0-%E5%BC%95%E8%A8%80/</id>
    <published>2023-10-05T06:29:39.000Z</published>
    <updated>2023-10-30T13:55:51.676Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读一篇关于多智能体强化学习的论文时，发现涉及到凸优化的知识我不会。于是打算自学，参考的教程是<ahref="https://www.bilibili.com/video/BV19M411T7S7?p=1&amp;vd_source=2501060da9b4bef86e2b8ec8a8d880b5">中科大凌青老师的教学视频</a>。</p><p>文中的笔记是我看完课程后的思考与总结，可能有错误还请指出！我速速修改=w=</p><span id="more"></span><p><img src="1.jpg" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在阅读一篇关于多智能体强化学习的论文时，发现涉及到凸优化的知识我不会。于是打算自学，参考的教程是&lt;a
href=&quot;https://www.bilibili.com/video/BV19M411T7S7?p=1&amp;amp;vd_source=2501060da9b4bef86e2b8ec8a8d880b5&quot;&gt;中科大凌青老师的教学视频&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;文中的笔记是我看完课程后的思考与总结，可能有错误还请指出！我速速修改=w=&lt;/p&gt;</summary>
    
    
    
    <category term="凸优化" scheme="http://example.com/categories/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>在VS Code中配置C/C++</title>
    <link href="http://example.com/2023/10/03/%E5%9C%A8VS-Code%E4%B8%AD%E9%85%8D%E7%BD%AEC-C/"/>
    <id>http://example.com/2023/10/03/%E5%9C%A8VS-Code%E4%B8%AD%E9%85%8D%E7%BD%AEC-C/</id>
    <published>2023-10-03T05:34:01.000Z</published>
    <updated>2023-10-09T16:48:51.785Z</updated>
    
    <content type="html"><![CDATA[<p>之前因为学了一点html，所以下了一个VS Code来写html代码。</p><p>今天要写C++的代码，以前都是用VS写的。但是突然想了一下既然都装了VSCode，为啥不配置一下。配置好了后以后写C/C++代码也不用打开繁重的VS了。而且VSCode还能加很多插件。</p><span id="more"></span><p>说干就干，上网找了资料，终于配置好了。还是有蛮多坑的，主要是因为网上的教程大部分版本比较老了。所以我来写个教程，方便别人和以后自己在别的电脑上配置。我总结出以下几步：</p><h3 id="下载mingw-w64并配置系统变量">1. 下载MinGW-w64并配置系统变量</h3><ul><li><p>MinGW是是将经典的开源 C语言 编译器 GCC 移植到了 Windows平台下，并且包含了 Win32API ，因此可以将源代码编译为可在 Windows中运行的可执行程序。</p></li><li><p>但是MinGW的很早就停止维护了，版本很老了。</p></li><li><p>MinGW-w64相当于升级版的MinGW，是一个开源项目，不断在更新维护着。</p></li><li><p><ahref="https://sourceforge.net/projects/mingw-w64/files/mingw-w64/mingw-w64-release/">下载链接</a>，划到最下面，选择“MinGW-W64GCC-8.1.0”下的“x86_64-win32-seh”进行下载。</p></li><li><p>下载好后，解压到自己想要的位置。然后将其中的bin路径配置到系统变量中。</p></li><li><p>打开cmd，输入gcc --version和gdb--version，弹出版本信息就说明这一步完成了。</p></li></ul><h3 id="下载插件cccode-runner">2. 下载插件C/C++，Code Runner</h3><ul><li>在VS Code中下载即可。</li></ul><h3 id="配置文件">3. 配置文件</h3><ul><li><p>新建一个项目文件夹，在下面建立一个.vscode文件夹，下面建立三个文件，launch.json，tasks.json，c_cpp_properties.json，然后依次把我的代码复制进去。注意代码中的“（改为自己的路径）”</p></li><li><p>lauch.json</p></li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C++ Launch (GDB)&quot;</span><span class="punctuation">,</span>                </span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span>                         </span><br><span class="line"><span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span>                        </span><br><span class="line"><span class="attr">&quot;targetArchitecture&quot;</span><span class="punctuation">:</span> <span class="string">&quot;x86&quot;</span><span class="punctuation">,</span>                </span><br><span class="line"><span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">,</span>                 </span><br><span class="line"><span class="attr">&quot;miDebuggerPath&quot;</span><span class="punctuation">:</span><span class="string">&quot;D:\\app\\mingw64\\bin\\gdb.exe&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span>     </span><br><span class="line"><span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span>                  </span><br><span class="line"><span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">,</span>                  </span><br><span class="line"><span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>                  </span><br><span class="line"><span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/app/mingw64/bin/g++.exe&quot;</span>  （改为自己的路径）          </span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li>tasks.json</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/app/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">    <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;-g&quot;</span><span class="punctuation">,</span><span class="string">&quot;-std=c++11&quot;</span><span class="punctuation">,</span><span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span><span class="string">&quot;-o&quot;</span><span class="punctuation">,</span><span class="string">&quot;$&#123;workspaceRoot&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;fileLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;relative&quot;</span><span class="punctuation">,</span> <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;regexp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;severity&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/app/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;D:/app/mingw64/bin/g++.exe&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceRoot&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;owner&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cpp&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fileLocation&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;relative&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span></span><br><span class="line">                <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;pattern&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;regexp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;file&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;line&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;column&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;severity&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li>c_cpp_properties.json</li></ul><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Win32&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">                <span class="string">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">                <span class="string">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">                <span class="string">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">                <span class="string">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include//c++/tr1&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">                <span class="string">&quot;D:/app/mingw64/x86_64-w64-mingw32/include&quot;</span>（改为自己的路径）</span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;__GNUC__=6&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;__cdecl=__attribute__((__cdecl__))&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;msvc-x64&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;browse&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                    <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="string">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">                    <span class="string">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">                    <span class="string">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">                    <span class="string">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include/&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">                    <span class="string">&quot;D:/app/mingw64/lib/gcc/x86_64-w64-mingw32/8.1.0/include//c++/tr1&quot;</span><span class="punctuation">,</span>  （改为自己的路径）</span><br><span class="line">                    <span class="string">&quot;D:/app/mingw64/x86_64-w64-mingw32/include&quot;</span>  （改为自己的路径）</span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C:\\Program Files\\Microsoft Visual Studio\\2022\\Professional\\VC\\Tools\\MSVC\\14.36.32532\\bin\\Hostx64\\x64\\cl.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c17&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><ul><li><p>在项目文件夹中新建cpp文件，随便写一个程序。然后F5调试。</p></li><li><p>如果能输出正确结果就没问题。如果不能，比如std或者cout报错的话，就打开设置，在"C/C++"中找到C_Cpp:intelliSense Engine，将默认的“Default”改为“Tag Parser”。</p></li><li><p>此时按F5就可以正常实现调试功能了。</p></li><li><p>其实如果你不用调试的话，直接Ctrl + F5用CodeRunner跑代码就行了。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前因为学了一点html，所以下了一个VS Code来写html代码。&lt;/p&gt;
&lt;p&gt;今天要写C++的代码，以前都是用VS写的。但是突然想了一下既然都装了VS
Code，为啥不配置一下。配置好了后以后写C/C++代码也不用打开繁重的VS了。而且VS
Code还能加很多插件。&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://example.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>个人博客搭建说明</title>
    <link href="http://example.com/2023/10/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2023/10/03/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AF%B4%E6%98%8E/</id>
    <published>2023-10-03T05:32:44.000Z</published>
    <updated>2023-10-05T05:01:08.392Z</updated>
    
    <content type="html"><![CDATA[<p>使用GitHub + Hexo搭建的本博客。</p><p>教程参考<ahref="https://zhuanlan.zhihu.com/p/102592286">从零开始搭建个人博客（超详细）- 知乎 (zhihu.com)</a>。</p><p>上面这篇文章可以说是从0到1很详细的介绍了搭建个人博客的全流程，不过仍然有许多小错误，需要结合评论区和其它博文一起阅读才会避免踩坑。</p><span id="more"></span><p>我大致总结一下流程：</p><ol type="1"><li>注册GitHub</li><li>下载Git并将Git绑定到GitHub（使用token）</li><li>购买域名</li><li>安装node.js并配置环境变量（建议全程使用cmd管理员而不是gitbash）</li><li>安装hexo</li><li>解析域名</li><li>设置并美化主题</li></ol><p>另外，博客首页的头像是用的GitHub的头像链接，另外我不打算采用图床，因为怕翻车。所以文章里的全部图片都是存储在本地并push到GitHub中，若加载不出或速度慢可以尝试挂个梯子。</p><p>域名第一年花了9块，之后续费好像是20多块一年。在阿里云买的。</p><p>看板娘参考了两篇文章：<ahref="https://github.com/stevenjoezhang/live2d-widget">设置看板娘</a>,<ahref="https://www.cnblogs.com/c10udlnk/p/14727173.html">个性化配置看板娘</a>。</p><p>但是live2d的模型默认的这几个我不是很熟悉，以后有空了想换成我自己喜欢的人物角色。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用GitHub + Hexo搭建的本博客。&lt;/p&gt;
&lt;p&gt;教程参考&lt;a
href=&quot;https://zhuanlan.zhihu.com/p/102592286&quot;&gt;从零开始搭建个人博客（超详细）
- 知乎 (zhihu.com)&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;上面这篇文章可以说是从0到1很详细的介绍了搭建个人博客的全流程，不过仍然有许多小错误，需要结合评论区和其它博文一起阅读才会避免踩坑。&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://example.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
</feed>
