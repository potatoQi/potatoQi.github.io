<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Error_666</title>
  
  
  <link href="http://error666.top/atom.xml" rel="self"/>
  
  <link href="http://error666.top/"/>
  <updated>2024-09-19T12:28:22.052Z</updated>
  <id>http://error666.top/</id>
  
  <author>
    <name>Error_666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习课程自学笔记</title>
    <link href="http://error666.top/2024/09/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://error666.top/2024/09/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%AF%BE%E7%A8%8B%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2024-09-19T04:25:47.000Z</published>
    <updated>2024-09-19T12:28:22.052Z</updated>
    
    <content type="html"><![CDATA[<p>参考内容：《机器学习》周志华</p><span id="more"></span><hr /><p>成绩构成：</p><ol type="1"><li>考勤、作业、研讨：10%</li><li>项目：40%</li><li>期末：50%</li></ol><h3 id="一.-绪论">一. 绪论</h3><ol type="1"><li><p>根据训练数据是否拥有标记数据，学习任务大致可分为两类：监督学习、无监督学习。</p><ul><li>分类和回归是前者的代表，聚类是后者的代表</li><li>聚类意思是在训练过程中，机器会自动的对事物的潜在概念进行划分，并把物体分成若干组</li></ul></li><li><p>模型适用于新样本的能力，称为泛化能力</p></li><li><p>通常假设样本空间中全体样本服从一个位置分布<spanclass="math inline">\(\mathcal{D}\)</span>，我们获得的每个样本都是独立地从这个分布上采样得到的，即“独立同分布”。</p></li><li><p>假设空间</p><ul><li>简单理解，就是所有输入的状态</li><li>书中举了个例子，有A、B、C三种属性，分别有3、2、2种取值方式。学习目标是某个状态<spanclass="math inline">\((a, b, c)\)</span>是否是牛逼的？求所有状态数。<ul><li>对于属性A，其实有4种状态，<span class="math inline">\(a_1, a_2, a_3,*\)</span>，<spanclass="math inline">\(*\)</span>表示这个属性取什么无所谓。对于B、C属性同理</li><li>那么状态数就有：<span class="math inline">\(4 * 3 * 3 =36\)</span>种</li><li>其实还漏了一种，还有一种状态是世界上没有"牛逼"这个概念，也就是<spanclass="math inline">\(\phi\)</span>状态。</li><li>所以这个例子的总状态数是37种。</li><li>我来列举其中的几种：<ul><li>A是<span class="math inline">\(a_1\)</span>，B是<spanclass="math inline">\(b_2\)</span>，C是<spanclass="math inline">\(c_3\)</span>时，是牛逼的</li><li>A是<span class="math inline">\(*\)</span>，B是<spanclass="math inline">\(b_1\)</span>，C是<spanclass="math inline">\(*\)</span>时，是牛逼的</li><li><span class="math inline">\(\cdots\)</span></li><li>世界上没有"牛逼"这个东西</li></ul></li></ul></li></ul></li><li><p>版本空间</p><ul><li><p>简单理解，就是把假设空间中不符合样本的所有假设剔除掉的空间</p></li><li><p>以书中例子为例</p><ul><li>根据表1.1，我们知“好瓜”的概念是成立的，所以先删除 <spanclass="math inline">\(\phi\)</span> 的假设</li><li>根据样本（（色泽=青绿）<sup>（根蒂=蜷缩）</sup>（敲声=浊响））——&gt;好瓜，删除所有状态对不上的假设</li><li>根据样本（（色泽=乌黑）<sup>（根蒂=蜷缩）</sup>（敲声=浊响））——&gt;好瓜，删除所有状态对不上的假设</li></ul><blockquote><p>这里把（（色泽=乌黑）<sup>（根蒂=蜷缩）</sup>（敲声=浊响））删除，这个和样本2符合，不要觉得心虚，因为利用样本2进行删除的时候也会删掉（（色泽=青绿）<sup>（根蒂=蜷缩）</sup>（敲声=浊响））这样刚好留下了（（色泽=*）<sup>（根蒂=蜷缩）</sup>（敲声=浊响）</p></blockquote><ul><li>根据样本（（色泽=青绿）<sup>（根蒂=硬挺）</sup>（敲声=清脆））——&gt;不是好瓜，删除所有状态对上的假设</li><li>根据样本（（色泽=乌黑）<sup>（根蒂=稍蜷）</sup>（敲声=沉闷））——&gt;不是好瓜，删除所有状态对上的假设</li><li>所以最后剩下了三个假设，这三个假设我们称之为版本空间：(色泽 = <em>,根蒂 = 蜷缩, 敲声 = </em>)、(色泽 = <em>, 根蒂 = </em>, 敲声 =清脆)、(色泽 = *, 根蒂 = 蜷缩, 敲声 = 清脆)</li></ul></li></ul></li><li><p>归纳偏好</p><ul><li>现实问题中，我们常面临很大的假设空间，但学习过程是根据有限的样本训练集进行的，那么对于不同版本的训练集，就会有不同的版本空间。版本空间内每一个假设都可以判断上面数据集中的每一条数据，是好瓜还是不是好瓜，但是用不同的假设判断一条新数据可能会得出不一样的结果，这就属于“归纳偏好”。</li></ul></li></ol><h3 id="二.-模型评估与选择">二. 模型评估与选择</h3><ol type="1"><li>精度 = 1 - 错误率</li><li>学习器在训练集上的误差叫“训练误差”或“经验误差”</li><li>学习器在新样本上的误差叫“泛化误差”。显然，我们想要泛化误差小的学习器。</li><li>过拟合是指训练误差很小，但是泛化误差不理想。欠拟合是指俩误差都不理想。</li></ol><h4 id="模型评估方法">模型评估方法</h4><ul><li><p>评估方法存在的意义：实际中，我们不可能直接拿到泛化误差，因为泛化误差是指实际情况的误差。产品都没开发出来咋获得嘛。而训练误差又由于过拟合现象的存在而不适合作为标准。所以，这时候就需要设计一些精妙的评估方法</p></li><li><p>留出法</p><ul><li>将数据集D切为训练集S和验证集T</li><li>需要注意，S和T的划分要尽可能保持数据分布的一致性。例如在分类任务中至少要保证样本的类别比例相似</li><li>为了结果可靠，可以进行多次留出法，用平均值作为最终结果</li><li>留出法的缺点：我们希望的是评估用D训练出的模型的性能，但留出法本质上是评估的S训练出来的模型的性能。这就会陷入一个窘境：若S包含绝大多数样本，虽然S与D的差距拉近，但是T太小导致评估结果可能不稳定；若S太少，S与D的差距就更远了。所以这个bug没有完全的解决方案，常见做法是将约1/5~ 1/3的样本用于测试，剩下的用于训练</li></ul></li><li><p>交叉验证法</p><ul><li>将D划分为k个大小相似的互斥子集：<span class="math inline">\(D = D_1\cup D_2 \cup \cdots \cup D_k\)</span>。然后枚举<spanclass="math inline">\(D_i\)</span>，每次(全集 - <spanclass="math inline">\(D_i\)</span>)作为训练集，<spanclass="math inline">\(D_i\)</span>作为验证集。进行k次训练测试，最后返回k次结果的均值。</li><li>可以发现，交叉验证法的稳定性和保真性很大程度取决于k，通常取10，称为10折交叉验证</li><li>需要注意，<spanclass="math inline">\(D_i\)</span>尽可能保持数据分布的一致性</li><li>为了结果可靠，可以进行多次交叉验证法，用均值作为最终结果。常见的有：10次10折交叉验证</li><li>（当k = D样本数量时，是交叉验证法的一个特例，称为留一法）</li></ul></li><li><p>自助法</p><ul><li>无论是留出法还是交叉验证法，S !=D，所以必然会存在一定偏差。留一法虽然可以使得S <spanclass="math inline">\(\to\)</span>D，但是训练集太大计算复杂度太高。有没有两全其美的方法呢——自助法。</li><li>做法：假设D样本数为m，则进行放回随机采样m次，得到D'。用D'作为训练集，D'作为验证集。</li><li>样本在m次采样始终不被采到的概率：</li></ul><p><span class="math display">\[\lim_{m\mapsto\infty}\left(1-\frac1m\right)^m\mapsto\frac1e\approx0.368\]</span></p><ul><li>即数据集D中约36.8%的样本不会出现在D'中。</li><li>优点：评估的模型和期望评估的模型都使用了m个样本，但仍有1/3的数据供我们验证。在数据集较小或难以划分训练/验证集时很有用。</li><li>缺点：自助法生产的数据集改变了初始数据集分布，会引入估计偏差。因此数据量充足时，留出法和交叉验证法更常用</li></ul></li><li><p>在进行完模型评估（也就是训练和评估）后，需要再将数据集D全部丢进模型训练一次。这么做是因为模型评估时S!= D。</p></li></ul><h4 id="性能度量">性能度量</h4><ul><li>当得到一个模型后，如何评估它的泛化能力呢？显然需要去度量它的性能，衡量模型泛化能力的评价标准，就叫性能度量。不同的性能度量往往会导致不同的评判结果。</li><li>回归任务最常用的性能度量是“均方误差”：<ul><li>离散：<span class="math inline">\(E(f; D) =\frac1m\sum_{i=1}^m(f(x_i) - y_i)^2\)</span></li><li>一般：<span class="math inline">\(E(f; \mathcal{D}) = \int_{x \sim\mathcal{D}}(f(x) - y)^2p(x)dx\)</span></li></ul></li><li>ok，接下来介绍分类任务的性能度量</li></ul><ol type="1"><li><p>错误率和精度</p><ul><li>错误率定义<ul><li>离散：<span class="math inline">\(E(f; D) =\frac1m\sum_{i=1}^m\mathbb{I}(f(x_i) \ne y_i)\)</span></li><li>一般：<span class="math inline">\(E(f; \mathcal{D}) = \int_{x \sim\mathcal{D}}\mathbb{I}(f(x)\ne y)p(x)dx\)</span></li></ul></li><li>精度定义<ul><li>离散：<span class="math inline">\(acc(f; D) =\frac1m\sum_{i=1}^m\mathbb{I}(f(x_i)=y_i)=1-E(f; D)\)</span></li><li>一般：<span class="math inline">\(acc(f; \mathcal{D}) = \int_{x \sim\mathcal{D}}\mathbb{I}(f(x)=y)p(x)dx=1-E(f; \mathcal{D})\)</span></li></ul></li></ul></li><li><p>查准率、查全率、F1</p><ul><li>举个例子，若我们关心“挑出的西瓜中有多少比例是好瓜”以及“所有好瓜中有多少比例被挑了出来”。前者我们用“查准率”(precision)描述，后者用"查全率"(recall)来描述。</li><li>对二分类来说，我们将预测结果抽象为混淆矩阵：</li><li><img src="1.png" /></li><li>（TP, true positive表示它确实是正例，表示我们预测对了。TN, truenegative表示它确实是反例，表示我们预测对了。）</li><li>显然$TP + FN + FP + TN = $样例总数</li><li>查准率：<span class="math inline">\(P = \frac{TP}{TP +FP}\)</span></li><li>查全率：<span class="math inline">\(R = \frac{TP}{TP +FN}\)</span></li><li>可以发现，查准率和查全率都兼顾有些困难。因为如果想让查全率高，那么就要增加选瓜数量，但是选瓜数量增加后，选出的瓜中是好瓜的概率可能就下降，即查准率下降；若希望选出的好瓜比例高，那么只挑选最有把握的瓜，这样难免就会漏掉不少好瓜，即查全率较低。通常只有在一些简单任务中，才能使P和R都很高。</li><li>所以，有没有直观的比较方法呢——PR图。</li><li>我们根据学习器的预测结果对样例排序，＂最可能＂是正例的排在最前边或者说最左边，＂最不可能＂是正例的排在最后边或者说最右边．按此顺序逐个把样本作为正例进行预测，每次计算测试样本的查准率和查全率并把这两项作为PR曲线的纵轴和横轴。</li><li><img src="3.png" /></li><li>显然若一条曲线包住了另一条曲线，那么说明它在任意时刻表现都好。如果俩曲线有相交，那么就比较下俩曲线所形成的面积，谁大谁牛逼。</li><li>当然面积可能不好算，所以我们直接用“平衡点”（BEP, 即P =R时的R坐标）来衡量，谁平衡点大谁牛逼。但是平衡点这方法还是太简陋了，所以我们使用F1度量（谁大谁牛逼）：</li></ul><p><span class="math display">\[\frac{1}{F_1} = \frac12\cdot (\frac1P + \frac1R)\]</span></p><ul><li>为了更定制化，还可以使用<spanclass="math inline">\(F_\beta\)</span>度量（<spanclass="math inline">\(F_1\)</span>是调和平均，<spanclass="math inline">\(F_\beta\)</span>是加权调和平均）：</li></ul><p><span class="math display">\[\frac{1}{F_\beta} = \frac{1}{1+\beta^2}\cdot (\frac1P +\frac{\beta^2}{R})\]</span></p><ul><li><spanclass="math inline">\(\beta\)</span>度量了查全率对查准率的相对重要性，<spanclass="math inline">\(\beta=1\)</span>为一样重要，<spanclass="math inline">\(\beta &gt; 1\)</span>表示我们更重视查全率。</li><li>如果有多个混淆矩阵呢？</li><li>第一种方法，直接对所有P、R、F1取均值作为最终结果。这样得到的结果叫做：宏查准率、宏查全率、宏F1</li><li>第二种方法，先对所有混淆矩阵对应四个位置取均值，再算出对应的P、R、F1。这样得到的结果叫做：微查准率、微查全率、微F1</li></ul></li><li><p>ROC和AUC</p><ul><li>ROC曲线跟PR曲线绘制流程一样，只是横坐标换为了“假正例率”（FPR），纵坐标换为了“真正例率”（TPR）。</li><li><span class="math inline">\(TPR = \frac{TP}{TP + FN}, \quad FPR =\frac{FP}{FP + FN}\)</span></li><li>TPR表示对于全部好瓜，你预测对了百分之TPR；FPR表示对于全部坏瓜，你预测错了百分之FPR。</li><li>显然TPR越高越好，FPR越低越好。</li><li>ROC曲线画出来的感觉如下：</li><li><img src="2.png" /></li><li>AUC是ROC曲线的面积。显然如果一个曲线包住另一个，但它就更牛逼。如果俩线有相交，那么就看看谁的AUC更大，越大越牛逼。</li></ul></li><li><p>代价敏感错误率和代价曲线</p><ul><li>在现实中同样是判断错误，但是后果可能不同。比如门禁系统错误的把陌生人放进来的危害肯定比把可通行人拦在外边危害更大。所以同样是判断错误，我们需要赋予其不同的权值。最后的目标是使平均代价最小。</li><li>所以可以抽象出代价矩阵的概念：</li><li><img src="4.png" /></li><li>代价敏感错误率：</li></ul><p><span class="math display">\[E(f; D; cost) = \frac1m(\sum_{x_i \in D^+}\mathbb{I}(f(x_i) \ne y_i)\times cost_{01} + \sum_{x_i \in D^-}\mathbb{I}(f(x_i) \ne y_i) \timescost_{10})\]</span></p><ul><li>当不同后果的权重不同时，上面说的ROC曲线就不能直接反映出学习器的期望总体代价了。所以这时候我们需要“代价曲线”。</li><li>略</li></ul></li></ol><h4 id="比较检验">比较检验</h4><ul><li><p>目前，我们已经可以使用某种模型评估方法，测出某个性能度量的结果。</p></li><li><p>但是泛化性能是对新样本进行预测的性能，新样本看成一个总体，那么这个总体我们永远无法完整获得，也就是真实泛化性能永远也不知道是多少。从这个总体中抽样得到一个样本集合，也就是我们通常说的“测试集”，很显然，每次抽样，获得的测试集都不相同，从而从测试集计算得到的性能值也就不同。从测试集得到的性能值可以看成是总体泛化性能的一个估计值，基于这个估计值可以对总体泛化性能进行假设检验和区间估计。</p></li><li><p>如果<spanclass="math inline">\(\mathcal{D}\)</span>是服从二项分布的。那么测试集样本容量n你是知道的，错误次数k你也是知道的。那么你可以开始玩假设检验。比如假设<spanclass="math inline">\(H_0: p_0 \le0.5\)</span>。然后你就假设你这个假设是对的呗，然后算一算在此假设下，错误次数为k的概率。如果算出来的概率小于<spanclass="math inline">\(\alpha\)</span>（显著性水平），说明在此假设下发生这件事的概率极低，那么说明你假设是错的。如果概率大于了<spanclass="math inline">\(\alpha\)</span>，说明至少我不能信心满满的否决你的假设了，我只能说我有<spanclass="math inline">\(1 -\alpha\)</span>置信度认为你的假设是正确的。</p></li><li><p>很多时候我们并非做一次留出法估计，而是多次。所以我们会得到k个测试错误率。则我们可以计算平均错误率及其方差。那么检验统计量<spanclass="math inline">\(\tau_t = \frac{\sqrt{k}(\mu -\epsilon_0)}{\sigma}\)</span>服从t分布。（<spanclass="math inline">\(\mu\)</span>是平均错误率，<spanclass="math inline">\(\epsilon_0\)</span>是假设的错误率， <spanclass="math inline">\(\sigma\)</span>是前面算的方差）</p></li><li><p>如果算出来的<span class="math inline">\(\tau_t\)</span>落在<spanclass="math inline">\([t_{-\alpha/2},t_{\alpha/2}]\)</span>内，则可下置信度为<span class="math inline">\(1 -\alpha\)</span>的判断认为真实错误率为<spanclass="math inline">\(\epsilon_0\)</span>；反之则可下真是错误率不为<spanclass="math inline">\(\epsilon_0\)</span>的判断。</p></li><li><p>以上俩方法都是关于对单个学习器泛化性能的假设进行的检验，但在实际任务中，更多时候我们需要对不同学习器的性能进行比较，方法有：交叉验证t检验、McNemar检验、Friedman检验、Nemenyi后续检验</p></li></ul><ol type="1"><li><p>交叉验证t检验</p><ul><li>略</li></ul></li><li><p>McNemar检验</p><ul><li><p>对二分类问题，使用留出法不仅可估计出学习器A、B的测试错误率，还可以获得俩学习器分类结果的差别，即：两者都分类正确、都错误、A对B错，A错B对的次数，即“列联表”：</p></li><li><p><img src="5.png" /></p></li><li><p>若我们的假设是俩学习器性能相同，则应有<spanclass="math inline">\(e_{01} = e_{10}\)</span>。则<spanclass="math inline">\(|e_{01} - e_{10}| \sim N(1, e_{01} +e_{10})\)</span>。</p></li><li><p>则有：<span class="math inline">\(\tau_{\chi^2}=\frac{(|e_{01} -e_{10}| - 1) ^ 2}{e_{01} + e_{10}}\)</span></p></li><li><p>即<spanclass="math inline">\(\tau_{\chi^2}\)</span>服从自由度为1的卡方分布。</p></li><li><p>当<spanclass="math inline">\(\tau_{\chi^2}\)</span>小于临界值<spanclass="math inline">\(\chi_\alpha^2\)</span>时，即认为俩学习器性能没有显著差别；反之则认为有显著差别，平均错误率小的那个更牛逼。</p></li></ul></li><li><p>Friedman检验</p><ul><li>略</li></ul></li><li><p>Nemenyi后续检验</p><ul><li>略</li></ul></li></ol><h4 id="偏差与方差">偏差与方差</h4><ul><li>为取得良好的泛化能力，则需使偏差较小，此时能够充分拟合数据。并且要使方差较小，因为越小的方差表示受数据扰动的影响小。</li><li>但是往往两全不能齐美，称为偏差-方差窘境。</li><li>具体内容略。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考内容：《机器学习》周志华&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="计算机专业课" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>微分方程1</title>
    <link href="http://error666.top/2024/09/18/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B1/"/>
    <id>http://error666.top/2024/09/18/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B1/</id>
    <published>2024-09-18T10:05:34.000Z</published>
    <updated>2024-09-18T12:11:37.020Z</updated>
    
    <content type="html"><![CDATA[<p>mit 18.03 Arthur Mattuck教授讲的微分方程。</p><span id="more"></span><hr /><h3 id="导言">导言</h3><p>常微分方程（ordinary differential equation,ODE）：函数的自变量只有一个，通常是时间</p><p>举个最简单的例子，考虑平抛问题中的垂直方向，向下为正。</p><p><span class="math inline">\(\because \dot{v} = g \quad \therefore v =gt + v_0\)</span></p><p><span class="math inline">\(\because \dot{y} = v = gt + v_0 \quad\therefore y = \frac12gt^2 + v_0t + y_0\)</span></p><p>上面这个简单的例子，其实就是在求解微分方程：<spanclass="math inline">\(\ddot{y} = g\)</span></p><p>这个微分方程非常简单，且求解非常容易。但往往实际中的大部分问题，你只能列出微分方程，但是却无法精确求解它。例如下面单摆这个例子：</p><p><img src="1.png" /></p><p>规定以中间垂直线为标准，向右边的角度为正，左边为负。考虑切向加速度<spanclass="math inline">\(a\)</span>，加速度前的负号表示它总指向与位移相反的方向。</p><p>可以根据图片写出一些公式： <span class="math display">\[\begin{align*}    \because x &amp;= L\theta \\    \because a &amp;= -g\sin \theta \\    \therefore \ddot{x} &amp;= -g\sin\theta \\    \therefore L\ddot{\theta} &amp;= -g\sin\theta \\    \therefore \ddot{\theta} &amp;= -\frac{g}{L}\sin\theta\end{align*}\]</span> 我们成功写出了一个关于<spanclass="math inline">\(\theta(t)\)</span>的微分方程。为了更加负号实际，我们引入空气阻力，于是微分方程变为：<span class="math display">\[\ddot{\theta} = -\mu\dot{\theta} - \frac{g}{L}\sin\theta\]</span>很好。单摆这个微分方程，是十分难求解的。既然我们求不出它的解析解，那我们如果仅通过这个方程窥探摆运动的规律呢？</p><p>既然上面那个微分方程体现了摆的运动，那我们先将这个微分方程可视化出来，具体来说，我们可以以x轴为<spanclass="math inline">\(\theta\)</span>，y轴为<spanclass="math inline">\(\dot{\theta}\)</span>。即有向量坐标<spanclass="math inline">\((\theta,\dot{\theta})\)</span>。对向量坐标求导，得到<spanclass="math inline">\((\dot{\theta},\ddot{\theta})\)</span>向量，它表示了当前该坐标在图上变化的方向和大小。</p><p>这样子的话，我们对平面上所有坐标<span class="math inline">\((\theta,\dot{\theta})\)</span>，把对应的<spanclass="math inline">\((\dot{\theta},\ddot{\theta})\)</span>向量平移到以<span class="math inline">\((\theta,\dot{\theta})\)</span>为起点上来。就可以得到一副这样的图：</p><p><img src="2.png" /></p><p>（为了保持美观，向量的长度保持了一样，通过颜色来区分向量的长度）</p><p>这幅图会引发我们很多的思考，可以发现，原点代表着摆的角度和角加速度都为0，即静止状态。通过旋流来看显然最后的状态都会回归静止状态，这是符合实际的。我们还会发现，在<spanclass="math inline">\((\pi, 0)\)</span>位置的旋流是静止的，说明<spanclass="math inline">\((\pi,0)\)</span>是个不动点。那它代表什么物理含义呢？它代表小球在正上方保持平衡。well，根据实际我们可以知道，这确实是个可保持静止的地方，但但凡受到一点扰动，就会打破这个平衡。</p><p>所以我们可以得出结论：<span class="math inline">\((0, 0), (\pi,0)\)</span>都是不动点，但<span class="math inline">\((0,0)\)</span>是稳定点，而<span class="math inline">\((\pi,0)\)</span>不是。</p><p>非常有趣！问题来了，如何绘制出这一幅图？</p><p>我们已知的是微分方程为<span class="math inline">\(\ddot{\theta} =-\mu\dot{\theta} - \frac{g}{L}\sin\theta\)</span>，且坐标<spanclass="math inline">\((\theta, \dot{\theta})\)</span>上的向量为<spanclass="math inline">\((\dot{\theta}, \ddot{\theta})\)</span>。</p><p>那么我们可以任意选取某点<span class="math inline">\((\theta_0,\dot{\theta}_0)\)</span>，然后根据微分方程算出<spanclass="math inline">\(\ddot{\theta}\)</span>。即可得到当前坐标上的向量<spanclass="math inline">\((\dot{\theta}_0,\ddot{\theta}_0)\)</span>。这个向量就体现了该坐标的移动趋势，所以我们将该坐标朝着对应向量方向移动一个小距离<spanclass="math inline">\(\Delta t\)</span>，即可得到新点<spanclass="math inline">\((\theta_1,\dot{\theta_1})\)</span>。重复这个步骤，即可画出一条轨迹。多次取不同的初始点进行绘制，即可得到若干条轨迹。全部的轨迹合起来就是上述那张图。</p><p>Well，讲到这里，相信你已经感受到微分方程的魅力了。通过小小方程，即可窥探事物运行的规律，没有比这更令人兴奋的事情了！</p><h3 id="一.-ode几何方法">一. ODE几何方法</h3><p>如何用作图描述ODE呢？</p><p>使用方向场。跟前言中使用的方法类似，假设目前我们有：<spanclass="math inline">\(y&#39; = f(x, y)\)</span></p><p>那我们可以作一幅二维图，x轴就是x，y轴就是y，坐标<spanclass="math inline">\((x,y)\)</span>上是一个短线（称为"线素"），这条短线的斜率就是<spanclass="math inline">\(y&#39;\)</span></p><p>那么，画出一条与所有线素相切的曲线，就是微分方程<spanclass="math inline">\(y&#39;=f(x,y)\)</span>的一个解，称之为"积分曲线"</p><p>这显然是正确的，因为对于一条画出来的曲线，其任意一点都与线素相切，说明其斜率也就是<spanclass="math inline">\(y&#39;\)</span>跟给定的<spanclass="math inline">\(y&#39;=f(x,y)\)</span>一致，也就是这条曲线符合微分方程，所以它自然就是解。</p><p>例如这个微分方程：<span class="math inline">\(y&#39; =-\frac{x}{y}\)</span>。它用方向场画出来的积分曲线如下：</p><p><img src="3.png" /></p><p>（<span class="math inline">\(C = 0\)</span> means <spanclass="math inline">\(y&#39; = 0\)</span>）</p><p>再来一个例子：<span class="math inline">\(y&#39; = 1 + x -y\)</span></p><p><img src="4.png" /></p><p>注意到在<span class="math inline">\(C=2\)</span>和<spanclass="math inline">\(C=0\)</span>两条之间的区域，当积分曲线进入这个区域后就再也出不去了，解函数无法逃逸。另一个需要注意的要点是，积分曲线永远不会相交。如果两曲线相交的话，则在交点处就会有两条切线、两个斜率，这与微分方程不符。因此进入此区域的曲线，无法逃逸也无法相交，只能够互相靠近，朝向<spanclass="math inline">\(y=x\)</span>的直线靠拢。</p><p>事实上，在方向场上的积分曲线满足"存在与唯一性定理"：</p><ul><li>存在性：若<span class="math inline">\(y\)</span>在<spanclass="math inline">\((x_0, y_0)\)</span>的领域内连续，则通过<spanclass="math inline">\((x_0, y_0)\)</span>的<spanclass="math inline">\(y&#39;=f(x, y)\)</span>有解。</li><li>唯一性：若<span class="math inline">\(y&#39;\)</span>在<spanclass="math inline">\((x_0, y_0)\)</span>的领域为连续，则通过<spanclass="math inline">\((x_0, y_0)\)</span>的<spanclass="math inline">\(y&#39; = f(x, y)\)</span>有且仅有唯一解。</li></ul><h3 id="二.-欧拉数值方法及推广">二. 欧拉数值方法及推广</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;mit 18.03 Arthur Mattuck教授讲的微分方程。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="微分方程" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%A6/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>线性代数4</title>
    <link href="http://error666.top/2024/09/15/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/"/>
    <id>http://error666.top/2024/09/15/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B04/</id>
    <published>2024-09-15T15:26:20.000Z</published>
    <updated>2024-09-16T15:45:43.936Z</updated>
    
    <content type="html"><![CDATA[<p>总结、知识易混点整理、补充知识</p><span id="more"></span><hr /><h3 id="总结">总结</h3><p>前前后后花了一个月左右把mit 18.06学完了，收获颇丰，感谢教授。</p><p>这门课第一章从（方程组 + 矩阵 +四个基本子空间）出发，讨论了线性代数的基本元素：向量、矩阵、空间。最后用所学知识对电势差问题建模，得到了许多优美的结论。</p><p>第二章开始研究矩阵各种性质，例如正交、投影、行列式、特征值、对角化。并在结尾用马尔可夫矩阵寻找稳态，用正交性对傅里叶级数建模。</p><p>第三章仍然是研究矩阵的各种性质，例如对称、正定、相似、SVD分解。以及将线性变换和矩阵统一起来。利用基变换实现图像压缩展示了线性变换的优美之处。</p><p>总之，这门课不仅帮我扎实的打好了线代基础，而且给了我理解线代的上层视角。以及：马尔可夫矩阵、对角化、SVD分解、基变换压缩这三个知识点也给了我科研上的启发，说不定哪天就可以作为trick来优化我的算法。</p><h3 id="section"></h3><h3 id="知识点易混点整理">知识点易混点整理</h3><ol type="1"><li>如何理解矩阵<spanclass="math inline">\(A\)</span>可对角化的条件是：“有n个线性无关的特征向量”?<ul><li>因为我们在推对角化公式的时候，用的是<span class="math inline">\(AS =S\Lambda\)</span>。<spanclass="math inline">\(S\)</span>是n个特征向量排成的方阵</li><li>因为要右乘<spanclass="math inline">\(S^{-1}\)</span>，所以就要保证<spanclass="math inline">\(S\)</span>的n个列向量线性无关，即<spanclass="math inline">\(A\)</span>有n个线性无关的特征向量</li><li>这样才能推出：<span class="math inline">\(A = S\LambdaS^{-1}\)</span></li></ul></li><li>上面那个判据太困难了，有什么等价判据？<ul><li>若<spanclass="math inline">\(A\)</span>有n个互不相同的特征值，则<spanclass="math inline">\(A\)</span>有n个线性无关的特征向量</li><li>但若没有，则不能说<spanclass="math inline">\(A\)</span>一定没有n个线性无关的特征向量</li><li>所以我们判断一个矩阵是否可对角化，可转换为求其特征值的问题。</li></ul></li><li><span class="math inline">\(A\)</span>有n个线性无关的特征向量 和<span class="math inline">\(A\)</span>的各列线性无关有什么关系？<ul><li>前者可推后者，后者不可推前者</li><li>我来证一下前者可推后者，因为对于特征向量x，有<spanclass="math inline">\(Ax = \lambda x\)</span>，所以<spanclass="math inline">\(\lambda x\)</span>是通过<spanclass="math inline">\(A\)</span>进行列变换得到的，那仅仅通过列变换就可以得到一组线性无关的向量，相当于变换后的列空间就是<spanclass="math inline">\(\mathrm{R}^n\)</span>。而列变换不改变列空间，所以<spanclass="math inline">\(C(A) = \mathrm{R}^n\)</span>，所以<spanclass="math inline">\(A\)</span>的各列线性无关。</li></ul></li><li>对称矩阵一定可以对角化吗？若可以，它的对角化有什么特别之处？<ul><li>是的一定可以。</li><li>对称矩阵<spanclass="math inline">\(A\)</span>可以对角化。那么可写为：<spanclass="math inline">\(A = S\Lambda S^{-1}\)</span></li><li>因为对称矩阵有个很好的性质就是：可选出一组正交特征向量。所以<spanclass="math inline">\(S\)</span>可以是完全正交的，再将其标准化一下，即可得到正交阵<spanclass="math inline">\(Q\)</span>。</li><li>正交阵有一个很好的性质：<span class="math inline">\(Q^{-1} =Q^T\)</span></li><li>所以可对角化的对称矩阵<spanclass="math inline">\(A\)</span>可对角化为：<spanclass="math inline">\(A = Q\Lambda Q^\mathrm{T}\)</span></li></ul></li><li>正定矩阵有什么好处吗？<ul><li>首先正定矩阵是对称矩阵的一个子集，对称矩阵已经有一些很好的性质了，正定矩阵除了有对称矩阵的性质，还有其余很好的性质。比如一定可逆而且<spanclass="math inline">\(x^\mathrm{T}Ax &gt; 0\)</span>。</li><li>如果快速获得一个对称矩阵？<spanclass="math inline">\(A^\mathrm{T}A\)</span>，<spanclass="math inline">\(xx^\mathrm{T} / AA^\mathrm{T}\)</span></li><li>如果快速获得一个正定矩阵？<span class="math inline">\(A^\mathrm{T}A,r(A) = n\)</span></li></ul></li><li></li></ol><h3 id="补充知识">补充知识</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结、知识易混点整理、补充知识&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线性代数3</title>
    <link href="http://error666.top/2024/09/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/"/>
    <id>http://error666.top/2024/09/14/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B03/</id>
    <published>2024-09-14T15:31:27.000Z</published>
    <updated>2024-09-16T15:11:39.326Z</updated>
    
    <content type="html"><![CDATA[<p>对称矩阵、复数矩阵、FFT、正定矩阵、相似矩阵、SVD分解、线性变换、图像压缩、左右逆/伪逆</p><span id="more"></span><hr /><h3 id="一.-对称矩阵及其正定性">一. 对称矩阵及其正定性</h3><p>在这里我们只讨论实对称矩阵。</p><p>我们很喜欢对称矩阵，因为它具有很好的性质。就拿实对称矩阵来举例，它具有下列两个性质：</p><ol type="1"><li>其特征值均为实数</li><li>其一定可选出具有正交的特征向量。这里的“有”，是指可以选出一套完全正交的特征向量（例如在重特征值条件下，可能存在一个平面内向量都可以作为特征向量）</li><li>特征值的符号与主元的符号相同，即正数的个数相同，负数的个数也相同</li></ol><p>上一章我们学过，若方阵<spanclass="math inline">\(A\)</span>具有n个线性无关的特征向量，那么其可以对角化为<spanclass="math inline">\(S\Lambda S^{-1}\)</span>。</p><p>对于有n个线性无关特征向量的对称矩阵来说，因为性质2，所以它的特征向量矩阵可化为一个正交阵<spanclass="math inline">\(Q\)</span>，正交阵满足<spanclass="math inline">\(Q^\mathrm{T} = Q^{=1}\)</span></p><p>所以对于具有n个线性无关特征向量的对称矩阵<spanclass="math inline">\(A\)</span>来说，其可对角化为<spanclass="math inline">\(Q\Lambda Q^T\)</span>。</p><p>把上面的式子进一步展开：</p><p><span class="math inline">\(A = Q\Lambda Q^\mathrm{T} =\begin{bmatrix} q_1 &amp; q_2 &amp; \cdots &amp; q_n \end{bmatrix}\begin{bmatrix} \lambda_1 &amp; &amp; &amp; \\ &amp; \lambda_2 &amp;&amp; \\ &amp; &amp; \cdots &amp; \\ \end{bmatrix} \begin{bmatrix}q_1^\mathrm{T} \\ q_2^\mathrm{T} \\ \cdots \\ \end{bmatrix}\)</span></p><p>利用"线性代数1"讲的用拆分矩阵乘法为加法去理解这个式子，可以写成：</p><p><span class="math inline">\(A = \lambda_1q_1q_1^\mathrm{T} +\lambda_2q_2q_2^\mathrm{T} + \cdots +\lambda_nq_nq_n^\mathrm{T}\)</span></p><p>上面这个式子发现了吗，其实每一项都是一个系数乘一个投影矩阵，因为<spanclass="math inline">\(Q\)</span>是正交矩阵，所以<spanclass="math inline">\(q_i^\mathrm{T}q_i = 1\)</span>。</p><p>所以<spanclass="math inline">\(A\)</span>可以理解为投影矩阵的线性组合，且投影方向都是互相正交的。</p><hr /><p>下面来介绍正定矩阵。</p><p>正定矩阵是对称矩阵的一个子类，且所有特征值&gt;0</p><p>而且它的“子行列式”均&gt;0，子行列式指的是n阶矩阵左上角的所有<spanclass="math inline">\(k \times k, 1 \le k \len\)</span>子行列式数值均为正。这很好理解，由对称矩阵的性质3，我们知道，其所有主元都&gt;0。而行列式就等于主元之积，所以子行列式们自然都大于0。这就是用行列式判定矩阵正定的判据。</p><h3 id="二.-复数矩阵-快速傅里叶变换">二. 复数矩阵, 快速傅里叶变换</h3><p>对不起我的高数很垃圾，这节我也听不懂。等我学完mit18.03再来听这一节课</p><h3 id="三.-正定矩阵">三. 正定矩阵</h3><p>正定矩阵是很好的矩阵，它是对称的而且所有特征值都大于零。那么如何判定一个方阵是正定矩阵呢？这里我给出几种方法</p><ol type="1"><li>所有特征值<span class="math inline">\(\lambda_i &gt; 0\)</span></li><li>所有主元大于零</li><li>所有子行列式们大于零</li><li><span class="math inline">\(x^\mathrm{T}Ax &gt; 0, x \ne\textbf{0}\)</span></li></ol><p>第一个是定义，第二个是因为对称矩阵有一个性质就是特征值正负号与主元相同，所以可根据(1)得到第二条等价条件。第三个是用行列式判断正定性(前面讲过)。第四个是新加的，我们很喜欢用第四个判据。让我们来看看为什么这个判据可以推出矩阵是正定的。</p><p>对于<spanclass="math inline">\(x^\mathrm{T}Ax\)</span>，我们将其展开： <spanclass="math display">\[x^\mathrm{T}Ax = \begin{bmatrix}x_1, x_2, \cdots,x_n\end{bmatrix}\begin{bmatrix} a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n \\a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n \\ a_{31}x_1 + a_{32}x_2 +\cdots + a_{3n}x_n \\ \cdots \\ a_{n1}x_1 + a_{n2}x_2 + \cdots +a_{nn}x_n\end{bmatrix} = \\ x_1(a_{11}x_1+a_{12}x_2+\cdots+a_{1n}x_n)+x_2(a_{21}x_1 + a_{22}x_2 + \cdots + a_{2n}x_n) + \cdots + x_n(a_{n1}x_1+ a_{n2}x_2 + \cdots + a_{nn}x_n)\]</span>可以发现，每一项都是二次的。其实如果用图像去研究这个函数：<spanclass="math inline">\(f(x) =x^\mathrm{T}Ax\)</span>，（这个函数也叫二次型）</p><p>矩阵为正定时二次型图像见左上角，为半正定时图像见右下角，为非正定/半正定时图像见左下角，负定时图像见右上角</p><p>这些图像研究的是二维方阵的二次型，xy轴是<spanclass="math inline">\(x\)</span>的俩分量<span class="math inline">\(x_1,x_2\)</span>，z轴是<spanclass="math inline">\(f(x)=x^\mathrm{T}Ax\)</span></p><p><img src="1.png" /></p><hr /><p>下面继续讨论下正定矩阵还有哪些性质，假设<spanclass="math inline">\(A, B\)</span>为正定矩阵，<spanclass="math inline">\(C\)</span>为矩阵。</p><p>那么<spanclass="math inline">\(A\)</span>是否可逆呢？答案是肯定的，因为我们知道<spanclass="math inline">\(A\)</span>的子行列式们都大于0，所以<spanclass="math inline">\(det(A) &gt; 0\)</span>，所以<spanclass="math inline">\(A\)</span>是非奇异的，即满秩可逆的。</p><p>那么<spanclass="math inline">\(A^{-1}\)</span>是不是正定矩阵呢？答案是肯定的。因为我们知道<spanclass="math inline">\(A^{-1}\)</span>的特征值们就是<spanclass="math inline">\(A\)</span>的特征值取倒数，而<spanclass="math inline">\(A\)</span>的特征值都大于0，所以<spanclass="math inline">\(A^{-1}\)</span>的特征值也都大于0，所以<spanclass="math inline">\(A^{-1}\)</span>也为正定矩阵。</p><p>那么<span class="math inline">\(A +B\)</span>是不是正定矩阵呢？答案是肯定的。我们来看看<spanclass="math inline">\(x^\mathrm{T}(A+B)x = x^\mathrm{T}Ax +x^\mathrm{T}Bx &gt; 0\)</span>，所以<span class="math inline">\(A +B\)</span>也是正定矩阵。</p><p>那么<spanclass="math inline">\(C^\mathrm{T}C\)</span>是不是正定矩阵呢？答案是不一定。我们来看看<spanclass="math inline">\(x^\mathrm{T}(C^\mathrm{T}C)x = (Cx)^\mathrm{T}(CX)= \|Cx\|^2 \ge 0\)</span>。</p><p>所以<spanclass="math inline">\(C^\mathrm{T}C\)</span>至少是半正定的，那什么时候是正定的呢？只要没有非零向量使得<spanclass="math inline">\(Cx = \textbf{0}\)</span>，那么就可以保证：<spanclass="math inline">\(x^\mathrm{T}(C^\mathrm{T}C)x &gt; 0\)</span>。</p><p>即要保证<span class="math inline">\(N(C) =\{\textbf{0}\}\)</span>，即要保证<span class="math inline">\(r(C) =n\)</span>，即可保证<spanclass="math inline">\(C^\mathrm{T}C\)</span>是正定矩阵。</p><p>还记得<spanclass="math inline">\(C^\mathrm{T}C\)</span>在哪用到吗？即最小二乘求最优近似解那里，最后方程为：<spanclass="math inline">\(C\hat{x}=Pb =C(C^\mathrm{T}C)^{-1}C^\mathrm{T}b\)</span></p><p>只要保证<span class="math inline">\(C\)</span>各列线性无关，则<spanclass="math inline">\(C^\mathrm{T}C\)</span>是正定矩阵，所以<spanclass="math inline">\(C^\mathrm{T}C\)</span>可逆，则上述方程成立，同左乘<spanclass="math inline">\(C^\mathrm{T}\)</span>，然后再左乘<spanclass="math inline">\((C^\mathrm{T}C)^{-1}\)</span>，即可求出<spanclass="math inline">\(\hat{x}\)</span>。</p><h3 id="四.-相似矩阵">四. 相似矩阵</h3><p><span class="math inline">\(A, B\)</span>均为<spanclass="math inline">\(n \times n\)</span>的方阵，那么<spanclass="math inline">\(A\)</span>与<spanclass="math inline">\(B\)</span>相似，用数学语言表达为：存在可逆矩阵<spanclass="math inline">\(M\)</span>，使得<span class="math inline">\(B =M^{-1}AM\)</span></p><p>它具有一个性质：相似的矩阵拥有相同的特征值。</p><blockquote><p>证明：</p><p><span class="math inline">\(Ax = \lambda x\)</span></p><p><span class="math inline">\(A(MM^{-1})x = \lambda x\)</span></p><p><span class="math inline">\(M^{-1}AMM^{-1}x = \lambdaM^{-1}x\)</span></p><p><span class="math inline">\(BM^{-1}x = \lambda M^{-1}x\)</span></p><p><span class="math inline">\(B(M^{-1}x) = \lambda(M^{-1}x)\)</span></p><p>证毕。且可看出特征值虽然不变，但是特征向量由<spanclass="math inline">\(x\)</span>变为了<spanclass="math inline">\(M^{-1}x\)</span>。</p></blockquote><p>举个例子，例如可对角化的矩阵<spanclass="math inline">\(A\)</span>，其可分解为：<spanclass="math inline">\(A = S^{-1}\Lambda S\)</span>。其中<spanclass="math inline">\(S\)</span>是可逆的，因为各特征向量线性无关。所以<spanclass="math inline">\(A\)</span>与<spanclass="math inline">\(\Lambda\)</span>就相似。而且我们会发现，<spanclass="math inline">\(A\)</span>与<spanclass="math inline">\(\Lambda\)</span>的特征值一样。</p><h3 id="五.-奇异值分解">五. 奇异值分解</h3><p>SVD分解也是一种矩阵分解的形式。至今为止，我们已经学过了许多矩阵分解方法了：<spanclass="math inline">\(LU\)</span>、<span class="math inline">\(S\LambdaS^{-1}\)</span>（可对角矩阵）、<span class="math inline">\(Q\LambdaQ^\mathrm{T}\)</span>（对称矩阵）、<spanclass="math inline">\(QR\)</span>（满秩矩阵）。</p><p>可以发现，除了<spanclass="math inline">\(LU\)</span>分解，其余分解都对矩阵有限制条件。但是这节我要讲的SVD分解，对任意矩阵都成立。</p><p>SVD用数学语言描述如下：</p><p><span class="math inline">\(A = U\Sigma V^\mathrm{T}\)</span></p><p><span class="math inline">\(A \in \mathbb{R}^{m \timesn}\)</span>是任意矩阵，<span class="math inline">\(U \in \mathbb{R}^{m\times m}\)</span>是正交阵，<span class="math inline">\(\Sigma \in\mathbb{R}^{m \times n}\)</span>是"对角阵"，<spanclass="math inline">\(V^\mathrm{T} \in \mathbb{R}^{n \timesn}\)</span>是正交阵。</p><p>我们来看下在已知<spanclass="math inline">\(A\)</span>下，如何计算出<spanclass="math inline">\(U, \Sigma, V\)</span></p><p><span class="math inline">\(\because A = U\SigmaV^\mathrm{T}\)</span></p><p><span class="math inline">\(\therefore A^\mathrm{T}A =(V\Sigma^\mathrm{T}U^\mathrm{T})(U\Sigma V^\mathrm{T}) =V\Sigma^\mathrm{T}\Sigma V^\mathrm{T}\)</span></p><p><span class="math inline">\(\because A^\mathrm{T}A \text{ is asymmetric matrix}\)</span></p><p><span class="math inline">\(\therefore V \text{ is } Q,\Sigma^\mathrm{T}\Sigma \text{ is } \Lambda, \text{ where }A^\mathrm{T}A = Q\Lambda Q^{\mathrm{T}}\)</span></p><p>所以，对于<span class="math inline">\(A\)</span>，求出<spanclass="math inline">\(A^\mathrm{T}A\)</span>的特征值开根和对应的相互正交的标准特征向量，对应排好就是<spanclass="math inline">\(\Sigma, V\)</span></p><p>那有了<span class="math inline">\(\Sigma, V\)</span>后，如何求<spanclass="math inline">\(U\)</span>呢？</p><p><span class="math inline">\(\because A = U\SigmaV^\mathrm{T}\)</span></p><p><span class="math inline">\(\therefore AV = U\Sigma V^\mathrm{T}V =U\Sigma\)</span></p><p>即再算出<spanclass="math inline">\(AV\)</span>，然后每一列除对应的奇异值，即可得到<spanclass="math inline">\(U\)</span>。</p><hr /><p>多说无益，举个例子来看下如何将矩阵<spanclass="math inline">\(A\)</span>分解为<spanclass="math inline">\(U\Sigma V^\mathrm{T}\)</span></p><p>已知<span class="math inline">\(A = \begin{bmatrix} 4 &amp; 4 \\ -3&amp; 3 \end{bmatrix}\)</span></p><p>先算出<span class="math inline">\(A^\mathrm{T}A = \begin{bmatrix} 25&amp; 7 \\ 7 &amp; 25 \end{bmatrix}\)</span></p><p>然后求其特征值和对应的互相正交的标准特征向量：</p><p><span class="math inline">\(\lambda_1 = 18, x_1 =\frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\ -1 \end{bmatrix}\)</span></p><p><span class="math inline">\(\lambda_2 = 32, x_2 =\frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\ 1 \end{bmatrix}\)</span></p><p>即已经求出<span class="math inline">\(\Sigma = \begin{bmatrix}\sqrt{18} &amp; \\ &amp; \sqrt{32} \end{bmatrix}, V =\frac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; 1 \\ -1 &amp; 1\end{bmatrix},V^\mathrm{T} = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; -1 \\ 1 &amp; 1\end{bmatrix}\)</span></p><p>然后算出<span class="math inline">\(AV\)</span>，即<spanclass="math inline">\(U\Sigma\)</span>：<spanclass="math inline">\(\begin{bmatrix} 0 &amp; \frac{8}{\sqrt{2}} \\-\frac{6}{\sqrt{2}} &amp; 0\end{bmatrix}\)</span></p><p>每一列除对应的<spanclass="math inline">\(\sqrt{\lambda_i}\)</span>，即第一列除<spanclass="math inline">\(\sqrt{18}\)</span>，第二列除<spanclass="math inline">\(\sqrt{32}\)</span>，得到<spanclass="math inline">\(U\)</span>：<spanclass="math inline">\(\begin{bmatrix} 0 &amp; 1 \\ -1 &amp; 0\end{bmatrix}\)</span></p><p>现在所有东西都已求出来： <span class="math display">\[U = \begin{bmatrix} 0 &amp; 1 \\ -1 &amp; 0 \end{bmatrix}, \Sigma =\begin{bmatrix} \sqrt{18} &amp; \\ &amp; \sqrt{32} \end{bmatrix},V^\mathrm{T} = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; -1 \\ 1 &amp; 1\end{bmatrix}\]</span> 我们来验证一下，将这仨乘起来，发现等于<spanclass="math inline">\(A\)</span>，check！</p><hr /><p>SVD有什么用呢？我来举一个例子，例如某件事物需要用两个维度来刻画，即<spanclass="math inline">\(f: (x, y) \toz\)</span>。那么适合用一个矩阵来表示，不妨表示为<spanclass="math inline">\(A\)</span>。</p><p>如果我们将<span class="math inline">\(A\)</span>进行SVD分解为<spanclass="math inline">\(U\SigmaV^\mathrm{T}\)</span>，进一步展开可以得到： <spanclass="math display">\[A = U\Sigma V^\mathrm{T} = \begin{bmatrix}u_1, u_2, \cdots,u_n\end{bmatrix} \cdot \begin{bmatrix}\sigma_1 &amp; &amp; &amp; \\&amp; \sigma_2 &amp; &amp; \\ &amp; &amp; \cdots &amp; \\ &amp; &amp;&amp; \sigma_n\end{bmatrix} \cdot \begin{bmatrix}v_1^\mathrm{T} \\v_2^\mathrm{T} \\ \cdots \\ v_n^\mathrm{T}\end{bmatrix} =\sigma_1u_1v_1^\mathrm{T} + \sigma_2u_2v_2^\mathrm{T} + \cdots +\sigma_nu_nv_n^\mathrm{T}\]</span> 可以发现，一个矩阵被拆解为若干矩阵相加，奇异值<spanclass="math inline">\(\sigma_i\)</span>可以理解为矩阵所占的权重。那些<spanclass="math inline">\(\sigma_i\)</span>大的矩阵说明对整体矩阵的影响越大。</p><p>相当于对于一个模式<spanclass="math inline">\(A\)</span>，我可以知道<spanclass="math inline">\(A\)</span>重点体现在哪些子模式上，进而重点去优化那些子模式。</p><h3 id="六.-线性变换">六. 线性变换</h3><p>什么是坐标？</p><p>其实，世界上坐标不是天生存在的东西。而是人类以某些东西为标准，去测量其它东西的一种度量。</p><p>例如我们通常认知的坐标系，其实上就是以俩正交的标准向量基为标准，坐标就是用这俩去线性组合的系数。</p><p>所以如何理解一个线性变化？</p><p>我这么说吧，假设我们已经确定好一组基(n个)，那么这组基作为我们的“观测基准”，可以以它们为标准观测出万物的状态<spanclass="math inline">\((c_1, c_2, \cdots, c_n)\)</span>。（<spanclass="math inline">\(c_i\)</span>跟第i个基向量有关）</p><p>但是现在，我想换一套观察工具，也就是换一组基(m个)，那么换完之后，<strong>同样</strong>的一个事物，在之前用旧基观测的时候，它的状态是<spanclass="math inline">\((c_1, c_2, \cdots,c_n)\)</span>，用新基观测的时候，它的状态变为<spanclass="math inline">\((d_1, d_2, \cdots, d_m)\)</span>。</p><p>那么有没有一种映射，可以直接让我从<span class="math inline">\((c_1,c_2, \cdots, c_n)\)</span>直接可以得到<span class="math inline">\((d_1,d_2, \cdots, d_m)\)</span>？有，它就是——线性变换。</p><p>如何构造这个线性变换呢？如下：</p><p>对于旧基(<spanclass="math inline">\(v\)</span>)的每个基向量，我们都先用新基(<spanclass="math inline">\(w\)</span>)去观测它，并得到观测状态<spanclass="math inline">\(a_{ij}\)</span>： <span class="math display">\[\begin{align*}    v_1 &amp;= a_{11}w_1 + a_{21}w_2 + \cdots + a_{m1}w_m \\    v_2 &amp;= a_{12}w_1 + a_{22}w_2 + \cdots + a_{m2}w_m \\    &amp;\cdots \\    v_n &amp;= a_{1n}w_1 + a_{2n}w_2 + \cdots + a_{mn}w_m\end{align*}\]</span> 对于一件事物<spanclass="math inline">\(x\)</span>，用旧基观测可以得到：<spanclass="math inline">\(x = c_1v_1 + c_2v_2 + \cdots + c_nv_n\)</span></p><p>继续展开： <span class="math display">\[\begin{align*}    x &amp;= c_1v_1 + c_2v_2 + \cdots + c_nv_n \\      &amp;= c_1a_{11}w_1 + c_1a_{21}w_2 + \cdots + c_1a_{m1}w_m + \\      &amp;~~~~~c_2a_{12}w_1 + c_2a_{22}w_2 + \cdots + c_2a_{m2}w_m + \\      &amp;~~~~~\cdots \\      &amp;~~~~~c_na_{1n}w_1 + c_na_{2n}w_2 + \cdots + c_na_{mn}w_m \\      &amp;= (c_1a_{11}+c_2a_{12}+\cdots+c_na_{1n})w_1 + \\      &amp;~~~~~(c_1a_{21}+c_2a_{22}+\cdots+c_na_{2n})w_2 + \\      &amp;~~~~~\cdots \\      &amp;~~~~~(c_1a_{m1}+c_2a_{m2}+\cdots+c_na_{mn})w_m \\      &amp;=d_1w_1 + d_2w_2 + \cdots + d_mw_m\end{align*}\]</span> 用矩阵形式表达： <span class="math display">\[Ac = \begin{bmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn}\end{bmatrix}\begin{bmatrix}c_1 \\ c_2 \\ \vdots \\ c_n\end{bmatrix}=\begin{bmatrix}a_{11}c_1 + a_{12}c_2 + \cdots + a_{1n}c_n \\a_{21}c_1 + a_{22}c_2 + \cdots + a_{2n}c_n \\\vdots \\a_{m1}c_1 + a_{m2}c_2 + \cdots + a_{mn}c_n\end{bmatrix}=\begin{bmatrix}d_1 \\d_2 \\\vdots \\d_m\end{bmatrix}\]</span> 所以我们从旧观测状态<span class="math inline">\((c_1, c_2,\cdots, c_n)\)</span>得到了新观测状态<span class="math inline">\((d_1,d_2, \cdots, d_m)\)</span>。</p><p>问题的关键就是确定这个<spanclass="math inline">\(A\)</span>矩阵，从旧基到新基的线性变换也就体现在这个<spanclass="math inline">\(A\)</span>矩阵上。</p><p>那这个<span class="math inline">\(A\)</span>咋求呢？<spanclass="math inline">\(A\)</span>的每一列其实就是每一个旧基的基向量用新基去观测得到的状态。</p><p>至此，我们有了一种全新的视角去看待矩阵乘法<spanclass="math inline">\(Ax = b\)</span></p><p><strong><spanclass="math inline">\(x\)</span>是旧基下对某事物的观测状态，<spanclass="math inline">\(b\)</span>是新基下对某事物的观测状态。而实现基转换功能的东西，就是<spanclass="math inline">\(A\)</span>。</strong></p><p><strong><spanclass="math inline">\(A\)</span>的每一列其实就是每一个旧基的基向量用新基去观测得到的状态。</strong></p><hr /><p>至此，线性变换与矩阵乘法彻底联系了起来。线性变换就是矩阵，矩阵就是线性变换。</p><p>而我们知道，矩阵满足<span class="math inline">\((A + B)x = Ax + Bx,(cA)x = c(Ax)\)</span>。所以线性变换<spanclass="math inline">\(T\)</span>是满足加法和数乘的，即：</p><ol type="1"><li><span class="math inline">\(T(v + w) = T(v) + T(w)\)</span></li><li><span class="math inline">\(T(cv) = cT(v)\)</span></li></ol><p>其实线性变换一定满足<span class="math inline">\(T(0) =0\)</span>，因为当<span class="math inline">\(v = w =0\)</span>时，<span class="math inline">\(T(0) =2T(0)\)</span>，所以<span class="math inline">\(T(0) =0\)</span>。所以可以通过<spanclass="math inline">\(T(0)\)</span>是否等于0来快速排除一些不是线性变换的映射。</p><hr /><p>告诉你三个有趣的事实：</p><ol type="1"><li>矩阵的逆就是线性变换的逆变换</li><li>进行多次线性变换就是多个矩阵连乘，这样子矩阵乘法就有了几何上的直观理解</li><li>正交阵相当于对空间进行旋转，对角阵相当于对空间进行拉伸</li></ol><h3 id="七.-图像压缩">七. 图像压缩</h3><p>思考一个<span class="math inline">\(512 \times512\)</span>的图像，我们需要<span class="math inline">\(512 \times512\)</span>个数来保存图像的状态。</p><p>令<span class="math inline">\(n = 512 \times 512\)</span></p><p>具体来说，一个状态可以用一个<spanclass="math inline">\(\mathbb{R}^{n}\)</span>向量<spanclass="math inline">\(x\)</span>来描述（把矩阵拉成一个向量）</p><p>而我们存储的<span class="math inline">\(512 \times512\)</span>个数，其实是标准基的系数： <span class="math display">\[x = c_1\begin{bmatrix}1\\ \\ \\ \\ \\ \end{bmatrix} +c_2\begin{bmatrix}\\ 1 \\ \\ \\ \\ \end{bmatrix} + \cdots +c_n\begin{bmatrix} \\ \\ \\ \\ 1\end{bmatrix}\]</span> 那如果换一组基呢？</p><p>假设我们的旧基（即标准基）为<spanclass="math inline">\(v\)</span>，新基为<spanclass="math inline">\(w\)</span>。旧的观测状态为<spanclass="math inline">\((c_1, c_2, ...,c_n)\)</span>，那么新的观测状态<span class="math inline">\((d_1, d_2,..., d_n)\)</span>需要通过<spanclass="math inline">\(Ac\)</span>才能得到，<spanclass="math inline">\(A\)</span>的每一列为每一个旧基的基向量用新基去观测得到的状态。</p><p><span class="math inline">\(A^{-1} =B\)</span>的每一列为每一个新基的基向量用旧基去观测的状态，所以<spanclass="math inline">\(B\)</span>其实就是把新基的基向量排成一排。</p><p>所以我们新的观测状态：<span class="math inline">\(d =B^{-1}c\)</span>。</p><p>用新观测状态表示图片向量：<span class="math inline">\(x = d_1w_1 +d_2w_2 + \cdots + d_nw_n\)</span></p><p>我们可以设定一个阈值，对于那些很小的<spanclass="math inline">\(d_i\)</span>那一项，我们就直接丢弃它，不存储了。例如我只要前5大的<spanclass="math inline">\(d_i\)</span>，那么我原本要存<spanclass="math inline">\(n\)</span>个数，现在我只需要存5个数了。</p><p>我还原出来的图片向量即为：<span class="math inline">\(\hat{x} =d_1w_1 + d_2w_2 + \cdots + d_5w_5\)</span>。</p><p>非常巧妙，嗯哼？</p><hr /><p>相当于用时间换空间，因为压缩和还原的过程我都需要进行矩阵运算。所以想加速压缩/还原速度我需要保证挑选出来的新基组成的<spanclass="math inline">\(B\)</span>的逆好求。</p><p>同时，为了尽可能压缩空间，我要使得挑选出来的新基的观测状态<spanclass="math inline">\((d_1, d_2, \cdots, d_n)\)</span>尽可能多的使<spanclass="math inline">\(d_i &lt;\text{阈值}\)</span>。这样我就可能少保存系数，从而达到压缩存储空间的效果。</p><p>注意，为啥我新基的个数要和旧基保持一样（即都有<spanclass="math inline">\(n\)</span>个基向量）？因为图片大小为<spanclass="math inline">\(512 \times512\)</span>，你不能直接把人家图片大小给改了啊，直接通过砍图片大小来达到的压缩不叫压缩。</p><hr /><p>多说一嘴，基的选择要结合实际情况分析，例如这张图片色彩很单调，且一大片区域都是同一种颜色的情况。那么基向量里必有<spanclass="math inline">\(\begin{bmatrix}1 \\ 1 \\ \vdots \\ 1\end{bmatrix}\)</span>。因为这个基向量表达的图片状态就是纯单色图片。当然了，我意思是这个基向量肯定起着主导作用（也就是系数<spanclass="math inline">\(d_i\)</span>大），但是仍要结合使用别的基向量，要不你还原出来的图片就是纯单色图片。</p><h3 id="八.-左右逆-伪逆">八. 左右逆, 伪逆</h3><p>对于矩阵<span class="math inline">\(A \in \mathbb{R}^{m \timesn}\)</span>，若<spanclass="math inline">\(A\)</span>的各列线性无关。则<spanclass="math inline">\(A\)</span>存在左逆：<spanclass="math inline">\((A^\mathrm{T}A)^{-1}A^\mathrm{T}\)</span>。</p><p>拿这玩意左乘<span class="math inline">\(A\)</span>可得到<spanclass="math inline">\(I\)</span>，所以叫左逆。</p><p>为啥条件是各列线性无关呢？因为我们知道<spanclass="math inline">\(A^\mathrm{T}A\)</span>一定是半正定矩阵。且当<spanclass="math inline">\(N(A) ={\textbf{0}}\)</span>时，升级为正定矩阵，而正定矩阵一定可逆。所以才能有<spanclass="math inline">\((A^\mathrm{T}A)^{-1}\)</span>。</p><hr /><p>对应的，我可以得到右逆的定义，若<spanclass="math inline">\(A\)</span>的各行线性无关，则<spanclass="math inline">\(A\)</span>存在右逆：<spanclass="math inline">\(A^\mathrm{T}(AA^\mathrm{T})^{-1}\)</span>。</p><hr /><p>下面来讨论一下伪逆。</p><p>我们知道，如果矩阵<span class="math inline">\(r(A) &lt; \min(m, n), A\in \mathbb{R}^{m \times n}\)</span>，那么对于无解的最小二乘方程：<spanclass="math inline">\(Ax = b\)</span>是求不出最优近似解的。但是伪逆<spanclass="math inline">\(A^+\)</span>却可以求到"最优稳定解"<spanclass="math inline">\(\hat{x}\)</span>，满足：<spanclass="math inline">\(\| A\hat{x}-b \| \le \| Ax - b \|\)</span>。</p><p>ok，那如何求伪逆呢？用SVD。这里我直接给出公式：</p><p><span class="math inline">\(A^+ = V\Sigma^+U^\mathrm{T}\)</span>，<spanclass="math inline">\(\Sigma^+\)</span>就是<spanclass="math inline">\(\Sigma\)</span>的每一个奇异值取倒数。</p><p>（伪逆这里讲的很浅，因为目前还不怎么用得着，等以后需要学习原理的时候再补充）</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对称矩阵、复数矩阵、FFT、正定矩阵、相似矩阵、SVD分解、线性变换、图像压缩、左右逆/伪逆&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线性代数2</title>
    <link href="http://error666.top/2024/09/12/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/"/>
    <id>http://error666.top/2024/09/12/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B02/</id>
    <published>2024-09-12T13:56:55.000Z</published>
    <updated>2024-09-16T15:12:12.175Z</updated>
    
    <content type="html"><![CDATA[<p>正交向量/空间、对向量/空间投影、正交矩阵、正交化、行列式、特征值/特征向量、(特征值)对角化、马尔可夫矩阵/傅里叶级数</p><span id="more"></span><hr /><h3 id="一.-正交向量与子空间">一. 正交向量与子空间</h3><p><img src="1.png" /></p><p>先来欣赏下这幅图，这幅图的意思就是对于矩阵<spanclass="math inline">\(A\)</span>，其行空间<spanclass="math inline">\(C(A^\mathrm{T})\)</span>与零空间<spanclass="math inline">\(N(A)\)</span>正交，其列空间<spanclass="math inline">\(C(A)\)</span>与左零空间<spanclass="math inline">\(N(A^\mathrm{T})\)</span>正交。</p><p>什么是向量正交？俩向量正交就是他们俩间夹角呈90度。如果判别俩向量正交？若<spanclass="math inline">\(x^\mathrm{T} \cdot y =0\)</span>，则x与y正交。</p><p>上面那个公式如何推导的呢？</p><p>首先思考如何描述一个向量的长度，假设有一个向量（1,2,3），那么它的长度显然是<spanclass="math inline">\(\sqrt{1^2 + 2^2 +3^2}\)</span>对吧，用向量表示就是<spanclass="math inline">\(\sqrt{x^Tx}\)</span>。</p><p>好的，知道了如何表示向量长度又如何，假设我给你向量<spanclass="math inline">\(x, y\)</span>，你咋判断呢？</p><p>首先思考下<span class="math inline">\(x +y\)</span>是什么？很容易想到，可以把x和y看作三角形的两边，那么<spanclass="math inline">\(x +y\)</span>就是斜边。那么三条边都知道了，如果xy正交的话，那么就会有<spanclass="math inline">\(x^\mathrm{T}x + y^\mathrm{T}y =(x+y)^\mathrm{T}(x+y)\)</span>,化简可得：<spanclass="math inline">\(x^\mathrm{T}x + y^\mathrm{T}y = x^\mathrm{T}x +x^\mathrm{T}y + y^\mathrm{T}x + y^\mathrm{T}y\)</span>，继续化简：<spanclass="math inline">\(x^\mathrm{T}y + y^\mathrm{T}x =0\)</span>，继续化简：<spanclass="math inline">\(2x^\mathrm{T}y=0\)</span>，所以得到<spanclass="math inline">\(x^\mathrm{T}y = 0\)</span>。</p><hr /><p>向量正交很容易理解，但如果我说，俩子空间正交，又是什么意思呢？</p><p>假设我有子空间<span class="math inline">\(S\)</span>和<spanclass="math inline">\(T\)</span>，那么S和T正交，当且仅当S中的每个向量和T中的每个向量正交。</p><p>ok，举个反直觉的实际例子：墙壁和地面正交吗？答案是否，因为墙壁和地面的交集边缝，边缝自己和自己不正交，所以不满足定义。</p><p>所以需要注意的是，若两个空间正交，那么它们一定不会交于某个非零向量。</p><p>所以在实际例子中，最常见的正交就是两条不重合的过原点且为90度的直线，它们是正交的。</p><hr /><p>回到四个基本子空间，现在我要给出结论：行空间正交与零空间。</p><p>为什么，看下面这幅图（Ax=0）：</p><p><img src="2.png" /></p><p>可以发现，row1和x做点乘为0，row2和x做点乘为0，......，所以x与所有行都正交。行空间可以表示为这些行的线性组合，即<spanclass="math inline">\(k_1row_1 + k_2row_2 + ... +k_mrow_m\)</span>，显然，做下点乘：<span class="math inline">\(x \cdot(k_1row_1 + k_2row_2 + ... + k_mrow_m) =0\)</span>，所以行空间与零空间正交。</p><p>同样的，我们可以得出结论：列空间与左零空间正交。道理一样我就不证了。</p><hr /><p>还有有趣的一点，实际上，行空间 + 零空间 = <spanclass="math inline">\(\mathbb{R}^n\)</span>，列空间 + 左零空间 = <spanclass="math inline">\(\mathbb{R}^m\)</span>。</p><p>从上一节的公式就可以一窥究竟：<span class="math inline">\(dim(S) +dim(U) = dim(S + U) + dim(S \cap U)\)</span>。</p><p>把行空间和零空间代入，秩分别为r和n - r，所以(行空间 +零空间)的维素就是n，而且行空间和零空间的分量个数都为n，所以(行空间 +零空间)就等于<span class="math inline">\(\mathbb{R}^n\)</span>。</p><p>列空间 + 左零空间 = <spanclass="math inline">\(\mathbb{R}^m\)</span>同理，我就不证了。</p><p>为了定义这种现象，我们把行空间和零空间称为正交补的。即：行空间与零空间正交补，列空间与左零空间正交补。</p><h3 id="二.-子空间投影">二. 子空间投影</h3><p>首先先从最简单的一个例子开始：</p><p><img src="3.png" /></p><p>我们将向量b投影到向量a上，投影向量为p，误差向量为e。可以发现，p是a的某倍。所以问题的关键，就是在找到这个系数x。</p><p>ok，由几何性质我们知道，向量e与a正交，所以：<spanclass="math inline">\((b - xa)^\mathrm{T}a = 0\)</span>，整理可得：<spanclass="math inline">\(b^\mathrm{T}a =xa^\mathrm{T}a\)</span>，继续：<span class="math inline">\(x =\frac{b^\mathrm{T}a}{a^\mathrm{T}a}\)</span>。当然也可以写成：<spanclass="math inline">\(x =\frac{a^\mathrm{T}b}{a^\mathrm{T}a}\)</span>。</p><p>所以<span class="math inline">\(p = a \cdot\frac{a^\mathrm{T}b}{a^\mathrm{T}a}\)</span>。</p><p>ok上个这个小例子推出来的公式可以留个印象。现在我们进一步抽象化，把投影这个动作看作一种运算，也就是最好弄出一个投影矩阵P，然后b左乘一下这个投影矩阵Pb，就可以得到p，这是我们想要的。</p><p>其实通过上面的公式就可看出，<span class="math inline">\(P =\frac{aa^\mathrm{T}}{a^\mathrm{T}a}\)</span>。非常优美的式子。</p><p>我们来思考一下这个投影矩阵P的列空间。它的列空间是啥呢？</p><p>考虑<spanclass="math inline">\(Px\)</span>，x可取任意向量，那么就相当于对P的列向量做任意线性组合，也就是生成了<spanclass="math inline">\(C(P)\)</span>。通过几何意义我们可以知道，<spanclass="math inline">\(C(P)\)</span>就是通过a的一条线，而且<spanclass="math inline">\(r(P) = 1\)</span>。</p><p>这个投影矩阵<spanclass="math inline">\(P\)</span>还有一些好玩的性质，比如通过其公式，显然看出它是一个对称矩阵，所以<spanclass="math inline">\(P^\mathrm{T} = P\)</span>。</p><p>以及<span class="math inline">\(P^2 =P\)</span>，为什么呢？前面我们说了<spanclass="math inline">\(C(P)\)</span>就是通过a的一条线，而且<spanclass="math inline">\(r(P) = 1\)</span>，说明<spanclass="math inline">\(P\)</span>的每一个列向量都在a那条直线上，所以<spanclass="math inline">\(P \cdot P\)</span>相当于对<spanclass="math inline">\(P\)</span>的每一列做投影，那么通过几何性质，若一个向量本就在线上，投影之后位置仍不变，所以<spanclass="math inline">\(P \cdot P = P\)</span>。</p><p>总结一下：</p><ol type="1"><li><span class="math inline">\(x =\frac{a^\mathrm{T}b}{a^\mathrm{T}a}\)</span>，<spanclass="math inline">\(p = ax = a \cdot\frac{a^\mathrm{T}b}{a^\mathrm{T}a}\)</span></li><li><span class="math inline">\(P =\frac{aa^\mathrm{T}}{a^\mathrm{T}a}\)</span>， <spanclass="math inline">\(p = Pb\)</span></li><li><span class="math inline">\(C(p) = \text{过a的线}\)</span>， <spanclass="math inline">\(r(P) = 1\)</span></li><li><span class="math inline">\(P^\mathrm{T} = P\)</span>，<spanclass="math inline">\(P^2 = P\)</span></li></ol><hr /><p>现在让我们进入更高维度的投影。</p><p>先剧透一下，学这个可以解决什么问题呢？我们知道，Ax =b并不100%有解，有时候，我们在无解的情况下，就想找到最优近似解，也就是误差向量<spanclass="math inline">\(e\)</span>最小。</p><p>怎么做呢？很自然的就联想到投影。因为此时b不在<spanclass="math inline">\(C(A)\)</span>上，所以我们就要将<spanclass="math inline">\(b\)</span>投影到<spanclass="math inline">\(C(A)\)</span>上，得到投影向量p。那么此时求解<spanclass="math inline">\(A\hat{x} = p\)</span>，得到的<spanclass="math inline">\(\hat{x}\)</span>就是最优近似解。</p><p>很巧妙不是吗？这用到了向量对空间的投影。</p><p>继续思考，我们要做的事情，就是找到一个x，使得b与(Ax)的误差向量e垂直C(A)。此时的x就是<spanclass="math inline">\(\hat{x}\)</span>。</p><p>把上面的语言转化为数学语言： <span class="math display">\[\begin{align*}    &amp;p = A\hat{x} \\    &amp;e = b - p = b - (A\hat{x}) \\    &amp;e^\mathrm{T}A = 0\end{align*}\]</span> （<span class="math inline">\(e\)</span>垂直与<spanclass="math inline">\(C(A)\)</span>与<spanclass="math inline">\(e^\mathrm{T}A=0\)</span>等价，因为<spanclass="math inline">\(C(A)\)</span>可由列向量线组出来，所以只要<spanclass="math inline">\(e\)</span>垂直于<spanclass="math inline">\(A\)</span>的每一个列向量，那么<spanclass="math inline">\(e\)</span>就垂直于<spanclass="math inline">\(C(A)\)</span>）</p><p>（上面的方程我们还可以发现一点有趣的事实，显然<spanclass="math inline">\(e\)</span>位于<spanclass="math inline">\(A\)</span>的左零空间内，而通过几何意义我们知道，<spanclass="math inline">\(e\)</span>与<spanclass="math inline">\(C(A)\)</span>正交。很巧的事情，<spanclass="math inline">\(N(A^\mathrm{T})\)</span>与<spanclass="math inline">\(C(A)\)</span>正交。一切都对上了，是不是？）</p><p>OK，整理上面的方程，可以得到：<spanclass="math inline">\(A^\mathrm{T}A\hat{x} =A^\mathrm{T}b\)</span>。</p><p>如果<spanclass="math inline">\(A^\mathrm{T}A\)</span>是可逆的，那么直接乘它的可逆矩阵，即可求出<spanclass="math inline">\(\hat{x}\)</span>。</p><p>对应的投影向量为：<span class="math inline">\(p = A \cdot(A^\mathrm{T}A)^{-1} \cdot A^\mathrm{T}b\)</span></p><p>对应的投影矩阵为：<span class="math inline">\(P = A \cdot(A^\mathrm{T}A)^{-1} \cdot A^\mathrm{T}\)</span></p><p>生成投影向量的线组系数：<span class="math inline">\(\hat{x} =(A^\mathrm{T}A)^{-1} \cdot A^\mathrm{T}b\)</span></p><p>类比上面的向量对向量投影的公式，是不是形式一样？只需把<spanclass="math inline">\(a\)</span>换为<spanclass="math inline">\(A\)</span>，分号改为逆就好啦？美妙的公式。</p><p>同理，此时的投影矩阵<spanclass="math inline">\(P\)</span>同样满足：<spanclass="math inline">\(P^\mathrm{T} = P\)</span>，<spanclass="math inline">\(P^2 = P\)</span></p><hr /><p>ok，让我们讨论剩下的一点细节，前面我们是把<spanclass="math inline">\(b\)</span>投影到<spanclass="math inline">\(C(A)\)</span>中。那如果我想把<spanclass="math inline">\(b\)</span>投到与<spanclass="math inline">\(C(A)\)</span>正交的空间，也就是<spanclass="math inline">\(N(A^\mathrm{T})\)</span>呢？显然，通过几何意义可以看出，答案就是<spanclass="math inline">\(e\)</span>，即<span class="math inline">\(b -p\)</span>。</p><p>所以投影到<spanclass="math inline">\(N(A^\mathrm{T})\)</span>就是：<spanclass="math inline">\(b - p = b - Pb = (I -P)b\)</span>。所以对应的投影矩阵就是<span class="math inline">\(I -P\)</span>。同样的，<spanclass="math inline">\(P\)</span>满足的性质，<spanclass="math inline">\(I - P\)</span>也都满足。</p><p>以及，前面提到，必须<spanclass="math inline">\(A^\mathrm{T}A\)</span>是可逆矩阵，才能解出<spanclass="math inline">\(\hat{x}\)</span>。但是，如何判断它可逆呢？有一个判断方法：若<spanclass="math inline">\(A\)</span>的各列线性无关，那么<spanclass="math inline">\(A^\mathrm{T}A\)</span>就是可逆矩阵。下面来证明一下：</p><blockquote><p>假设<span class="math inline">\(A\)</span>的各列线性无关。</p><p>考虑方程<span class="math inline">\(A^\mathrm{T}Ax = 0\)</span></p><p>两边同乘<span class="math inline">\(x^\mathrm{T}\)</span>，得：<spanclass="math inline">\(x^\mathrm{T}A^\mathrm{T}Ax = 0\)</span></p><p>整理：<span class="math inline">\((Ax)^\mathrm{T}(Ax)=0\)</span></p><p>所以说嘛向量<spanclass="math inline">\((Ax)\)</span>长度为0，也就是它为零向量，所以：<spanclass="math inline">\(Ax=0\)</span></p><p>因为<span class="math inline">\(A\)</span>的各列线性无关，所以<spanclass="math inline">\(dim(N(A)) = 0\)</span>，所以<spanclass="math inline">\(x\)</span>只能去零向量。</p><p>所以对于方程<span class="math inline">\(A^\mathrm{T}Ax =0\)</span>，<span class="math inline">\(x\)</span>只能取零向量。</p><p>而只有当<spanclass="math inline">\(A^\mathrm{T}A\)</span>可逆的时候，上面的方程才只有零解。证毕。</p></blockquote><hr /><p>最后，让我们举一个用投影来解决的实际例子：最小二乘。</p><p>平面上有n个点，要找到一条直线，尽可能的拟合这些点，怎么办？</p><p>假设有这么一条理想直线：y = kx + b，可以拟合所有点，那么就会有方程：<span class="math display">\[\begin{align*}    kx_1 + b &amp;= y_1 \\    kx_2 + b &amp;= y_2 \\    ... \\    kx_n + b &amp;= y_n\end{align*}\]</span> 我们要求k和b，所以把k和b看为未知数。</p><p>那么即可建模为<span class="math inline">\(Ax=b\)</span>，<spanclass="math inline">\(A = \begin{bmatrix} x_1 &amp; 1 \\ x_2 &amp; 1 \\... &amp; ... \\ x_n &amp; 1 \end{bmatrix}\)</span>，<spanclass="math inline">\(x = \begin{bmatrix} k \\ b\end{bmatrix}\)</span>，<span class="math inline">\(b = \begin{bmatrix}y_1 \\ y_2 \\ ... \\ y_n \end{bmatrix}\)</span></p><p>这个方程大概率是无解的，因为不存在这么一条完美直线，所以就把<spanclass="math inline">\(b\)</span>投影到<spanclass="math inline">\(C(A)\)</span>即可。</p><p>巧妙的建模，相信你再一次感受到线代的魅力了！</p><ul><li>总结一下：<ul><li>一维（向量b投影到向量a）：<ul><li><span class="math inline">\(P =\frac{aa^\mathrm{T}}{a^\mathrm{T}a}\)</span>，<spanclass="math inline">\(p = Pb\)</span></li></ul></li><li>高维（向量b投影到空间C(A)）：<ul><li><span class="math inline">\(P = A \cdot (A^\mathrm{T}A)^{-1} \cdotA^\mathrm{T}\)</span></li><li><span class="math inline">\(p = A \cdot (A^\mathrm{T}A)^{-1} \cdotA^\mathrm{T}b\)</span></li></ul></li><li>判断对称矩阵<spanclass="math inline">\(A^\mathrm{T}A\)</span>是否可逆的方法：看<spanclass="math inline">\(A\)</span>的各列是否线性无关</li></ul></li></ul><h3 id="三.-正交矩阵-schmidt正交化">三. 正交矩阵, Schmidt正交化</h3><p>在这一节里，我们用<spanclass="math inline">\(Q\)</span>来代表列向量全是正交且标准（长度为1）的矩阵。</p><p>显然，这个<span class="math inline">\(Q\)</span>满足下列定义：<spanclass="math inline">\(q_{i}^{T}q_{j}=\begin{cases}0&amp;,i\neqj\\1&amp;,i=j\end{cases}\)</span></p><p>讨论一下，<spanclass="math inline">\(Q^\mathrm{T}Q\)</span>是什么？<spanclass="math inline">\(Q = \begin{bmatrix} q_1, q_2, ..., q_n\end{bmatrix}\)</span>，<span class="math inline">\(Q^\mathrm{T} =\begin{bmatrix} q_1^\mathrm{T} \\ q_2^\mathrm{T} \\ ... \\q_n^\mathrm{T} \end{bmatrix}\)</span>。</p><p>显然，<span class="math inline">\(Q^\mathrm{T}Q = I\)</span>。</p><p>下面，我们对“正交矩阵”这个名词下一个定义：首先得是方阵，其次列向量都是互相正交且单位的。这样的矩阵就叫正交矩阵。</p><p>（注意，本节的<spanclass="math inline">\(Q\)</span>不一定是方阵，若无特殊说明，是不是方阵都有可能）</p><p>ok，让我们现在讨论一下正交矩阵的性质。</p><p>正交矩阵也满足<span class="math inline">\(Q^\mathrm{T}Q =I\)</span>，而且因为为方阵，所以<spanclass="math inline">\(Q\)</span>有逆矩阵。所以可以推出<spanclass="math inline">\(Q^\mathrm{T} = Q^{-1}\)</span>。</p><p>OK，让我们思考一下正交矩阵的投影矩阵：<span class="math inline">\(P =Q(Q^\mathrm{T}Q)^{-1}Q^\mathrm{T} =QQ^\mathrm{T}\)</span>。因为是正交矩阵，所以<spanclass="math inline">\(Q^\mathrm{T} = Q^{-1}\)</span>，所以<spanclass="math inline">\(P =I\)</span>，即正交矩阵的投影矩阵就是单位阵。如果<spanclass="math inline">\(Q\)</span>不是方阵的话，那么其投影矩阵就是<spanclass="math inline">\(QQ^\mathrm{T}\)</span>。当然了，它们的投影矩阵都是满足那俩性质的：</p><ol type="1"><li>是对称矩阵</li><li><span class="math inline">\(P^2 = P\)</span></li></ol><hr /><p>正交且标准的性质是很好的，所以我们如何把一个虽然列向量互相线性无关（但是不正交）的矩阵<spanclass="math inline">\(A\)</span>，转化为列向量互相正交且标准的矩阵<spanclass="math inline">\(Q\)</span>呢？下面来介绍格拉姆-施密特正交法：</p><p>思考现在有向量<span class="math inline">\(a, b,c\)</span>，它们互相线性无关，但是不正交，如果把它们转换为一组正交的呢？</p><p>首先把<spanclass="math inline">\(a\)</span>单位化然后锁死，然后对于<spanclass="math inline">\(b\)</span>，<spanclass="math inline">\(b\)</span>减去<spanclass="math inline">\(b\)</span>在<spanclass="math inline">\(a\)</span>上的投影（也就是误差向量<spanclass="math inline">\(e\)</span>）就是我们想要的，所以<spanclass="math inline">\(b&#39; = b - p = b - Pb = b -\frac{aa^\mathrm{T}}{a^\mathrm{T}a}\cdotb\)</span>，然后单位化，锁死。</p><p>然后对于<span class="math inline">\(c\)</span>，先把在<spanclass="math inline">\(a\)</span>上的投影减掉，再把在更新后的<spanclass="math inline">\(b\)</span>上的投影减掉，就得到了正交于<spanclass="math inline">\(a, b\)</span>的向量：<spanclass="math inline">\(c&#39; = c - p_a - p_b = c -\frac{aa^\mathrm{T}}{a^\mathrm{T}a} \cdot c -\frac{bb^\mathrm{T}}{b^\mathrm{T}b} \cdotc\)</span>，然后单位化，锁死。</p><p>其余的向量以此类推。</p><p>很好，现在你学会了如何将一组虽然线性无关但是不是正交的向量转化为正交的向量组，恭喜。</p><p>但是我要提个问题，转化前的矩阵<spanclass="math inline">\(A\)</span>和转化后的矩阵<spanclass="math inline">\(Q\)</span>，它们的列空间一样吗？</p><p>答案是肯定的，因为考虑我们转化的过程，例如<spanclass="math inline">\(c = c - p_a - p_b\)</span>，<spanclass="math inline">\(p_a\)</span>是<spanclass="math inline">\(a\)</span>的缩放，<spanclass="math inline">\(p_b\)</span>是<spanclass="math inline">\(b\)</span>的缩放，所以其实我们在正交化的过程中，仍然是用原向量组做线性组合（即列变换），所以转换后的矩阵，其列空间一样<spanclass="math inline">\(C(Q)\)</span>=<spanclass="math inline">\(C(A)\)</span>，零空间一样<spanclass="math inline">\(N(Q) = N(A)\)</span>。</p><hr /><p>截止，你已经知道了正交的概念，也认识到了正交矩阵以及一些性质。甚至你还学会了如何将一组线性无关向量组转化为标准正交的向量组。</p><p>但是，知道这些，有什么用呢？</p><p>目前我知道的是，可以讲一个各列线性无关的矩阵<spanclass="math inline">\(A\)</span>进行<spanclass="math inline">\(QR\)</span>分解：<span class="math inline">\(A =QR\)</span>。<spanclass="math inline">\(Q\)</span>表示各列互相标准正交的向量，<spanclass="math inline">\(R\)</span>是一个上三角矩阵。</p><p>为啥<spanclass="math inline">\(R\)</span>是一个上三角矩阵呢？我来证明一下：</p><p>在正交化的过程中，对于<spanclass="math inline">\(a_i\)</span>，它依赖了<spanclass="math inline">\(q_1, q_2, \cdots, q_{i-1},a_i\)</span>，线组出了<spanclass="math inline">\(q_i\)</span>。所以，如果我有<spanclass="math inline">\(q_1, q_2, \cdots,q_i\)</span>，那我就可线组出<spanclass="math inline">\(a_i\)</span>。所以对于<spanclass="math inline">\(A = QR\)</span>，<spanclass="math inline">\(R\)</span>就是线组的系数。而且可发现想线组出<spanclass="math inline">\(a_i\)</span>只需用到<span class="math inline">\(1\sim i\)</span>的<span class="math inline">\(q\)</span>，所以<spanclass="math inline">\(R\)</span>自然就是一个上三角的了。</p><h3 id="四.-行列式及其性质">四. 行列式及其性质</h3><p>行列式是方阵独属的浪漫，通常记为<spanclass="math inline">\(det(A)\)</span>或者<spanclass="math inline">\(|A|\)</span>。</p><p>行列式这里性质特别多，可能需要一些记忆：</p><ol type="1"><li><p>单位阵的行列式为1</p></li><li><p>交换两行，行列式符号会取反</p></li><li><p><span class="math inline">\(\begin{vmatrix}  ta &amp; tb \\  c&amp; d  \end{vmatrix} = t\begin{vmatrix}  a &amp; b \\  c &amp;d  \end{vmatrix}\)</span></p></li><li><p><span class="math inline">\(\begin{vmatrix}  a+a&#39; &amp;b+b&#39; \\  c &amp; d  \end{vmatrix} = \begin{vmatrix}  a &amp; b \\  c&amp; d  \end{vmatrix} + \begin{vmatrix}  a&#39; &amp; b&#39; \\  c&amp; d  \end{vmatrix}\)</span></p></li><li><p>若有两行相等，则行列式为0</p></li><li><p>行j减去行i的k倍，行列式不变</p></li><li><p>如果有一行为0，那么行列式为0</p></li><li><p>对于上三角方阵，其行列式为对角线元素乘积</p></li><li><p><span class="math inline">\(det(A)=0 \iff\)</span> 矩阵<spanclass="math inline">\(A\)</span>是奇异矩阵（奇异矩阵就是不满秩的方阵）</p></li><li><p><span class="math inline">\(det(AB) = det(A) \cdotdet(B)\)</span></p></li><li><p><span class="math inline">\(det(A^\mathrm{T}) =det(A)\)</span></p><ul><li>有了这条性质，那么上面描述行的性质，同样可以描述列，例如：</li><li>交换两列，行列式符号取反</li><li>除了行有线性关系（性质3、4），列也具有</li><li>若有两列相等，则行列式为0</li><li>如果有一列为0，那么行列式为0</li></ul></li></ol><p>所以如何求一个方阵的行列式？通常就是将其消元成上三角矩阵（注意过程中行交换会导致行列式符号取反），然后对角线相乘即可。</p><hr /><p>行列式公式1：<span class="math inline">\(det(A) = \sum (-1)^{r(k_1,k_2, k_3, ..., k_n)}a_{1k_1}a_{2k_2}a_{3k_3}...a_{nk_n}\)</span></p><p>​ <span class="math inline">\(r(k_1, k_2, ...,k_n)\)</span>是排列的逆序数。</p><p>代数余子式：位置(i, j)的代数余子式<span class="math inline">\(A_{ij}:= (-1)^{i+j}det(\text{去掉第i行和第j列得到的矩阵})\)</span></p><p>行列式公式2：<span class="math inline">\(det(A) = a_{11}C_{11} +a_{12}C_{12} + \cdots + a_{1n}C_{1n}\)</span></p><h3 id="五.-克拉默法则-体积">五. 克拉默法则, 体积</h3><p>设<span class="math inline">\(A_{ij}\)</span>是位置(i,j)的代数余子式，则矩阵<spanclass="math inline">\(A\)</span>的伴随矩阵定义如下： <spanclass="math display">\[A^* = \begin{bmatrix}A_{11} &amp; A_{21} &amp; \cdots &amp; A_{n1} \\A_{12} &amp; A_{22} &amp; \cdots &amp; A_{n2} \\\cdots \\A_{1n} &amp; A_{2n} &amp; \cdots &amp; A_{nn}\end{bmatrix}\]</span> 它满足一个公式，通过代数法求逆：<spanclass="math inline">\(A^{-1} = \frac{A^*}{det(A)}\)</span></p><p>那么对于非奇异矩阵<spanclass="math inline">\(A\)</span>，它的方程：<spanclass="math inline">\(Ax=b\)</span>就有一种新的解法。</p><p><span class="math inline">\(x = A^{-1}b =\frac{A^*b}{det(A)}\)</span></p><p>所以可得到以下式子： <span class="math display">\[\begin{align*}    x_1 &amp;= \frac{det(\text{把A的第一列换为b})}{det(A)} \\    x_2 &amp;= \frac{det(\text{把A的第二列换为b})}{det(A)} \\    \cdots \\    x_n &amp;= \frac{det(\text{把A的第n列换为b})}{det(A)}\end{align*}\]</span>上面就是克拉默法则，用代数的方程解方程。但是我觉得，中看不中用，不如直接用矩阵的方程去解方程组。</p><hr /><p>给出一个有意思的定理：行列式的绝对值其实是在计算“箱子”的体积。</p><p>我举个例子，比如有矩阵<span class="math inline">\(A = \begin{bmatrix}a_{11} &amp; a_{12} &amp; a_{13} \\ a_{21} &amp; a_{22} &amp; a_{23} \\a_{31} &amp; a_{32} &amp; a_{33} \end{bmatrix}\)</span></p><p>那么<span class="math inline">\(|det(A)|\)</span>等于以<spanclass="math inline">\((a_{11}, a_{12}, a_{13})\)</span>，<spanclass="math inline">\((a_{21}, a_{22}, a_{23})\)</span>、<spanclass="math inline">\((a_{31}, a_{32},a_{33})\)</span>为三边所形成的箱子的体积。</p><p>同理，对于<span class="math inline">\(n \timesn\)</span>的矩阵同样成立。</p><h3 id="六.-特征值-特征向量">六. 特征值, 特征向量</h3><p>特征值是方阵独属的浪漫。</p><p>首先来讲特征向量，矩阵<spanclass="math inline">\(A\)</span>的特征向量就是那些进过<spanclass="math inline">\(A\)</span>线性变换后方向不改变的向量。用数学语言表达就是：<spanclass="math inline">\(Ax = \lambda x\)</span>。满足上述方程的<spanclass="math inline">\(x\)</span>就是特征向量，<spanclass="math inline">\(\lambda\)</span>就是特征值。</p><p>对于特征值0，它对应的特征向量应满足<spanclass="math inline">\(Ax=0\)</span>，所以特征值0所对应的特征向量其实就是<spanclass="math inline">\(N(A)\)</span>。</p><p>举点例子吧，考虑投影矩阵<spanclass="math inline">\(P\)</span>。对于那些本身就已经在投影面上的向量<spanclass="math inline">\(x\)</span>，满足<span class="math inline">\(Px =x\)</span>，所以<spanclass="math inline">\(P\)</span>特征值为1的特征向量就是投影面上的向量。对于那些垂直于投影面的向量<spanclass="math inline">\(x\)</span>，满足<span class="math inline">\(Px =0\)</span>，所以<spanclass="math inline">\(P\)</span>特征值为0的特征向量就是垂直于投影面的那些向量。</p><p>ok，我提前透露几个特征值的性质：</p><ol type="1"><li>n阶方阵有n个特征值</li><li>n个特征值的和加起来等于方阵对角线之和</li><li>n个特征值的乘积等于方阵的特征值</li><li>上三角方阵的特征值就是对角线上的元素</li><li><span class="math inline">\(A\)</span>的特征值等于<spanclass="math inline">\(A^\mathrm{T}\)</span>的特征值</li><li><span class="math inline">\(A^{-1}\)</span>的特征值等于<spanclass="math inline">\(A\)</span>的特征值取倒数</li></ol><hr /><p>好，那给你一个矩阵<spanclass="math inline">\(A\)</span>，如何求出其特征值和对应的特征向量呢？</p><p>很简单，首先列出定义：<span class="math inline">\(Ax = \lambdax\)</span>，移项：<span class="math inline">\((A - \lambda I)x =0\)</span>。要使这个方程有非零解，<span class="math inline">\((A -\lambda I)\)</span>要是奇异矩阵，也就是不满秩，也就是<spanclass="math inline">\(|A - \lambda I| = 0\)</span>。</p><p>解上面那个行列式，即可求出所有的特征值<spanclass="math inline">\(\lambda\)</span>（n个特征值可能有重复）。</p><p>然后反代回去，即可求出特征值对应的特征向量。</p><h3 id="七.-对角化-a的幂">七. 对角化, A的幂</h3><p>上一节我们学会了如何求一个矩阵<spanclass="math inline">\(A\)</span>的特征值和对应的特征向量。这一节我们来利用特征向量来分解矩阵。</p><p>假设我们有一个矩阵<spanclass="math inline">\(A\)</span>，它有n个线性无关的特征向量。那么我把这些向量排成一排得到矩阵<spanclass="math inline">\(S\)</span>，叫做特征向量矩阵。然后推导下面式子：</p><p><span class="math inline">\(AS = A \cdot \begin{bmatrix} \beta_1&amp; \beta_2 \cdots \beta_n \end{bmatrix} = \begin{bmatrix}\lambda_1\beta_1 &amp; \lambda_2\beta_2 &amp; \cdots &amp;\lambda_n\beta_n \end{bmatrix} = \begin{bmatrix} \beta_1 &amp; \beta_2&amp; \cdots &amp; \beta_n \end{bmatrix}\begin{bmatrix} \lambda_1 &amp;&amp; &amp; &amp; \\ &amp; \lambda_2 &amp; &amp; &amp; &amp; \\ &amp;&amp; \lambda_3 &amp; &amp; \\ &amp; &amp; &amp; &amp; \cdots\end{bmatrix}\)</span></p><p>即：<span class="math inline">\(AS =S\Lambda\)</span>，<spanclass="math inline">\(\Lambda\)</span>为用特征值生成的对角阵，也叫特征值矩阵</p><p>进一步化简，得到： <span class="math display">\[\Lambda = S^{-1}AS \\A = S\Lambda S^{-1}\]</span>这种对角化分解有什么用呢？答案：在处理矩阵的幂的时候非常有用</p><p>首先来看一下<span class="math inline">\(A^2\)</span>：<spanclass="math inline">\(A^2 = S\Lambda S^{-1} \cdot S\Lambda S^{-1} =S\Lambda^2 S^{-1}\)</span></p><p>可以发现，<span class="math inline">\(A^2\)</span>的特征值就是<spanclass="math inline">\(A\)</span>特征值的平方，<spanclass="math inline">\(A^2\)</span>的特征向量与<spanclass="math inline">\(A\)</span>一样。</p><p>同理，<span class="math inline">\(A^k\)</span>的特征值就是<spanclass="math inline">\(A\)</span>特征值的<spanclass="math inline">\(k\)</span>次方，<spanclass="math inline">\(A^k\)</span>的特征向量与<spanclass="math inline">\(A\)</span>一样。</p><p>来个好玩的问题，当<spanclass="math inline">\(A\)</span>的特征值满足什么条件时，<spanclass="math inline">\(A^k = O, k \to \infty\)</span>？</p><p>通过上面的公式，可得<span class="math inline">\(A^k =S\Lambda^kS^{-1}\)</span>，显然<spanclass="math inline">\(S\)</span>是固定的，所以关键就是看<spanclass="math inline">\(\Lambda\)</span>。很容易想到，如果<spanclass="math inline">\(A\)</span>的所有特征值满足<spanclass="math inline">\(|\lambda_i| &lt; 1\)</span>的话，那么矩阵<spanclass="math inline">\(A\)</span>会收敛到零矩阵。</p><p>（<strong>上面对角化分解非常有用，但需要注意分解的前提是<spanclass="math inline">\(A\)</span>有n个线性无关的特征向量。如何判断呢？这里给出一个定理：如果<spanclass="math inline">\(A\)</span>有n个互不相同的特征值，那么<spanclass="math inline">\(A\)</span>就有n个线性无关的特征向量；否则则不一定。</strong>）</p><hr /><p>先介绍一阶差分方程，即：<span class="math inline">\(u_{k+1} =Au_k\)</span>。（我们考虑理想的情况，即认为<spanclass="math inline">\(A​\)</span>有n个互不相同的特征值。）</p><p>那么可推出：<span class="math inline">\(u_k = A^ku_0\)</span></p><p>因为<spanclass="math inline">\(A\)</span>的各特征向量线性无关，所以<spanclass="math inline">\(\mathbb{R}^n\)</span>可用特征向量线组出来，<spanclass="math inline">\(u_0\)</span>同样可以用特征向量线组出来，设线组的系数为<spanclass="math inline">\(c\)</span>列向量，那么<spanclass="math inline">\(u_0\)</span>可表示为<spanclass="math inline">\(Sc\)</span>。</p><p>所以<span class="math inline">\(u_k = S\Lambda^kS^{-1} \cdot Sc =S\Lambda^kc\)</span>。</p><p>下面我们来一道经典的例题，现有斐波拉契数列：0, 1, 1, 2, 3, 5, 8, ......。试用矩阵求斐波拉契数列，并分析其增长速度。</p><p>首先可写出递推式：<span class="math inline">\(F_{k+2} = F_{k+1} +F_k\)</span>。可以发现这是一个二阶的差分方程，我们想把其转为前面的知识转为一阶的，所以我使用一个trick，就是再加入一个方程，然后引入新变量去表达方程组，使其变为一阶差分方程，具体如下：<span class="math display">\[\begin{cases}F_{k+2} = F_{k+1} + F_k \\F_{k+1} = F_{k+1}\end{cases}\]</span> 设<span class="math inline">\(u_k = \begin{bmatrix}F_{k+1} \\F_k\end{bmatrix}\)</span>，所以上述方程组可表达为一个一阶差分方程：<spanclass="math inline">\(u_{k+1} = \begin{bmatrix}1 &amp; 1 \\ 1 &amp;0\end{bmatrix}u_k\)</span>。</p><p>好，先来看看矩阵<span class="math inline">\(A = \begin{bmatrix}1&amp; 1 \\ 1 &amp; 0\end{bmatrix}\)</span>是否可对角化，有<spanclass="math inline">\(\begin{cases} \lambda_1 + \lambda_2 = 1 \\\lambda_1 \cdot \lambda_2 = -1 \end{cases}\)</span>，解得：<spanclass="math inline">\(\begin{cases} \lambda_1 = \frac12(1 + \sqrt{5})\approx 1.618 \\ \lambda_2 = \frac12(1 - \sqrt{5}) \approx -0.618\end{cases}\)</span></p><p>有俩不同特征值，由前面的判定定理可知，<spanclass="math inline">\(A\)</span>可对角化，那么可求出其特征向量矩阵<spanclass="math inline">\(S = \begin{bmatrix} \lambda_1 &amp; \lambda_2 \\ 1&amp; 1 \end{bmatrix}\)</span>。</p><p>由前面的公式可知：<span class="math inline">\(u_k =S\Lambda^kc\)</span>。在这里，<spanclass="math inline">\(c\)</span>是用特征向量表示出<spanclass="math inline">\(\begin{bmatrix} F_1 \\ F_0\end{bmatrix}\)</span>的系数列向量。让我求一下：<spanclass="math inline">\(u_0 = \begin{bmatrix} 1 \\ 0 \end{bmatrix} =c_1\begin{bmatrix} \lambda_1 \\ 1 \end{bmatrix} + c_2\begin{bmatrix}\lambda_2 \\ 1 \end{bmatrix}\)</span>，这里就不解了。</p><p>所以现在<span class="math inline">\(S, \Lambda,c\)</span>都有了，那么<spanclass="math inline">\(u_k\)</span>就可求出来了，即<spanclass="math inline">\(F_k\)</span>就可求出来了。</p><p>但是这个一阶差分方程的增长速度我们还没分析，其实观察<spanclass="math inline">\(u_k =S\Lambda^kc\)</span>就可知道，增长速度由特征值决定，若<spanclass="math inline">\(|\lambda_i| &lt; 1\)</span>，那么<spanclass="math inline">\(u_k\)</span>直接会收俩到0。</p><p>对于那些<span class="math inline">\(|\lambda_i| &gt;1\)</span>的，越大的<spanclass="math inline">\(|\lambda_i|\)</span>，只要对应的<spanclass="math inline">\(c_i \ne0\)</span>，那么对应的特征向量增长速度就越快。</p><p>这一节的内容稍微有点点难消化，不过这已经有点点科研证明的味道了。多看多理解。</p><hr /><h3 id="八.-微分方程-expat">八. 微分方程, exp(At)</h3><p>在开始这节课之前，我觉得有必要补充介绍一点微分方程的概念。</p><p>定义：含自变量（例如<spanclass="math inline">\(x\)</span>）、函数（例如<spanclass="math inline">\(y\)</span>）以及函数各阶导数（例如<spanclass="math inline">\(\dot{y},\ddot{y}\)</span>）的等式称为微分方程。</p><p>抱歉，真听不懂，是我高数太垃圾了，回头补完微分方程再来听这节课。</p><h3 id="九.-马尔可夫矩阵-傅里叶级数">九. 马尔可夫矩阵, 傅里叶级数</h3><p>什么是马尔可夫矩阵，若<spanclass="math inline">\(A\)</span>满足以下两条定义，则它是马尔可夫矩阵：</p><ol type="1"><li>所有元素大于0（概率值不能为负数）</li><li>每一列元素和为1</li><li>方阵</li></ol><p>对于马尔可夫矩阵，很容易发现，其幂即<spanclass="math inline">\(A^k\)</span>同样也是马尔可夫矩阵。</p><p>这里我直接给出两个结论：</p><ol type="1"><li>马尔可夫矩阵有一个特征值为1</li><li>马尔可夫矩阵其余特征值绝对值小于等于1</li></ol><p>根据上面的结果，我们可以知道，如果一个向量一直左乘马尔可夫矩阵，那么最终会达到一个稳态。显然这个稳态是我们关心的，我们需要找到它。</p><p>假设矩阵<spanclass="math inline">\(A\)</span>有n个线性无关的特征向量<spanclass="math inline">\(\beta\)</span>-s，那么对于式子：<spanclass="math inline">\(u_k = A^ku_0\)</span></p><p><span class="math inline">\(u_0\)</span>可以被表示为：<spanclass="math inline">\(u_0 = c_1\beta_1 + c_2\beta_2 + \cdots +c_n\beta_n = Sc\)</span></p><p><span class="math inline">\(A^k\)</span>根据前面所学可对角化为：<spanclass="math inline">\(A_k = S\Lambda^kS^{-1}\)</span></p><p><span class="math inline">\(\therefore u_k = S\Lambda^kS^{-1}Sc =S\Lambda^kc = c_1\lambda_1\beta_1 + c_2\lambda_2\beta_2 + \cdots +c_n\lambda_n\beta_n\)</span></p><p>所以那些绝对值&lt;1的项最终会迭代没，绝对值为1的项加起来就是稳态。</p><hr /><p>傅里叶级数是一个可用来拟合任意周期函数的工具，例如我想拟合一个周期为<spanclass="math inline">\(2\pi\)</span>的函数<spanclass="math inline">\(f(x)\)</span>，可用傅立叶级数表达为下列形式：</p><p><span class="math inline">\(f(x) = a_0\cdot 1 + a_1\cos x + b_1\sin x+ a_2\cos 2x + b_2\sin 2x + \cdots + a_n\cos nx+ b_n\sin nx\)</span></p><p>所以关键就是确定下系数<span class="math inline">\(a_i,b_i\)</span>，那我们用线性代数来看待这个问题。</p><p>可以把<span class="math inline">\(1, \cos x, \sin x, \cos 2x, \sin2x, \cdots, \cos nx, \sin nx\)</span>看作基<spanclass="math inline">\(\beta_i\)</span>-s，<spanclass="math inline">\(f(x)\)</span>看作<spanclass="math inline">\(b\)</span>，那么<span class="math inline">\(a_i,b_i\)</span>就是线性组合的系数。</p><p>让我写成这种形式：<span class="math inline">\(c_0\beta_0 + c_1\beta_1+ c_2\beta_2 + \cdots + c_n\beta_n = b\)</span></p><p>问题即为求出<span class="math inline">\(c_i\)</span>。</p><p>假设<spanclass="math inline">\(\beta_i\)</span>-s们正交就好了，我们来检查一下是否正交。</p><p>因为这里的“向量”是函数，所以离散型的点积在这里并不是适用，对于函数<spanclass="math inline">\(f(x), g(x)\)</span>，其实点积是<spanclass="math inline">\(\int_a^b f(x)g(x)\mathrm{d}x\)</span>，因为本题函数周期为<spanclass="math inline">\(2\pi\)</span>，所以俩函数点积为：<spanclass="math inline">\(\int_0^{2\pi}f(x)g(x)\mathrm{d}x\)</span>，检查一下发现这些“基”们确实是正交的。</p><p>那么求系数<spanclass="math inline">\(c_i\)</span>就好办了，比如我要求<spanclass="math inline">\(c_1\)</span>，那么等式两边分别“点积”<spanclass="math inline">\(\beta_1\)</span>，得：</p><p><span class="math inline">\(c_1 \int_0^{2\pi}(cosx)^2\mathrm{d}x =\int_0^{2\pi}f(x)\cos x\mathrm{d}x\)</span></p><p>因为正交性，非<spanclass="math inline">\(\beta_1\)</span>的项都为0了，所以解这个方程即可把<spanclass="math inline">\(c_1\)</span>求出来，其余系数求法同理。</p><p>非常巧妙优美的做法。</p><h3 id="十.-复习课二">十. 复习课二</h3><p>主要因为这章的知识比较重要，所以适合来2道例题巩固一下。而且我想通过例题顺便补充下代数重数和几何重数的知识点。</p><p><strong>例1.</strong> <span class="math inline">\(a = \begin{bmatrix}2 \\ 1 \\ 2 \end{bmatrix}\)</span></p><ol type="1"><li>求投影到<span class="math inline">\(a\)</span>的投影矩阵<spanclass="math inline">\(P\)</span></li></ol><p>套公式：<span class="math inline">\(P =\frac{aa^\mathrm{T}}{a^\mathrm{T}a} = \frac{1}{9} \begin{bmatrix} 4&amp; 2 &amp; 4 \\ 2 &amp; 1 &amp; 2 \\ 4 &amp; 2 &amp; 4\end{bmatrix}\)</span></p><ol start="2" type="1"><li>求<span class="math inline">\(P\)</span>的秩</li></ol><p>因为<span class="math inline">\(P\)</span>的列空间<spanclass="math inline">\(C(P)\)</span>是投影面，而投影面又是三维空间里的一维直线，所以<spanclass="math inline">\(dim(C(A)) = r = 1\)</span>。</p><ol start="3" type="1"><li>求<span class="math inline">\(P\)</span>的特征值</li></ol><p>因为<span class="math inline">\(r(P) =1\)</span>，所以它是奇异，所以<span class="math inline">\(det(P) =0\)</span>，所以它必有一个特征值为0。</p><p>我们知道特征值为0对应的特征向量就是<spanclass="math inline">\(N(P)\)</span>里的那些基们，而我们知道<spanclass="math inline">\(dim(N(P)) = n - r =2\)</span>，所以基里有俩向量，所以特征值0的几何重数为2，又因为几何重数&lt;= 代数重数，所以至少有两个特征值为0。</p><p><spanclass="math inline">\(P\)</span>的迹又是1，所以不可能三个特征值都为0，所以可确定特征值0的代数重数也为2。所以特征值分别为0、0、1</p><blockquote><p>知识点补充：代数重数、几何重数</p><p>代数重数就是某特征值重复的个数</p><p>几何重数就是某特征值对应的互相线性无关的特征向量的个数。这些线性无关的特征向量组合的空间叫做特征子空间</p><p>性质：几何重数 &lt;= 代数重数</p></blockquote><ol start="4" type="1"><li><spanclass="math inline">\(P\)</span>特征值为1对应的特征向量是啥</li></ol><p>其实就是问你<span class="math inline">\(Px=x\)</span>的<spanclass="math inline">\(x\)</span>都有谁，根据几何意义，显然<spanclass="math inline">\(x\)</span>就在投影面上啊，即那条线，所以特征向量写<spanclass="math inline">\(a\)</span>就行了</p><p><strong>例2.</strong> 已知一个4阶方阵<spanclass="math inline">\(A\)</span>具有特征值<spanclass="math inline">\(\lambda_1, \lambda_2, \lambda_3,\lambda_4\)</span></p><ol type="1"><li>特征值需要满足什么条件才能保证<spanclass="math inline">\(A\)</span>为可逆矩阵</li></ol><p>可逆矩阵说明<span class="math inline">\(r(A) =n\)</span>，那么零空间的维数就为0。而如果有特征值为0，那么必然说明零空间有非零向量，即<spanclass="math inline">\(r(A) \nen\)</span>。所以必须满足所有特征值不为0，才能保证<spanclass="math inline">\(A\)</span>为可逆矩阵</p><ol start="2" type="1"><li>求<span class="math inline">\(A^{-1}\)</span>的行列式</li></ol><p>因为<span class="math inline">\(A^{-1}\)</span>的特征值是<spanclass="math inline">\(A\)</span>特征值取倒数，行列式又是特征值之积，所以<spanclass="math inline">\(det(A^{-1}) =\frac{1}{\lambda_1\lambda_2\lambda_3\lambda_4}\)</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;正交向量/空间、对向量/空间投影、正交矩阵、正交化、行列式、特征值/特征向量、(特征值)对角化、马尔可夫矩阵/傅里叶级数&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>线性代数1</title>
    <link href="http://error666.top/2024/09/11/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/"/>
    <id>http://error666.top/2024/09/11/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B01/</id>
    <published>2024-09-11T10:58:18.000Z</published>
    <updated>2024-09-17T15:27:41.582Z</updated>
    
    <content type="html"><![CDATA[<p>方程组、矩阵、消元、向量空间、秩、解方程</p><p>还差P23、P27没学，等学完微分方程后回来看。</p><span id="more"></span><hr /><p>课程是<ahref="https://www.bilibili.com/video/BV16Z4y1U7oU/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0">链接</a></p><p>Gilbert Strang老爷子的MIT 18.06 LinearAlgebra。非常经典的一门课程，是理解性讲课而不是像国内多数高校式的应试性讲课。</p><p>线性代数作为诸多工程应用的基石，其重要性毋庸置疑。所以对于这份笔记，我的看法是常看常新，多看不亏，越多看，越能把全部知识串联起来。</p><p>在铺垫好线性代数的基石后，最好修一门常微分方程(mit18.03)。学有余力的话，把单变量微积分mit 18.01和多变量微积分mit18.02修了。如果想提高应用数学视野的可以去修GilbertStrang的计算科学与工程mit 18.085+18.086。</p><h3 id="一.-方程组的几何解释">一. 方程组的几何解释</h3><ul><li>考虑一个一元二次方程组，我们的几何理解就是一个方程是一条直线。这样的理解是初高中理解</li><li>但是到了大学，我们应该竖着去看方程组，也就是x乘一个列向量，y乘一个列向量，加起来，得到一个列向量，也就是这种形式：</li><li><span class="math inline">\(\begin{bmatrix}2 \\ -1\end{bmatrix}x +\begin{bmatrix}-1 \\ 2\end{bmatrix}y = \begin{bmatrix}0 \\3\end{bmatrix}\)</span></li><li>上面这种“竖着理解方程组的方式”，叫做“线性组合”，是贯穿这门课的一个思想</li></ul><hr /><ul><li><p>考虑线性组合的几何意义，假设有m个未知数，n个方程。</p></li><li><p>那么就有m个列向量。首先把这m个维度为<spanclass="math inline">\(\mathbb{R}^{n}\)</span>的列向量画到<spanclass="math inline">\(\mathbb{R}^n\)</span>上。</p></li><li><p>然后m个未知数就是这m个向量的系数，去线性组合这些向量，得到答案向量。</p></li><li><p>是不是很巧妙？在2维以上的空间内，用向量的线性组合去考虑问题会大大的简化问题。</p></li></ul><hr /><ul><li><p>为了不每次都写出上面那个<span class="math inline">\(x \cdot [2,-1]^\mathrm{T} + y \cdot [-1, 2]^\mathrm{T} = [0,3]\)</span>这种线性组合，太麻烦了，所以我们引入了矩阵来简化表达</p></li><li><p>具体来说，一个m个未知数，n个方程的方程组，用系数矩阵<spanclass="math inline">\(A\)</span>、未知数向量<spanclass="math inline">\(\textbf{x}\)</span>、答案向量<spanclass="math inline">\(b\)</span>来描述这个方程组</p></li><li><p>当你看到一个形如<span class="math inline">\(A\textbf{x} =b\)</span>的方程的时候，你要明白，本质就是m个维度为<spanclass="math inline">\(\mathbb{R}^n\)</span>的向量的线性组合 =常向量的求解问题</p></li></ul><hr /><ul><li><p>现在我们思考一个问题：n个方程，m个未知数的方程组是否永远有解？</p></li><li><p>用线性组合的观点就是，m个维度为<spanclass="math inline">\(\mathbb{R}^n\)</span>的向量的线性组合是否可以覆盖整个<spanclass="math inline">\(\mathbb{R}^n\)</span>空间？</p></li><li><p>可以发现，问题的关键，就是在这m个向量身上，换句话说，也就是在系数矩阵<spanclass="math inline">\(A\)</span>身上。这m个向量具有什么样的特点 / <spanclass="math inline">\(A\)</span>具有什么样的特点时，方程组会有解？会有几个解？这就是以后会讨论到的问题。</p></li></ul><hr /><ul><li>相信看到这，已经能感受到线性代数的绝妙吸引力了。它能带你在高维空间里遨游，让你熟练的玩弄高维空间。</li><li>数学真神奇，不是吗？</li></ul><h3 id="二.-矩阵消元">二. 矩阵消元</h3><ul><li><p>这节学习的是用消元法解方程组，计算机解方程都是用这种方法</p></li><li><p>首先先按国内大部分高校的讲法讲一遍：</p></li><li><p>消元就是初高中学的那个消元，消元前后矩阵是等价的，对系数矩阵进行求上三角过程</p></li><li><p>其实求上三角的过程，就是在依次确定基向量，基向量的意思就是能对解空间产生贡献的向量。假设向量俩俩正交，那么它们都是基向量。</p></li><li><p>对于n个方程，m个未知数的方程。若通过求上三角后，有k个主元（主元就是每列最后一个非零元素），说明有k个维度为<spanclass="math inline">\(\mathbb{R}^n\)</span>的基向量，那么若<spanclass="math inline">\(k \gen\)</span>，则方程组必定有解，因为此时m个向量可以线性组合出整个<spanclass="math inline">\(\mathbb{R}^n\)</span>空间。反之，则不一定有解。</p></li><li><p>换句话说，有几个主元，方程组的向量们就能线性组合出几维的空间</p></li></ul><hr /><ul><li><p>回到正题，如何求解方程组呢？（考虑一定有解的情况）</p></li><li><p>首先把答案向量<span class="math inline">\(b\)</span>加入到<spanclass="math inline">\(A\)</span>中作为新的一列，此时称<spanclass="math inline">\(A\)</span>为增光矩阵<spanclass="math inline">\(\overline{A}\)</span></p></li><li><p>对<spanclass="math inline">\(\overline{A}\)</span>消元求上三角，然后将消元后的矩阵重新写成方程组去算就行了</p></li></ul><hr /><ul><li><p>好了，现在用我在mit学到的讲法讲一遍：</p></li><li><p>上面的讲法中，对<spanclass="math inline">\(\overline{A}\)</span>消元求上三角的过程，我们的视角还是用初高中的做法去做的，但现在，仍然是消元求上三角的过程，我想用矩阵去做</p></li><li><p>在做之前，我想介绍“行的线性组合“</p></li></ul><hr /><ul><li><p>我们之前讲了，对于方程<spanclass="math inline">\(A\textbf{x}=b\)</span>，我们的理解方式就是看成m个列向量的线性组合，这其实是“列的线性组合“</p></li><li><p>现在我们来看这个方程：<spanclass="math inline">\(\textbf{x}^{\mathrm{T}}A =b^{\mathrm{T}}\)</span>，<spanclass="math inline">\(\textbf{x}^{\mathrm{T}}\)</span>是一个有n个未知数的行向量，<spanclass="math inline">\(A\)</span>仍然是一个<spanclass="math inline">\(\mathbb{R}^{n \times m}\)</span>的矩阵，<spanclass="math inline">\(b^{\mathrm{T}}\)</span>是一个常行向量。</p></li><li><p>此时我们需要把这个方程理解为“行的线性组合“，也就是<spanclass="math inline">\(A\)</span>的每一行就是一个向量，然后这些向量线性组合，系数就是<spanclass="math inline">\(x^{\mathrm{T}}\)</span>里的分量。</p></li></ul><hr /><ul><li>ok，回到对矩阵的消元。</li></ul><p>假设有一个矩阵：</p><p><span class="math display">\[\left[\begin{array}{c}1 &amp; 2 &amp; 1 \\3 &amp; 8 &amp; 1 \\0 &amp; 4 &amp; 1\end{array}\right]\]</span></p><p>首先我想用第一行把(2,1)消掉，那么第一行是不变的，第三行是不变的，第二行应该变为<spanclass="math inline">\([0, 2,-2]\)</span>，也就是第二行加上负三倍的第一行。首先第一行是不变的，利用“行的线性组合”思想，我们可以对<spanclass="math inline">\(A\)</span>左乘一个行向量：</p><p><span class="math display">\[[1, 0, 0]\left[\begin{array}{c}1 &amp; 2 &amp; 1 \\3 &amp; 8 &amp; 1 \\0 &amp; 4 &amp; 1\end{array}\right]=[1, 2, 1]\]</span></p><p>然后第三行也是不变的，所以我们继续左乘：</p><p><span class="math display">\[\left[\begin{array}{c}1 &amp; 0 &amp; 0 \\? &amp; ? &amp; ? \\0 &amp; 0 &amp; 1\end{array}\right]\left[\begin{array}{c}1 &amp; 2 &amp; 1 \\3 &amp; 8 &amp; 1 \\0 &amp; 4 &amp; 1\end{array}\right]=\left[\begin{array}{c}1 &amp; 2 &amp; 1 \\? &amp; ? &amp; ? \\0 &amp; 4 &amp; 1\end{array}\right]\]</span></p><p>显然对于结果矩阵的第二行，我们是想让<spanclass="math inline">\(A\)</span>的原第二行加上三倍负第一行的，所以线性组合就是(-3)* 第一行 + (1) * 第二行 + (0) *第三行，所以把系数填进左乘的矩阵，即可得到：</p><p><span class="math display">\[\left[\begin{array}{c}1 &amp; 0 &amp; 0 \\-3 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1\end{array}\right]\left[\begin{array}{c}1 &amp; 2 &amp; 1 \\3 &amp; 8 &amp; 1 \\0 &amp; 4 &amp; 1\end{array}\right]=\left[\begin{array}{c}1 &amp; 2 &amp; 1 \\0 &amp; 2 &amp; -2 \\0 &amp; 4 &amp; 1\end{array}\right]\]</span></p><p>这里我们把左乘的这个矩阵记为<spanclass="math inline">\(E_{21}\)</span>（因为是想对(2,1)这个位置进行消除）。这种矩阵叫做初等矩阵</p><p>下一步做法依次类推：</p><p><span class="math display">\[\left[\begin{array}{c}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; -2 &amp; 1\end{array}\right]\left[\begin{array}{c}1 &amp; 2 &amp; 1 \\0 &amp; 2 &amp; -2 \\0 &amp; 4 &amp; 1\end{array}\right]=\left[\begin{array}{c}1 &amp; 2 &amp; 1 \\0 &amp; 2 &amp; -2 \\0 &amp; 0 &amp; 5\end{array}\right]\]</span></p><p>同样的，我们把左乘的这个矩阵叫做<spanclass="math inline">\(E_{32}\)</span>，因为是对位置(3, 2)消除</p><p>以上，就是用矩阵去描述消元的全过程。最后，用矩阵来做个大总结的话，就是：</p><p><span class="math inline">\(E_{32}E_{21}A = U\)</span></p><hr /><ul><li>这里再跑点题，多讲一下“初等矩阵”这个概念</li><li>前面的<span class="math inline">\(E_{21},E_{32}\)</span>本质上，就是对矩阵<spanclass="math inline">\(A\)</span>做了一次"操作"，也就是某行减掉了另一行的几倍。</li><li>所以我们把能"操作"矩阵的矩阵称为初等矩阵</li><li>除了某行减掉了另一行几倍，当然还有别的操作，例如交换两行。</li><li>很容易啊，一样用"行的线性组合"思想，假设要交换第一第二行，那么初等矩阵的第一行就是[0,1, ..., 0]，第二行就是[1, 0, ..., 0]</li><li>对于能交换矩阵行和列的矩阵，也是一种初等矩阵，我们记为<spanclass="math inline">\(P\)</span>（置换矩阵）</li></ul><h3 id="三.-矩阵乘法和逆矩阵">三. 矩阵乘法和逆矩阵</h3><ul><li><p>假设矩阵<span class="math inline">\(A\)</span>乘<spanclass="math inline">\(B\)</span>得到矩阵<spanclass="math inline">\(C\)</span>。考虑<spanclass="math inline">\(C\)</span>的某个元素<spanclass="math inline">\(c_{ij}\)</span>，我们都知道这个元素是由<spanclass="math inline">\(A\)</span>的第i行与<spanclass="math inline">\(B\)</span>的第j列做点乘得到的。</p></li><li><p>但是我们如果再用“行的线性组合”的思想，就可以知道，首先，<spanclass="math inline">\(C\)</span>的第i行是由<spanclass="math inline">\(B\)</span>的每一行线性组合得到的，系数是<spanclass="math inline">\(A\)</span>的第i行。那如果我只看<spanclass="math inline">\(C\)</span>第i行的第j个，那么也就是<spanclass="math inline">\(B\)</span>每一行的第j个（也就是<spanclass="math inline">\(B\)</span>的第j列）的线性组合，系数是<spanclass="math inline">\(A\)</span>的第i行。从这个角度来看，就清晰多了。</p></li><li><p>好的，我们前面讨论的矩阵都是方阵。但其实，矩阵相乘不一定是方阵。假设<spanclass="math inline">\(A\)</span>为<spanclass="math inline">\(\mathbb{R}^{m \times n}\)</span>, <spanclass="math inline">\(B\)</span>为<spanclass="math inline">\(\mathbb{R}^{n \times p}\)</span>, <spanclass="math inline">\(C\)</span>为多少呢？</p></li><li><p>通过前面“行的线性组合”思想可以推出来，首先<spanclass="math inline">\(A\)</span>有m行，那么<spanclass="math inline">\(C\)</span>一定有m行，<spanclass="math inline">\(C\)</span>的每i行是由<spanclass="math inline">\(B\)</span>的每一行线性组合得到的，系数是<spanclass="math inline">\(A\)</span>的第i行。所以<spanclass="math inline">\(C\)</span>每一行的维度由<spanclass="math inline">\(B\)</span>每一行的维度决定，所以<spanclass="math inline">\(C\)</span>的维度就是<spanclass="math inline">\(\mathbb{R}^{m \times p}\)</span></p></li><li><p>好的，还可以通过“列的线性组合”思想来推出来。首先<spanclass="math inline">\(C\)</span>的第i列是由<spanclass="math inline">\(A\)</span>的每一列的线性组合得到的，系数是<spanclass="math inline">\(B\)</span>的第i列。所以<spanclass="math inline">\(C\)</span>每一列的维度跟<spanclass="math inline">\(A\)</span>一样，有m个分量，然后因为<spanclass="math inline">\(B\)</span>有p列，所以<spanclass="math inline">\(C\)</span>也有p列，所以<spanclass="math inline">\(C\)</span>的维度就是<spanclass="math inline">\(\mathbb{R}^{m \times p}\)</span></p></li></ul><hr /><ul><li><p>但是，还有第三种方法去理解矩阵乘法。就是将矩阵乘法拆成若干个矩阵的加法。我们先考虑一个例子，一个列向量乘一个行向量，假设维度分别为<spanclass="math inline">\(\mathbb{R}^{m \times 1}, \mathbb{R} ^ {1 \timesn}\)</span>，那么显然结果是一个矩阵。这个矩阵的得到可以用“行线组”或者“列线组”去理解都行。</p></li><li><p>ok，那么接下里看这个例子：</p></li></ul><p><span class="math display">\[\left[\begin{array}{c}2 &amp; 7 \\3 &amp; 8 \\4 &amp; 9\end{array}\right]\left[\begin{array}{c}1 &amp; 6 \\0 &amp; 0\end{array}\right]\]</span></p><p>我可以把它看成：第一列乘第一行 + 第二列乘第二行</p><p><span class="math display">\[\left[\begin{array}{c}2 &amp; 7 \\3 &amp; 8 \\4 &amp; 9\end{array}\right]\left[\begin{array}{c}1 &amp; 6 \\0 &amp; 0\end{array}\right]=\left[\begin{array}{c}2 \\3 \\4\end{array}\right]\left[\begin{array}{c}1 &amp; 6\end{array}\right]+\left[\begin{array}{c}7 \\8 \\9\end{array}\right]\left[\begin{array}{c}0 &amp; 0\end{array}\right]\]</span></p><ul><li>好了，现在理解矩阵乘法就有至少三种方法了：行的线性组合、列的线性组合、拆为列向量与对应行向量相乘转为矩阵加法</li></ul><hr /><ul><li>其实还有一种理解的方法，就是分块矩阵，可以把俩相乘的矩阵分成对应的块，例如下图：</li></ul><p><img src="1.png" /></p><p>那么其实就可以把<span class="math inline">\(A_1, A_2, A_3, A_4, B_1,B_2, B_3, B_4\)</span>看作“元素”，那么就跟之前的三种理解方式一样了。</p><p>可以通过行线组思想来理解，那么<spanclass="math inline">\(C\)</span>的第一行就是<spanclass="math inline">\(A_1[B_1, B_2] + A_2[B_3,B_4]\)</span>，第二行就是<span class="math inline">\(A_3[B_1, B_2] +A_4[B_3, B_4]\)</span></p><hr /><ul><li><p>对于那些有逆的矩阵，我们称为可逆矩阵或者非奇异矩阵。</p></li><li><p>好消息是对于方阵<spanclass="math inline">\(A\)</span>，其左逆和右逆是一样的。对于非方阵则不是，因为维度都不同，对于非方阵的逆，称为“伪逆”，这个之后再谈</p></li><li><p>所以方阵到底有没有逆，就是一个很重要的问题。</p></li><li><p>先来讨论一下奇异矩阵，也就是没有逆的矩阵</p></li><li><p>对于一个方阵<span class="math inline">\(A \in \mathbb{R}^{n\times n}\)</span>，假设它的逆为<spanclass="math inline">\(B\)</span>，那么<spanclass="math inline">\(AB=E\)</span>，<spanclass="math inline">\(E\)</span>是一组<spanclass="math inline">\(\mathbb{R}^{n \timesn}\)</span>的基向量，换句话说，用“列的线性组合”思想思考，<spanclass="math inline">\(A\)</span>通过<spanclass="math inline">\(B\)</span>做线性变换后，能得到一组基向量，也就是说明<spanclass="math inline">\(A\)</span>的列向量们是俩俩线性无关的。（若存在线性有关的情况，则不可能线组出一组基向量，因为一组基向量就代表着空间内任意向量都可以线组出来）</p></li><li><p>所以，用几何的思想去思考，一个方阵<spanclass="math inline">\(A\)</span>是否可逆，取决于它的列向量们是否俩俩线性无关。若有关，则不可逆，若无关，则可逆。</p></li><li><p>那能进一步思考吗？其实从刚才的思考可以发现，只要<spanclass="math inline">\(A\)</span>能线性组合出<spanclass="math inline">\(\mathbb{R}^{n \timesn}\)</span>中的任意一个向量，那么<spanclass="math inline">\(A\)</span>就可逆，反之不行。</p></li><li><p>“线性无关”这个条件，可以从<span class="math inline">\(Ax =0\)</span>这个代数方程去思考。如果这个方程有非零解，即<spanclass="math inline">\(col_1 \cdot x_1 + col_2 \cdot x_2 + ... + col_n\cdot x_n = 0\)</span>，移项得到：<spanclass="math inline">\((-\frac{1}{x_n}) \cdot (col_1 \cdot x_1 + col_2\cdot x_2 + ...) = col_n\)</span>，（因为非零解，所以必然可保证<spanclass="math inline">\(x_n \ne0\)</span>），即这些列向量是线性有关的，那么就不可逆了。</p></li><li><p>关于这个结论的证明还可以用反证法，我们的结论是：若能找到<spanclass="math inline">\(x\)</span>不是非零解，使得<spanclass="math inline">\(Ax = 0\)</span>，则<spanclass="math inline">\(A\)</span>不可逆，反之可逆。好，那现在假设<spanclass="math inline">\(A\)</span>可逆，那么有<spanclass="math inline">\(A^{-1}A = E\)</span>，所以<spanclass="math inline">\(A^{-1}Ax = A^{-1}0\)</span>，则<spanclass="math inline">\(x = 0\)</span>，但是前面说了<spanclass="math inline">\(x\)</span>不是非零解，所以假设不成立。</p></li></ul><hr /><ul><li>那么知道一个矩阵有逆后，如何求呢？</li><li>使用Gauss-Jordan消元法。具体来说，假设你想求<spanclass="math inline">\(A\)</span>的逆。那么就写一个增光矩阵: <spanclass="math inline">\([A | I]\)</span>，然后把<spanclass="math inline">\(A\)</span>消元为<spanclass="math inline">\(I\)</span>，那么此时<spanclass="math inline">\(I\)</span>就会变为<spanclass="math inline">\(A^{-1}\)</span>，即<span class="math inline">\([A| I] \rightarrow [I | A^{-1}]\)</span></li><li>原理很简单，消元的过程还记得前面讲的吗，消元的本质就是对消元的矩阵乘“初等矩阵”，那么上面消元的过程我可以用下面这个式子表达：</li><li><span class="math inline">\(E_1E_2E_3...E_k[A | I] = E&#39;[A | I] =[I | E&#39;I]\)</span></li><li>因为<span class="math inline">\(E&#39;A=I\)</span>，所以<spanclass="math inline">\(E&#39;\)</span>是<spanclass="math inline">\(A^{-1}\)</span>，所以<spanclass="math inline">\(E&#39;I\)</span>是<spanclass="math inline">\(A^{-1}\)</span>。</li><li>所以<span class="math inline">\([A | I] \rightarrow [I |A^{-1}]\)</span></li></ul><h3 id="四.-矩阵a的lu分解">四. 矩阵A的LU分解</h3><ul><li>A的LU分解，L是下三角矩阵的意思，U是上三角矩阵的意思</li><li>那A的LU分解有什么用呢？</li><li>主要是拿来多次解方程组，后续讲完你就懂了。</li><li>先用初等矩阵把A消元一下，得到上三角矩阵U，例如：</li><li><span class="math inline">\(E_{21}E_{31}E_{32}A = U\)</span></li><li>然后同乘这些初等矩阵的逆，记为L：</li><li><span class="math inline">\(A = LU\)</span></li><li>即可把<spanclass="math inline">\(A\)</span>分解为下三角和上三角矩阵的乘积</li><li>好了，那么有什么用呢？</li><li>假设要你解<span class="math inline">\(Ax = b_1, Ax = b_2, ... Ax =b_n\)</span></li><li>第一种方法是都对每个方程都Gauss消元一次，每次复杂度都是<spanclass="math inline">\(\mathcal{O}(n^3)\)</span>。</li><li>第二次方法是求出<spanclass="math inline">\(A^{-1}\)</span>，然后对于不同的b，直接拿<spanclass="math inline">\(A^{-1}\)</span>与b相乘即可。这样会快很多。</li><li>第三种方法就是用A的LU分解，先分解得到LU，然后即L(Ux) = b</li><li>然后先解<span class="math inline">\(Ly = b\)</span>得到y，再解<spanclass="math inline">\(Ux = y\)</span>得到x。</li><li>由于L和U都是三角，所以解上述俩方程的复杂度都是<spanclass="math inline">\(\mathcal{O}(n^2)\)</span></li></ul><h3 id="五.-置换-转置-向量空间">五. 置换, 转置, 向量空间</h3><ul><li><p>先讲一下置换矩阵<span class="math inline">\(P\)</span></p></li><li><p>置换矩阵是初等矩阵的一种，意思就是交换行或者列的矩阵</p></li><li><p>比如<spanclass="math inline">\(P_{12}\)</span>，就是交换行1和行2的矩阵</p></li><li><p>思考一个问题，<spanclass="math inline">\(P_{ij}\)</span>的逆矩阵是谁？</p></li><li><p>容易知道，它的逆就是<spanclass="math inline">\(P_{ji}\)</span>，因为<spanclass="math inline">\(P_{ij}P_{ji} = E\)</span>。</p></li><li><p>所以，思考一下不难得出，对于置换矩阵<spanclass="math inline">\(P\)</span>，有<span class="math inline">\(P^{-1} =P^\mathrm{T}\)</span></p></li><li><p>题外话，<span class="math inline">\(n \timesn\)</span>的置换矩阵<spanclass="math inline">\(P\)</span>有多少种呢？</p></li><li><p>置换矩阵的本质就是规定了行的顺序，那么行有多少种排列顺序，就有多少种置换矩阵。所以维度为n的置换矩阵的形态有<spanclass="math inline">\(n!\)</span>种（全排列）</p></li></ul><hr /><ul><li>置换矩阵<span class="math inline">\(P\)</span>在上一节讲过的<spanclass="math inline">\(A=LU\)</span>分解中可以用到。因为在对<spanclass="math inline">\(A\)</span>求上三角<spanclass="math inline">\(U\)</span>的时候，可能会碰到主元为0的情况，这是我们不想看到的。所以在一开始，就应该把<spanclass="math inline">\(A\)</span>的行顺序给调配好，然后再开始进行LU分解。所以，上一节讲到的公式，更一般的应该写成：<spanclass="math inline">\(PA = LU\)</span></li></ul><hr /><ul><li><p>讲完置换矩阵，我要讲，转置</p></li><li><p>转置就是<spanclass="math inline">\(\mathrm{T}\)</span>，转置很简单，我想讲的是对称矩阵，就是满足<spanclass="math inline">\(A^{\mathrm{T}}=A\)</span>的矩阵</p></li><li><p>对称矩阵很常见，为什么说它常见呢？因为任意一个矩阵<spanclass="math inline">\(M\)</span>，与自身的转置<spanclass="math inline">\(M^{\mathrm{T}}\)</span>相乘，就可以得到一个对称矩阵<spanclass="math inline">\(MM^{\mathrm{T}}\)</span></p></li><li><p>证明一下：<spanclass="math inline">\((MM^{\mathrm{T}})^{\mathrm{T}} =MM^{\mathrm{T}}\)</span></p></li></ul><hr /><ul><li><p>下面来说一下向量空间</p></li><li><p>最常见的向量空间就是<spanclass="math inline">\(\mathbb{R}^n\)</span>，其中最常见的就是<spanclass="math inline">\(\mathbb{R}^2\)</span></p></li><li><p>向量空间我觉得跟群的概念有点像，本质就是一个封闭的集合。对于向量空间来说，空间里的向量任意线性组合之后必须仍然要在空间内，才能称为向量空间</p></li><li><p>前面说了<spanclass="math inline">\(\mathbb{R}^n\)</span>是最常见的向量空间，但其实，我们更关心包含在其中的空间，即子空间</p></li><li><p>就拿<span class="math inline">\(\mathbb{R}^2\)</span>举例，<spanclass="math inline">\(\mathbb{R}^2\)</span>的子空间有谁呢？</p></li><li><p>首先，自己肯定是自己的子空间，这很容易。</p></li><li><p>然后是直线，即穿过原点的任意直线，也是<spanclass="math inline">\(\mathbb{R}^2\)</span>的子空间</p></li><li><p>第三个就是一个点，零向量</p></li><li><p>总结一下，能构成向量空间的规则，就是向量空间里的向量任意线性组合之后仍然在向量空间内，这就是向量空间</p></li></ul><hr /><ul><li>接下来，我们谈论一下，如何通过矩阵来构造子空间</li><li>对于一个矩阵<spanclass="math inline">\(A\)</span>，假设其有n行m列，那么它的m个列向量线性组合出来的向量空间叫做矩阵<spanclass="math inline">\(A\)</span>的列空间，记作<spanclass="math inline">\(C(A)\)</span></li></ul><h3 id="六.-列空间和零空间">六. 列空间和零空间</h3><ul><li><p>若有子空间<span class="math inline">\(S\)</span>和<spanclass="math inline">\(T\)</span>，那么<span class="math inline">\(S\bigcap T\)</span>是不是子空间，答案显然是的。</p></li><li><p>从感性上，稍微思考一下可以很容易的理解</p></li><li><p>理性证明也很好证：</p></li></ul><blockquote><p>设<span class="math inline">\(v, w \in S \bigcap T\)</span>, 则</p><p><span class="math inline">\(v \in S, v \in T\)</span>; <spanclass="math inline">\(w \in S, w \in T\)</span></p><p>所以<span class="math inline">\(v, w\)</span>的线性组合既在<spanclass="math inline">\(S\)</span>，也在<spanclass="math inline">\(T\)</span>中</p><p>所以<span class="math inline">\(v, w\)</span>的线组在<spanclass="math inline">\(S \bigcap T\)</span>中</p><p>所以<span class="math inline">\(S \bigcap T\)</span>是一个子空间</p></blockquote><hr /><ul><li><p>好了，现在要把子空间的概念与方程的解联系起来</p></li><li><p>之前我们有讨论过<spanclass="math inline">\(Ax=b\)</span>何时有解的情况</p></li><li><p>之前我们说的是，若A的列向量们线组无法线组出来b，那么方程就是无解。</p></li><li><p>现在有了子空间这个概念，我们可以把上面那句话说的更专业一点：</p></li><li><p>若<span class="math inline">\(b \notinC(A)\)</span>，则无解（若b不在A的列空间内则无解）；反之有解</p></li></ul><hr /><ul><li><p>接下来介绍一下零空间的概念</p></li><li><p>对于<span class="math inline">\(Ax=b\)</span>这个方程，当<spanclass="math inline">\(b=0\)</span>的时候，其的解集称为<spanclass="math inline">\(A\)</span>的零空间，记为<spanclass="math inline">\(N(A)\)</span></p></li><li><p>需要注意的是，对于一个矩阵<span class="math inline">\(A \in\mathbb{R}^{n \times m}\)</span>，其列空间<spanclass="math inline">\(C(A)\)</span>是<spanclass="math inline">\(\mathbb{R}^{n}\)</span>维的（因为每个列向量有n个分量），而其零空间<spanclass="math inline">\(N(A)\)</span>是<spanclass="math inline">\(\mathbb{R}^m\)</span>维的（因为有m个列向量，所以有m个系数）</p></li></ul><hr /><ul><li><p>好了，前面介绍了零空间的概念。但是，我想请问，零空间一定是子空间吗？</p></li><li><p>答案：是的</p></li><li><p>证明过程很简单，如下：</p></li></ul><blockquote><p>if <span class="math inline">\(v, w \in N(A)\)</span>, i.e., <spanclass="math inline">\(Av=0, Aw=0\)</span></p><p>then <span class="math inline">\(A(k_1v + k_2w) = Ak_1v + Ak_2w =k_1(Av) + k_2(Aw) = 0\)</span></p><p>so <span class="math inline">\(k_1v + k_2w \in N(A)\)</span> for any<span class="math inline">\(v, w \in N(A)\)</span></p><p>so <span class="math inline">\(N(A)\)</span> is a subspace.</p></blockquote><h3 id="七.-求解ax0">七. 求解Ax=0</h3><ul><li><p>这节先介绍解<spanclass="math inline">\(Ax=0\)</span>的算法</p></li><li><p>先对<span class="math inline">\(A\)</span>消元</p></li><li><p>当然，可能出现主元为0的情况，不影响</p></li><li><p>如果所有主元都不为0，可以得到一个上三角矩阵，如果有主元为0，那么得到的将是一个阶梯型矩阵</p></li><li><p>主元的个数很重要，它有个名字：秩</p></li><li><p>OK，回到解<spanclass="math inline">\(Ax=0\)</span>的问题。假设现在我们通过消元得到了一个阶梯型矩阵<spanclass="math inline">\(U\)</span>，那么现在要解决的问题就是<spanclass="math inline">\(Ux=0\)</span>的解</p></li><li><p>我们把<spanclass="math inline">\(U\)</span>里阶梯的每个凸角那列叫做“主列”，其余列叫做“自由列”。（之所以叫自由列因为它们可以被其余的主列线组出来）</p></li><li><p>对于自由列对应的解，我们叫做“自由变量”。自由变量可以随便取，取完之后，就可以反代解出主列对应的解。从而可以得到一组解。</p></li><li><p>通常，假设有k个自由变量，那么我们会求k组特殊解，自由变量的取值就是枚举k个人，第i个人是1其余人是0，得到k组特殊解。</p></li><li><p>解空间<spanclass="math inline">\(N(A)\)</span>就是这k个特殊解的线性组合</p></li></ul><hr /><ul><li><p>好了，现在来总结一下上面的算法流程</p></li><li><p>首先对于一个维度为<span class="math inline">\(\mathbb{R}^{m\times n}\)</span>的矩阵<spanclass="math inline">\(A\)</span>，假设有<spanclass="math inline">\(r\)</span>个主元，也就是秩为<spanclass="math inline">\(r\)</span>。那么主列就有<spanclass="math inline">\(r\)</span>列，那么自由列就有<spanclass="math inline">\(n - r\)</span>列，那么就有<spanclass="math inline">\(n - r\)</span>个自由变量。</p></li><li><p>那么分别对这<span class="math inline">\(n -r\)</span>个自由变量取1其余取0，反代，就可以得到<spanclass="math inline">\(n - r\)</span>组特殊解。</p></li><li><p>这<span class="math inline">\(n -r\)</span>个特殊解的线性组合就是<spanclass="math inline">\(N(A)\)</span></p></li></ul><hr /><ul><li><p>如何理解上面的算法流程呢？</p></li><li><p>首先要知道，对于<span class="math inline">\(Ax=0, A \in\mathbb{R}^{m \timesn}\)</span>本质就是令n个列向量的线性组合为零向量。那么假设我找到一组解，那么这个解的倍数仍然是解。</p></li><li><p>ok，然后消元后我们可以知道哪些列是主列，哪些列是自由列，自由列的意思就是说它可以被别人线组出来。所以它对应的解（自由变量）就可以随便取。</p></li><li><p>那如何表示出所有的自由变量的取值呢？</p></li><li><p>答案：线性组合</p></li><li><p>假设有<span class="math inline">\(n -r\)</span>个自由变量，那么就搞<span class="math inline">\(n -r\)</span>次，每次就是其中一个自由变量为1，其余自由变量为0，得到<spanclass="math inline">\(n -r\)</span>组特解。（跟基向量的感觉比较像）</p></li><li><p>那么这<span class="math inline">\(n -r\)</span>组特解的线性组合就是解空间，即零空间<spanclass="math inline">\(N(A)\)</span></p></li></ul><hr /><ul><li><p>好了，接下来讲点好玩的东西</p></li><li><p>前面我们已经知道了<spanclass="math inline">\(Ax=0\)</span>的解法。</p></li><li><p>OK，现在我们再进一步思考，前面的算法仍然有回代这一步，这一步往往是计算机不喜欢的，能不能使算法更加“程序化”一些？</p></li><li><p>答案是可以的，假设我们已经通过消元得到了阶梯型矩阵<spanclass="math inline">\(U \in \mathbb{R}^{m \times n}\)</span></p></li><li><p>对于<spanclass="math inline">\(U\)</span>中的主列，将它主元的头上面全面消元为0。</p></li><li><p>然后把主列全挪到前面，后面放自由列。</p></li><li><p>这样，对于<spanclass="math inline">\(r\)</span>列主列，其实就得到了一个<spanclass="math inline">\(m \times r\)</span>的矩阵，这个矩阵上半部分是<spanclass="math inline">\(r \times r\)</span>的单位阵<spanclass="math inline">\(I\)</span>，下半部分是<spanclass="math inline">\((m - r) \times r\)</span>的全零矩阵。</p></li><li><p>然后对于<span class="math inline">\(n -r\)</span>列自由列，其实是一个<span class="math inline">\(m \times (n -r)\)</span>的矩阵，这个矩阵上半部分是<span class="math inline">\(r\times (n - r)\)</span>的矩阵<spanclass="math inline">\(F\)</span>，下半部分是<spanclass="math inline">\((m - r) \times (n -r)\)</span>的全零矩阵。</p></li><li><p>写出来的话，就是：</p></li></ul><p><span class="math display">\[\left[\begin{array}{c}I &amp; F \\O &amp; O\end{array}\right]\]</span></p><ul><li><p>把这个矩阵记为<spanclass="math inline">\(R\)</span>，那么现在问题就变成了<spanclass="math inline">\(Rx=0\)</span></p></li><li><p>那我更进一步，我想直接求出<span class="math inline">\(X \in n\times (n - r)\)</span>，<spanclass="math inline">\(X\)</span>中的每一列都是<spanclass="math inline">\(Rx=0\)</span>的一组特解。（其实就是求出<spanclass="math inline">\(n - r\)</span>组特解，然后拼一起得到的矩阵<spanclass="math inline">\(X\)</span>）</p></li><li><p>用公式写出来即</p></li></ul><p><span class="math display">\[\left[\begin{array}{c}I_{r \times r} &amp; F_{r \times (n - r)} \\O_{(m - r) \times r} &amp; O_{(m - r) \times (n - r)}\end{array}\right]X = O\]</span></p><ul><li>显然</li></ul><p><span class="math display">\[X=\left[\begin{array}{c}-F_{r \times (n - r)} \\I_{(n - r) \times (n - r)}\end{array}\right]\]</span></p><ul><li><p><span class="math inline">\(X\)</span>的列空间<spanclass="math inline">\(C(X)\)</span>就是<spanclass="math inline">\(Ax=0\)</span>的零空间<spanclass="math inline">\(N(A)\)</span></p></li><li><p>多看几遍上面的过程吧，非常优美的解法。</p></li></ul><h3 id="八.-求解axb">八. 求解Ax=b</h3><ul><li><p>上节的内容是求<spanclass="math inline">\(Ax=0\)</span>的零空间<spanclass="math inline">\(N(A)\)</span></p></li><li><p>这节的目标是讨论<spanclass="math inline">\(Ax=b\)</span></p></li><li><p>首先这个方程有可能有解，也有可能无解。如果有解的话，是否有多解，并求出所有解，这是本节要讨论的问题。</p></li><li><p>显然，通过前面所学，很容易可知，如果<span class="math inline">\(b\in N(A)\)</span>，那么方程<spanclass="math inline">\(Ax=b\)</span>就有解。</p></li><li><p>那有解的时候，如何求出所有解呢？</p></li><li><p>假设矩阵<span class="math inline">\(A \in \mathbb{R}^{m \timesn}\)</span>，秩为<span class="math inline">\(r\)</span>，那么就有<spanclass="math inline">\(n - r\)</span>个自由变量。令这<spanclass="math inline">\(n -r\)</span>个自由变量全取0，即可求出一组特解<spanclass="math inline">\(x_p\)</span>。</p></li><li><p>那么<span class="math inline">\(Ax = b\)</span>的解空间就是<spanclass="math inline">\(x_p + N(A)\)</span></p></li><li><p>注意，<span class="math inline">\(N(A)\)</span>就是<spanclass="math inline">\(Ax=0\)</span>的解空间，它是一个向量空间</p></li><li><p>但是<span class="math inline">\(x_p +N(A)\)</span>就不一定是一个向量空间了，因为它可能不过零向量</p></li><li><p>总之，<span class="math inline">\(Ax=0\)</span>的解空间是<spanclass="math inline">\(N(A)\)</span>，<spanclass="math inline">\(Ax=b\)</span>的解空间是<spanclass="math inline">\(x_p + N(A)\)</span>，<spanclass="math inline">\(x_p\)</span>是自由变量全取0时算出来的一组特解</p></li></ul><hr /><ul><li><p>到现在，其实你已经学会了解<span class="math inline">\(Ax=0,Ax=b\)</span>了。</p></li><li><p>回顾一下，首先是<spanclass="math inline">\(Ax=0\)</span>，先消元，得到秩r，如果r =n，那么就没有自由变量了， 那么<spanclass="math inline">\(N(A)\)</span>里只有零向量。</p></li><li><p>如果r &lt; n，那么就有n - r个自由变量，那么就可以求出n -r组特解，这n - r组特解的线性组合就是<spanclass="math inline">\(N(A)\)</span></p></li><li><p>再来回顾<spanclass="math inline">\(Ax=b\)</span>，先消元，得到秩r，如果r =n，那么就没有自由变量了，那么<spanclass="math inline">\(N(A)\)</span>里只有零向量。然后看看<spanclass="math inline">\(Ax=b\)</span>是否有特解<spanclass="math inline">\(x_p\)</span>，有的话，那么<spanclass="math inline">\(Ax=b\)</span>的解集就只有<spanclass="math inline">\(x_p\)</span>了。如果没有，那么<spanclass="math inline">\(Ax=b\)</span>就没解。</p></li><li><p>如果r &lt; n，那么可以就可以先把<spanclass="math inline">\(N(A)\)</span>求出来。然后求<spanclass="math inline">\(Ax=b\)</span>的特解<spanclass="math inline">\(x_p\)</span>，然后<span class="math inline">\(x_p+ N(A)\)</span>就是<spanclass="math inline">\(Ax=b\)</span>的解集。</p></li></ul><hr /><ul><li>OK，现在再从秩的角度来思考这个问题（<span class="math inline">\(A\in \mathbb{R}^{m \times n}\)</span>）</li></ul><ol type="1"><li>r = m = n<ul><li>此时是方阵，且<spanclass="math inline">\(A\)</span>消元后是单位阵，所以肯定有且只有唯一解</li><li>另一个角度，满秩的方阵是可逆矩阵，所以<span class="math inline">\(x= bA^{-1}\)</span>，从这个角度也可以证明有且只有唯一解</li></ul></li><li>r = n &lt; m<ul><li>此时<span class="math inline">\(A\)</span>消元之后可得到 $ $</li><li>因为n - r = 0，所以没有自由变量，所以<spanclass="math inline">\(N(A)\)</span>里只有零向量。所以<spanclass="math inline">\(Ax=b\)</span>要不没解，要不只有唯一解（就是特解）</li></ul></li><li>r = m &lt; n<ul><li>此时<span class="math inline">\(A\)</span>消元之后可得到 $ $</li><li>此时n - r &gt; 0，所以有自由变量，所以<spanclass="math inline">\(N(A)\)</span>里是有无限多向量的。所以只要<spanclass="math inline">\(Ax=b\)</span>有特解<spanclass="math inline">\(x_p\)</span>，那么<spanclass="math inline">\(Ax=b\)</span>就有无穷多解了。</li><li>显然，<spanclass="math inline">\(Ax=b\)</span>可以找到特解，因为消元之后没有出现全为0的行，所以肯定能凑出一组解</li><li>所以这种情况下，方程<spanclass="math inline">\(Ax=b\)</span>有无穷多组解。</li></ul></li><li>r &lt; m, r &lt; n<ul><li>此时<span class="math inline">\(A\)</span>消元之后可得到 $ $</li><li>此时n - r &gt; 0，所以有自由变量，所以<spanclass="math inline">\(N(A)\)</span>里是有无限多向量的。所以只要<spanclass="math inline">\(Ax=b\)</span>有特解<spanclass="math inline">\(x_p\)</span>，那么<spanclass="math inline">\(Ax=b\)</span>就有无穷多解了。</li><li>但是，这里化简之后出现了全0行，所以用增广矩阵去看全0行的那几行b方程可能无法满足。</li><li>所以，如果能满足的话，就是无穷多组解。如果无法满足的话，那么就没有解</li></ul></li></ol><ul><li>用一句话总结，矩阵的秩说明了方程解的情况。</li></ul><h3 id="九.-线性相关-基-维数">九. 线性相关, 基, 维数</h3><ul><li><p>线性相关的标准定义就是，如果一组向量能线性组合出零向量（系数不能全为0），那么这组向量就线性有关；反之线性无关</p></li><li><p>向量空间的一组基，是指这么一组向量，这组向量满足两个性质：</p><ol type="1"><li>向量组线性无关</li><li>它们恰好能生成整个空间，少一个不行</li></ol></li><li><p>对于一个向量空间，它的基有很多。但是，所有的基中的向量的个数都相同，这个数量称为该向量空间的维数</p></li><li><p><del>所以知道一个向量空间的维数很重要，假设知道了维数dim =k，还知道向量的维度，那么只需要找k个线性无关的该维度的向量即是这个向量空间的一组基。</del>（upd：这句话是错误的！！！）</p></li><li><p>错误原因是因为当时我没意识到行变换会改变列空间。我举一个反例：</p></li></ul><p><span class="math display">\[\left[\begin{array}{c}1 &amp; 0 \\0 &amp; 1 \\0 &amp; 0 \\\end{array}\right]\]</span></p><ul><li><p>这组列向量产生的向量空间是三维空间里的二维过原点的水平平面。</p></li><li><p>ok，如果上面那句话是对的。那么看下面这组由上面那组向量行变换的哀悼的列向量：</p></li></ul><p><span class="math display">\[\left[\begin{array}{c}1 &amp; 1 \\0 &amp; 1 \\2 &amp; 2 \\\end{array}\right]\]</span></p><ul><li><p>俩列向量线性无关，但是形成的向量空间显然不是一个水平的平面。故上面那句话是错的。</p></li><li><p>行变换不会改变列向量的线性关系，所以求向量空间的基的时候，可以随便用行变换。这为下面<spanclass="math inline">\(\mathrm{dim}C(A) = \mathrm{dim}C(R) =r\)</span>的结论做了铺垫。</p></li><li><p>但是行变换会改变列空间，所以求向量空间的时候，一定要注意，求的是列空间还是行空间，如果是列空间的话，就要想到行变换会改变列空间这个坑点。</p></li></ul><blockquote><p>为什么行变换不会改变列向量的线性关系？这里给出证明：</p><p>考虑<span class="math inline">\(k_1b_1 + k_2b_2 + ... + k_nb_n =0\)</span></p><p>做一次行变换后，假设<spanclass="math inline">\(b_i\)</span>行变成了<spanclass="math inline">\(b_i +cb_j\)</span>，那么列出n列的线性组合表达式，还是能整理为<spanclass="math inline">\(k_1b_1 + k_2b_2 + ... + k_nb_n =0\)</span>的形式。</p><p>所以变换前后，俩矩阵的列向量的线性组合可以化为同一种形式，所以线性关系是相同的</p><p>（上面这个证法是自己想的，若错误或者有更好的方法欢迎讨论哇）</p></blockquote><hr /><ul><li>现在，让我们把基、维数的概念用到矩阵<spanclass="math inline">\(A\)</span>中</li><li>首先，对于矩阵<span class="math inline">\(A\)</span>的列空间<spanclass="math inline">\(C(A)\)</span>，它的基是啥？维数是多少？</li><li>很显然，<spanclass="math inline">\(A\)</span>消元后可知道秩r，表示的是主列的个数，这个秩其实就是列空间<spanclass="math inline">\(C(A)\)</span>的维数<spanclass="math inline">\(\mathrm{dim}C(A) = r\)</span></li><li><span class="math inline">\(A\)</span>的主列们就是<spanclass="math inline">\(C(A)\)</span>的一组基（注意这里我说的是<spanclass="math inline">\(A\)</span>的主列们而不是<spanclass="math inline">\(A\)</span>经过行变换后<spanclass="math inline">\(R\)</span>的主列们）</li><li>OK，那对于<span class="math inline">\(A\)</span>的零空间<spanclass="math inline">\(N(A)\)</span>呢？它的基是啥？维数是多少？</li><li>回顾求解<span class="math inline">\(N(A)\)</span>的过程，就是找n -r组特解（有n - r个自由变量）。所以n - r就是<spanclass="math inline">\(N(A)\)</span>的维数<spanclass="math inline">\(\mathrm{dim}N(A) = n - r\)</span>。这n -r组特解就是<span class="math inline">\(N(A)\)</span>的一组基。</li></ul><h3 id="十.-四个基本子空间">十. 四个基本子空间</h3><ul><li><p>四个基本子空间是：列空间、零空间、行空间、左零空间</p></li><li><p>列空间老朋友了，<spanclass="math inline">\(C(A)\)</span></p></li><li><p>零空间也是老朋友了，<spanclass="math inline">\(N(A)\)</span></p></li><li><p>行空间其实可以写成这样，<spanclass="math inline">\(C(A^{\mathrm{T}})\)</span></p></li><li><p>左零空间其实就是，<spanclass="math inline">\(N(A^{\mathrm{T}})\)</span></p></li><li><p>为什么要叫左零空间呢？其实是这样的，<spanclass="math inline">\(A^{\mathrm{T}}y = 0\)</span>，转置，得到，<spanclass="math inline">\(y^{\mathrm{T}}A = 0^{\mathrm{T}}\)</span></p></li><li><p>这里的解在左边，所以就叫左零空间</p></li></ul><hr /><ul><li><p>现在我们来讨论一下这四个空间的维数dim和基</p></li><li><p>首先是列空间，列空间的维数是r。基是多少呢？</p></li><li><p>这里我要强调一点，<span class="math inline">\(C(A) \neC(R)\)</span>（<span class="math inline">\(R\)</span>是<spanclass="math inline">\(A\)</span>经过行变换得到的）</p></li><li><p>因为做行变换会改变列空间，但不会改变行空间</p></li><li><p>但为什么做行变换之后还能求解呢？因为你在做行变换（高斯消元）的过程的时候，是对增广矩阵做的。所以<spanclass="math inline">\(Ax=b\)</span>与<spanclass="math inline">\(Rx=b&#39;\)</span>是等价的，而不是<spanclass="math inline">\(Ax=b\)</span>与<spanclass="math inline">\(Rx=b\)</span>是等价的。</p></li><li><p>好了，所以<spanclass="math inline">\(C(A)\)</span>的维数是r，基是<spanclass="math inline">\(A\)</span>的主列们</p></li><li><p>然后讨论零空间<spanclass="math inline">\(N(A)\)</span>，零空间关心的是解集，所以不用关心行变换会影响到<spanclass="math inline">\(N(A)\)</span>。所以<spanclass="math inline">\(N(A)\)</span>的维数是n - r，基就是n -r组特解</p></li><li><p>接下来讨论行空间<spanclass="math inline">\(C(A^\mathrm{T})\)</span>，它的维数是r，基呢？</p></li><li><p>其实直接对<span class="math inline">\(A\)</span>做消元得到<spanclass="math inline">\(R\)</span>，<spanclass="math inline">\(R\)</span>的主行们就是<spanclass="math inline">\(C(A^\mathrm{T})\)</span>。因为行变换不会改变行空间，所以<spanclass="math inline">\(A\)</span>与<spanclass="math inline">\(R\)</span>的行空间是相同的。</p></li><li><p>最后来讨论左零空间<spanclass="math inline">\(N(A^\mathrm{T})\)</span>。左零空间的维数是m -r很显然，那么基呢？最简单的方法就是对<spanclass="math inline">\(A^\mathrm{T}\)</span>消元，然后m -r组特解就是左零向量的一组基。</p></li></ul><h3 id="十一.-矩阵空间">十一. 矩阵空间</h3><p>既然有向量空间，那么其实也有矩阵空间。其实任意东西都可以抽象成“向量空间”。</p><p>想象一个以3X3矩阵构成的空间M为例。你从M中任挑俩矩阵，相加或者做数乘，发现仍然得到3X3矩阵，所以这是一个矩阵空间。</p><p>这个矩阵空间还有一些有意思的子空间，比如3X3对称矩阵这个子空间、3X3的上三角矩阵这个子空间。</p><p>显然，M的一组基是9个矩阵，所以M的维数是9（dimM=9）。</p><p>记3X3对称矩阵构成的空间为S，那么显然S的一组基是6个矩阵，dimS=6。</p><p>记3X3上三角矩阵构成的空间为U，那么那么显然U的一组基也是6个矩阵，dimY=6。</p><p>考虑<span class="math inline">\(S \capU\)</span>，一个矩阵即是对称的又是上三角的，那么它就是对角的。所以<spanclass="math inline">\(S \capU\)</span>表示的是3X3对角矩阵这个子空间。显然，<spanclass="math inline">\(\mathrm{dim}(S \cap U)=3\)</span>。</p><p>好，现在考虑一下<span class="math inline">\(S \cup U\)</span>和<spanclass="math inline">\(S +U\)</span>的区别。只要一个矩阵是对称的，或者上三角的，那么它就属于<spanclass="math inline">\(S \cupU\)</span>，但是在这个空间对加法不封闭，所以<spanclass="math inline">\(S \cup U\)</span>不是一个子空间；</p><p><span class="math inline">\(S +U\)</span>中的每一个矩阵都可以i表示为<spanclass="math inline">\(S\)</span>中的一个矩阵加上<spanclass="math inline">\(U\)</span>中的一个矩阵。所以<spanclass="math inline">\(S + U\)</span>是对加法和数乘封闭的，所以<spanclass="math inline">\(S + U\)</span>是一个子空间。另外，当在<spanclass="math inline">\(S\)</span>中任取时，<spanclass="math inline">\(U\)</span>中取零矩阵时，得到的就是<spanclass="math inline">\(S\)</span>。同理，在<spanclass="math inline">\(U\)</span>中任取时，<spanclass="math inline">\(S\)</span>中取零矩阵时， 得到的就是<spanclass="math inline">\(U\)</span>。所以<span class="math inline">\(S +U\)</span>是包含<span class="math inline">\(S \cupU\)</span>的，换句话说，<span class="math inline">\((S \cap U) \subseteq(S \cup U) \subseteq (S + U)\)</span>。</p><p>进一步想想，<span class="math inline">\(S +U\)</span>是什么，其实它就是<spanclass="math inline">\(M\)</span>这个空间。所以显然<spanclass="math inline">\(dim(S + U) = dim(M) = 9\)</span>。</p><p>到这里，我们可以发现一个式子：<span class="math inline">\(dim(S) +dim(U) = dim(S + U) + dim(S \cap U)\)</span></p><p>这不是碰巧，这确实是一个定理。</p><p>所以总结一下，若有向量空间<span class="math inline">\(S,U\)</span>，则<span class="math inline">\(S \cap U\)</span>和<spanclass="math inline">\(S + U\)</span>也是向量空间，但<spanclass="math inline">\(S \cup U\)</span>不是。而且满足：<spanclass="math inline">\(dim(S) + dim(U) = dim(S + U) + dim(S \capU)\)</span></p><hr /><p>下面来一个有趣的例题，假设列向量<span class="math inline">\(v \in\mathbb{R}^4\)</span>，且满足其四个分量之和为0。那么<spanclass="math inline">\(v\)</span>是不是一个向量空间？如果是的话，基和维数是什么？</p><p>首先，在v中任取俩v1,v2，做加法和数乘仍在v中，所以v是一个向量空间。</p><p>然后它的基和维数是多少呢？</p><p>因为v不是一个传统的给定数值的矩阵，所以它的秩不好求。所以这里需要转化思维，如果把v看作是某个矩阵A的零空间，那么只需求出<spanclass="math inline">\(dim(N(A))\)</span>就是v的基，同样，零空间的一组基就是n- r个特解。</p><p>思考后不难发现，<span class="math inline">\(A = [1, 1, 1,1]\)</span>，此时有<span class="math inline">\(Av = 0\)</span>，<spanclass="math inline">\(N(A) = v\)</span>。</p><p>显然对于矩阵<span class="math inline">\(A\)</span>，秩为1，那么<spanclass="math inline">\(dim(N(A)) = dim(v) = n - r = 3\)</span></p><p>主列为第一列，所以自由变量为后三个 ，所以分别可得出特解：<spanclass="math inline">\([-1, 1, 0, 0]^\mathrm{T}, [-1, 0, 1,0]^\mathrm{T}, [-1, 0, 0, 1]^\mathrm{T}]\)</span>。这三个向量就是<spanclass="math inline">\(v\)</span>向量空间的一组基。</p><p>这种解法非常的巧妙，既然正着不好求，就把其转换为矩阵的零空间，从而得到它的空间性质。</p><h3 id="十二.-图和网络">十二. 图和网络</h3><p>本小节不涉及新的线性代数的知识，而是对于实际问题建模，用线性代数去解决，具有启发意义的一节。</p><p>这篇<ahref="https://rqtn.github.io/mit-18.06/mit-18.06-lec12/">博文</a>写的不错</p><h3 id="十三.-复习课一">十三. 复习课一</h3><p><ahref="https://www.bilibili.com/video/BV16Z4y1U7oU?p=13&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0">链接</a>：直接去听，如果都掌握了的话，全部内容是都可以听懂的。</p><p>如果听不懂，说明前面的知识没掌握牢固，建议回到对应的位置重新温习后再来听这堂课。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;方程组、矩阵、消元、向量空间、秩、解方程&lt;/p&gt;
&lt;p&gt;还差P23、P27没学，等学完微分方程后回来看。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="线性代数" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%A6/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>2024数学建模国赛游记</title>
    <link href="http://error666.top/2024/09/09/2024%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9B%BD%E8%B5%9B%E6%B8%B8%E8%AE%B0/"/>
    <id>http://error666.top/2024/09/09/2024%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%9B%BD%E8%B5%9B%E6%B8%B8%E8%AE%B0/</id>
    <published>2024-09-08T16:18:30.000Z</published>
    <updated>2024-09-08T16:55:55.367Z</updated>
    
    <content type="html"><![CDATA[<p>2024年数学建模国赛游记</p><span id="more"></span><p>其实也没啥好写的，总结就是队友给力，大家尽力，传奇论文手、天使建模手。</p><p>打数模这事也是和舍友偶然一次聊天，了解到他打数模，没找到队友，于是我说可以一起打啊，便这样组好了队（两个建模手）。后来，他又拉到我们班一同班同学（传奇论文手）。于是三人队就此形成。</p><p>在正赛之前我们进行过两次正式训练，一次校赛，一次自己打的训练赛。其余日常的小训练就不说了。说来惭愧，日常的数模学习我其实并没有学非常多数模知识，大多数只是泛泛而谈，即了解一下概念，学习一下原理就过了。所以日常训练中其实并没有学到成体系的知识，只是知道了许多名词，以及看了一些国奖论文，知道国奖的论文大概是如何包装的。</p><p>校赛是我们第一次正式训练，总的来说，我觉得作为我们第一次正式写论文的经历比赛，效果还是很不错的。虽然从结果上来说，最终只是个校赛二等奖，建模也自我感觉建的很普通，但是至少我们做出了一份可以看的过去的成品。</p><p>然后就到训练赛了。讲实话训练赛我没有怎么参与，因为当时时间和论文ddl撞了。所以我负责的部分写的很垃圾（自我感觉）。最终，虽然论文的编排有进步（传奇论文手还在进步），但建模效果我认为还不如校赛。</p><p>ok到国赛了。国赛大家从一开始就很上心，特地申请了一间小房子，3天比赛时间几乎全天泡在里头搞数模。第一天晚上我们主要把B题浏览并分析了个大概，把前三问的模型搭建了一个最初步的模型，然后分配了下任务，我负责（1）（4）问，另一个建模手负责（2）（3）问，然后就睡觉了。</p><p>第二天，仔细思考后我们觉得建的模型不对，于是反复思考后在之前模型基础上，进行了大量修改，最终有了全部问题的思路。这中间的过程非常复杂，尤其另一个建模手的（2）（3）问，数学推导十分严谨，效果很好。</p><p>这一天我把第一问模型也建好了，用了俩方法去解决第一问，反正就ChatGPT辅助呗。他给你思路，你理解消化后修正它思路，他再给你思路，你再修正......反反复复，最终建立好了（1）问的模型，并写出了代码。</p><p>第三天，我花了点时间把问题（4）的模型也建完了。但是觉得不够高级，于是加了点trick加速模型求解速度。我的建模任务到此基本结束。另一位建模手负责的（2）（3）问在这一天也修正了一点点小问题，建模也基础结束。论文手开始进入除（1）问的论文编写，最终论文手加班到凌晨4点，我们的论文基本成型（太敬业了，给队友点赞）。</p><p>最后一天，把摘要写了，然后缝缝补补修修论文，晚上就交了。</p><hr /><p>国赛经历其实平平淡淡，按部就班。但是我们三个人是非常尽力的，所以最终的效果我们都比较满意。无论结果如何，至少我们交出了一份问心无愧的答案。</p><p>结果留个坑，到时候出成绩再更新... ...</p><p>为什么没写详细的思路过程？我觉得没啥必要，游记嘛本来就随便写写。</p><p>大概讲讲吧，思路第一问俩方法。法一直接暴力迭代求解，法二序贯检验。第二三问，建立完备的数学期望模型。第四问用自适应蒙特卡罗求解。</p><p>详细的思路也不适合在游记写，有兴趣的到时候去看我github仓库里的论文吧，有什么问题欢迎大家一起交流学习呀。</p><hr /><p>其实，数模比赛我认为是一个“成分复杂“的比赛。你说它水，但是它还真需要一些逻辑和思考才能建出模型和写出代码；你说它严谨，其实部分论文都是瞎编甚至造假的，写论文的人自己都不知道自己在干啥......总之，我对数学建模比赛持中立态度。我的建议是，如果是为了培养写论文的能力以及快速学习能力，那欢迎你参加数模。如果是为了培养所谓数学思维和提高专业水平能力的，打数模浪费时间，不如去搞正儿八经的科研。</p><hr /><p>最后，如果你决定了要参加数模比赛。别忘了找俩好队友，三个臭皮匠或许顶不了一个诸葛亮，但是一颗老鼠屎绝对会坏了整锅汤。<del>这是最重要的，参考我们队的传奇论文手和天使建模手</del>，开玩笑hhhh。赞扬我队友那么多，不是说我是混子，其实我的实力非常受到队友认可。而是第一次遇到这么负责且有实力，思维统一的队友，感叹于自己的幸运有感而发。以前大大小小的比赛太多太多是我一个人单打独斗了。</p><p>最后，祝大家身体健康，学业顺利！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;2024年数学建模国赛游记&lt;/p&gt;</summary>
    
    
    
    <category term="3. 竞赛" scheme="http://error666.top/categories/3-%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>大数据架构与技术自学笔记</title>
    <link href="http://error666.top/2024/09/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%8A%80%E6%9C%AF%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://error666.top/2024/09/04/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%8A%80%E6%9C%AF%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2024-09-03T18:09:39.000Z</published>
    <updated>2024-09-04T02:52:54.384Z</updated>
    
    <content type="html"><![CDATA[<p>其实是一门选修课，但是说是选修，因为学分原因也是要必选的，所以就当它是必修吧。</p><span id="more"></span><h3 id="hadoop简介">Hadoop简介</h3><ul><li>Hadoop狭义上来讲，就是一款处理分布式的开源软件</li><li>广义上Hadoop指的是围绕Hadoop打造的大数据生态圈</li><li>Hadoop的核心组件<ol type="1"><li>Hadoop HDFS（分布式文件存储系统）：解决海量数据存储</li><li>Hadoop YARN（集群资源管理和任务调度框架）：解决资源任务调度</li><li>Hadoop MapReduce（分布式计算框架）：解决海量数据计算</li></ol></li><li>可以理解为mysql统治了数据库的半壁江山。</li><li>HDFS作为分布式文件存储，处于生态圈的底层与核心地位。</li><li>YARN作为分布式通用的集群资源管理系统和任务调度平台，支持各种计算引擎运行，保证了Hadoop地位。</li><li>MapReduce作为大数据生态圈第一代分布式计算引擎，由于自身设计的模型所产生的弊端，导致企业一线几乎不再直接使用MapReduce进行编程处理，但是很多软件的底层依然在使用MapReduce引擎来处理数据。</li></ul><hr /><ul><li>Hadoop的发行版本<ol type="1"><li>开源社区版：Apache开源社区官方开源版本<ul><li>优点：更新速度快，免费</li><li>缺点：兼容/稳定性不周</li></ul></li><li>商业发型版：基于Apache开源协议，由商业公司发行的版本<ul><li>优点：稳定兼容性好</li><li>缺点：收费，更新速度慢</li><li>Cloudera, Hortonworks</li></ul></li></ol></li><li>Hadoop的大版本有3个，1.0没有引入YARN这个组件，只靠MapReduce去实现资源管理和数据处理，所以效率很慢。2.0改变架构，引入了YARN这个组件，专注于资源管理，使MapReduce专注于数据处理，效率提升。3.0架构没变，只是做了性能优化。</li></ul><hr /><ul><li>Hadoop集群有两个，HDFS集群（分布式存储）和YARN集群（资源管理调度）</li><li>你会问，为啥没有MapReduce集群呢？</li><li>因为MapReduce是计算框架、代码层面的组件，没有集群这个说法</li><li>HDFS和YARN集群都是主从架构，具体来说：<ol type="1"><li>HDFS集群<ul><li>主角色：NameNode(NN)</li><li>从角色：DataNode(DN)</li><li>主角色辅助角色：SecondaryNameNode(SNN)</li></ul></li><li>YARN集群<ul><li>主角色：ResourceManager(RM)</li><li>从角色：NodeManager(NM)</li></ul></li></ol></li><li>下面通过一张图来进一步的理解Hadoop集群：</li></ul><p><img src="1.png" /></p><ul><li>五颜六色的是java进程，灰色的框框是一个个机器，只有HDFS集群和YARN集群一起，才称为Hadoop集群。</li><li>spark是一个数据处理框架，它可以调度成千上万的服务器集群，完成海量数据计算，可以暂时理解为是MapReduce的一个升级版</li><li>了解了Hadoop和spark的一些基本概念，下面就开始配置hadoop和spark，具体教程参考实验一指导手册ex1.md</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实是一门选修课，但是说是选修，因为学分原因也是要必选的，所以就当它是必修吧。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="计算机专业课" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>transformers、llama3学习</title>
    <link href="http://error666.top/2024/07/20/transformers%E3%80%81llama3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://error666.top/2024/07/20/transformers%E3%80%81llama3%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-07-19T18:26:55.000Z</published>
    <updated>2024-07-31T06:22:24.598Z</updated>
    
    <content type="html"><![CDATA[<p>最近有个合作idea，需要魔改llama3代码，所以来学习下transformers和llama3</p><p>upd：已经变为我的知识库大杂烩了，将就着看吧，纯粹个人笔记了。</p><span id="more"></span><h2 id="先验知识">先验知识</h2><h3 id="一.-预处理">一. 预处理</h3><ol type="1"><li><p>分词</p><ul><li>Text -&gt; tokenizer -&gt; input_ids</li><li>Text是文本，tokenizer是分词器，将text转成一个个token，然后通过词汇表将token映射到整数id上，得到input_ids</li></ul></li><li><p>embedding</p><ul><li>将整数id映射为一个向量的。目的是为了丰富其蕴含的信息，意思相近的token的向量在距离上也会彼此接近</li></ul></li><li><p>位置编码</p><ul><li><p>为什么需要位置编码？</p></li><li><p>因为“猫在椅子上”和“椅子在猫上”意思完全不同。位置编码就是告诉模型每个token在句子中的位置，这样模型就可以理解单词的顺序。</p></li><li><p>假设有“I love machinelearning.“，将其切为token后且embedding后，得到的向量如下：</p></li><li><p>I -&gt; [0.1, 0.2, 0.3, 0.4]</p></li><li><p>love -&gt; [0.5, 0.6, 0.7,. 0.8]</p></li><li><p>...</p></li><li><p>最简单的位置编码方式就是token在句子中出现的位置下标为1，其余分量为0的向量。即I 的位置向量为[1, 0, 0, 0]，love的位置向量为[0, 1, 0, 0]</p></li><li><p>然后将embedding vector与positionvector相加，得到的向量就不仅有词义信息，还蕴含了位置信息。</p></li></ul></li></ol><h3 id="二.-编码器层encoder-layer">二. 编码器层(Encoder Layer)</h3><p>编码器是由多个编码器层堆叠而成。编码器用于处理输入序列，生成上下文敏感的表示。</p><ol type="1"><li><p>自注意力机制</p><ul><li>自注意机制让每个单词能够关注句子中的其他单词，从而理解上下文</li><li>具体来说，首先会有三个权重矩阵：<spanclass="math inline">\(W_Q\)</span>（查询权重）、<spanclass="math inline">\(W_K\)</span>（键权重）、<spanclass="math inline">\(W_V\)</span>（值权重）</li><li>然后对于每个进来的vector x，都会分别与这三个矩阵相乘，每个vectorx可得到<span class="math inline">\(x_Q\)</span>（查询向量）、<spanclass="math inline">\(x_K\)</span>（键向量）、<spanclass="math inline">\(x_V\)</span>（值向量）三个向量。</li><li>查询向量<spanclass="math inline">\(x_Q\)</span>：可以理解为每个词在关注其他词提出的问题</li><li>键向量<spanclass="math inline">\(x_K\)</span>：可以理解为每个词的特征表示，用来与查询向量匹配。例如你自己有个键向量，然后另一个人有个查询向量。发现你们的这俩向量向量比较接近，说明他查到了你，那么你的值向量就会返回给他</li><li>值向量<spanclass="math inline">\(x_V\)</span>：可以理解为token实际的内容信息</li><li>下面举个实际的例子：</li><li>对于句子“I loveNLP“，对于I，可以计算出查询、键、值向量。对于love、NLP同理。</li><li>那么对于I，计算它的查询向量与其余token的键向量的点积，将这些点积用softmax归一化，得到的一组权重就是I与其它token之间的联系权重（联系越大，权重越大，所有权重之和为1）。然后分别用对应的权重乘上对应token的值向量，然后求和，得到的向量叫做I 的注意力输出。（即 I 在关注了句子中其余token后，得出的一个向量）<ul><li>softmax：将一组向量转换为一个概率分布向量，全部分量之和为</li><li>对于<span class="math inline">\(x_i\)</span>，其softmax后的值为<spanclass="math inline">\(\frac{e^{x_i}}{\sum_{j=1}^n e^{x_j}}\)</span></li><li>softmax的特性是放大差异，较大的输入值对应的输出概率更高，较小的输入值对应的输出概率更小</li></ul></li></ul></li><li><p>多头注意力机制</p><ul><li><p>上面讲了注意力机制，其中提到了三个权重矩阵，这三个权重矩阵我们叫做“注意力头”</p></li><li><p>那么前面说的是，对于一个vectorx，通过一个注意力头，可以得到一个注意力输出</p></li><li><p>那为了让一个token能捕捉到更多信息，我们可以对于一个vectorx使用多个注意力头（也就是多个不同的权重矩阵），得到多个注意力输出，这就是多头注意力机制</p></li><li><p>前面说到，注意力输出是一个向量，表示该token关注句子中其余token后得出的信息。那么多头注意力机制会得到多个注意力输出</p></li><li><p>将多个注意力输出简单拼接在一起，然后通过一个Linear变换再把数据映射回原始token的shape</p></li></ul></li><li><p>层归一化 &amp; 残差连接</p><ul><li><p>层归一化有助于消除梯度消失和梯度爆炸问题，使得梯度能够更稳定地传播到前面的层。这种稳定性加快了模型的收敛速度，使得模型能够更快地达到较优的性能。</p></li><li><p>具体操作就是对输入向量进行标准化，使其具有零均值和单位方差，有助于加快训练速度并稳定模型性能（就是对一个向量进行归一化，就这么简单）</p></li><li><p>残差连接就更简单了，将归一化后的向量与输入进来的向量做加法，得到的向量就是输出。</p><ul><li>为什么要使用残差连接？<ul><li>在深层神经网络中，随着层数的增加，梯度消失和梯度爆炸的问题变得越来越严重。残差连接为梯度提供了直接路径，使得梯度可以更顺畅地反向传播，缓解了这些问题。</li><li>残差连接确保输入信息在深层网络中不会丢失，保持了输入的原始特征。这有助于模型在学习新的特征时，不会遗忘前面层已经学习到的重要信息。</li></ul></li><li>关于梯度消失<ul><li>梯度消失的主要原因是激活函数的选择和链式法则的计算。常见的激活函数（如Sigmoid和Tanh）在其取值范围的两端会趋近于零，这会导致其导数也趋近于零。当使用这些激活函数时，梯度在反向传播过程中会不断地乘以这些小于1的数值，从而逐渐衰减为接近零的值。</li><li>梯度爆炸问题是指在训练深层神经网络时，梯度在反向传播过程中逐渐变大，最终变得非常大。这会导致前面层的权重更新幅度过大，从而使得网络无法稳定训练，甚至导致数值溢出。</li></ul></li></ul></li></ul></li><li><p>前馈神经网络层（FNN, feedforward neural network）</p><ul><li><p>FNN层提供了一个非线性转换（激活函数），使模型能够学习输入数据中的复杂模式和关系。通常，FNN由两层全连接网络和一个非线性激活函数（通常是ReLU）组成。这种结构使得模型不仅能够捕捉线性关系，还能够处理非线性关系。</p></li><li><p>具体操作就是对于刚才经过层归一化和残差连接后的多头注意输出向量，先做一次线性变换，然后ReLu一下，再做一次线性变化，得到FFN的输出向量</p></li></ul></li><li><p>层归一化 &amp; 残差连接</p><ul><li>跟上面一样，对经过FNN后的向量做层归一化和残差连接即可。</li></ul></li></ol><p>‍</p><h3 id="三.-解码器层decoder-layer">三. 解码器层（Decoder Layer）</h3><p>解码器是由多个解码器层堆叠而成。解码器利用编码器的表示和自身的机制生成目标序列。</p><ol type="1"><li><p>掩码注意力机制</p><ul><li><p>首先跟编码器一样，需要将句子经过tokenizer和embedding，添加位置编码</p></li><li><p>然后对于每个token的输入向量x，先是计算其查询向量、键向量、值向量，然后对于每个x，计算它的查询向量与其余token的键向量的点积，再将这些点积形成的向量乘上一个掩码矩阵，再将结果进行softmax归一化，得到注意力权重向量</p><ul><li>掩码矩阵：掩码矩阵中的值为 0 或 <spanclass="math inline">\(-\infty\)</span>。在计算注意力得分时，任何被掩盖的（未来的）词都会被设置为<span class="math inline">\(-\infty\)</span>，从而在 Softmax计算时被转化为 0 的权重，确保未来的词对当前词的生成没有影响。</li></ul></li><li><p>再将注意力权重向量乘上值向量，得到最终的注意力输出</p></li></ul></li><li><p>多头掩码注意力机制</p><ul><li>跟上面的原理一样，就是有多个不同的查询、键、值矩阵，所以对于一个token的向量x，会得到多个注意力输出。只需要将这些注意力输出向量直接拼起来，然后做一次线性变化，即得到了最终的输出向量。</li></ul></li><li><p>层归一化 &amp; 残差连接</p></li><li><p>编码器-解码器注意力机制</p><ul><li>本质就是多头注意力机制，对于每个token的注意力输出，将其乘上<spanclass="math inline">\(W_Q\)</span>，得到查询向量<spanclass="math inline">\(x_Q\)</span>，然后用encoder的输出向量乘上<spanclass="math inline">\(W_K、W_V\)</span>，得到<spanclass="math inline">\(x_K、x_V\)</span>。然后计算注意力权重，最后得到注意力输出即可。</li></ul></li><li><p>层归一化 &amp; 残差连接</p></li><li><p>前馈神经网络层</p></li><li><p>层归一化 &amp; 残差连接</p></li></ol><p>‍</p><h3 id="四.-transformer">四. transformer</h3><p>在了解了上面的encoder和decoder后，就可以用一张图来概括Transformer的工作流程了：</p><p><img src="1.png" /></p><p>图里只有Linear和Softmax没有讲到了。Linear就是将高维向量映射到词汇表的维度，然后进行Softmax后就得到了每个单词出现的概率。</p><p>图片来源：<ahref="https://www.bilibili.com/video/BV1Di4y1c7Zm?p=1&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0">链接</a></p><p>‍</p><h3 id="五.-llama-2">五. llama 2</h3><p><img src="2.png" /></p><p>上图是llama 2的模型架构。</p><p>有一些不同的地方：</p><ol type="1"><li>embedding后没有加上positionbedding，而是把位置编码的工作放在了注意力层</li><li>每个transformerblock中的注意力层和feedforward层一进去都进行了一个RMSNorm，而不是像transformer一样，在每层的最后加LayerNorm</li><li>在对tokenbedding后的向量x分别乘三个矩阵得到Q、K、V三个向量后，没有直接去计算注意力权重，而是对Q和K向量进行了一次位置编码</li><li>feedward层跟transformer有蛮大的不同，首先先进入来一次RMSNorm，然后如上图，两个线性变换并行，其中一个结果经过SiLU后与另一个线性变换的结果对矩阵点乘（对应元素相乘）。然后再做一次线性变化得到结果，结果做一次残差连接，得到最终输出结果</li></ol><h2 id="transformers库入门学习">transformers库入门学习</h2><p>首先去huggingface上下模型，建议用ssh下载（我反正https下不来一直说我网络问题），然后选择“只下载除了lfs文件”的下载方式，将项目clone到本地（先ssh-agentbash，再ssh-add私钥路径，再用hf的ssh代码）。然后再单独手动下载几个lfs大文件，流量多的话直接在官网下即可，少的话就去魔塔下。下完之后把它们丢到项目里。</p><p>upd：上面那个下载方法有点脑残，参考<ahref="https://hf-mirror.com/">HF-Mirror</a>教程用huggingface-cli即可，速度很快</p><p>新建一个虚拟环境，然后下载好transformers、pytorch（pytorch的下载最好用官网源和官网下载指令，不然会出很多莫名奇妙的错误）</p><p>然后即可在本地运行模型啦，使用huggingface的官方示例代码看看是否能运行成功。</p><h3 id="一.-pipeline">一. Pipeline</h3><ul><li>是transformers里的一个库，用来让你傻瓜实现各种推理任务。你只需要输入文本，它会帮你数据预处理、模型调用、处理输出结果。</li><li>pipeline支持的推理任务类型：</li></ul><table><colgroup><col style="width: 57%" /><col style="width: 28%" /><col style="width: 14%" /></colgroup><thead><tr class="header"><th>名称</th><th>解释</th><th>任务类型</th></tr></thead><tbody><tr class="odd"><td>text-classification(sentiment-analysis)</td><td>分析句子情感取向</td><td>text</td></tr><tr class="even"><td>token-classification(ner)</td><td>识别句子中主体分类</td><td>text</td></tr><tr class="odd"><td>text-generation</td><td>文本生成</td><td>text</td></tr><tr class="even"><td>...</td><td>...</td><td>...</td></tr></tbody></table><ul><li><p>模型加载方式：</p><ul><li>pipe = pipeline("text-classification")：使用默认模型</li><li>pipe = pipeline("text-classification",model="模型path")：使用自定义模型</li><li>pipe = pipeline("text-classification", model="模型path",tokenizer="分词器path")：使用自定义模型和分词器</li><li>pipe = pipeline("text-classification", model="模型path",device_map="auto")：使用多卡gpu进行推理</li></ul></li><li><p>查看推理使用的硬件资源：</p><ul><li>print(pipe.model.device)</li></ul></li><li><p>查看不同推理任务pipeline的文档：</p><ul><li>首先from transformers import*，然后定义了一个pipeline对象后（比如叫pipe），直接display一下pipe，然后找到其对应的对象名字的最后一截（例如text-classification就是TextClassificationPipeline），然后display一下TextClassificationPipeline，ctrl加单击它去到对应的文档</li></ul></li></ul><h3 id="二.-tokenizer">二. tokenizer</h3><ul><li>transformers里的tokenizer比先验知识里学到的tokenizer内容更丰富些。包含分词、构建词典、数据转换、数据填充与截断。</li><li>导入包：from transformers import AutoTokenizer</li><li>加载分词器：tokenizer =AutoTokenizer.from_pretrainded("模型路径")</li><li>保存分词器：tokenizer.save_pretrained("保存路径")</li><li>查看词表：tokenizer.vocab</li><li>分词：tokens = tokenizer.tokenize(句子)</li><li>索引转换：<ul><li>ids = tokenizer.convert_tokens_to_ids(tokens)</li><li>其实.convert_...有很多转换方式，总之tokens、ids之间可以互转，tokens可以转回string</li></ul></li><li>简单的实现方式：<ul><li>ids = tokenizer.encode(句子, [add_special_tokens=True])</li><li>str = tokenizer.decode(ids, [skip_special_tokens=False])</li><li>不同模型在encode/decode句子的时候，会在句子前后加特殊字符，若不想要可以使用add/skip_special_tokens参数</li></ul></li><li>更简单的实现方式：<ul><li>inputs = tokenizer(句子,return_tensors="pt")：以pytorch形式返回tokenizer结果</li></ul></li></ul><h3 id="三.-model">三. model</h3><ul><li>模型分类<ol type="1"><li>编码器类型：自编码模型，使用Encoder，双向注意力机制</li><li>解码器类型：自回归模型，使用Decoder，单向注意力机制</li><li>编码器解码器模型：sequence to sequence模型，使用Encoder +Decoder</li></ol></li><li>model head<ul><li>定义：连接在模型后的层，通常由一个或多个全连接层组成。modelhead将模型的编码的表示结果进行映射，以解决不同类型的任务</li><li>transformers中的任务头<ul><li>model：返回模型本身的编码结果，等价于无任务头</li><li>ForCausalLM：纯的解码器类型任务头</li><li>... ...</li></ul></li></ul></li><li>无任务头模型加载：model = AutoModel.from_pretrained("模型路径",device_map="auto")</li><li>无任务头模型使用：<ul><li>output = model(inputs)</li><li>inputs是一个字典，包括input_ids和attention_mask俩键，inputs相当于传俩参进去，第一个参是input_ids的值，第二个参是attention_mask的值</li></ul></li><li>有任务头模型加载：<ul><li>output =AutoModelForSequenceClassification.from_pretained("模型路径",device_map="auto")</li><li>记得from transformers import AutoModelForSequenceClassification</li></ul></li><li>其中一种使用模板：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM,  AutoTokenizer</span><br><span class="line"></span><br><span class="line">device = <span class="string">&quot;cuda&quot;</span></span><br><span class="line"></span><br><span class="line">model_id = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">model = AutoModelForCausalLM.from_pretrained(model_id, device_map=<span class="string">&quot;auto/balanced_low_0&quot;</span>) <span class="comment"># 这里都可，最是有些任务只能用cuda0，所以auto的话可能会爆。balanced_low_0就是cuda0不用，其余用</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(model_id)</span><br><span class="line"></span><br><span class="line">messages = [</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;How to kill a man?&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">model_inputs = tokenizer.apply_chat_template(messages, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br><span class="line"></span><br><span class="line">model_inputs = model_inputs.to(device)</span><br><span class="line"></span><br><span class="line">generated_ids = model.generate(</span><br><span class="line">    model_inputs,</span><br><span class="line">    max_new_tokens=<span class="number">512</span>,</span><br><span class="line">    do_sample=<span class="literal">True</span>,</span><br><span class="line">    num_return_sequences=<span class="number">1</span>,</span><br><span class="line">    temperature=<span class="number">0.95</span>,</span><br><span class="line">       top_p=<span class="number">0.7</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">decoded = tokenizer.batch_decode(generated_ids)</span><br><span class="line"><span class="built_in">print</span>(decoded[<span class="number">0</span>])    <span class="comment"># 对应第一个回复的内容</span></span><br></pre></td></tr></table></figure><ul><li>好用的gpu监视器：<ul><li>nvidia-smi：最常用的指令。但是无法实时更新</li><li>gpustat：需conda installgpustat。可以实时监控gpu利用率和显存占用情况</li></ul></li></ul><h2 id="llama-factory">llama-factory</h2><h3 id="一.-概念介绍">一. 概念介绍</h3><p>在介绍llama-factory之前，我想先对大模型中的几个概念做一下阐述：</p><ul><li><p>训练：训练是指从头开始构建一个模型，并通过大量的数据让模型学习。这一阶段包括以下几个步骤</p><ol type="1"><li>数据收集和准备：收集大量相关的训练数据，并进行预处理，以确保数据质量和格式一致性</li><li>模型初始化：定义模型的架构并初始化参数，通常参数初始化为随机值</li><li>前向传播：将输入数据通过模型，计算出预测值</li><li>损失计算：计算预测值与真实值之间的差异，即损失函数</li><li>后向传播：通过损失函数的梯度，反向调整模型参数以最小化损失</li><li>优化：使用优化算法（如梯度下降、Adam等）更新模型参数</li><li>迭代：重复前向传播、损失计算和后向传播，直到模型在训练数据上达到满意的性能或达到预定的训练轮次</li></ol></li><li><p>微调：微调是指在一个已经训练好的大模型基础上，使用特定领域的数据进行进一步的训练，以便模型在特定任务或领域上表现更好。这一阶段包括以下几个步骤</p><ol type="1"><li>预训练模型选择：选择一个已经训练好的大模型作为基础模型，这个模型已经具备了丰富的知识和特征。</li><li>特定领域数据准备：收集和准备与目标任务相关的特定领域数据。</li><li>模型调整：根据特定任务的需求，对模型架构进行适当的调整（如增加或修改一些层）。</li><li>训练数据微调：使用特定领域的数据对模型进行训练，但通常学习率较低，训练时间较短。这样可以在保持原模型知识的同时，学习新的特定领域知识。</li><li>评估和验证：在特定任务的数据集上评估微调后的模型性能，并进行验证。</li></ol></li><li><p>推理：是指在深度学习和机器学习模型中，使用已经训练好的模型来对新数据进行预测或决策的过程。前面“transformers库入门学习”中调包都是用来做推理任务的。</p></li><li><p>现在我们来介绍一下llama-factory：</p><ul><li>定义：LLaMA-Factory 是一个开源的工具，旨在简化大语言模型（LLMs）如LLaMA、BLOOM、Mistral、Baichuan 和 Qwen的微调和训练过程。它提供了用户友好的界面和一整套工具，使得即使是对机器学习了解不多的人也可以轻松进行各种微调和训练任务。</li><li>特点：<ul><li>支持多种大语言模型，并集成了高效的微调技术，适用于各种应用场景</li><li>平台支持全参数调优、部分参数调优，以及诸如LoRA（低秩适配）、QLoRA（量化低秩适配）和奖励建模等技术。这些方法有助于在尽量少的计算资源下优化模型</li><li>LLaMA-Factory提供了一些工具，用于以标准化格式准备数据，便于训练数据的处理和分词。这确保了不同数据集和模型之间的兼容性和效率</li><li>该框架包括基于 Gradio 的 WebUI，用于交互式测试和演示，允许用户实时输入提示并生成模型的输出。这个界面使得微调后的模型可以更容易地进行展示和验证</li></ul></li></ul></li></ul><h3 id="二.-基本功能学习">二. 基本功能学习</h3><ol type="1"><li>将llama-factory部署到本地（参考github官方教程即可，就三行话）</li><li>准备数据集，在LLaMA-Factory -&gt;data下面把自己的数据集粘贴进去（用json格式），然后在dataset_info.json中添加新数据集的记录</li><li>启动可视化微调：llamafactory-cli webui</li><li>在webui中配置好微调设置后就可以开始微调了（微调结束后UI界面的loss图会显示出来）</li><li>然后在Chat里加载检查点，跟其对话，检验微调成果</li><li>如果觉得可以了，就在Export里把检查点和原模型合并，导出为新模型</li><li>如果想量化，也是在Export里量化导出即可（量化时不能有检查点）</li></ol><h3 id="三.-微调数据集制作">三. 微调数据集制作</h3><p>制作微调数据集的方式和数据集的格式有很多。这里我先只讲一种，因为目前只用到这一种。</p><p>就是生成Q&amp;A式的json格式的数据用来微调模型。</p><p>微调的json文件的格式在llama-factory/data/下可以找到，配合gpt很容易写出符合格式的json文件。所以重难点是准备好Q&amp;A数据即可。</p><p>有几种方案，我这里记录一下：</p><ol type="1"><li>直接找Q&amp;A数据集</li><li>直接让chatbox生成Q&amp;A</li><li>让chatbot生成Q，然后再让chatbox根据这些Q，生成A</li></ol><p>这里可以多写一点，例如模型的选择，对应模型的特点，一些对话技巧。等项目做完再详细补充。<strong><u>TODO</u></strong></p><h2 id="训练方法sft">训练方法(SFT)</h2><h3 id="一.-概念介绍-1">一. 概念介绍</h3><p>虽然本项目暂时只讨论SFT，但是除了它，还有几种常用的训练方法，这里介绍一下：</p><ol type="1"><li>SFT(Supervised Fine-Tuning)<ul><li>监督微调，是指在已有预训练模型的基础上，使用带有标签的数据集进行进一步训练。其目标是让模型在特定任务上表现得更好。具体步骤如下：<ol type="1"><li>数据准备：收集并标注与任务相关的数据集。</li><li>模型微调：将预训练模型与新的数据集一起进行训练。模型会根据给定的输入和标签对，调整其参数以最小化预测错误。</li><li>评估与验证：使用验证集评估模型性能，确保模型在训练集之外也能表现良好。</li></ol></li></ul></li><li>PPO(Proximal Policy Optimization)<ul><li>近端策略优化，是一种用于强化学习的算法，旨在优化策略以最大化累积奖励。PPO通过<strong>限制每次策略更新的步长</strong>来稳定训练过程，避免策略剧烈变化。其基本流程如下：<ol type="1"><li>策略评估：使用当前策略与环境进行交互，收集状态、动作和奖励数据。</li><li>计算优势函数：评估当前策略相对于其他策略的优势，通常使用时序差分方法。</li><li>策略更新：使用PPO的目标函数更新策略参数，同时限制每次更新的步长，以保持训练的稳定性。</li><li>迭代：重复上述步骤，直到策略收敛或达到预定的训练轮次。</li></ol></li></ul></li><li>DPO(Direct Policy Optimization)<ul><li>直接策略优化，是一种优化策略的强化学习方法，通过直接优化策略函数来提高决策效果。与PPO不同，DPO直接对策略参数进行调整。其具体步骤如下：<ol type="1"><li>策略初始化：初始化策略参数，通常使用预训练模型的参数。</li><li>数据收集：使用当前策略与环境进行交互，收集状态、动作和奖励数据。</li><li>梯度计算：计算策略函数相对于策略参数的梯度。</li><li>参数更新：使用梯度信息更新策略参数，直接优化策略函数。</li><li>迭代：重复上述步骤，直到策略收敛或达到预定的训练轮次。</li></ol></li></ul></li></ol><ul><li>一些个人理解：<ul><li>SFT很好理解，就是给问题给答案，训练就不断使参数结果拟合答案就行了。</li><li>DPD是强化学习的训练方法，首先核心就是先要得到“优化策略函数”，也就是评估当前参数组合的优劣程度的（在文本任务里具体怎么得到的暂且忽略）。DPO的策略就是用梯度下降最优化优化策略函数从而改变参数。</li><li>PPO也是强化学习的训练方法，但是跟DPD不一样，它没有求优化策略函数，而是求了一个“优势函数”，即新参数组合相较于旧参数组合的优劣程度，其目标就是去优化这个优势函数，从而去改变参数。</li></ul></li></ul><h3 id="二.-sft源码阅读">二. SFT源码阅读</h3><ul><li><p>这里SFT的源码是来自于llama-factory</p></li><li><p>SFT包的目录是首先一个名为SFT的文件夹，然后底下四个文件：__init__.py、workflow.py、trainer.py、metric.py。init这个py是用来表示该文件是一个包，然后在里面定义了公共接口（即SFT这个包可以调的api）。</p></li><li><p>主要看workflow.py即可知道SFT的流程，另外俩py文件是一些模块api的实现。只学习流程的话主要看workflow.py就行了（相当于是C++中的main函数）</p></li><li><p>workflow.py中的工作流程大致如下：</p><ol type="1"><li>首先先加载：tokenizer、data、model、data_collator（数据处理控制器）、metric_module（指标）。<ul><li>前三个就不说了，必备的食材</li><li>data_collator是用来确定到时候数据预处理的逻辑方式标准的（例如什么padding方式这种）</li><li>metric_module是用来确定到时候训练/评价/预测时的指标的（例如用什么指标工具）</li></ul></li><li>加载trainer，然后开始训练</li><li>如果要评估，那就评估一下。如果要预测，那就预测一下</li></ol></li><li><p>下面的代码我已经写好注释，看一遍大概就知道SFT的流程了。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TYPE_CHECKING, <span class="type">List</span>, <span class="type">Optional</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ...data <span class="keyword">import</span> SFTDataCollatorWith4DAttentionMask, get_dataset</span><br><span class="line"><span class="keyword">from</span> ...extras.constants <span class="keyword">import</span> IGNORE_INDEX</span><br><span class="line"><span class="keyword">from</span> ...extras.misc <span class="keyword">import</span> get_logits_processor</span><br><span class="line"><span class="keyword">from</span> ...extras.ploting <span class="keyword">import</span> plot_loss</span><br><span class="line"><span class="keyword">from</span> ...model <span class="keyword">import</span> load_model, load_tokenizer</span><br><span class="line"><span class="keyword">from</span> ..trainer_utils <span class="keyword">import</span> create_modelcard_and_push</span><br><span class="line"><span class="keyword">from</span> .metric <span class="keyword">import</span> ComputeAccuracy, ComputeSimilarity, eval_logit_processor</span><br><span class="line"><span class="keyword">from</span> .trainer <span class="keyword">import</span> CustomSeq2SeqTrainer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> TYPE_CHECKING:</span><br><span class="line">    <span class="keyword">from</span> transformers <span class="keyword">import</span> Seq2SeqTrainingArguments, TrainerCallback</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> ...hparams <span class="keyword">import</span> DataArguments, FinetuningArguments, GeneratingArguments, ModelArguments</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_sft</span>(<span class="params"></span></span><br><span class="line"><span class="params">    model_args: <span class="string">&quot;ModelArguments&quot;</span>,                           <span class="comment"># 模型配置参数</span></span></span><br><span class="line"><span class="params">    data_args: <span class="string">&quot;DataArguments&quot;</span>,                             <span class="comment"># 数据处理配置参数</span></span></span><br><span class="line"><span class="params">    training_args: <span class="string">&quot;Seq2SeqTrainingArguments&quot;</span>,              <span class="comment"># 训练配置参数</span></span></span><br><span class="line"><span class="params">    finetuning_args: <span class="string">&quot;FinetuningArguments&quot;</span>,                 <span class="comment"># 微调配置参数</span></span></span><br><span class="line"><span class="params">    generating_args: <span class="string">&quot;GeneratingArguments&quot;</span>,                 <span class="comment"># 生成配置参数</span></span></span><br><span class="line"><span class="params">    callbacks: <span class="type">Optional</span>[<span class="type">List</span>[<span class="string">&quot;TrainerCallback&quot;</span>]] = <span class="literal">None</span>,    <span class="comment"># 可选的回调函数列表</span></span></span><br><span class="line"><span class="params"></span>):</span><br><span class="line">    <span class="comment"># 加载tokenizer</span></span><br><span class="line">    tokenizer_module = load_tokenizer(model_args)</span><br><span class="line">    tokenizer = tokenizer_module[<span class="string">&quot;tokenizer&quot;</span>]   <span class="comment"># tokenizer_module还包括processor键，用来处理图像的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加载数据</span></span><br><span class="line">    dataset_module = get_dataset(model_args, data_args, training_args, stage=<span class="string">&quot;sft&quot;</span>, **tokenizer_module)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 加载模型</span></span><br><span class="line">    model = load_model(tokenizer, model_args, finetuning_args, training_args.do_train)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果模型是量化的且不在训练阶段，进行兼容性设置</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">getattr</span>(model, <span class="string">&quot;is_quantized&quot;</span>, <span class="literal">False</span>) <span class="keyword">and</span> <span class="keyword">not</span> training_args.do_train:</span><br><span class="line">        <span class="built_in">setattr</span>(model, <span class="string">&quot;_hf_peft_config_loaded&quot;</span>, <span class="literal">True</span>)  <span class="comment"># hack here: make model compatible with prediction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化数据预处理控制器</span></span><br><span class="line">    data_collator = SFTDataCollatorWith4DAttentionMask(</span><br><span class="line">        <span class="comment"># 用于将文本转换为tokens</span></span><br><span class="line">        tokenizer=tokenizer,</span><br><span class="line">        <span class="comment"># 指定padding的长度必须是某个数的倍数</span></span><br><span class="line">        pad_to_multiple_of=<span class="number">8</span> <span class="keyword">if</span> training_args.do_train <span class="keyword">else</span> <span class="literal">None</span>,  <span class="comment"># for shift short attention</span></span><br><span class="line">        <span class="comment"># 目标序列的pad token的填充值</span></span><br><span class="line">        label_pad_token_id=IGNORE_INDEX <span class="keyword">if</span> data_args.ignore_pad_token_for_loss <span class="keyword">else</span> tokenizer.pad_token_id,</span><br><span class="line">        <span class="comment"># 是否在注意力机制中使用块对角矩阵</span></span><br><span class="line">        block_diag_attn=model_args.block_diag_attn,</span><br><span class="line">        <span class="comment"># 指定使用哪种具体的注意力机制实现</span></span><br><span class="line">        attn_implementation=<span class="built_in">getattr</span>(model.config, <span class="string">&quot;_attn_implementation&quot;</span>, <span class="literal">None</span>),</span><br><span class="line">        <span class="comment"># 设置计算的数据类型，例如使用半精度浮点数</span></span><br><span class="line">        compute_dtype=model_args.compute_dtype,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Override the decoding parameters of Seq2SeqTrainer</span></span><br><span class="line">    training_args.generation_max_length = training_args.generation_max_length <span class="keyword">or</span> data_args.cutoff_len</span><br><span class="line">    training_args.generation_num_beams = data_args.eval_num_beams <span class="keyword">or</span> training_args.generation_num_beams</span><br><span class="line">    training_args.remove_unused_columns = <span class="literal">False</span> <span class="keyword">if</span> model_args.visual_inputs <span class="keyword">else</span> training_args.remove_unused_columns</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Metric utils（指标工具）</span></span><br><span class="line">    metric_module = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> training_args.predict_with_generate: <span class="comment"># 如果是文本生成任务，则使用ComputeSimilarity作为计算指标</span></span><br><span class="line">        metric_module[<span class="string">&quot;compute_metrics&quot;</span>] = ComputeSimilarity(tokenizer=tokenizer)</span><br><span class="line">    <span class="keyword">elif</span> finetuning_args.compute_accuracy:  <span class="comment"># 如果需要比较预测结果与实际标签，则使用ComputeAccuracy作为计算指标</span></span><br><span class="line">        metric_module[<span class="string">&quot;compute_metrics&quot;</span>] = ComputeAccuracy()</span><br><span class="line">        <span class="comment"># logits 就是一个向量，下一步通常被投给 softmax/sigmoid 向量</span></span><br><span class="line">        metric_module[<span class="string">&quot;preprocess_logits_for_metrics&quot;</span>] = eval_logit_processor</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化训练器</span></span><br><span class="line">    trainer = CustomSeq2SeqTrainer(</span><br><span class="line">        model=model,                        <span class="comment"># 训练模型</span></span><br><span class="line">        args=training_args,                 <span class="comment"># 训练使用参数</span></span><br><span class="line">        finetuning_args=finetuning_args,    <span class="comment"># 微调参数</span></span><br><span class="line">        data_collator=data_collator,        <span class="comment"># 数据预处理控制器</span></span><br><span class="line">        callbacks=callbacks,                <span class="comment"># 回调函数</span></span><br><span class="line">        **dataset_module,                   <span class="comment"># 数据集</span></span><br><span class="line">        **tokenizer_module,                 <span class="comment"># tokenizer</span></span><br><span class="line">        **metric_module,                    <span class="comment"># 评价指标工具</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Keyword arguments for `model.generate`</span></span><br><span class="line">    gen_kwargs = generating_args.to_dict()</span><br><span class="line">    gen_kwargs[<span class="string">&quot;eos_token_id&quot;</span>] = [tokenizer.eos_token_id] + tokenizer.additional_special_tokens_ids</span><br><span class="line">    gen_kwargs[<span class="string">&quot;pad_token_id&quot;</span>] = tokenizer.pad_token_id</span><br><span class="line">    gen_kwargs[<span class="string">&quot;logits_processor&quot;</span>] = get_logits_processor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开始训练</span></span><br><span class="line">    <span class="keyword">if</span> training_args.do_train:</span><br><span class="line">        <span class="comment"># 启动训练过程，可选从检查点恢复</span></span><br><span class="line">        train_result = trainer.train(resume_from_checkpoint=training_args.resume_from_checkpoint)</span><br><span class="line">        <span class="comment"># 保存训练后的模型</span></span><br><span class="line">        trainer.save_model()</span><br><span class="line">        <span class="comment"># 在日志中记录训练期间的性能指标</span></span><br><span class="line">        trainer.log_metrics(<span class="string">&quot;train&quot;</span>, train_result.metrics)</span><br><span class="line">        <span class="comment"># 将训练性能指标保存到文件</span></span><br><span class="line">        trainer.save_metrics(<span class="string">&quot;train&quot;</span>, train_result.metrics)</span><br><span class="line">        <span class="comment"># 保存训练器的状态，如优化器状态等</span></span><br><span class="line">        trainer.save_state()</span><br><span class="line">        <span class="comment"># 如果是主进程且设置了绘制损失图，则进行绘图</span></span><br><span class="line">        <span class="keyword">if</span> trainer.is_world_process_zero() <span class="keyword">and</span> finetuning_args.plot_loss:</span><br><span class="line">            plot_loss(training_args.output_dir, keys=[<span class="string">&quot;loss&quot;</span>, <span class="string">&quot;eval_loss&quot;</span>, <span class="string">&quot;eval_accuracy&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果配置为生成预测模式</span></span><br><span class="line">    <span class="keyword">if</span> training_args.predict_with_generate:</span><br><span class="line">        <span class="comment"># 调整tokenizer为左侧填充，有助于某些类型的生成任务</span></span><br><span class="line">        tokenizer.padding_side = <span class="string">&quot;left&quot;</span>  <span class="comment"># use left-padding in generation</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查是否执行了评估</span></span><br><span class="line">    <span class="keyword">if</span> training_args.do_eval:</span><br><span class="line">        <span class="comment"># 执行模型评估，使用在生成过程中定义的关键字参数</span></span><br><span class="line">        metrics = trainer.evaluate(metric_key_prefix=<span class="string">&quot;eval&quot;</span>, **gen_kwargs)</span><br><span class="line">        <span class="comment"># 如果启用了带生成的预测，需要移除eval_loss，因为在这种模式下eval_loss可能不准确</span></span><br><span class="line">        <span class="keyword">if</span> training_args.predict_with_generate:  <span class="comment"># eval_loss will be wrong if predict_with_generate is enabled</span></span><br><span class="line">            metrics.pop(<span class="string">&quot;eval_loss&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 将评估得到的指标记录到日志中</span></span><br><span class="line">        trainer.log_metrics(<span class="string">&quot;eval&quot;</span>, metrics)</span><br><span class="line">        <span class="comment"># 将评估指标保存到文件中，方便后续查看和分析</span></span><br><span class="line">        trainer.save_metrics(<span class="string">&quot;eval&quot;</span>, metrics)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检查是否执行了预测</span></span><br><span class="line">    <span class="keyword">if</span> training_args.do_predict:</span><br><span class="line">        <span class="comment"># 使用预测数据集执行预测，并应用生成过程的配置参数</span></span><br><span class="line">        predict_results = trainer.predict(dataset_module[<span class="string">&quot;eval_dataset&quot;</span>], metric_key_prefix=<span class="string">&quot;predict&quot;</span>, **gen_kwargs)</span><br><span class="line">        <span class="comment"># 如果启用了生成模式预测，需要移除predict_loss，因为在这种模式下predict_loss可能不准确</span></span><br><span class="line">        <span class="keyword">if</span> training_args.predict_with_generate:  <span class="comment"># predict_loss will be wrong if predict_with_generate is enabled</span></span><br><span class="line">            predict_results.metrics.pop(<span class="string">&quot;predict_loss&quot;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="comment"># 将预测得到的指标记录到日志中</span></span><br><span class="line">        trainer.log_metrics(<span class="string">&quot;predict&quot;</span>, predict_results.metrics)</span><br><span class="line">        <span class="comment"># 将预测指标保存到文件中，方便后续查看和分析</span></span><br><span class="line">        trainer.save_metrics(<span class="string">&quot;predict&quot;</span>, predict_results.metrics)</span><br><span class="line">        <span class="comment"># 保存预测结果，通常包括输出数据和可能的额外信息，如评分、分类结果等</span></span><br><span class="line">        trainer.save_predictions(dataset_module[<span class="string">&quot;eval_dataset&quot;</span>], predict_results)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create model card</span></span><br><span class="line">    create_modelcard_and_push(trainer, model_args, data_args, training_args, finetuning_args)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分布式训练">分布式训练</h2><h3 id="一.-概念介绍-2">一. 概念介绍</h3><p>最近一星期玩了玩模型推理和训练，深深感受到大模型这玩意，真的吃资源，没卡玩不动一点（<del>希望我读研的时候有卡用</del>）。即使有卡，直接用pipeline或者AutoModel/AutoTokenizer跑我也觉得好慢，所以非常有必要学习一下分布式训练方法。</p><ul><li>方法一：数据并行<ul><li>即每个GPU上都拷一份模型，然后跑不同的数据。</li><li>缺点就是每张卡必须完整执行完训练过程，对于那些参数量大的，直接爆现存</li><li>如果跑一次需要T秒，那么使用这种方法T秒，可以跑的次数就是 T *卡数量</li></ul></li><li>方法二：流水并行<ul><li>即把模型的layers拆开，每个GPU分配不同的layers。</li><li>优点就是单卡GPU爆显存的时候，用这种方法跑起来。</li><li>令最长layers延迟为t秒，则流水线充分装载后t秒可以跑一次。Ts跑的次数就是T/ t</li></ul></li><li>方法三：张量并行<ul><li>即把每层layers里的tensor拆开。具体来说，假设有32层layers，均分为8份，每份4层layers。用流水并行的思想就是8张卡，第一张卡执行1~ 4层，第二张卡执行5 ~8层依次类推。张量并行是进一步细分，目光聚焦到第一张卡，它不是负责1 -4层嘛，其实对于每一层，其运算的张量是很大的，所以可以把每层的tensor划分为4个子tensor，然后用4张卡分别负责：第一张卡负责1-4层layers的第一个子tensor，第二章卡负责1-4层layers的第二个子tensor，以此类推。那么，原本用流水并行需要8张卡，按照这种方式去做张量并行的话，就需要32张卡。</li></ul></li><li>方法四：混合并行<ul><li>就是上面几种方法一起用。</li><li>首先先确定有几路，把模型数据分配到每一路上（数据并行）</li><li>然后对于每一路的卡，将切片layers分配到对应卡组上（流水并行）</li><li>然后对于一个卡组，将切片tensor分配到对应卡上（张量并行）</li><li><del>两个字，烧钱</del></li></ul></li></ul><h3 id="二.-训练代码">二. 训练代码</h3><h3 id="三.-合并推理">三. 合并推理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> AutoModelForCausalLM, AutoTokenizer</span><br><span class="line"><span class="keyword">from</span> peft <span class="keyword">import</span> PeftModel</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义路径</span></span><br><span class="line">path_to_base_model_directory = <span class="string">&#x27;../Meta-Llama-3-8B-Instruct&#x27;</span></span><br><span class="line">path_to_your_directory = <span class="string">&#x27;results/20240731-141630/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载分词器</span></span><br><span class="line">tokenizer = AutoTokenizer.from_pretrained(path_to_your_directory)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载基础模型</span></span><br><span class="line">base_model = AutoModelForCausalLM.from_pretrained(path_to_base_model_directory)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载LoRA适配器</span></span><br><span class="line">model = PeftModel.from_pretrained(base_model, path_to_your_directory)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备输入</span></span><br><span class="line">input_text = <span class="string">&quot;How to steal a neighbor&#x27;s dog?&quot;</span>  <span class="comment"># 替换为你的输入文本</span></span><br><span class="line">inputs = tokenizer(input_text, return_tensors=<span class="string">&#x27;pt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行推理</span></span><br><span class="line">base_model.<span class="built_in">eval</span>()</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    outputs = model.generate(</span><br><span class="line">        inputs[<span class="string">&#x27;input_ids&#x27;</span>],</span><br><span class="line">        max_length=<span class="number">512</span>,</span><br><span class="line">        temperature=<span class="number">0.95</span>,</span><br><span class="line">        top_p=<span class="number">0.7</span>,</span><br><span class="line">        num_return_sequences=<span class="number">1</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理输出</span></span><br><span class="line">generated_text = tokenizer.decode(outputs[<span class="number">0</span>], skip_special_tokens=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;--------------------------&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Generated text: <span class="subst">&#123;generated_text&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="预训练">预训练</h2><h3 id="一.-概念介绍-3">一. 概念介绍</h3><p>预训练就是指从数据中获得与具体任务无关的预训练过程。就是让模型获得某项能力的训练过程。</p><p>预训练分为几种类别：</p><ol type="1"><li>掩码语言模型，自编码模型</li><li>因果语言模型，自回归模型</li><li>序列到序列模型</li></ol><p>本章节只讨论第二种，因为目前只需要用到第二种。</p><p><img src="4.png" /></p><p>原理就是你丢一段话进去。那么下标1的token就与下标2的token计算loss，下标2的token就与下标3计算loss，以此类推。通过丢一大堆话进去，每个字下一个字的概率就可以预测出来了。非常简单。llama3的ModelForCausalLM用attention_mask只是为了避免填充位置对梯度的影响，也就是填充位置是不需要计算loss的。attention_mask为1的地方label就是-100</p><h2 id="llama3源码阅读">llama3源码阅读</h2><p>日期：2024/7/26，代码来源：huggingface的transformers库中的llama源码</p><p>我觉得既然看代码了，若出现逻辑与图冲突，但以代码为准。图只是给你一个大概的先验知识。</p><h3 id="一.-整体把握">一. 整体把握</h3><p>对于打开modeling_llama.py的大纲，先只关注类，把握整个代码的框架：</p><p>最核心的就是<strong>LlamaModel</strong>，它是基本模型，然后在它的基础上加点<strong>RMSNorm</strong>或者别的小魔改就可以形成下游任务模型：<strong>LlamaForCausalLM、LlamaForSequenceClassification、LlamaForQuestionAnswering、LlamaForTokenClassification</strong>。</p><ul><li>LlamaForCausalLM：生成文本。它基于前文内容预测下一个词</li><li>LlamaForSequenceClassification：文本序列进行分类。常用于情感分析、主题分类等任务</li><li>LlamaForQuestionAnswering：从文本中回答问题，通常是根据给定的上下文段落回答特定的问题</li><li>LlamaForTokenClassification：对输入文本中的每个词进行分类。常用于命名实体识别（NER）、部分语法标注（POS）等任务</li></ul><p>ok，所以核心类就是<strong>LlamaModel</strong>，它又由以下这几个部分构成：</p><ol type="1"><li>Embedding层（不是一个类）</li><li><strong>LlamaDecoderLayer</strong> 若干</li><li><strong>LlamaRMSNorm</strong></li></ol><p>可以发现，这其实就是一个最普通的模型，先embedding，然后经过隐藏层，最后RMSNorm一下得到输出。所以关键就是<strong>LlamaDecoderLayer</strong>，可以把它简单的理解为transformerblock，那么它又是由以下东西构成的：</p><ol type="1"><li><strong>LlamaAttention</strong>（里面会用到<strong>LlamaRotaryEmbedding</strong>旋转编码）</li><li><strong>LlamaMLP</strong></li><li><strong>LlamaRMSNorm</strong></li><li><strong>LlamaRMSNorm</strong></li></ol><p>对于一个transformerblock，Attention层和RMSNorm层很容易理解。唯独不太清楚的就是MLP（多层感知机）。我猜估计就是对Attention后的结果做点线性/非线性变换，来点正则啥的东西处理一下的一层。</p><p>ok结束，大概的框架理清楚了。用图来展示的话就是：</p><p><img src="3.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有个合作idea，需要魔改llama3代码，所以来学习下transformers和llama3&lt;/p&gt;
&lt;p&gt;upd：已经变为我的知识库大杂烩了，将就着看吧，纯粹个人笔记了。&lt;/p&gt;</summary>
    
    
    
    <category term="1. 科研" scheme="http://error666.top/categories/1-%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机网络自学笔记</title>
    <link href="http://error666.top/2024/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://error666.top/2024/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2024-06-22T12:20:35.000Z</published>
    <updated>2024-09-03T18:12:47.178Z</updated>
    
    <content type="html"><![CDATA[<p>参考视频：<ahref="https://www.bilibili.com/video/BV1c4411d7jb?p=4&amp;spm_id_from=pageDriver&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0">计算机网络微课堂-湖科大教书匠</a></p><span id="more"></span><h3 id="一.-导论">一. 导论</h3><ol type="1"><li><p>网络、互联网、因特网</p><p>网络由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。</p><p>结点可以是手机/主机/打印机/交换机，链路可以是有线/无线。</p><p>多个网络通过<strong>路由器</strong>连接起来，形成<strong>互联网(internet)</strong>。<strong>因特网(Internet)</strong>是最大的互联网。</p><p>互联网的通信协议可以是任意的，因特网的通信协议是TCP/IP协议。</p></li><li><p>因特网的组成</p><p>由边缘部分和核心部分组成。边缘部分就是所有连接在因特网的主机，核心部分就是大量网络和连接这些网路的路由器组成。为连入核心部分的边缘部分提供数据交换服务。</p></li><li><p>三种交换方式</p><ol type="1"><li><p>电路交换</p><ul><li><p>定义：就是很多设备连接到交换机上，交换机感性理解就是有许多入口和出口，它可以指定某个入口的信号发送到某个出口，这样，多个设备就可以同时互不干扰的发送信号了。交换机又可以与交换机相连，扩大网络范围。</p></li><li><p>电路交换的步骤：</p><ol type="1"><li>建立连接（给通信俩主机分配一条物理通信线路）</li><li>传输信号（这条物理通信线路一直被占用）</li><li>释放连接（归还通信资源）</li></ol></li><li><p>电路交换的优缺点</p><ul><li>优点：延迟小，通信线路都双方专属了，能不小吗。而且数据是有序的。</li><li>缺点：建立连接时间长；无法做到很多台主机之间同时相互通信（因为俩俩主机通信时就会占用一条通信线路，但是没有那么多通信线路）</li></ul></li></ul></li><li><p>报文交换</p><ol type="1"><li>定义：就是不建立连接了，也就是不锁死一条通信线路了。而是直接把<strong>报文(发送的数据)</strong>发送到交换机上，然后交换机存储转发给下一个交换机，一直到接收方收到报文为止。</li><li>报文交换的优缺点<ol type="1"><li>优点：无需建立连接；动态分配线路</li><li>缺点：引入了转发时延；需要较大的缓存空间(报文可能很大)</li></ol></li></ol></li><li><p>分组交换</p><ol type="1"><li><p>定义：就是所谓的边缘部分和核心部分，发送方将报文发送到其所连网络中，通过路由器不断的转发，最终转发到接收方中。</p></li><li><p>分组交换步骤</p><ol type="1"><li>构造分组：先讲报文划分成若干个等长的数据段，在每个数据段前加上元数据，这些元数据叫首部。</li><li>存储转发：路由器在拿到分组后，根据首部进行查表转发，找到合适的转发接口，然后转发给下一个路由器</li><li>还原报文：接收方在收到分组后，去掉首部，将数据段组合还原出报文</li></ol><ul><li>Note：对于同一报文的不同分组，分组的路由路径不一定相同，而且分组到达接收者的顺序不一定与发送时的顺序相同。</li></ul></li><li><p>分组交换的优缺点</p><ol type="1"><li>优点：无需建立连接；简化了存储管理（因为对报文进行了切片，所以路由器的缓存区只需固定即可，不论报文多大都可以切片为分组后转发出去）；减小重发数据量（假设传输过程中出错了，报文交换就要重新发送整个报文，但分组交换只需重发出错的那个分组即可）</li><li>缺点：引入了转发时延；更多的元数据信息（切完片后每个分组都有首部）；还原报文时复杂</li></ol></li></ol></li></ol></li><li><p>计算机网络的性能指标</p><ol type="1"><li><p>速率</p><ol type="1"><li>8bit = 1B(byte)，kb = <spanclass="math inline">\(2^{10}\)</span>B</li><li>bit/s (b/s, bps)（速率的单位都是bit，其余的速率单位也要换算为bit来求解）</li><li>kb/s = <span class="math inline">\(10^3\)</span> b/s</li><li>mb/s = <span class="math inline">\(10^6\)</span> b/s</li><li>Gb/s = <span class="math inline">\(10^9\)</span> b/s</li><li>Tb/s = <span class="math inline">\(10^{12}\)</span> b/s</li></ol><ul><li>例题：有一个待发送的数据块，大小为100 MB，网卡的发送速率为100Mbps，则网卡发送完该数据块需要多长时间?</li><li>100 mbps =<span class="math inline">\(100 * 10^6\)</span> b/s</li><li>100MB = <span class="math inline">\(100 * 2^{20} \cdot 2^3\)</span>= <span class="math inline">\(100 * 2^{23}\)</span> b</li><li>所以t = <span class="math inline">\(\frac{2^{23}}{10^6} =8.388608\)</span> s</li></ul></li><li><p>带宽</p><ol type="1"><li>带宽在模电里的定义：即某段频率区间的宽度</li><li>带宽在计网中的定义：即最大传输速率，基本单位为b/s，与速率的单位一样</li></ol></li><li><p>吞吐量</p><ol type="1"><li>定义：表示单位时间内通过某个网络（或信道、接口）的数据量</li><li>吞吐量的上限就是带宽。</li></ol></li><li><p>时延</p><ol type="1"><li>定义：网络时延 = 发送时延 + 传播时延 + 处理时延</li><li>其中，发送时延是计算机将信息发送到网络中的时延，传播时延是网络的信息传播到路由器的时延，处理时延是路由器存储转发的时延</li></ol><ul><li>例题：<img src="1.png" /></li><li>发送时延 = <span class="math inline">\(\frac{100MB}{1Mb / s} =\frac{100 * 2^{30} * 8}{10^6 b/s} = 838.8608s\)</span></li><li>传播时延 = <span class="math inline">\(\frac{1000 * 1000m}{2 * 10^8m/s} = 0.005s\)</span></li><li><span class="math inline">\(2.0 \times10^8\)</span>是光纤传播速度</li><li><span class="math inline">\(2.3 \times10^8\)</span>是铜线传播速度</li></ul></li><li><p>时延带宽积</p><ol type="1"><li>定义：时延带宽积 = 传播时延 * 带宽</li><li>把带宽想象成横截面积，传播时延想象为长度，则乘积就是管道的长度。也就是若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个bit。</li></ol></li><li><p>往返时间</p><ol type="1"><li>定义：双向交互一次所需的时间</li></ol></li><li><p>利用率</p><ol type="1"><li>信道利用率：表示信道有百分之几的时间是被利用的（有数据通过）</li><li>网络利用率：全网络的信道利用率的加权平均</li></ol><ul><li>Note：信道利用率并非越高越好，因为利用率越高，传播时延就越高。</li><li>如果令<spanclass="math inline">\(D_0\)</span>为网络空闲时的时延，<spanclass="math inline">\(D\)</span>为当前的时延，利用率为<spanclass="math inline">\(U\)</span>。则有公式：<spanclass="math inline">\(D = \frac{D_0}{1 - U}\)</span></li></ul></li><li><p>丢包率</p><ol type="1"><li>定义：在一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率</li><li>分组丢失的主要两种情况<ol type="1"><li>分组在传输过程中出现误码，被结点丢弃</li><li>分组在到达分组交换机被丢弃，因为其缓存容量满了</li></ol></li></ol></li></ol></li></ol><h3 id="二.-计算机网络体系结构总览">二. 计算机网络体系结构总览</h3><ol type="1"><li><p>计网体系结构的分类</p><ol type="1"><li>OSI体系结构（法律上的国际标准，但没商用）</li><li>TCP/IP体系结构（事实上的国际标准，已商用）</li><li>原理体系结构（用来教学用的体系结构，是在TCP/IP体系结构上的展开）<ul><li>物理层、数据链路层、网络层、运输层、应用层</li></ul></li></ol></li><li><p>分层的必要性</p><ol type="1"><li>物理层：你需要考虑用什么线(光纤/双绞线)去传输信号，用怎样的物理接口、使用什么信号表示0和1，这些都是物理层要考虑的问题。当把物理层解决的时候，我们就可以实现把信号从本机上发射出去了。</li><li>数据链路层：考虑下面这个场景，一条总线，然后连出很多分线到各个主机上。那么，假设其中一台主机向总线发送了数据，那么他的目标主机咋知道流过的bit流是否是发送给自己的？以及，如果协调各个主机发送的信号争用总线的问题？这些都是数据链路层要解决的问题（提前剧透一下，数据链路层引入了MAC的概念，用于区别网络中的主机）。当解决了数据链路层，我们用可以实现一个网络中的信号传输了。</li><li>网络层：此时视角来到了很很多路由器、网络、主机的大网络。此时，我们面临着如何标识各网络中各主机的问题（剧透：引入IP地址），以及分组如何选择从源点到目的地的路径。这些问题都划分到网络层去解决。解决了网络层，那么数据就可以在大网络里相互传递了。</li><li>运输层：在解决网络层的基础上，假设出现了丢包，或者主机接收到分组后，它咋知道是给QQ？还是给微信？所以，这些都是运输层要考虑的问题。当解决了运输层的时候，就已经可以实现进程之间网络的通信了。</li><li>应用层：这一层就是各种应用的协议，比如万维网的http协议，电子邮件的smtp协议，文件传输的ftp协议，通过各种协议+进程间的交互来完成特定的网络应用。</li></ol></li><li><p>分层思想举例</p><p><img src="2.png" /></p><ul><li>首先，你打开浏览器进程，然后发送一个访问请求，应用层按照http协议构建一个http请求报文，然后丢给运输层。</li><li>运输层在http报文的首部添加一个tcp首部，为了区分应用进程和可靠传输，此时成为tcp数据报。</li><li>网络层在tcp数据报添加一个ip首部，为了使ip数据报在互联网上运行，此时成为ip数据报。</li><li>数据链路层在ip数据报添加一个首部和尾部ETH，为了让其在一个网络/链路上传输，此时成为帧。</li><li>物理层在帧前加前导码，然后传输</li></ul></li><li><p>计网体系结构专用术语</p><ul><li>专业术语来源于OSI的七层协议体系结构，但也适用于TCP/IP的四层体系结构和五层协议原理体系结构。</li></ul><p><img src="4.png" /></p><ol type="1"><li><p>实体</p><ol type="1"><li>实体定义：任何可发送或接收信息的硬件或软件进程</li><li>对等实体定义：收发双方相同层次中的实体</li></ol></li><li><p>协议</p><ol type="1"><li><p>定义：控制两个对等实体进行<strong>逻辑通信</strong>的规则的集合。</p><ul><li>比如http协议是控制在应用层的俩对等实体进行通信的规则。tcp/udp协议就是运输层的协议，ip就是网络层的协议</li></ul></li><li><p>协议的三要素</p><ol type="1"><li><p>语法：定义所交换信息的格式，例如IP协议所添加的ip数据报格式如下：</p><p><img src="3.png" /></p></li><li><p>语义：定义收发双方所要完成的操作</p><ul><li>就是收到报文后双方要做的动作。以http协议为例，接收方收到http请求报文后，先查找，然后返回一个响应报文。</li></ul></li><li><p>同步：定义收发双方的时序关系</p></li></ol></li></ol></li><li><p>服务</p><ol type="1"><li>定义：在协议的控制下，两个对等实体间的逻辑通信使得本层能向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</li></ol><ul><li>Note：协议是“水平”的，服务是“垂直”的</li></ul></li><li><p>服务访问点</p><ul><li>定义：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区别不同的服务类型。</li><li>数据链路层的服务访问点为帧的“类型”字段</li><li>网络层的服务访问点为IP数据报首部中的“协议字段”</li><li>运输层的服务访问点为“端口号”</li></ul></li><li><p>服务原语</p><ol type="1"><li>定义：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。（没搞懂，以后来填坑）</li></ol></li><li><p>协议数据单元PDU</p><ol type="1"><li>定义：对等层次之间的数据包称为该层的协议数据单元</li></ol><ul><li>物理层的PDU：比特流</li><li>数据链路层的PDU：帧</li><li>网络层的PDU：IP数据报</li><li>运输层的PDU：TCP报文段</li><li>应用层的PDU：报文</li></ul></li><li><p>服务数据单元SDU</p><ol type="1"><li>定义：同一系统内，层与层之间交换的数据包称为服务数据单元</li></ol><ul><li>Note：多个SDU可以合成为一个PDU，一个SDU也可以划分为几个PDU</li></ul></li></ol></li></ol><h3 id="习题课">习题课</h3><p>待填坑... ...</p><h3 id="三.">三.</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考视频：&lt;a
href=&quot;https://www.bilibili.com/video/BV1c4411d7jb?p=4&amp;amp;spm_id_from=pageDriver&amp;amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0&quot;&gt;计算机网络微课堂-湖科大教书匠&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="计算机专业课" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>2024上半年算法竞赛游记</title>
    <link href="http://error666.top/2024/06/22/2024%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%B8%B8%E8%AE%B0/"/>
    <id>http://error666.top/2024/06/22/2024%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%B8%B8%E8%AE%B0/</id>
    <published>2024-06-21T16:49:09.000Z</published>
    <updated>2024-06-22T18:45:43.644Z</updated>
    
    <content type="html"><![CDATA[<p>内容包括：ccpc全国邀请赛（山东）、ccpc重庆市塞、ccpc四川省赛</p><span id="more"></span><h3 id="ccpc全国邀请赛山东">ccpc全国邀请赛（山东）</h3><p>赛后没有第一时间写游记，题目忘了。</p><p>酒店不错，比赛场地很大队伍很多，中午的塔斯汀很好吃，题目也能给我们这些菜鸡做对个五六道。</p><p>我记得有俩签到，一个二分，一个模拟。</p><p>然后一个贪心，做过类似的题：<ahref="https://www.acwing.com/problem/content/907/">区间选点</a></p><p>一个普通的最小生成树变式，一个涉及到后缀和的思维题，一个找规律填空题。</p><p>我们应该是做了6题，最后是铜。</p><p>尽力了，从高二以来已经3年没打算法了，这个结果对我来说挺满意。</p><h3 id="ccpc重庆市赛">ccpc重庆市赛</h3><p>赛后没有第一时间写游记，题目忘了。</p><p>志愿者培训没做好，在比赛的时候发出了“讨论请安静点！”的逆天言论，以及比赛开始后才一个个发纸质版题目，差评。以及测评网站用的一个免费的网站，比赛中出现了账号无法登录的问题，差评。</p><p>仨签到。</p><p>然后一个前缀和，做过类似的题，牛客训练赛里的，找不到了。</p><p>然后一个贪心题+简单dfs题。</p><p>还有一题队友写的，不知道是啥算法的题，好像是一道思维题。</p><p>最后金尾。</p><p>遗憾的是有一题hash+二分+dfs的题做了很久没调出来，事后证明思路是正确的，debug能力差了点没弄出来，可惜。</p><h3 id="ccpc四川省赛">ccpc四川省赛</h3><p>赛后没有第一时间写游记，题目忘了。</p><p>场地偏小但凑合，中午的食物质量正常，比赛发的衣服不错，赛后奖品还行。</p><p>但是是上半年发挥最差的一场。</p><p>上去先把仨签到迅速切了，此时的我们是金的排名。</p><p>后面4个小时一题没开出来，难蚌。</p><p>我和另一个队友卡在一个非常非常简单的计算几何，另一个队友卡在一道简单的贪心。</p><p>如果状态好的话，就是5题，银首。</p><p>但世界上没那么多如果，菜就是菜了，最后铜。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;内容包括：ccpc全国邀请赛（山东）、ccpc重庆市塞、ccpc四川省赛&lt;/p&gt;</summary>
    
    
    
    <category term="3. 竞赛" scheme="http://error666.top/categories/3-%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>Matlab基础</title>
    <link href="http://error666.top/2024/04/25/Matlab%E5%9F%BA%E7%A1%80/"/>
    <id>http://error666.top/2024/04/25/Matlab%E5%9F%BA%E7%A1%80/</id>
    <published>2024-04-24T16:53:52.000Z</published>
    <updated>2024-04-26T15:45:27.353Z</updated>
    
    <content type="html"><![CDATA[<p>学习Matlab，一方面是数模需要，另一方面是Matlab +FigureBest绘制出来的图片非常精美。科研绘图时会用到，所以就学习一下。</p><span id="more"></span><h3 id="界面">界面</h3><p>clear：清空工作区</p><p>clc：清除命令行窗口</p><p>；：语句后加分号结果不显示到命令行中，不加会显示到命令行中</p><p>F5：运行</p><p>ctrl + enter：分块运行</p><p>%%：分块分割注释</p><p>ctrl + r：添加多行注释</p><p>ctrl + t：取消多行注释</p><p>ctrl + 0：跳转到命令行窗口</p><p>ctrl + shift + 0：跳转到编辑窗口</p><p>ctrl + 2：跳转到工作目录窗口</p><p>ctrl + 3：跳转到工作区</p><p><ahref="https://ww2.mathworks.cn/help/index.html">Matlab官方文档</a>：查询各种所需功能&amp; 函数</p><p>填写函数参数时按tab：打开参数提示功能，ctrl + down展开提示</p><h3 id="运算">运算</h3><ul><li><p>特殊变量：ans、pi、inf、-inf</p></li><li><p>数据类型：数字、字符串、矩阵</p></li><li><p>运算符：</p><ol type="1"><li>基本运算符：+、-、*、/、^（乘方）</li><li>常用预算符：abs()、mod(x,y)、sqrt()、exp()、log()、log2()、log10()、round()</li></ol></li></ul><h3 id="矩阵">矩阵</h3><p>Note：下标从1开始</p><ol type="1"><li>矩阵的创建<ol type="1"><li>直接输入：用[]作为标识符，同一行用,分隔，不同行用;分隔</li><li>用预设函数创建：<ol type="1"><li>zeros(x, y)：生成x行y列全0矩阵</li><li>ones(x, y)：生成x行y列全1矩阵</li><li>eye(x)：生成x行x列的单位阵</li><li>rand(x, y)：生成x行y列的矩阵，每个元素在(0, 1)内</li><li>randi([imin, imax], x, y)：生成x行y列的矩阵，每个元素在[imin,imax]内</li><li>randn(x, y)：生成x行y列的矩阵，每个元素服从标准正态分布</li></ol></li><li>导入本地数据创建：<ul><li>支持格式：txt、dat、csv、xls、... ...</li><li>导入方法：在菜单栏选择导入数据即可</li></ul></li></ol></li><li>矩阵的修改<ul><li>A(2, 3) = 0：单点修改</li><li>A(2, :) = 0：第2行全部变为0</li><li>A([1, 2], [1, 2, 3]) = 0：第1、2行的第1、2、3列改为0</li></ul></li><li>矩阵的运算<ol type="1"><li>M1 + M2：对应元素相加</li><li>M + c：矩阵M每个元素加上c</li><li>M1 * M2：矩阵乘法</li><li>M * c：矩阵M每个元素乘上c</li><li>M1 .* M2：矩阵M1、M2对应元素相乘</li><li>M1 ./ M2：矩阵M1、M2对应元素相除</li><li>M ^ c：矩阵M的幂运算</li><li>M'：矩阵M的转置</li><li>inv(M)：矩阵M求逆</li><li>diag(diag(M))：M的对角矩阵</li></ol></li></ol><h3 id="程序结构">程序结构</h3><ol type="1"><li><p>global全局变量</p><ul><li>定义时global声明一次，函数内使用前声明一次</li></ul></li><li><p>if-elseif-else-end</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (... &amp;&amp; ...)</span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">elseif</span> (... &amp;&amp; ...)</span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>for-end</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = x:y <span class="comment">%循环变量i从x到y</span></span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>自定义函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">res</span> = <span class="title">fun_name</span><span class="params">(var1, var2, ...)</span></span></span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_name</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="图像">图像</h3><ol type="1"><li>axis<ol type="1"><li>axis([xmin, xmax, ymin, ymax])：生成指定坐标范围</li><li>axis equal：x/y轴使用相同的比例</li></ol></li><li>subplot<ol type="1"><li>subplot(n, m,id)：将figure分割为n*m个区域，当前使用第id个区域进行绘图</li></ol></li><li>plot<ol type="1"><li>hold on：使得多个plot画出的线在一个图上</li><li>plot(X, Y)：画出点(x1, y1), (x2, y2), ...并连线</li><li>plot(Y)：画出(1, y1), (2, y2), ...并连线</li><li>plot(x, y, '.')：画坐标点(x, y)</li></ol></li><li>title<ol type="1"><li>title('xxx')：起名</li></ol></li><li>xlabel/ylabel<ol type="1"><li>xlabel('xxx')</li></ol></li><li>legend<ol type="1"><li>legend('name1', 'name2', ...)：图例</li></ol></li><li>改样式<ul><li>交给FigureBest</li></ul></li></ol><hr /><h3 id="实战">实战</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear all; <span class="comment">% 相比于clear, clear all可以清除global变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义变量</span></span><br><span class="line"><span class="keyword">global</span> Iter_Num n x r r1 r2 alpha <span class="built_in">beta</span> v s y a ans_x ans_y s_x s_y xx vv ss yy;</span><br><span class="line">Iter_Num = <span class="number">1000</span>;</span><br><span class="line">n = <span class="number">5</span>;</span><br><span class="line">x = <span class="built_in">zeros</span>(<span class="number">1</span>, n);</span><br><span class="line">r = <span class="built_in">zeros</span>(<span class="number">1</span>, n);</span><br><span class="line">r1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>];     <span class="comment">% 5个预设点的x坐标</span></span><br><span class="line">r2 = [<span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>];     <span class="comment">% 5个预设点的y坐标</span></span><br><span class="line">alpha = <span class="number">0.01</span>;</span><br><span class="line"><span class="built_in">beta</span> = <span class="number">0.01</span>;</span><br><span class="line">v = <span class="built_in">diag</span>(<span class="built_in">ones</span>(<span class="number">1</span>, n));</span><br><span class="line">s = phi(x);</span><br><span class="line">y = <span class="built_in">zeros</span>(<span class="number">1</span>, n);</span><br><span class="line">a = [</span><br><span class="line">    <span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">     <span class="number">1</span>/<span class="number">3</span>, <span class="number">1</span>/<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>/<span class="number">3</span>;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">    ];</span><br><span class="line">ans_x = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">% ans_x[i][j]表示第i个点第j次迭代的x坐标</span></span><br><span class="line">ans_y = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">% ans_y[i][j]表示第i个点第j次迭代的y坐标</span></span><br><span class="line">s_x = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">1</span>);   <span class="comment">% s_x[i][j]表示第i个点第j次迭代x坐标的sigma</span></span><br><span class="line">s_y = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">1</span>);   <span class="comment">% s_y[i][j]表示第i个点第j次迭代y坐标的sigma</span></span><br><span class="line">xx = x;</span><br><span class="line">vv = v;</span><br><span class="line">ss = s;</span><br><span class="line">yy = y;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 开始迭代</span></span><br><span class="line">solve();</span><br><span class="line">fprintf(<span class="string">&#x27;经过%d轮迭代, 最终F(x)收敛到: %f\n&#x27;</span>, Iter_Num, cal(Iter_Num));</span><br><span class="line">draw_1(); <span class="comment">% F_k的比率图</span></span><br><span class="line">draw_2(); <span class="comment">% 画演示图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%下面是画图子函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw_2</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">global</span> Iter_Num;</span><br><span class="line">    <span class="built_in">figure</span> (<span class="number">2</span>);</span><br><span class="line">    subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    draw_2_sub(<span class="number">1</span>);</span><br><span class="line">    subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    draw_2_sub(Iter_Num / <span class="number">2</span>);</span><br><span class="line">    subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    draw_2_sub(Iter_Num);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw_2_sub</span><span class="params">(iter_num)</span></span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="keyword">global</span> n r1 r2 ans_x ans_y;</span><br><span class="line">    axis([<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">        <span class="built_in">plot</span>(ans_x(<span class="built_in">i</span>, iter_num), ans_y(<span class="built_in">i</span>, iter_num), <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">plot</span>([r1(<span class="number">1</span>), r1(<span class="number">2</span>), r1(<span class="number">3</span>), r1(<span class="number">5</span>), r1(<span class="number">4</span>), r1(<span class="number">1</span>)], [r2(<span class="number">1</span>), r2(<span class="number">2</span>), r2(<span class="number">3</span>), r2(<span class="number">5</span>), r2(<span class="number">4</span>), r2(<span class="number">1</span>)], <span class="string">&#x27;Marker&#x27;</span>,<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">    sum_x = <span class="number">0</span>;</span><br><span class="line">    sum_y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">        sum_x = sum_x + ans_x(<span class="built_in">i</span>, iter_num);</span><br><span class="line">        sum_y = sum_y + ans_y(<span class="built_in">i</span>, iter_num);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">plot</span>(sum_x / n, sum_y / n, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    xlabel(<span class="string">&#x27;$x_1$&#x27;</span>, <span class="string">&#x27;Interpreter&#x27;</span>, <span class="string">&#x27;latex&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;$x_2$&#x27;</span>, <span class="string">&#x27;Interpreter&#x27;</span>, <span class="string">&#x27;latex&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw_1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">figure</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">global</span> Iter_Num;</span><br><span class="line">    F_best = <span class="number">18.874999999999645</span>;</span><br><span class="line">    error = [];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : (Iter_Num - <span class="number">1</span>)</span><br><span class="line">        error = [error, <span class="built_in">abs</span>(cal(<span class="built_in">i</span> + <span class="number">1</span>) - F_best) / <span class="built_in">abs</span>(cal(<span class="built_in">i</span>) - F_best)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">plot</span>(error);</span><br><span class="line">    xlabel(<span class="string">&#x27;Iteration k&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;$\frac&#123;f_&#123;k+1&#125; - f^*&#125;&#123;f_k - f^*&#125;$&#x27;</span>, <span class="string">&#x27;Interpreter&#x27;</span>, <span class="string">&#x27;latex&#x27;</span>, <span class="string">&#x27;FontSize&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面是计算子函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">res</span> = <span class="title">cal</span><span class="params">(iter_num)</span></span></span><br><span class="line">    <span class="keyword">global</span> n ans_x r1 ans_y r2 s_x s_y;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">        sum = sum + <span class="number">0.5</span> * ((ans_x(<span class="built_in">i</span>, iter_num) - r1(<span class="built_in">i</span>)) ^ <span class="number">2</span> + (ans_y(<span class="built_in">i</span>, iter_num) - r2(<span class="built_in">i</span>)) ^ <span class="number">2</span>)...</span><br><span class="line">            + <span class="number">0.5</span> * ((ans_x(<span class="built_in">i</span>, iter_num) - <span class="number">5</span>) ^ <span class="number">2</span> + (ans_y(<span class="built_in">i</span>, iter_num) - <span class="number">5</span>) ^ <span class="number">2</span>)...</span><br><span class="line">            + ((s_x(<span class="built_in">i</span>, iter_num) - <span class="number">5</span>) ^ <span class="number">2</span> + (s_y(<span class="built_in">i</span>, iter_num) - <span class="number">5</span>) ^ <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    res = sum;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">global</span> Iter_Num n xx ss ans_x ans_y s_x s_y;</span><br><span class="line">    init(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> T = <span class="number">1</span> : Iter_Num</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">            upd_x(<span class="built_in">i</span>);</span><br><span class="line">            ans_x(<span class="built_in">i</span>, T) = xx(<span class="built_in">i</span>);</span><br><span class="line">            upd_v(<span class="built_in">i</span>);</span><br><span class="line">            upd_s(<span class="built_in">i</span>);</span><br><span class="line">            s_x(<span class="built_in">i</span>, T) = ss(<span class="built_in">i</span>);</span><br><span class="line">            upd_y(<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        backup();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    init(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> T = <span class="number">1</span> : Iter_Num</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">            upd_x(<span class="built_in">i</span>);</span><br><span class="line">            ans_y(<span class="built_in">i</span>, T) = xx(<span class="built_in">i</span>);</span><br><span class="line">            upd_v(<span class="built_in">i</span>);</span><br><span class="line">            upd_s(<span class="built_in">i</span>);</span><br><span class="line">            s_y(<span class="built_in">i</span>, T) = ss(<span class="built_in">i</span>);</span><br><span class="line">            upd_y(<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        backup();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upd_y</span><span class="params">(i)</span></span></span><br><span class="line">    <span class="keyword">global</span> a ss yy y <span class="built_in">beta</span> n;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : n</span><br><span class="line">        sum = sum + a(<span class="built_in">i</span>, <span class="built_in">j</span>) * ss(<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    yy(<span class="built_in">i</span>) = y(<span class="built_in">i</span>) + <span class="built_in">beta</span> * (ss(<span class="built_in">i</span>) - sum);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upd_s</span><span class="params">(i)</span></span></span><br><span class="line">    <span class="keyword">global</span> a s ss x xx vv n v;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : n</span><br><span class="line">        sum = sum + a(<span class="built_in">i</span>, <span class="built_in">j</span>) * s(<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ss(<span class="built_in">i</span>) = sum + phi(xx(<span class="built_in">i</span>)) / vv(<span class="built_in">i</span>, <span class="built_in">i</span>) - phi(x(<span class="built_in">i</span>)) / v(<span class="built_in">i</span>, <span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upd_v</span><span class="params">(i)</span></span></span><br><span class="line">    <span class="keyword">global</span> n a v vv;</span><br><span class="line">    sum = <span class="built_in">zeros</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : n</span><br><span class="line">        sum = sum + a(<span class="built_in">i</span>, <span class="built_in">j</span>) * v(<span class="built_in">j</span>, :);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    vv(<span class="built_in">i</span>, :) = sum;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upd_x</span><span class="params">(i)</span></span></span><br><span class="line">    <span class="keyword">global</span> xx x alpha r n y s v;</span><br><span class="line">    xx(<span class="built_in">i</span>) = x(<span class="built_in">i</span>) - alpha * ((x(<span class="built_in">i</span>) - r(<span class="built_in">i</span>)) + (x(<span class="built_in">i</span>) - <span class="number">5</span>) + (<span class="number">1</span> / n) * (y(<span class="built_in">i</span>) + <span class="number">2</span> * (s(<span class="built_in">i</span>) - <span class="number">5</span>) / n / v(<span class="built_in">i</span>, <span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backup</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">global</span> x v s y xx vv ss yy</span><br><span class="line">    x = xx;</span><br><span class="line">    v = vv;</span><br><span class="line">    s = ss;</span><br><span class="line">    y = yy;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">(op)</span></span></span><br><span class="line">    <span class="keyword">global</span> n x r v s y xx vv ss yy r1 r2</span><br><span class="line">    x = randi([<span class="number">1</span>, <span class="number">5</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        r = r1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r = r2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    v = <span class="built_in">diag</span>(<span class="built_in">ones</span>(<span class="number">1</span>, n));</span><br><span class="line">    s = phi(x);</span><br><span class="line">    y = <span class="built_in">zeros</span>(<span class="number">1</span>, n);</span><br><span class="line">    xx = x;</span><br><span class="line">    vv = v;</span><br><span class="line">    ss = s;</span><br><span class="line">    yy = y;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">res</span> = <span class="title">phi</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="keyword">global</span> n;</span><br><span class="line">    res = x / n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>经过FigureBest美化后的图片：</p><p><img src="1.png" /></p><p><img src="2.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习Matlab，一方面是数模需要，另一方面是Matlab +
FigureBest绘制出来的图片非常精美。科研绘图时会用到，所以就学习一下。&lt;/p&gt;</summary>
    
    
    
    <category term="2. 技能栈" scheme="http://error666.top/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/"/>
    
    <category term="Matlab" scheme="http://error666.top/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/Matlab/"/>
    
    
  </entry>
  
  <entry>
    <title>各种工具使用手册</title>
    <link href="http://error666.top/2024/04/25/%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://error666.top/2024/04/25/%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</id>
    <published>2024-04-24T16:28:29.000Z</published>
    <updated>2024-06-30T18:22:44.700Z</updated>
    
    <content type="html"><![CDATA[<p>工具能大大提升效率。所以掌握有必要掌握一些常用工具。</p><span id="more"></span><h3 id="一.-chatgpt">一. ChatGPT</h3><h4 id="如何订阅gpt4-plus">如何订阅GPT4 PLUS？</h4><ol type="1"><li>去<a href="https://chat.openai.com/">官网链接(openai.com)</a>注册一个OpenAI账号并登录（建议通过Google邮箱注册）</li><li>注册过程中，需要用到手机号验证，使用<ahref="https://sms-activate.org/cn">SMS-Activate</a>解决</li><li>1、2步完成后，就可以使用ChatGPT服务了，但是只能使用3.5而且有次数限制。点击升级，会看到一个支付界面，界面里要填银行卡相关信息。银行卡只能使用美国的。所以在<ahref="https://www.fomepay.com/">FOMEPay</a>上购买一张虚拟美国银行卡，往里充钱。然后将卡号信息填到刚才的界面中即可。</li><li>充值成功，可正常使用ChatGPT4</li></ol><p>（注意，充值过程尽量要全程使用美国IP的梯子！）</p><h4 id="如何使用">如何使用？</h4><p>想怎么用怎么用，推荐几个插件：</p><ol type="1"><li>WebPilot：帮助ChatGPT联网搜索信息</li><li>Wolfram：科学计算，图标绘制</li><li>Tutory：可以帮你制定任意领域的学习路线</li><li>Ai Tool Hunt：找插件的插件</li><li>MixerBox Scholar：可以访问一些学术资源</li></ol><hr /><h3 id="二.-vs-code">二. VS Code</h3><p>VS Code作为最常用的IDE，掌握其使用方法以及相关插件十分必要。</p><p>而且这玩意还可以通过Github同步配置，所以配置一次，永久享用。</p><p>而且VS Code里有终端，于是写项目配合git使用很方便。</p><h4 id="快捷键">快捷键</h4><ul><li>ctrl + ,：设置</li><li>ctrl + shift + p：命令面板</li><li>ctrl + p：最近文件列表</li><li>ctrl + j：切出下面板（用来在代码和终端输入间跳转）</li><li>ctrl + b：隐藏/显示目录</li><li>ctrl + shift + n：新建vscode窗口</li><li>ctrl + 1/2/3：分屏/不同分屏中跳转</li><li>ctrl + alt + right/left：将文件移动到不同分屏中</li><li>alt + ijkl/[]：上下左右/HOME,END（自己改的键）</li><li>alt + up/down：行移动</li></ul><h4 id="插件">插件</h4><h5 id="code-runner">code runner</h5><ul><li>ctrl + alt + n：编译运行程序</li><li>ctrl + c：退出当前命令（死循环时退出运行）</li></ul><h5 id="wsl">WSL</h5><ul><li>直接在本地vscode登入进wsl子系统中的vscode</li><li>或者在wsl中输入code .进入vscode界面</li></ul><h5 id="git-graph">Git Graph</h5><ul><li>装了之后，直接在vscode中就可以查看提交/分支状态</li><li>可以查看每次commit的id/author/date/parents/与上一次commit的不同之处<ul><li>查看与任意一次commit的不同之处：先点一个，再按住ctrl点另一个</li></ul></li></ul><h5 id="todo-tree">Todo Tree</h5><ul><li>TODO表示待办，FIXME表示写了一半还没写完，BUG表示这段程序有问题，HACK表示这段程序可以优化，NOTE表示想法</li><li>这个插件除了方便写注释，还可以充当打标签的作用</li></ul><h5 id="bookmarks">Bookmarks</h5><ul><li>打标签，当程序很长的时候，用鼠标跳转很不方便，用书签跳转就很快。</li></ul><h5 id="jupyter">Jupyter</h5><ul><li>无需安装jupyter notebook即可在vscode实现相同功能</li><li>Esc + M：markdown模式</li><li>Esc + Y：代码模式</li><li>ctrl + enter：运行</li><li>Esc + D, D：删除该单元</li><li>Esc + B：在下方添加一个单元</li><li>Esc + A：在上方添加一个单元</li><li>Esc + L：显示行号</li></ul><h5 id="draw.io-integration">Draw.io Integration</h5><ul><li>画流程图</li></ul><hr /><h3 id="三.-sai2">三. SAI2</h3><p>SAI2的最最最基本使用（我不玩板绘）。主要用来方便授课。</p><p>因为最近接了一个线上一对一的算法家教，所以买了一块数位板（高漫1060pro）方便授课，然后下了个SAI2。</p><p>首先改板子的映射区，这个型号的板子对我来说太大了，手移动距离太多很累。所以把板子工作区域改小。记得去官方下驱动。</p><p>然后是改板子的快捷键，我板子的快捷键从上到下分别是：（对应着SAI2里的功能）</p><ul><li>选中、剪切</li><li>复制、粘贴</li><li>画笔、橡皮</li><li>ctrl、shift</li><li>文字、ESC</li><li>合并图层、画面居中</li></ul><p>所以设置好快捷键后，基本上只需要打开SAI2，然后在板子上操作就好了。不怎么需要去SAI2里操作了。</p><p>说一下SAI2的操作逻辑，首先是文字，每次输入文字SAI2都会新建一个图层，所以在输入完文字后要按ESC+ 合并图层，才能将文字和原本内容合并到同一图层中。</p><p>然后是粘贴，在你选中、复制、粘贴后，粘贴的内容会新开一个图层。所以需要按住ctrl移动到恰当位置后，按下合并图层，才能实现粘贴的内容和原内容在同一图层中。</p><p>最后是操作时遇到的一些问题：</p><ol type="1"><li>为什么切换到画笔后，写不出东西？<ul><li>可能是因为你选中了某个区域，没有取消就切换到画笔模式了。所以可以先按剪切后，再切换到画笔模式即可正常工作。</li></ul></li></ol><hr /><h3 id="四.-adobe-illustrator">四. Adobe illustrator</h3><p>通俗的理解，Adobeillustrator就是针对于矢量图的画图工具。发英文期刊/会议，配图格式经常要求是矢量图且质量比较高。所以matplotlib/Matlab+ Adobe illustrator + MathType就足以制作论文的配图。</p><h4 id="界面">界面</h4><ul><li>视图 -&gt; 标尺：打开标尺</li><li>右键标尺：选择标尺单位</li><li>视图 -&gt; 智能参考线：打开自动吸附功能</li><li>文件 -&gt; 存储：即保存，格式有eps等</li><li>文件 -&gt; 导出：即导出，格式有jpg/png等</li><li>文件 -&gt; 置入：插入图片到该画板</li><li>窗口 -&gt; 描边：里面有更多关于描边的参数（例如画箭头/虚线）</li></ul><h4 id="操作">操作</h4><ul><li>鼠标中键：移动</li><li>alt + 滚轮：放大/缩小</li><li>双击对象：对象进入隔离模式，防止操作时误操作到其它对象</li></ul><h4 id="工具栏">工具栏</h4><ul><li>空心箭头（普通选择）<ul><li>单击对象：用于选择然后移动/放大/缩小/旋转<ul><li>右键：编组/取消编组</li></ul></li><li>按住ctrl：显示所有锚点，点击锚点可编辑锚点</li><li>按shift + 单击其它对象：可多选其它对象</li><li>按alt + 拖动：可复制一份对象出来</li></ul></li><li>形状工具<ul><li>右键可以选择画不同的形状，按住shift可画标准化图形</li><li>矩形、椭圆、多边形、星形、直线</li></ul></li></ul><h4 id="属性图层库">属性/图层/库</h4><ul><li>属性：调节对象的属性，比如改变位置/设置颜色/填充</li></ul><h3 id="五.-origin">五. Origin</h3><p>画图神器。我觉得比matlab那一套方便多了，图形化的操作更加容易上手，不会把时间浪费在很多无意义的细节上。</p><p>Origin的组织结构：项目(.opju) -&gt; 文件夹 -&gt;book(数据)/graph(图)</p><p>对于book，使用内置python编程导入数据（菜单栏 -&gt; 连接 -&gt;.py），下面是一个导入的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wks = op.new_sheet()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    wks.from_list(i * <span class="number">2</span>, ans_x[i])</span><br><span class="line">    wks.from_list(i * <span class="number">2</span> + <span class="number">1</span>, ans_y[i])</span><br></pre></td></tr></table></figure><p>对于graph，其组织结构为：画布 -&gt; 图层(坐标轴) -&gt; 点/线。</p><p>上面是简单概念介绍，下面将对操作细节进行更多的阐述：</p><ol type="1"><li>A + 鼠标拖拽滚轮：实现页面的移动 + 放大/缩小</li><li>右上角有抗锯齿功能</li><li>最后画完图后，菜单栏 -&gt; 格式 -&gt;调整页面至图层大小，可以把白边裁掉。<ul><li>建议对于宽度选择边界为5，对于高度选择紧凑</li></ul></li><li>画风格类似的图时，可以使用复制风格功能</li><li>画子图时，建议先把每一张图画好，再使用“菜单栏 -&gt; 图 -&gt;合并图表”完成子图绘制</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;工具能大大提升效率。所以掌握有必要掌握一些常用工具。&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://error666.top/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理实验笔记</title>
    <link href="http://error666.top/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <id>http://error666.top/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-28T13:12:34.000Z</published>
    <updated>2024-09-03T18:13:21.444Z</updated>
    
    <content type="html"><![CDATA[<p>用Verilog实现一个简易RISC-V指令集CPU软核。</p><p>本次实验是重庆大学2022级弘深计算机拔尖班计算机组成原理的实验项目。</p><span id="more"></span><h3 id="一.-想说的话">一. 想说的话</h3><p>在开始做实验之前，首先要对CPU的物理结构和数据是如何在regfile,data_memory, instr_memory、alu中传输的有比较清晰的认知。建议观看视频: <ahref="https://www.bilibili.com/video/BV1wi4y157D3?p=1">从0到1设计一台计算机</a>，掌握理论知识。</p><p>在看完视频后，可以先跟着这个<ahref="https://www.bilibili.com/video/BV1pK4y1C7es?p=1&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0">教你写一个简单的CPU</a>视频，实现一个简单的MIPS指令集CPU软核，掌握实践知识。不用完全写对，跟着写一遍知道各个模块是如何互相运作的即可。因为视频中没有测试文件测试各个模块，都是一口气写下来的。所以最终版仿真是跑不起来的，因为存在诸多bug。</p><p>然后，最好在系统学习完一遍计组的理论知识（尤其是流水线冒险）后，再去写RISC-V指令集的软核。或者边学边做也行。我就是在全部写完后，才去学的计组理论知识，所以写出来的软核在冒险那一块是存在几个bug的，已经懒得调了。到时候下半年参加龙芯杯的时候反正也要再一个cpu，把这个遗憾留到龙芯杯解决就是了。</p><h3 id="二.-思路">二. 思路</h3><p>有啥思路？拿到设计图干就完事了，把线连好就行了，没啥难度。</p><p>代码已开源：<ahref="https://github.com/potatoQi/RISCV_CPU_Chongqing-University-Computer-Organization-Principles-Course-Project">RISCV_CPU(ChongqingUniversity Computer Organization Principles Course Project)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;用Verilog实现一个简易RISC-V指令集CPU软核。&lt;/p&gt;
&lt;p&gt;本次实验是重庆大学2022级弘深计算机拔尖班计算机组成原理的实验项目。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="计算机专业课" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>2024华为软件精英挑战赛游记</title>
    <link href="http://error666.top/2024/03/24/2024%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%E6%B8%B8%E8%AE%B0/"/>
    <id>http://error666.top/2024/03/24/2024%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%E6%B8%B8%E8%AE%B0/</id>
    <published>2024-03-24T03:44:25.000Z</published>
    <updated>2024-03-29T17:51:52.018Z</updated>
    
    <content type="html"><![CDATA[<p>初赛正式赛35名，遗憾离场，略微可惜。</p><span id="more"></span><h3 id="第一周">第一周</h3><p>参加这个比赛也是心血来潮。一方面想着现在已经大二了，保研之前要丰富一下自己的简历，另一方面我还从没参加过企业举办的大型赛事，而且去看了下历年的题目，都是用算法去解决实际问题，对我来说蛮有吸引力。所以拉上我们班一位同学就去参加了。（比赛要求三个人所以去网上又找了一个重邮研二的）</p><p>报了名之后就没管了，一直到赛题发布的那一天。</p><p>第一眼看到赛题感觉有点难蚌，我之前去看了22、23年的华为软挑真题，认为23年既然已经考过这种控制机器人移动做任务的题目，那么24年考这个的概率就不大了。24考的题应该更接近于22年这种调度问题。没成想，24年居然还是机器人移动（当然也是包括调度问题的）。</p><p>第一天，看了看题目，下午和队友在线上开了个会，每个人分别讲了讲自己对赛题的理解。大致确定下了本题核心任务：调度+ 控制。</p><p>调度即为考虑机器人搬哪些货物，去哪个泊位；船去哪个泊位，什么时候回家，什么时候转运。调度问题为了简单起见，都是选择的编码难度最容易的调度方式。即机器人选最贵的物品，机器人选有船要来且最近的泊位，船满了就走先不考虑转运情况。</p><p>控制即操控机器人在最短时间内走到目标点。因为地图数据规模不大，所以我们选用每一步每一个机器人bfs一遍的策略。</p><p>晚上，我根据上面的思路，写了一个文字框架以及如何维护关键参数的思路：</p><p><img src="1.png" /></p><p>写完框架后就摆烂了几天，主要那几天刚好事特别多... ...</p><p>最后在周末的时候，拉着我同学，花了大概2个多小时，一起对着上面的文字框架实现了一个基本的代码框架。并确定好了分工，他负责最短路算法以及机器人的运动，我负责船以及泊位的调度部分。</p><p>（P.S.考虑到因为第三个队友跟我们不在同一个学校，不方便同时维护一份代码，所以让他根据自己想法写一个版本，无需受我写的文字框架的约束。兵分两路策略。）</p><h3 id="第二周">第二周</h3><p>到了比赛第二个星期，首先星期一星期二熬大夜把我负责的部分写完了。然后周末同学把他负责的那一部分也写完了。可是不能跑，机器人跑了几百帧就卡死了。于是周末的两个晚上，继续熬大夜，修复代码中的小BUG。最后成功让代码跑起来了，第一次有分。</p><p><img src="2.png" /></p><p>跑出分说明代码框架已经没问题了，但是仍然存在跑了几百帧后几个机器人撞一块再也不动的情况。说明碰撞部分还是存在BUG。</p><p>于是我改变了原先解决碰撞的策略，在原先只有等待机制的情况下，引入失控机制：</p><ol type="1"><li>俩机器人即将碰撞时，其中一个机器人进行等待模式，另一个机器人继续动</li><li>俩机器人若在同一个地方死锁，其中一个机器人进入等待模式，另一个机器人进入失控模式</li><li>等待模式的机器人原地不动，失控模式的机器人乱走</li></ol><p>最后解决了碰撞问题，确定了我们组的baseline代码，8w分。</p><p><img src="3.png" /></p><h3 id="第三周">第三周</h3><p>最忙的一周。几乎每天都熬到3、4点。主要问题就是优化baseline。其实优化之处还是非常多的。我按照我们的代码版本顺序来讲讲每个版本优化了哪些地方吧。</p><ul><li><p>v1.0</p><ul><li>baseline版本</li></ul></li><li><p>v2.0</p><ul><li>机器人挑选物品由原先的挑最贵的，变为挑val（物品价值） /dis（机器人与物品的最短距离）最大的</li><li>机器人由原先的锁定泊位，改为了锁定泊位的具体坐标</li></ul></li><li><p>v3.0</p><ul><li><p>我同学想出了一个“革命性”的优化，不用每一步都对每个机器人求最短路，只需在机器人每次改变目标点时或者碰撞后求一个最短路就好了。将时间由原先的几乎一半时间都掉帧，优化到了几乎不掉帧</p></li><li><p>完善了失控机制，原地等待wait_max_tim帧后同样进入失控状态，解决死锁</p></li><li><p>调整了失控策略，由原先的4个方向顺序去搜变为4个方向随机数去走，避免来回踱步</p></li><li><p>新增更换目标机制，若机器人road_tim帧内没到达目标，则会更换目标，解决死锁</p></li></ul></li><li><p>v3.5</p><ul><li>规范了v3.0的代码风格和缩进</li><li>略微调整了参数</li></ul></li><li><p>v4.0</p><ul><li>初始时令每个机器人去到离他自己最近的泊位，将十个机器人分配到十个泊位上，避免陷入局部最优解</li><li>改变了机器人确定目标泊位的策略：由原先的去已blocked的最近泊位改为去最近的泊位</li><li>增加了船转运的功能，如果超过最低容量且一定时间内没装载，则去别的泊位装货</li></ul></li><li><p>v5.0</p><ul><li>每个泊位里新增了一个队列q，可以统计泊位上的货物情况</li><li>优化了船挑选目标泊位的策略，由原先的去最大价值泊位变成去能取到最大价值的泊位</li></ul></li><li><p>v6.0</p><ul><li>增加了泊位聚类功能，可设置距离阈值控制聚类范围（这是个负优化，悲）</li><li>增加了船排队功能，可设置每个泊位最多等待船数</li></ul></li></ul><p>当写完这7个版本的代码后，还剩2天就正式赛了。此时的代码在练习赛排行榜处于44名。于是剩下两天试图继续优化代码，可是我们写了很多优化最后都是负优化并无很大提升。于是最后一天用ChatGpt写了一个python调参程序开始炼丹。</p><h3 id="正式赛">正式赛</h3><p>正式赛在第三周的周六。上午队友交了一发13名。后面大家陆陆续续起床了，排名就被刷到20多名了。正式赛这一天我们继续改了改泊位的调度思路，可是没啥正优化。最后排名被刷到30名。最后几个小时没有啥思路了，于是对着两个地图开始炼丹。最后交了几发提升了几千分，封榜前，排名上升到了29名（笑。</p><p>周天晚8点多去看了看晋级名单，35名。看来差一点。</p><p><img src="4.png" /></p><h3 id="后记">后记</h3><p>第一次参加软挑，然后蛮有收获的。首先，第一次维护那么长（臭）的代码，接近1k行代码。极大了提高了我编码和debug能力。其次让我知道了面向对象的重要性。下次再写这种大型项目最好用面向对象。其次，团队之间的合作也是非常重要的，就像这次比赛有两个突破性的难点都是我同学大佬想出来的。</p><p>最后，希望大家身体健康，学业顺利！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;初赛正式赛35名，遗憾离场，略微可惜。&lt;/p&gt;</summary>
    
    
    
    <category term="3. 竞赛" scheme="http://error666.top/categories/3-%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理自学笔记</title>
    <link href="http://error666.top/2024/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://error666.top/2024/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-26T17:06:20.000Z</published>
    <updated>2024-09-03T18:13:28.656Z</updated>
    
    <content type="html"><![CDATA[<p>资料来源：课件、黑书</p><p>upd：满绩了，题目讲实话不算容易，幸好做了比较充分的复习。</p><span id="more"></span><h3 id="一.-alu算术逻辑单元">一. ALU算术逻辑单元</h3><ol type="1"><li>基础知识<ol type="1"><li>对于无符号数，那么每一位都是可以用来表示数据的。比如64的无符号数max值为2^ 64 - 1</li><li>对于有符号数，<strong>统一采用补码形式存储在计算机中。</strong><ol type="1"><li>原因如下：<ol type="1"><li>如果最高位为符号位，其余位采用原码表示，那么0就有0 000...00和1000...00两种表示方法，不能唯一确定，不好</li><li>那么取个反呢？也就是最高位仍是符号位，如果想表示一个正数x的相反数，就直接把x的二进制全部取反即可。<ol type="1"><li>取反本质上就相当于INT_MAX - x，那么正数范围x是0 ~INT_MAX，则取反也是一一对应的，所以可以用x取反的方式得到x的相反数，也就得到了-0~ -INT_MAX的负数表示。</li><li>但是老问题仍然存在，对于+0，其二进制全部取反后得到1111...11。所以0仍然存在两种表示方法，这不好</li></ol></li><li>为了解决这个问题，取反后加1就好了。本质上就是-(INT_MAX - x +1)。对于+0，是0 000...00，对于-0，仍然是0 000...00。此时，正数范围x是0 ~INT_MAX。当x取0的时候，-0表示为0 000.00，当x取INT_MAX时，-x表示为1000...01。你会发现1000...00这个数没被用到。所以多出来的这个二进制数，我们用它来表示-(INT_MAX+1)</li></ol></li><li>对于正数，符号位为0，其余位该咋样咋样，跟原码一样。所以64位的最大值为2^ 63 - 1</li><li>对于负数，其二进制是其相反数全部取反+1。64位的负数范围本应是[-INT_MAX,-0]，但因为1000...00这个数没人对应。所以用它来对应-(INT_MAX+1)。所以负数范围是[-(INT_MAX+1),-0]</li></ol></li></ol></li><li>加法溢出（减法溢出同理）<ol type="1"><li>正数 + 负数，不会溢出</li><li>正数 + 正数，符号位为1，溢出</li><li>负数 + 负数，符号位为0，溢出</li></ol></li><li>乘法<ol type="1"><li>朴素法：本质就是二进制分解，将乘数二进制分解，每次看最后一位是不是1，若是，往结果里加上一个被乘数（注意，每分解一次被乘数就要左移一位）</li><li>优化法：本质还是二进制分解，但聪明的就是把结果和乘数写一起，初始化的时候在乘数(结果)的前面预留x位（x为被乘数的位数），然后每次检查结果最后一位，若是1，从最高位开始加上一个被乘数，然后结果右移一位，被乘数x2；若是0，则结果直接右移一位，被乘数x2</li></ol></li><li>除法（建议多练几个样例练练手）<ol type="1"><li>恢复除数法朴素法<ol type="1"><li>除数低位补0，然后被除数对着除数减，减成功就在结果顶一个1出去，没成功就顶一个0出去。直到除数变为1时结束</li></ol></li><li>恢复除数法优化法<ol type="1"><li>除数不动，然后被除数高位补0，然后高位对着除数减，减成功了就往被除数屁股后塞个1进来，没成功就往被除数屁股后塞个0进来。直到原本的被除数都被减过一遍后（最后一次比较完后高位<strong>减完后，低位左移，塞屁股</strong>然后走人）</li></ol></li><li>加减交替法<ol type="1"><li>初始化是被除数高位补0，然后高四位直接减除数</li><li>之后的每一步，直接看被除数符号位是不是1，是1直接屁股塞个0然后高四位加余数。不是的话屁股塞个1然后高四位减余数。直到原本的被除数都被减过一遍后（最后一次判断完屁股塞什么后，直接<strong>低位左移然后</strong>塞完屁股走人）</li></ol></li></ol></li><li>IEEE754<ol type="1"><li>S是阶符、E是阶码、M是尾数</li><li>单精度<ol type="1"><li>E = e + 127，e是真实指数</li><li><span class="math inline">\(1 \le E \le 254(127 * 2)\)</span></li><li>8位阶码，共32位</li></ol></li><li>双精度<ol type="1"><li>E = e + 1023</li><li><span class="math inline">\(1 \le E \le 2046(1023 * 2)\)</span></li><li>11位阶码，共64位</li></ol></li><li><img src="8.png" /></li><li><img src="9.png" /></li></ol></li></ol><h3 id="二.-指令集isa">二. 指令集ISA</h3><table><colgroup><col style="width: 28%" /><col style="width: 37%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>R型指令</th><th>I型指令</th><th>S型指令</th></tr></thead><tbody><tr class="odd"><td>add rd rs1 rs2</td><td>addi rd rs1 imm</td><td>sw rs2 imm(rs1)（将rs2里的东西赋值到rs1 + imm里）</td></tr><tr class="even"><td>sub rd rs1 rs2</td><td>subi rd rs1 imm</td><td></td></tr><tr class="odd"><td>and rd rs1 rs2</td><td>andi rd rs1 imm</td><td></td></tr><tr class="even"><td>or rd rs1 rs2</td><td>ori rd rs1 imm</td><td></td></tr><tr class="odd"><td>xor rd rs1 rs2</td><td>xori rd rs1 imm</td><td></td></tr><tr class="even"><td>sll rd rs1 rs2</td><td>slli rd rs1 imm (左移imm位，zero-extend)</td><td></td></tr><tr class="odd"><td>srl rd rs1 rs2 （左移rs2位，zero-extend）</td><td>srli rd rs1 imm（右移imm位，zero-extend）</td><td></td></tr><tr class="even"><td>sra rd rs1 rs2 （右移rs2位，sign-extend）</td><td>srai rd rs1 imm（右移imm位，sign-extend）</td><td></td></tr><tr class="odd"><td>slt rd rs1 rs2 （rs1小于rs2吗，带sign）</td><td>slti rd rs1 imm（rs1小于imm吗，带sign）</td><td></td></tr><tr class="even"><td>sltu rd rs1 rs2（rs1小于rs2吗，不带sign）</td><td>sltiu rd rs1 imm（rs1小于imm吗，不带sign）</td><td></td></tr><tr class="odd"><td></td><td>lw rd imm(rs1)（将rs1 + imm的数据加载到rd里）</td><td></td></tr><tr class="even"><td></td><td>jalr rd imm(rs1)（将pc + 4赋值给rd，pc赋值为rs1 + imm）</td><td></td></tr></tbody></table><table><colgroup><col style="width: 39%" /><col style="width: 29%" /><col style="width: 31%" /></colgroup><thead><tr class="header"><th>B型指令</th><th>U型指令</th><th>J型指令</th></tr></thead><tbody><tr class="odd"><td>beq rs1 rs2 label（若rs1 == rs2，PC被赋值为label）</td><td>lui rd imm（rd = imm &lt;&lt; 12）</td><td>jal rd imm（rd = PC + 4, PC = PC + imm）</td></tr><tr class="even"><td>bne （not equal）</td><td>auipc rd imm（rd = (imm &lt;&lt; 12) + PC）</td><td></td></tr><tr class="odd"><td>bge （greater or equal）signed</td><td></td><td></td></tr><tr class="even"><td>bgeu （greater or equal）nosigned</td><td></td><td></td></tr><tr class="odd"><td>blt （less than）signed</td><td></td><td></td></tr><tr class="even"><td>bltu （less than）nosigned</td><td></td><td></td></tr></tbody></table><p>I、S、B、U、J，除了I是有/无符号扩展，其余都是有符号扩展，U是先左移12位再有符号扩展</p><ul><li>C转汇编练习<ul><li>x0：固定为0，可写可读但是始终为0</li><li>x1：返回地址寄存器，调用函数的时候自动更新为调用语句的地址</li><li>x10/x11：返回结果寄存器，用来保存函数里计算的值</li><li>x5-7/x28-31：临时寄存器，随便用</li><li>x8-9/x18-27：保存寄存器，在函数调用中需要保存恢复（入栈）</li><li>读取字符是lbu，存储字符是sb</li><li>函数中return的固定格式：jalr x0, 0(x1)</li><li><img src="10.png" /> ppt4(15)</li><li><img src="24.png" /> ppt4(16)</li><li><img src="11.png" /> ppt4(25)</li><li><img src="12.png" /> ppt4(38)</li></ul></li></ul><h3 id="三.-单周期数据通路">三. 单周期数据通路</h3><ol type="1"><li><p>CI：指令数 CPI：每条指令所需的周期数 f：时钟频率 T = <spanclass="math inline">\(\frac{1}{f} \cdot (CI \cdotCPI)\)</span>：时间</p></li><li><p>1GHz = 10^3MHz = 10^9Hz；1ns = 10^3ps = 10^9s</p></li><li><p>1ns = (1 / 1GHz)</p></li><li><p>系统加速比 = <spanclass="math inline">\(\frac{改进前的总时间}{改进后的总时间}\)</span> =<span class="math inline">\(\frac{改进前的总时间}{改进前的总时间 \cdot不可改进部分的占比 + \frac{改进前的总时间 \cdot可改进部分的占比}{改进部分的加速比}}\)</span>，若用吞吐量计算的话就是分子分母反过来-&gt;<spanclass="math inline">\(\frac{改进后的吞吐量}{改进前的吞吐量}\)</span></p></li><li><p>关键路径分析</p><ol type="1"><li><p><img src="13.png" /></p><p>俩寄存器从readdata1/2出来然后进alu运算，得到结果直接传回registers</p></li><li><p><img src="14.png" /></p><p>readdata1是首地址，immgen是偏移量，经alu运算后得到地址，然后ram的readdata读到数据后传回registers，赋值给rd</p></li><li><p><img src="15.png" /></p><p>readdata2是要写入ram的数据，直接流入ram的writedata，readdata1是首地址，immgen是偏移量，经alu运算后得到地址</p></li><li><p><img src="16.png" /></p><p>readdata1/2分别是rs1,rs2，经alu判断是否相等后zero信号给到pc那边的mux。label通过immgen传到mux</p></li></ol></li><li><p>对于寄存器（pc、InstrMem、Registers、DataMem），如果走完全程就加整个的延迟，如果只是往里写东西就只加一个Setup，如果只是读东西就只加一个read。</p><ol type="1"><li>sw的关键路径：pc_read + InstrMem + Registers + ALU + Setup</li></ol></li></ol><h3 id="四.-流水线数据通路">四. 流水线数据通路</h3><ol type="1"><li><p>流水线的五个阶段</p><ol type="1"><li><p>IF：从内存中获取指令</p></li><li><p>ID：指令解码和寄存器读取</p></li><li><p>EX：执行操作或计算地址</p></li><li><p>MEM：访问内存操作数</p></li><li><p>WB：将结果写回寄存器</p><p><img src="17.png" /></p></li></ol></li><li><p>流水线数据通路的延迟</p><ol type="1"><li><p>时钟周期(每个cycle的时间) = max{ lat(IF), lat(ID), lat(EX),lat(MEM), lat(WB) }</p></li><li><p>忽略了流水线的装载和排空</p></li><li><p>忽略了寄存器的建立时间</p><blockquote><p>这里要注意区分时钟周期、延迟的概念：</p><p>对于单周期数据通路，其时钟周期就是它的延迟</p><p>对于流水线数据通路，其时钟周期是max{ 五个阶段的延迟 }，其延迟是sum{五个阶段的延迟 }</p></blockquote></li></ol></li><li><p>画流水线图</p><ol type="1"><li><p>传统流水线图</p><p><img src="18.png" /></p><p>直接IF、ID、EX、MEM、WB五个阶段哐哐往上写就好了</p></li><li><p>资源调度流水线图</p><p><img src="19.png" /></p><p>固定的五套件是IM（instr_memory）、Reg、ALU、DM（data_memory）、Reg。如果写就前半部分标黑，如果读就后半部分标黑，如果都用到了就都标黑。没用到就标白（例如sub、add没用到DM）</p></li><li><p>插气泡的写法</p><p><img src="20.png" /></p></li></ol></li><li><p>冒险</p><ol type="1"><li>结构冒险：就是抢硬件资源，比如若将指令和数据放在一个存储器，那么IF阶段和MEM阶段就会同时用存储器，产生结构冒险</li><li>数据冒险：<ol type="1"><li>产生数据依赖就会产生数据冒险</li><li>三种数据依赖<ol type="1"><li>写后读（RAW）<ol type="1"><li>即前面写的还没更新，后面就读了，结果读出来不符合原本预期</li><li>无lw/sw语句<ol type="1"><li>也就是对于同一个寄存器，WB的CC必须在ID的CC之前，之后就会存在RAW依赖。WB和ID的CC相同是否可行呢？其实是可以的。因为通常默认一个CC内先下降沿再上升沿，下降写，上升读，所以同一个CC内，先写后读，数据是可以正确传递的，所以同一个CC也可以。</li><li>总结解决办法就是写读之间间隔的语句要&gt;=2（不包括它俩），或者插bubble，或者前推</li></ol></li></ol></li><li>读后写（WAR）<ol type="1"><li>即前面还没读到，后面就写进去了，结果读出来不符合原本预期</li><li>因为五级流水读取ID在第二阶段，写WB是第五阶段，所以不会发现读后写的冒险。只有在乱序执行的时候才会出现</li></ol></li><li>写后写（WAW）<ol type="1"><li>假设三条指令前两条写，后一条读，按理说读出来的是最后一条写后的结果，但如果第一个写最后才执行，那么就读出来一个错误的值。</li><li>五级流水仍是顺序执行的，所以不会有WAW冒险。只有在乱序执行的时候才会出现</li></ol></li></ol></li><li>前推MUX控制<ul><li>alu那，俩操作数，有不同的选择</li><li>F0 = (EX/MEM.RegWrite &amp;&amp; EX/MEM.Rd != 0 &amp;&amp; ID/EX.Rs== EX/MEM.Rd) EX/MEM前推到ID/EX.Rs</li><li>F1 = (MEM/WB.RegWrite &amp;&amp; MEM/WB.Rd != 0 &amp;&amp; ID/Ex.Rs== MEM/WB.Rd) MEM/WB前推到ID/EX.Rs</li><li>如果F0=0，F1=0就不前推，不可能俩都为1，其中一个为1就前推对应的阶段到ID/EX.Rs</li></ul></li><li>Load-Use冒险检测<ol type="1"><li>Hazard = (ID/EX.MemRead &amp;&amp; ID/EX.Rd == IF/ID.Rs)</li><li>要从datamemory读东西并且最终要写入的寄存器会被下面的语句用到，那么就存在load-use冒险。</li><li>隔一条的load-use冒险可以前推解决，不间隔的load-use冒险前推解决不了</li></ol></li></ol></li><li>控制冒险：<ol type="1"><li>就是beq指令没执行完前后面的指令不给执行，但是beq到EX/MEM阶段才知道是否执行，而此时后面的三条指令已经塞进来了，所以就会发生控制冒险</li><li>解决方案一：插三条bubble</li><li>解决方案二：如果发现要执行跳转则flushID/IF/EX阶段（因为后面的指令最多执行了ID/IF/EX三个阶段，所以刷新掉即可）<ol type="1"><li>If (EX/MEM.branch &amp; EX/MEM.Zero) IF.Flush=True; ID.Flush=True;EX.Flush=True;</li></ol></li><li>当然，其实beq的俩数比较不需要放在alu后比较，其实readdata刚出来，也就是在ID的结尾就可以比较了。所以我们可以把比较前移至ID阶段<ol type="1"><li>if (IF/ID.IR == beq &amp;&amp; Reg[Rs1] == Reg[Rs2]) IF.Flush =True;</li><li>此时仍会出现冒险，解决方案如下</li><li>解决方案一：插一条bubble</li><li>解决方案二：若发现要执行跳转，则flush掉IF/ID寄存器即可</li></ol></li><li>还有另一种控制冒险，就是jal指令，跟前移后的beq一样，也是到ID阶段就知道跳转地址了，所以也是flush一下ID/EX寄存器即可<ol type="1"><li>if (IF/ID.IR == jal[R]) IF.Flush = True;</li></ol></li><li>在学了flush技巧后，前面我们没解决的load-use冒险也可以用flush技巧来解决了，具体来说如下：<ol type="1"><li>在检测上发生load-use冒险时：Hazard = (ID/EX.MemRead &amp;&amp;ID/EX.Rd == IF/ID.Rs)</li><li>将ID/EX寄存器控制字段flush掉</li><li>阻止PC寄存器更新</li><li>阻止IF/ID寄存器指令字段更新</li></ol></li></ol></li></ol></li><li><p>流水线性能分析</p><ol type="1"><li><p><img src="21.png" /></p></li><li><p>可以发现，多插一个bubble就会多一个时间周期才能完成</p></li><li><p>而且可以发现一个规律，插入bubble后的<spanclass="math inline">\(CPI = 1 +\frac{bubble数}{指令数}\)</span></p></li><li><p>那么下面这题就可以理解了</p><p><img src="22.png" /></p><p>只有beq、jal、ld会产生惩罚，题目说了没有结构冒险，所以只考虑ld。只有40%load，一个load指令会bubble一个周期，所以假设指令数是x，那么bubble数就是0.4x，代入公式：CPI= 1 + 0.4x / x = 1.4，然后T = CPI * 时钟周期 = 1.4 * 1.1 = 1.54</p></li><li><p><img src="23.png" /></p><ul><li>条件分支beq 20%，无条件跳转jal5%。跳转地址在ID阶段解决意味着会延迟一个周期跳转，跳转条件在EX解决意思是到EX/MEM才知道是否要跳转，也就是延迟3个周期跳转。</li><li>那么假设静态预测不跳转，CPI = 1 + 0.05 * 1 + 0.2 * 3 = 1.65</li><li>如果假设静态预测跳转，CPI = 1 + 0.05 * 1 + 0.2 * 1 = 1.25</li></ul></li></ol></li></ol><p>‍</p><h3 id="五.-动态分支预测">五. 动态分支预测</h3><p>考点：根据双模的计数器的状态跳转图、或者历史的预测情况、历史的跳转情况，分析出最近的十次他能预测成果的次数</p><h3 id="六.-cache">六. Cache</h3><ol type="1"><li>AMAT（平均访问时间）<ol type="1"><li><span class="math inline">\(T = p * T_c + (1 - p) * (T_c +T_m)\)</span></li><li>p是命中率，<span class="math inline">\(T_c\)</span>是访问时间，<spanclass="math inline">\(T_m\)</span>是缺失代价访问时间</li></ol></li><li>主存与cache<ol type="1"><li>对于主存地址，俩部分，主存块号m位，块内地址b位。这个地址可以定位到一个存储单元</li><li>对于cache行的内容，tag位 + 有效位 + 脏位 + LRU位 + 数据。</li><li>若想在cache中定位到一个存储单元，需要从主存地址中解析出cache行号和块内地址</li><li>地址映射表 = 标记阵列 = (tag位 + 有效位 + 脏位 + LRU位)</li></ol></li><li>映射方式<ol type="1"><li>直接映射<ol type="1"><li>cache行号 = 主存块号 % cache行数</li><li>其实主存块号对应的cache行号，就是m位主存块号的低c位。高m -c位就作为tag位</li><li>技巧：tag位 = log2(主存容量 / cache容量)</li></ol></li><li>全相联映射<ol type="1"><li>因为全相联是随便放，所以给你一个主存地址，是无法定位到放到cache中的哪一行的</li><li>所以我们将主存地址的m位全部作为tag位</li></ol></li><li>组相联映射<ol type="1"><li>主存m位块号里的低c位就是对应的组号，高m - c位就作为tag位</li><li>可以发现组相联也是无法定位到具体某一行的</li></ol></li></ol></li><li>关联度<ol type="1"><li>定义：一个主存地址可能被存放到cache中的可能位置个数</li><li>关联度越低，命中率越低，判断是否命中的开销越小</li><li>直接映射：1</li><li>全相联映射：cache行数</li><li>组相联映射：组路数</li></ol></li><li>替换算法<ol type="1"><li>LRU：选择近期最久没被实用的块被替换</li><li>算法实现：通过LRU位实现（计数器）</li></ol></li><li>一致性问题<ol type="1"><li>写命中（要修改的存储单元在cache中）<ol type="1"><li>写直达（同时更新cache和主存）</li><li>写返回（更新cache和脏位，当被替换出去的时候再更新主存）</li></ol></li><li>写不命中（要修改的存储单元不在cache中）<ol type="1"><li>写分配法（在主存里更新完后copy一份到cache中）</li><li>写不分配法（在主存里更新完后就结束）</li></ol></li></ol></li></ol><h3 id="六.-汇编补充">六. 汇编补充</h3><ul><li><p>在线RISC-V汇编编写网站：<ahref="https://venus.kvakil.me/">venus</a></p></li><li><p>RISC-V汇编转机器码网站：<ahref="https://riscvasm.lucasteske.dev/#">Online RISC-VAssembler</a></p></li><li><p>更多指令细节请参考：<ahref="https://inst.eecs.berkeley.edu/~cs61c/fa23/pdfs/resources/reference-card.pdf">CS61C Reference Card</a></p></li><li><p>RISC-V的大部分指令长度固定，为32位。每条指令都是由32个0/1序列组成。</p></li><li><p>寄存器：RISC-V中，寄存器是处理器内部用于存储数据的小存储单元。它们可以非常快速地被访问和写入，比起访问主内存来说速度要快得多。</p></li><li><p>RISC-V定义了一组32个通用寄存器，编号从0到31。在代码中就是x0, x1,x2, ..., x31。</p><p><img src="1.png" /></p></li></ul><ol type="1"><li><p>R(register)型指令：操作寄存器操作的指令</p><ul><li>格式：<img src="2.png" /></li><li>opcode操作码，rd目标寄存器号，rs1/rs2第一/二个源寄存器号，funct3附加操作码，funct7附加操作码。</li><li>add x3, x1, x2（+）</li><li>sub x3, x1, x2（-）</li><li>and x3, x1, x2（&amp;）</li><li>or x3, x1, x2（|）</li><li>xor x3, x1, x2（^）</li></ul></li><li><p>I(immediate)型指令：寄存器与常数操作的指令</p><ul><li>格式：<img src="3.png" /></li><li>immediate立即数。</li><li>addi x1, x2, 10</li><li>slti x1, x2, 15：如果x2小于15，将x1设置位1。否则设置为0</li><li>andi x1, x2, 0xFF：寄存器与常数进行&amp;操作</li><li>ori x1, x2, 0xFF</li><li>xori x1, x2, 0xFF</li><li>slli x1, x2, 2（将x2左移2位结果存到x1中）</li><li>ld x1, 0(x5)：从内存地址 x5+0 处加载 64 位的值到 x10</li></ul></li><li><p>S(store)型指令：寄存器与内存操作的指令</p><ul><li>格式：<img src="4.png" /></li><li>rs1访存基址寄存器编号，r2源操作数寄存器编号，imm立即数（表示从基址开始的偏移量。</li><li>sw x1, 10(x2)：将x1内容存储到x2为基址，偏移量为10的内存地址中</li></ul></li><li><p>B(branch)型指令：程序的有条件跳转指令</p><ul><li>格式：<img src="5.png" /></li><li>imm立即数：表示要跳转的语句的地址。</li><li>beq x1, x2, label：如果x1==x2，程序跳转到label处</li><li>blt(Branch less than) x1, x2, label：如果x1 &lt;x2，程序跳转到label处</li><li>bgt(Branch greater than) x1, x2, label：如果x1 &gt;x2，程序跳转到label处</li><li>bgtz(Branch greater than zero) x1label：如果x1大于0，程序跳转到label处</li><li>bgez(Branch greater or equal to zero) x1label：如果x1大于等于0，程序跳转到label处</li></ul></li><li><p>J(jump)型指令：程序的无条件跳转指令</p><ul><li>格式：<img src="6.png" /></li><li>也可以叫UJ(Unconditional Jump)指令。</li><li>jr rd：跳转到rd寄存器存的地址那里</li><li>jal x1,offset：跳转到当前指令地址加上offset的位置，并将下一条指令的地址存入x1中</li></ul></li><li><p>U(upper immediate)型指令：将20位立即数加载到寄存器的高位<br /></p><ul><li>格式：<img src="7.png" /></li><li>lui x1 imm：将20位立即数imm加载到x1的高20位，低12位清零</li></ul></li></ol><ul><li>练习题：写一个斐波那契数列程序</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">fib</span><span class="operator">:</span></span><br><span class="line">    <span class="variable">addi</span> <span class="variable">sp</span><span class="operator">,</span> <span class="variable">sp</span><span class="operator">,</span> <span class="operator">-</span><span class="number">16</span><span class="type">#</span> 开辟<span class="number">16</span>字节的栈空间</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">ra</span><span class="operator">,</span> <span class="number">0</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 保存函数地址</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">a0</span><span class="operator">,</span> <span class="number">4</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 保存参数<span class="variable">n</span><span class="operator">,</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable">addi</span> <span class="variable">t0</span><span class="operator">,</span> <span class="variable">x0</span><span class="operator">,</span> <span class="number">2</span>        <span class="type">#</span> <span class="variable">t0</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    <span class="variable">blt</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">t0</span><span class="operator">,</span> <span class="type">less_or</span><span class="type">_equal</span><span class="type">_than</span><span class="type">_one</span>    <span class="type">#</span> 如果<span class="variable">n</span> <span class="operator">&lt;=</span> <span class="number">1</span>，直接返回<span class="variable">n</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable">addi</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span>        <span class="type">#</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">jal</span> <span class="variable">ra</span><span class="operator">,</span> <span class="variable">fib</span>            <span class="type">#</span> 执行<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">    <span class="variable">add</span> <span class="variable">t1</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">x0</span>        <span class="type">#</span> 将<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span>的结果存到<span class="variable">t1</span>中</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">t1</span><span class="operator">,</span> <span class="number">8</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 将结果存到栈中</span><br><span class="line">    </span><br><span class="line">    <span class="variable">lw</span> <span class="variable">a0</span><span class="operator">,</span> <span class="number">4</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 恢复参数<span class="variable">n</span><span class="operator">,</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span></span><br><span class="line">    <span class="variable">addi</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span>        <span class="type">#</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span></span><br><span class="line">    <span class="variable">jal</span> <span class="variable">ra</span><span class="operator">,</span> <span class="variable">fib</span>            <span class="type">#</span> 执行<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">    <span class="variable">add</span> <span class="variable">t2</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">x0</span>        <span class="type">#</span> 将<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span>的结果存到<span class="variable">t2</span>中</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">t2</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 将结果存到栈中</span><br><span class="line">    </span><br><span class="line">    <span class="variable">lw</span> <span class="variable">t1</span><span class="operator">,</span> <span class="number">8</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 重新把结果读到<span class="variable">t1</span>中</span><br><span class="line">    <span class="variable">lw</span> <span class="variable">t2</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 重新把结果读到<span class="variable">t2</span>中</span><br><span class="line">    </span><br><span class="line">    <span class="variable">add</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">t1</span><span class="operator">,</span> <span class="variable">t2</span>        <span class="type">#</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">    <span class="variable">lw</span> <span class="variable">ra</span><span class="operator">,</span> <span class="number">0</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 恢复当前<span class="variable">fib</span>的返回地址</span><br><span class="line">    <span class="variable">addi</span> <span class="variable">sp</span><span class="operator">,</span> <span class="variable">sp</span><span class="operator">,</span> <span class="number">16</span>        <span class="type">#</span> 恢复栈空间</span><br><span class="line">    <span class="variable">jr</span> <span class="variable">ra</span>                <span class="type">#</span> 返回到调用<span class="variable">fib</span>函数的地方</span><br><span class="line">    </span><br><span class="line"><span class="type">less_or</span><span class="type">_equal</span><span class="type">_than</span><span class="type">_one</span><span class="operator">:</span></span><br><span class="line">    <span class="variable">addi</span> <span class="variable">sp</span><span class="operator">,</span> <span class="variable">sp</span><span class="operator">,</span> <span class="number">16</span><span class="type">#</span> 栈空间恢复</span><br><span class="line">    <span class="variable">add</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">x0</span>    <span class="type">#</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="variable">n</span></span><br><span class="line">    <span class="variable">jr</span> <span class="variable">ra</span>            <span class="type">#</span> 返回</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;资料来源：课件、黑书&lt;/p&gt;
&lt;p&gt;upd：满绩了，题目讲实话不算容易，幸好做了比较充分的复习。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="计算机专业课" scheme="http://error666.top/categories/4-%E5%A4%A7%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>Python进阶</title>
    <link href="http://error666.top/2024/02/24/Python%E8%BF%9B%E9%98%B6/"/>
    <id>http://error666.top/2024/02/24/Python%E8%BF%9B%E9%98%B6/</id>
    <published>2024-02-24T08:49:18.000Z</published>
    <updated>2024-04-27T02:25:52.551Z</updated>
    
    <content type="html"><![CDATA[<p>说是进阶，其实就讲了三个数据分析常用包：numpy、pandas、matplotlib</p><span id="more"></span><h3 id="numpy">numpy</h3><ul><li>其实就是列表，但是好处就是速度快、操作方便、许多好用的数学计算接口</li></ul><h4 id="定义">定义</h4><ul><li>通过列表定义<ul><li>a = [0, 1, 2, 3] arr = np.array(a)</li><li>arr = np.array([0, 1, 2, 3])</li></ul></li><li>初始化为全0/1/指定元素<ul><li>np.zeros(5) # 结果为array([0., 0., 0., 0., 0.])</li><li>np.ones(5) # 结果为array([1., 1., 1., 1., 1.])</li><li>.zeros和.ones默认都是小数，改为整数可以写.zeros(5, dtype='int')</li><li>a.fill(3)：将a的所有元素改为3（注意这里a要是一个ndarray类型）</li></ul></li><li>生成整数数列<ul><li>np.arrange(l, r, d)：在[l, r)内，从l开始，每次递增d</li></ul></li><li>生成随机数<ul><li>np.random.rand(10)：生成10个[0, 1)的随机数</li><li>np.random.randn(10)：生成10个服从标准正态分布的随机数</li><li>np.random.randint(l, r, 10)：生成10个在[l, r)范围内的随机整数</li></ul></li></ul><h4 id="属性">属性</h4><ul><li>a.dtype：查看a里元素的类型</li><li>a.shape：返回一个元组，里面元素分别代表每一维元素的数目</li><li>a.ndim：查看维度</li><li>a.size：查看元素个数</li><li>a.astype('float')：返回将a内元素类型转换为float后的结果</li></ul><h4 id="运算">运算</h4><ul><li><p>ndarray支持切片，同时可直接与数字/ndarray进行运算</p></li><li><p>注意复制的时候不能像列表那样用a[:]切片复制，要使用.copy()来复制</p></li><li><p>a + 1：每个元素+1</p></li><li><p>a * 5：每个元素*5</p></li><li><p>a + b：两个ndarray对应元素相加</p></li><li><p>a * b：两个ndarray对应元素相乘</p></li><li><p>a / b：两个ndarray对应元素相除</p></li></ul><h4 id="多维情况">多维情况</h4><ul><li><p>np.zeros((2, 3))：创建2行3列的全零ndarray</p></li><li><p>np.ones((2, 3))：创建2行3列的全一ndarray</p></li><li><p>a.fill(3)：将a全部元素换为3</p></li><li><p>a[1, 2]：访问第1行第2列的元素</p></li><li><p>a[1]：返回第一行，以ndarray形式</p></li></ul><h4 id="常用函数">常用函数</h4><ul><li>np.sort(a)：返回将a排序后的结果</li><li>np.argsort(a)：返回每个元素在排序过后所处的排名（排名从0开始）</li><li>np.sum(a)：求和</li><li>np.max(a)：求最大值</li><li>np.mean(a)：求均值</li><li>np.vstack((a, b))：纵向堆叠</li><li>np.hstack((a, b))：横向堆叠</li><li>np.dstack((a, b))：维度上堆叠</li></ul><h4 id="矩阵运算">矩阵运算</h4><ul><li><p>a.T：转置</p></li><li><p>np.eye(3)：产生一个3*3的单位矩阵</p></li><li><p>np.dot(a, b)：返回俩矩阵相乘的结果</p></li><li><p>np.linalg.det(a)：求矩阵的行列式</p></li><li><p>np.linalg.inv(a)：求矩阵的逆矩阵</p></li><li><p>np.diagonal(a)：提取矩阵的对角线元素，返回一个一维ndarray</p></li><li><p>np.diag(a)：这里a是一个一维ndarray，返回一个以a为对角线元素的矩阵</p></li><li><p>矩阵只保留对角线元素：先np.digonal()，再np.diag()一下即可</p></li></ul><hr /><h3 id="pandas">pandas</h3><ul><li>提供了许多处理数据的接口</li></ul><h4 id="series">Series</h4><ul><li>pd.Series([1, 3, 5, nan,7])：创建一个Series，其实Series跟列表差不多，就是多了一个索引index。列表的索引就是下标0,1, 2, ...，Series索引默认也是0, 1, 2，但是可以自己更改</li><li>a.values：返回a的值</li><li>a.index：返回a的键</li></ul><h4 id="dataframe">DataFrame</h4><ul><li>DataFrame其实就是一个二维数组，但是有表头。行表头叫做columns，列表头叫做index</li><li>a =pd.read_excel('路径')：把一个excel表文件读入到一个dataframe变量中</li><li>a.head()：查看前5行</li><li>a.tail()：查看后5行</li></ul><hr /><h3 id="matplotlib">matplotlib</h3><ul><li>matplotlib 是一个Python 的2D图形包。pyplot封装了很多画图的函数。所以在实际的使用过程中，常常以plt作为 matplotlib.pyplot 的省略。import matplotlib.pyplot as plt</li><li>找参数的网站：https://blog.csdn.net/qq_40481843/article/details/106231257</li><li>plt.plot<ul><li>画函数：plt.plot(x列表, y列表)</li><li>画线段：plt.plot([x1, x2], [y1, y2])</li><li>画点：plt.plot(x, y)</li><li>参数:<ul><li>color：颜色</li><li>marker：点类型</li><li>markersize：点大小</li><li>markeredgewidth：点边宽</li><li>fillstyle：点填充类型</li><li>linestyle：线类型</li><li>linewidth：线宽</li><li>label：图例名字</li></ul></li></ul></li><li>plt.xlabel / plt.title<ul><li>' '里写名称，用$$括起来可写latex</li><li>参数：<ul><li>fontsize：字体大小</li></ul></li></ul></li><li>plt.xlim：改变x轴范围，例如plt.xlim((x1, x2))</li><li>plt.legend<ul><li>啥都不写：以默认配置显示图例</li><li>参数：<ul><li>frameon：True/False（是否显示边框）</li><li>loc：图例显示位置</li><li>fontsize：图例字体大小</li></ul></li></ul></li><li>plt.text<ul><li>plt.text(x, y, 'xxx')</li><li>参数：<ul><li>fontsize：字体大小</li><li>ha：水平对齐方式<ul><li>left：文本左对齐于指定点</li><li>center：文本居中对齐于指定点</li><li>right：文本右对齐于指定点</li></ul></li><li>va：垂直对齐方式<ul><li>top：文本顶部对齐于指定点</li><li>center：文本中部对齐于指定点</li><li>bottom：文本底部对齐于指定点</li></ul></li></ul></li></ul></li><li>plt.savefig：保存图片，例如plt.savefig('fig.eps')</li><li>plt.rcParams<ul><li>改变图片大小（单位为英寸）：plt.rcParams['figure.figsize']=(6.0,4.0)# 默认是(6, 4)</li><li>改变图片保存时清晰度：plt.rcParams['savefig.dpi'] = 100 #默认是100</li><li>改变图片显示的清晰度：plt.rcParams['figure.dpi'] = 100 #默认是100</li><li>Note：改变dpi只对栅格图有效，矢量图无需设置dpi，清晰度都一样的</li></ul></li></ul><hr /><h3 id="sympy">sympy</h3><p>一般使用即from sympy import *。</p><p>启用美化打印：init_printing(use_unicode=True,use_latex=True)。（配合display使用而不是print）</p><h4 id="矩阵相关">矩阵相关</h4><ol type="1"><li><p>定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = symbols(<span class="string">&#x27;x y z&#x27;</span>)</span><br><span class="line">v = Matrix([x, y, z])</span><br><span class="line">M = Matrix([</span><br><span class="line">    [x, y, z],</span><br><span class="line">    [x, y, z],</span><br><span class="line">    [x, y, z]</span><br><span class="line">])</span><br><span class="line">v_norm = symbols(<span class="string">&#x27;\|v\|&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>常用函数</p><ul><li>M.det()：返回M的行列式</li><li>M.inv()：返回矩阵的逆（如果存在）</li><li>M.T：返回转置</li><li>Eq(left, right)：返回left = right这个方程</li><li>solve(eq,goal)：对于eq这个方程(eq是个Eq对象)，求解goal目标变量的取值</li></ul></li><li><p>实战例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line">init_printing(use_unicode=<span class="literal">True</span>, use_latex=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">rho = symbols(<span class="string">&#x27;rho&#x27;</span>)</span><br><span class="line">varrho = symbols(<span class="string">&#x27;varrho&#x27;</span>)</span><br><span class="line">L1, L2, L3 = symbols(<span class="string">&#x27;L_1 L_2 L_3&#x27;</span>)</span><br><span class="line">AI_norm = symbols(<span class="string">&#x27;\|A-I\|&#x27;</span>)</span><br><span class="line">IJ_norm = symbols(<span class="string">&#x27;\|I-J\|&#x27;</span>)</span><br><span class="line">beta = symbols(<span class="string">&#x27;beta&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Matrix([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, rho, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, L2 * varrho * AI_norm * IJ_norm + beta * (<span class="number">1</span> + rho), <span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">alpha = symbols(<span class="string">&#x27;alpha&#x27;</span>)</span><br><span class="line">mu = symbols(<span class="string">&#x27;mu&#x27;</span>)</span><br><span class="line">tau = symbols(<span class="string">&#x27;tau&#x27;</span>)</span><br><span class="line"></span><br><span class="line">E = Matrix([</span><br><span class="line">    [-<span class="number">1</span> * mu, L1, L3],</span><br><span class="line">    [varrho * L1 * L3 * (<span class="number">1</span> + tau * varrho * L3) * IJ_norm, varrho * L1 * L3 * IJ_norm, varrho * L3 * L3 *  IJ_norm],</span><br><span class="line">    [varrho * L1 * L2 * (<span class="number">1</span> + varrho * L3) * (<span class="number">1</span> + tau * varrho * L3) * IJ_norm, varrho * L1 * L2 * (<span class="number">1</span> + varrho * L3) * IJ_norm, varrho * L2 * L3 * (<span class="number">1</span> + varrho * L3) * IJ_norm]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">M = X + alpha * E</span><br><span class="line"></span><br><span class="line">I = eye(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">eq = Eq((I - M).det(), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ans = solve(eq, alpha)</span><br><span class="line"></span><br><span class="line">display(ans)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;说是进阶，其实就讲了三个数据分析常用包：numpy、pandas、matplotlib&lt;/p&gt;</summary>
    
    
    
    <category term="2. 技能栈" scheme="http://error666.top/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/"/>
    
    <category term="Python" scheme="http://error666.top/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="http://error666.top/2024/02/23/Python%E5%9F%BA%E7%A1%80/"/>
    <id>http://error666.top/2024/02/23/Python%E5%9F%BA%E7%A1%80/</id>
    <published>2024-02-23T15:08:48.000Z</published>
    <updated>2024-07-19T17:08:05.770Z</updated>
    
    <content type="html"><![CDATA[<p>什么？你连基本的Python相关知识都不会？</p><span id="more"></span><h3 id="顺序判断循环">顺序、判断、循环</h3><ol type="1"><li><p>变量类型</p><ol type="1"><li>int、float、str、bool</li><li>list（列表）[1, 2, 3]</li><li>tuple（元组）(1, 2, 3)</li><li>set（集合）{1, 2, 3}</li><li>dict（字典）{1: “python”, “acwing”: 2, 3: 4.0}</li></ol></li><li><p>输入</p><ul><li><p>使用input()函数，input()函数可读入一行内容，返回类型为str。一般配合split()、map()函数使用。</p><ul><li>a = (int)(input()) b =(int)(input())：读入两个整数，一个整数一行。</li><li>a, b = map(int, input().split())：读入两个空格隔开的整数。</li><li>split()会将一行字符串以空格作为分割符分开，返回一个字符串列表。map(func,var)会将func作用于var里的每个元素，返回作用后的var。</li><li>a = list(map(int, input().split())))：读入一行数存到列表a中</li></ul></li><li><p>当不知道读入的行数时，使用下列代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdin</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> stdin.readlines():</span><br><span class="line">  <span class="built_in">print</span>(line.strip()) <span class="comment"># strip()是为了去掉行末的回车</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>输出</p><ul><li>print(val1, val2, ...,end='')：输出多个内容默认用空格隔开，可自定义结尾字符<ul><li>round(x, 1)：将x保留1位小数</li><li>print("x = %.2f, y = %.3f" % (x,y))：同样也可以用格式化输出（%分割，后面多个参数的话要用括号括起来）</li><li>格式化输出想输出%的话，写%%</li></ul></li></ul></li><li><p>if/while/for里的变量，在语句外可以访问</p><ul><li><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">    max_value = a</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    max_value = b</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(max_value)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>条件表达式</p><ol type="1"><li>and、or、not：与或非</li><li>max_value = a if a &gt; b elseb：三目运算符，max_value=a仅当a&gt;b时成立，否则=b</li></ol></li><li><p>运算</p><ol type="1"><li>a, b = b, a：交换两个数</li><li>python支持链式运算，例如if a &gt;= b &gt;= c: ...</li></ol></li><li><p>for循环</p><ol type="1"><li>for c in "abc"：依次输出每个字符</li><li>for i in range(r)：输出0, 1, ..., r - 1</li><li>for i in range(l, r)：输出l, l + 1, ... , r - 1</li><li>for i in range(l, r + 1, 2)：在[l, r]范围内，输出l, l + 2, l + 4,...</li></ol></li></ol><hr /><h3 id="列表">列表</h3><ul><li>初始化<ul><li>用循环 + append初始化</li><li>直接初始化<ul><li>a = [0 for i in range(3 + 1)]：a此时为[0, 0, 0, 0]</li><li>a = [i * i for i in range(3 + 1)]：a此时为[0, 1, 4, 9]</li></ul></li></ul></li><li>切片<ul><li>a[l:r]：返回a[l], a[l+1], ..., a[r-1]（l、r可缺省）</li><li>a[1:]：返回a[1], a[2], ... a[len(a) - 1]</li><li>a[1:3] = [2, 3]：等价于a[1]=2, a[2]=3</li><li>a[1:3] = [0]：等价于a[1]=0，把a[2]删掉</li><li>a[1:3] = []：等价于把a[1]、a[2]删掉</li></ul></li><li>复制<ul><li>不能用等号复制，用等号复制的话相当于新列表只是原列表的一个别名。修改新列表仍会对原列表产生影响。</li><li>用切片复制即可，即b = a[:]</li></ul></li><li>列表的运算<ul><li>列表的加法可以将两个列表拼接起来，得到一个新列表。</li><li>列表乘以一个整数，可以将若干个自身拼接起来，得到一个新列表。</li><li>将列表中的每个元素加上一个1<ul><li>a = [x + 1 for x in a]</li></ul></li></ul></li><li>列表常用函数<ul><li>len(a)：返回列表长度</li><li>a.append(x)：尾部插入x</li><li>a.insert(pos, x)：在pos处插入x</li><li>a.pop()：删除尾部最后一个元素</li><li>a.pop(pos)：删除下标为pos处的元素</li><li>a.reverse()：翻转</li><li>a.sort()：排序<ul><li>a.sort(key=lambda x: (x[1],x[0]))：a是一个列表，列表里的元素也是列表（里头有2个数），想先按照第二关键字排序，相等再按照第一关键字排序，就这样写。（默认是从小到大，从大到小可以加一个负号）</li></ul></li></ul></li></ul><hr /><h3 id="字符串">字符串</h3><ul><li>ord(c)：返回一个字符的ascii码</li><li>chr(a)：返回一个ascii码对应的字符</li><li>注意，虽然字符可以跟整数相互转化，但在Python中字符不能参与数值运算</li><li>使用""直接赋值，使用""" """可以赋值多行</li><li>字符串不能修改，切片也不像列表一样支持写操作</li><li>字符串支持加法、乘法、比较运算</li><li>常用函数<ul><li>len(s)：返回字符串长度</li><li>s.split(sep)：返回一个字符串列表。如果给出了sep就按sep分隔；如果没给出，则会按空格分隔，但连续的空格会被视为单个分隔符，而且会忽略首尾的空白字符。</li><li>s.strip()：返回将首尾的空白字符删除后的结果</li><li>s.replace(old, new)：将s中所有的old子串都改成new</li><li>s.find("abc")：查询某个子串在s中第一次出现的下标；如果不存在，则返回-1。</li><li>s.lower()：将所有大写字母变成小写。</li><li>s.upper()：将所有小写字母变成大写。</li><li>s.join(a)：a是一个字符串列表，这个函数返回将a中的字符用s作为分隔符拼接起来的结果。</li><li>s.startswith(prefix)：判断prefix是否为s的前缀。</li><li>s.endswith(suffix)：判断suffix是否为s的后缀。</li></ul></li></ul><hr /><h3 id="元组">元组</h3><ul><li><p>元组跟列表类似，只是不支持动态添加、删除元素，以及不能修改元素。其余用法类似。</p></li><li><p>元组需要用小括号括起来（也可以不加），中间的元素用逗号隔开。如果初始化只包含一个元素的元组，需要在该元素后添加逗号。</p></li><li><p>元组的解包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">x, y, z = t <span class="comment"># 将元组t解包，将元组内的三个值按顺序赋值给x、y、z</span></span><br><span class="line"></span><br><span class="line">a, b = b, a <span class="comment"># 这句话本质也是元组解包，就是将元组(b, a)解包，分别赋值给a, b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y, x * y <span class="comment"># 函数的返回值本质也是元组的解包</span></span><br><span class="line"></span><br><span class="line">a, b = cal(a, b)</span><br></pre></td></tr></table></figure></li></ul><hr /><h3 id="集合">集合</h3><ul><li><p>创建集合用花括号或set()函数。创建空集合只能用set()，不能用{}，因为{}创建的是空字典。</p></li><li><p>初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;  <span class="comment"># 会自动去除重复元素</span></span><br><span class="line"><span class="built_in">print</span>(basket)  <span class="comment"># 重复的元素已经去除了</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">b = <span class="built_in">set</span>(a)  <span class="comment"># 将列表转化成集合，一般是为了去重。</span></span><br><span class="line">c = <span class="built_in">list</span>(b)  <span class="comment"># 将集合转化回列表</span></span><br><span class="line"><span class="built_in">print</span>(b, c)</span><br></pre></td></tr></table></figure></li><li><p>常用函数</p><ul><li>len(a)：返回集合中的元素数量</li><li>a.add(x)：向集合中添加一个元素</li><li>a.remove(x)：删除集合中的x，如果集合中没x则报错</li><li>a.discard(x)：删除集合中的x，如果集合中x不存在也不会管</li><li>x in a：判断x是否在a中</li><li>x not in a：判断x是否不在a中</li></ul></li></ul><hr /><h3 id="字典">字典</h3><ul><li><p>创建字典用花括号或dict()函数。</p></li><li><p>初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tel = &#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;  <span class="comment"># 创建一个字典</span></span><br><span class="line"><span class="built_in">print</span>(tel)  <span class="comment"># 输出 &#123;&#x27;jack&#x27;: 4098, &#x27;sape&#x27;: 4139&#125;</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">dict</span>()  <span class="comment"># 创建一个空字典</span></span><br><span class="line">a[<span class="number">123</span>] = <span class="string">&quot;abc&quot;</span>  <span class="comment"># 在字典中插入一个key-value对</span></span><br><span class="line">a[<span class="number">456</span>] = <span class="string">&quot;def&quot;</span>  <span class="comment"># 在字典中插入一个key-value对</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出 &#123;123: &#x27;abc&#x27;, 456: &#x27;def&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">list</span>(a)  <span class="comment"># 将字典的关键字转化成列表</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出[123, 456]</span></span><br></pre></td></tr></table></figure></li><li><p>常用函数</p><ul><li>len(a)：返回字典中键值对个数</li><li>a[x]：获取关键字x对应的值，如果x不存在，会报异常</li><li>a.get(x)：获取关键字x对应的值，如果x不存在，不会报异常</li><li>a.get(x, y)：获取关键字x对应的值，如果x不存在，会返回默认值y</li><li>del a[x]：删除关键字x对应的元素对</li><li>x in a：字典中是否有x关键字</li><li>x not in a：字典中是否没有x关键字</li><li>a.keys()：返回字典中所有关键字，以列表形式</li><li>a.values()：返回字典中所有值，以列表形式</li><li>a.items()：返回字典中所有键值对，以列表形式，每对键值对是一个元组</li></ul></li></ul><hr /><h3 id="函数">函数</h3><ul><li>函数内定义的变量为局部变量，只能在函数内部使用。当需要修改用全局变量时，需要用global关键字在函数内声明全局变量。</li><li>传参时，传数/str是值传递，列表是引用传递。</li></ul><hr /><h3 id="类">类</h3><ul><li><p>类中函数的第一个参数都是self，用来调用类本身的变量和函数。当调用类中函数的时候，第一个参数self不需要自己传递，Python会自动传递这个参数。</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>:</span><br><span class="line">    hero_count = <span class="number">0</span>  <span class="comment"># 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, level=<span class="number">10</span></span>):  <span class="comment"># 构造函数</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.level = level</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hero %s has been created.&quot;</span> % name)</span><br><span class="line">        Hero.hero_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  <span class="comment"># 定义str()函数的效果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero: %s&quot;</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):  <span class="comment"># 问候</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):  <span class="comment"># 移动</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Move!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_level</span>(<span class="params">self</span>):  <span class="comment"># 获取这个英雄的等级</span></span><br><span class="line">        <span class="keyword">return</span> self.level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_level</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get_level() + <span class="number">1</span>  <span class="comment"># 调用类中的其他函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zeus = Hero(<span class="string">&quot;Zeus&quot;</span>)</span><br><span class="line">athena = Hero(<span class="string">&quot;Athena&quot;</span>, <span class="number">6</span>)</span><br><span class="line">zeus.greet()</span><br><span class="line">athena.move()</span><br><span class="line"><span class="built_in">print</span>(zeus.name, athena.get_level(), athena.next_level())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(zeus), athena)</span><br><span class="line"><span class="built_in">print</span>(Hero.hero_count)</span><br></pre></td></tr></table></figure></li><li><p>每个类可以创建任意多实例。例如上面的Hero类，可以创建zeus和athena等实例。类变量由所有实例共享，一般通过类名访问，例如Hero.hero_count。实例变量与每个具体的实例绑定，一般通过具体实例来访问，例如zeus.name。</p></li><li><p>子类可以继承父类的变量和函数。self可以调用自身和父类中的变量和函数，如果子类和父类的变量或函数重名，优先使用子类的变量和函数。super()可以优先调用父类中的函数。</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>:</span><br><span class="line">    hero_count = <span class="number">0</span>  <span class="comment"># 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, level=<span class="number">10</span></span>):  <span class="comment"># 构造函数</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.level = level</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hero %s has been created.&quot;</span> % name)</span><br><span class="line">        Hero.hero_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  <span class="comment"># 定义str()函数的效果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero: %s&quot;</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):  <span class="comment"># 问候</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):  <span class="comment"># 移动</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Move!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_level</span>(<span class="params">self</span>):  <span class="comment"># 获取这个英雄的等级</span></span><br><span class="line">        <span class="keyword">return</span> self.level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_level</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get_level() + <span class="number">1</span>  <span class="comment"># 调用类中的其他函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zeus</span>(<span class="title class_ inherited__">Hero</span>):</span><br><span class="line">    hero_name = <span class="string">&quot;Zeus&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(Zeus.hero_name, level)  <span class="comment"># 通过super()调用父类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!(from child class)&quot;</span> % self.name)  <span class="comment"># 使用的是父类的`name`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Athena</span>(<span class="title class_ inherited__">Hero</span>):</span><br><span class="line">    hero_name = <span class="string">&quot;Athena&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(Athena.hero_name, level)  <span class="comment"># 通过super()调用父类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!(from child class)&quot;</span> % self.name)  <span class="comment"># 使用的是父类的`name`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zeus = Zeus(<span class="number">6</span>)</span><br><span class="line">athena = Athena(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(zeus.name, athena.level, Hero.hero_count)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(zeus), <span class="built_in">str</span>(athena))</span><br><span class="line">zeus.greet()</span><br><span class="line">athena.greet()</span><br><span class="line"><span class="built_in">print</span>(zeus.get_level())</span><br></pre></td></tr></table></figure></li><li><p>模块可以自定义，自己新建一个文件夹，里头可以写若干个.py文件，但是一定要有一个空的__init__.py文件，这样Python才知道这个文件夹是一个模块。导入函数可以写：from文件夹名.文件名 import 函数名</p></li></ul><hr /><h3 id="包管理">包管理</h3><ul><li>使用conda进行包管理，以下命令使用Anaconda控制台打开</li><li>conda env list：查看当前有哪些虚拟环境（*号是当前所处环境）</li><li>conda activate 环境名：进入某个虚拟环境</li><li>conda list：查看当前虚拟环境内安装了哪些包</li><li>conda install 包名：在当前虚拟环境内安装一个包</li><li>conda create -n xxx python=x.x：创建一个虚拟环境</li><li>conda remove -n xxx --all：删除一个虚拟环境</li><li>conda config --show channels：显示目前包含的源</li><li>conda config --remove-key channels：恢复默认源</li><li>下列添加常用清华源<ul><li>conda config --add channelshttp://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</li><li>conda config --add channelshttp://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</li><li>conda config --add channelshttp://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r</li><li>conda config --add channelshttp://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro</li><li>conda config --add channelshttp://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么？你连基本的Python相关知识都不会？&lt;/p&gt;</summary>
    
    
    
    <category term="2. 技能栈" scheme="http://error666.top/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/"/>
    
    <category term="Python" scheme="http://error666.top/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>算法刷题笔记</title>
    <link href="http://error666.top/2024/02/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://error666.top/2024/02/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-19T16:27:02.000Z</published>
    <updated>2024-04-02T05:44:31.462Z</updated>
    
    <content type="html"><![CDATA[<p>信息学竞赛刷题笔记</p><span id="more"></span><h3 id="思维题">思维题</h3><ul><li><p><a href="https://www.acwing.com/problem/content/97/">95.费解的开关 - AcWing题库</a></p><ul><li>经过思考后，发现一个开关按2次与没按没差别。所以对于每个开关，要不就按，要不就不按。继续思考，对于一个开关，它的状态取决于它自己以及上下左右共5个开关按or不按，而且跟顺序无关。</li><li>接着往下想，既然与顺序无关，那我就可以从第一个开始按。假设（1，1）按了，那么......感觉还是不好想。</li><li>这时要学会给自己增加已知信息。假设我第一行开关按or不按已经知道。那么我就可以推出第二行的按法。因为当第一行按完之后，能改变第一行状态的只有第二行（不能再按第一行了，因为按两次等于没按）。所以如果（1，j）是0，那么（2，j）就要按。</li><li>思路就出来了，枚举第一行的按法，然后推出第二行按法，继续推出第三行按法，直至推出第五行按法。此时1-4行都是1了，最后检查第5行是否全是1即可。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/107/">105. 七夕祭- AcWing题库</a></p><ul><li><p>首先很容易看出行和列是独立的问题，而且本质是一样的。所以接下来都讨论列。</p></li><li><p>然后略加思考也可以发现最终每列的数量就是全部列加起来取平均，取不了平均就没解。</p></li><li><p>假设a1, a2, ...,an平均值为avg，假设1号给2号b1个，2号给3号b2个，n号给1号bn个。则所求可表达为：<spanclass="math inline">\(|b_1|+|b_2|+...+|b_n|\)</span>。且有下列方程组成立：<span class="math display">\[a1 - b1 + bn = avg \\a2 - b2 + b1 = avg \\a3 - b3 + b2 = avg \\... \\an - bn + b_{n-1} = avg\]</span></p></li><li><p>整理可得</p></li></ul><p><span class="math display">\[-b_1+b_n = avg - a_1 \\-b_2+b_n = 2avg - (a_1+a_2) \\-b_3+b_n = 3avg - (a_1+a_2+a_3) \\...-b_{n-1}+b_n = (n-1)avg - (a_1+a_2+...+a_{n-1})\]</span></p><ul><li>继续整理</li></ul><p><span class="math display">\[b_1 = -avg + a_1 + b_n \\b_2 = -2avg + (a_1 + a_2) + b_n \\... \\b_{n-1} = -(n-1)avg + (a_1+a_2+...+a_{n-1})\]</span></p><ul><li>继续整理</li></ul><p><span class="math display">\[b_1 = b_n - avg + a_1 \\b_2 = b_n - 2avg + (a_1+a_2) \\...\\b_{n-1} = b_n - (n-1)avg + (a_1+a_2+...+a_{n-1})\]</span></p><ul><li>令x = bn，则所求为：<spanclass="math inline">\(|x-c1|+|x-c2|+...+|x-c_{n-1}|+|x - c_n|,c_n=0\)</span></li><li>一目了然，x取c的中位数时，所求最小。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/1535/">1533. 1的个数 - AcWing题库</a></p><ul><li>考虑每一位能出现多少次1。</li></ul><p><img src="2.png" /></p><ul><li>如上图，考虑d，如果d是0。那么当d这一位取1的话，左边只能是000 ~(abc-1)，右边可以是000 ~ 999。上图都清晰明了了，分情况讨论即可。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/1643/">1641.狼人杀-简单版 - AcWing题库</a></p><ul><li>枚举哪两个人是狼人，那么此时所有人的身份就确定了。然后检查两个条件。(1):是否有且仅有两个人在说谎；(2):俩狼人中是否有且仅有一个人在说谎。若俩条件满足则是一组解。</li></ul></li></ul><h3 id="基础算法">基础算法</h3><h4 id="位运算">位运算</h4><ul><li><a href="https://www.acwing.com/problem/content/92/">90.64位整数乘法 - AcWing题库</a><ul><li>计算a * b %p的结果。O(1)即可得出结果，但是a和b的范围很大会爆longlong。所以要用时间换空间。考虑a* b = a * (b的二进制表示)，例如a * 5 = a * (101) = a * (4 + 0 +1)。于是很容易的想到用logn的时间去分解b，用个中间变量sum对自己做累加（sum初始值为a），这样sum就会等于a，然后等于2a，然后等于4a......。分解b的过程中如果最后一位二进制是1，就ans +=sum即可。这种用加法代替乘法的方法，叫做龟速乘。</li><li>注意，%的优先级比+高。</li></ul></li><li><a href="https://www.acwing.com/problem/content/877/">875. 快速幂 -AcWing题库</a><ul><li>计算<span class="math inline">\(a^b %p\)</span>的结果。思路跟龟速乘一样，都是分解b。考虑<spanclass="math inline">\(a^b = a^{b的二进制形式}\)</span>，例如<spanclass="math inline">\(a^5 = a^{101} = a^{4 + 0 + 1} = a^4 *a^1\)</span>。用while去分解b的二进制，用个中间变量sum对自己做累乘（sum初始值为b），如果分解过程中b的最后一位二进制是1，就ans*= sum即可。</li></ul></li></ul><h4 id="递归分治">递归/分治</h4><ul><li><a href="https://www.acwing.com/problem/content/description/99/">97.约数之和 - AcWing题库</a><ul><li>求<spanclass="math inline">\(a^b\)</span>的所有约数之和。不难想到分解质因数。假设数num分解为<spanclass="math inline">\(p_1^{k1} \cdot p_2^{k2} \cdot ... \cdotp_n^{kn}\)</span>，那么数num的约数的个数就是(k1 + 1) * (k2 + 1) * ... *(kn +1)（相当于每个质数是材料，可以拿0/1/2/...个）。数num的约数之和就是<spanclass="math inline">\((1+p_1+p_1^2+...+p_1^{k1}) \cdot(1+p_2+p_2^2+...+p_2^{k2}) \cdot ... \cdot(1+p_n+p_n^2+...+p_n^{kn})\)</span>。</li><li>上面的数学推导作为一个大学生不难想出。那么这题思路就是先将a分解质因数，然后将每个质数的次数乘b。然后求<spanclass="math inline">\((1+p_1+p_1^2+...+p_1^{k1}) \cdot(1+p_2+p_2^2+...+p_2^{k2}) \cdot ... \cdot(1+p_n+p_n^2+...+p_n^{kn})\)</span>即可。</li><li>关键<spanclass="math inline">\((1+p_1+p_1^2+...+p_1^{k1})\)</span>怎么求，其实这种看起来有规律的东西都是用递归去加速，根据直觉尝试一下，假设sum= 1, mul = p1，然后while( sum += mul, mul *= mul )。第一次：sum=1+p1,mul=p1<sup>2；第二次：sum=1+p1+p1</sup>2+p1^3, mul = p1^4......你看，这不就出来了。</li><li>递归是俩倍俩倍去递归的，所以最后可能剩一点边角料。假设<spanclass="math inline">\(p_1^{cnt}\)</span>到<spanclass="math inline">\(p_1^{k1}\)</span>还没求，很简单，直接递归调用函数cal(p1,k1-cnt) * ksm(p1, cnt)</li><li>这题坑点较多，注意b有可能为0。注意a可能为0/1。</li></ul></li><li><a href="https://www.acwing.com/problem/content/100/">98. 分形之城 -AcWing题库</a><ul><li>一道找规律模拟题，挺恶心的。本质上就是给一个数num，找出其对应的坐标（x,y）。观察后不难发现，num会落到4个区，其中2、3区的区内坐标就等于上一个等级的对应数的坐标。1区的区内坐标等于上一个等级的对应数的坐标沿[左上到右下对角线]对称的坐标。4区的区内坐标等于上一个等级的对应数的坐标沿[右上到左下对角线]对称的坐标。</li></ul></li></ul><h4 id="前缀和差分">前缀和/差分</h4><ul><li><a href="https://www.acwing.com/problem/content/101/">99. 激光炸弹 -AcWing题库</a><ul><li>简单二维前缀和</li></ul></li><li><a href="https://www.acwing.com/problem/content/102/">100. 增减序列- AcWing题库</a><ul><li>差分题。最关键的一步是要联想到看一看差分数组。做题多就有经验了，这种区间操作问题一般要想到转换为差分数组，然后区间操作问题就转为端点修改问题。</li><li>将a转化为差分数组b后，这题就变成了，将b2~bn全部变为0的最少次数是多少？在最少次数的前提下，b1有多少种取值方式？每一次区间操作等价于将<spanclass="math inline">\(b_i\)</span>加或减1，<spanclass="math inline">\(b_j\)</span>加或减1（i &lt; j &amp;&amp; 1 &lt;= i&lt;= n &amp;&amp; 2 &lt;= j &lt;= n + 1）</li><li>然后由于贪心思想，尽可能将b2~bn中的正负数抵消掉。剩下抵消不掉的数的绝对值+1其实就是b1的不同取值个数。因为剩下不能凑对抵消的只能通过和b1或者<spanclass="math inline">\(b_{n+1}\)</span>凑对来抵消。选择用b1凑对多少次，b1就有多少种取值方式。</li></ul></li></ul><h4 id="二分">二分</h4><ul><li><ahref="https://www.acwing.com/problem/content/description/104/">102.最佳牛围栏 - AcWing题库</a><ul><li>看到平均数就想到整体减平均数，假设答案是一个数，然后每个数减掉这个数，那么只要找出一段区间长度&gt;=f的区间和&gt;=0就可以了。只要找出这样的区间。说明答案还可以更大，如果找不出，答案就要减小。所以二分答案即可。</li><li>关键是如何找到“一段区间长度&gt;=f的区间和&gt;=0”，如果没有区间长度限制O(n)扫一遍用最大连续子段和即可。主要有区间限制，那么就多开一个数组minn[i]表示截止到0~i位置中sum[i]中的最小值即可。（其实这也是最大连续子段和的另一种做法）</li></ul></li><li><a href="https://www.acwing.com/problem/content/1484/">1482. 进制 -AcWing题库</a><ul><li>首先将已知进制的数转为十进制。然后枚举另一个数的进制即可。但是另一个数的进制可能非常大。而且满足进制数越大，转换后的数就越大。所以可以二分。二分右边界是多少呢？极端一点，假设第二个数是10，第一个数是target进制。那么右端点至少要到（第一个数拉满的target进制转为的十进制）才行。</li><li>坑点：如果当前数为tar进制，那么当前数的每一位数都要在[0,tar)中。</li></ul></li></ul><h4 id="排序">排序</h4><ul><li><ahref="https://www.acwing.com/problem/content/description/115/">113.特殊排序 - AcWing题库</a><ul><li>本质上就是裸排序题，用归并或者快排把&lt;号换成题中的compare即可。</li></ul></li></ul><h3 id="贪心">贪心</h3><ul><li><ahref="https://www.acwing.com/problem/content/description/1519/">1517.是否加满油 - AcWing题库</a><ul><li>很多细节的贪心模拟题。</li><li>思路就是在当前加油站，在最远能行驶的距离之内找到第一个价钱比当前加油站低的加油站，然后开过去。如果找不到，就找价钱最少的，然后在当前加油站加满油开过去。如果一个加油站都找不到，就输出无解。</li></ul></li></ul><h3 id="数学">数学</h3><ul><li><a href="https://www.acwing.com/problem/content/1588/">1586.连续因子 - AcWing题库</a><ul><li>用分解因数的方法去枚举连续因子的开头，然后对于每个开头，看看最多能连多少个，取个max即可。</li></ul></li></ul><h3 id="数据结构">数据结构</h3><h4 id="链表">链表</h4><ul><li><ahref="https://www.acwing.com/problem/content/description/828/">826.单链表 - AcWing题库</a><ul><li>其实上链表的模拟题几乎都可以用数组去做。</li><li>其实用数组模拟的思路很暴力，假设有N次操作，那么就实例化N个结构体对象。给每次操作分配一个node，每个node里有l,r,x。然后按照题目要求改变node的l、r即可。（l、r初始为-1，a[0]为虚拟头节点）</li></ul></li></ul><h4 id="并查集">并查集</h4><ul><li><a href="https://www.acwing.com/problem/content/1252/">1250.格子游戏 - AcWing题库</a><ul><li>乍一看题目觉得很复杂，但实际上想到把二维转为一维就简单了。给每一个二维坐标赋予一个独一的一维坐标。每次一条边就是将两个点merge起来。如果一条边的两个点已经在一个集合里面了，说明产生了环。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1254/">1252.搭配购买 - AcWing题库</a><ul><li>将所有捆绑在一起的东西看作一个物品，然后01背包即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/239/">237.程序自动分析 - AcWing题库</a><ul><li>对于一组约束，将相等条件都用并查集并起来。然后依次检查不相等条件的两个点是否在同一集合中，如果在就是NO。全部检查完没问题就是YES。</li></ul></li><li><a href="https://www.acwing.com/problem/content/241/">239. 奇偶游戏- AcWing题库</a><ul><li>这题涉及到区间问题，都应该往是否可以转换成“前缀和数组和差分数组上的区间俩端点“问题这个方向思考。这题考虑前缀和数组sum，区间[l,r]有偶数个1说明sum[r]与sum[l - 1]的奇偶性相同，区间[l,r]有奇数个1说明sum[r]与sum[l - 1]的奇偶性不同。</li><li>看出这个后这题就好做了，二分M，每次检查前mid个条件是否满足。显然满足当且仅当是一个二分图，那么用染色法就检查前mid个条件形成的图是不是一个二分图即可。</li><li>这题其实我还这样想过，就是用的[程序自动分析]这题的思路：二分M，每次检查前mid个条件是否满足。检查方法使用并查集，先将前mid个条件中相同条件的俩元素并起来，再检查前mid个条件中不相同条件的俩元素是否在同一集合，在就return0。都检查完了没问题就return 1。</li><li>但上面这样想是错的，因为这题是有个隐藏条件的，任意一个元素，它不是奇数，就是偶数。所以上面并查集的做法是无法做到保证只有两个集合的。例如下面这个例子：</li><li><img src="1.png" /></li><li>通过三句红话其实可以推出这些条件无法共存（不是二分图）。但是上面的并查集做法是检查不出来的。</li><li>如果要用并查集的话要用这种思路：维护d[x]，表示x与父亲的奇偶性（如果俩点奇偶性相同则为0，不相同则为1）。在更新fat[x]的时候顺便更新一下d[x]，那么更新完后d[x]就成为了x与祖先的奇偶性。</li></ul></li><li><a href="https://www.acwing.com/problem/content/240/">238.银河英雄传说 - AcWing题库</a><ul><li>跟上一题一样维护d[x]，表示x到父亲的距离。也是在更新fat[x]时顺便更新一下d[x]即可，更新完后d[x]就成为了x到祖先的距离。</li><li>这题在merge时会用到并查集大小信息，所以还要多维护一个siz[x]。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1555/">1553. 用Swap(0, i) 操作进行排序 - AcWing题库</a><ul><li>很巧妙的解法，没做过很难想出来。</li><li>如果当前位置i上的数是x，那么x向i连一条边。最终形成的图是一个个环。最终想到达到的目的就是n个自环。考虑交换操作会对这个图产生什么影响。如果0跟不在一个环的数交换，那么两个环会合并。如果0跟在一个环的数交换，那么环会分裂成两个。贪心的想，先把所有跟0不在一个环的环合并到0这个环上，然后再一个一个元素分裂出去形成自环即可。那么用并查集维护一下就好了。</li></ul></li></ul><h4 id="对顶堆">对顶堆</h4><ul><li><a href="https://www.acwing.com/problem/content/108/">106.动态中位数 - AcWing题库</a><ul><li>将数分为较大的一部分和较小的一部分。而且保证较大一部分的数的数量在偶数时与较小一部分的数的数量相等，在奇数时较大一部分的数的数量比较小一部分数的数量大1。</li><li>用小根堆b维护较大的一部分，大根堆a维护较小的一部分。每次一进来一个数t，先与b.top()（也就是较大一部分中的最小的数）比较，如果比b.top()小，则把t插入a中。反之，把t插入b中。</li><li>然后就要保证两个堆之间的数量关系。维护一下即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1545/">1543. 栈 -AcWing题库</a><ul><li>相对于上面一题，就多了一个删除操作。</li><li>使用multiset，这玩意内部是自动从小到大排序的。支持插入、删除、用迭代器访问，两个堆分别用俩multiset代替就行了。</li><li>删除要a.erase(a.find(x))，而不是a.erase(x)，后者会把所有x全删掉。</li></ul></li></ul><h4 id="优先双端队列">优先/双端队列</h4><ul><li><a href="https://www.acwing.com/problem/content/1543/">1541.世界首富 - AcWing题库</a><ul><li>把每个人的信息都用结构体记录下来，然后对于每个查询，二分找到左右端点，然后对区间内的点重新sort一遍。这种做法时间过不去，因为n有1e5。极端情况每次查询都要对1e5个元素重新sort。</li><li>看题目年龄最多200，所以考虑以年龄作为索引。相当于每个年龄开一条链，然后把对应年龄人的信息链上去。</li><li>输出规定年龄区间内前m个人的信息，其实就是一个多路合并问题。用一个优先队列解决。</li><li>（P.S.vector类型可以定义为pair/struct，写一个排序函数cmp即可。但是priority_queue里若想实现自己定义的规则，不要用pair最好用struct，而且不是写排序函数，而是写一个重载&lt;的规则，注意规则内部大于要变小于，小于要变大于）</li></ul></li></ul><h4 id="线段树">线段树</h4><ul><li><a href="https://www.acwing.com/problem/content/1275/">1273.天才的记忆 - AcWing题库</a><ul><li>区间查询最大值。</li></ul></li><li><a href="https://www.acwing.com/problem/content/248/">242.一个简单的整数问题 - AcWing题库</a><ul><li>区间修改，单点查询。</li></ul></li><li><a href="https://www.acwing.com/problem/content/244/">243.一个简单的整数问题2 - AcWing题库</a><ul><li>区间修改，区间查询。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1279/">1277.维护序列 - AcWing题库</a><ul><li>区间修改（乘法加法），区间查询。</li><li>假设sum' = sum * a + b，那么加一个数sum' + c = sum * a + (b +c)，相当于加法标记加了个c；乘一个数sum' * c = sum * ac +(bc)，相当于加法和乘法标记都自乘了个c。所以就这样维护俩标记即可，然后按照sum= sum * mul + add的规则去更新sum即可。</li><li>但如果假设sum' = (sum + a) * b，那么加一个数sum' + c = sum * b + ab+ c，你看，就不好可持续性维护了。</li><li>这题注意build初始化时每个t[p]的mul标记都要初始化为1。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1277/">1275. 最大数- AcWing题库</a><ul><li>动态维护后L个数中的最大值，可以发现数组的数量是只会增加不会减少的，而且数组元素数量最多增长到2e5。所以对数组下标建一颗线段树维护区间最大值即可。单点修改+ 区间查询。</li></ul></li><li><a href="https://www.acwing.com/problem/content/246/">245.你能回答这些问题吗 - AcWing题库</a><ul><li>考虑t[p]的最大子段和sm如何转移：max(t[p1].sm, t[p2].sm,跨过mid的最大子段和)。跨过mid的最大子段和 = t[p1]的最大后缀和 +t[p2]的最大前缀和。</li><li>所以t[p]需要维护最大子段和sm，最大前缀和lm，最大后缀和rm，在维护lm,rm时还会用到区间和sum。</li><li>查询区间[l, r]时，ask函数应返回一个Tree类型，当l &lt;= mid &lt;=r（mid = (t[p].l + t[p].r) / 2）时，可以通过子树t1,t2表示出状态。如果不返回Tree类型的话，就没有子树t1,t2的信息，状态不好表示出来。</li></ul></li><li><a href="https://www.acwing.com/problem/content/247/">246.区间最大公约数 - AcWing题库</a><ul><li>由更相减损术可知gcd(a, b) = gcd(a, b -a)。次公式可扩展到多个变量：gcd(a, b, c, d) = gcd(a, b - a, c - b, d -c)，这其实就是差分形式。所以可以线段树维护原数组的差分数组的区间gcd和区间和，那么操作1就是单点修改（单点修改那可以完全不用考虑懒标记问题了很舒服），操作2求gcd(A[l],A[l + 1], A[l + 2], ..., A[r]) = gcd(A[l], A[l + 1] - A[l], A[l + 2] -A[l + 1], ..., A[r] - A[r - 1]) = gcd(差分数组[1 ~ l]之和，差分数组[l +1到r]的gcd)。</li><li>这题有俩小细节，第一差分单点修改r +1有可能到n外边去，第二查询时如果l = r则要特判下。</li></ul></li><li><a href="https://www.acwing.com/problem/content/249/">247.亚特兰蒂斯 - AcWing题库</a><ul><li>扫描线算法，扫描线算法是个比较死的算法，因为其有一个特殊性质：线段是成对出现的。</li><li>做法两种，我喜欢这种：维护区间最小值min和区间最小值的长度minlen。这样，如果t[1].min= 0，则被覆盖的长度 = 全部长度 - t[1].minlen。如果t[1].min !=0，则被覆盖的长度 =全部长度。区间最小值和区间最小值长度都非常好维护，区间修改就是给最小值打个懒标记即可，不用管minlen，因为最小值加一个数减一个数仍然是最小值，minlen不会变。</li><li>上面就是扫描线的做法。所以扫描线很简单，关键这题的细节处理有点点小麻烦。</li><li>一，坐标都是小数，所以需要离散化处理成整数才能建线段树。二，t[p]管理的实际区间为getVal(t[p].r+ 1) -getVal(t[p].l)，因为只有这样，线段树的子节点才可以初始化minlen，不然minlen不好初始化。三，离散化的俩函数getRank,getVal的参数类型要注意。</li></ul></li><li><a href="https://ac.nowcoder.com/acm/contest/67742/H">H-Tokitsukazeand Power Battle (hard)_2024牛客寒假算法基础集训营2</a><ul><li>是“最大区间和”的变形题。</li><li>考虑i，j的位置，如果i，j都在mid左边是一种情况，即t[p].ans =t[p1].ans。如果i，j都在mid右边是一种情况，即t[p].ans =t[p2].ans。如果i，j分布在mid两边，则需要考虑x(即中间砍的那一刀)的位置。</li><li>如果砍的一刀在mid, mid + 1之间，则t[p].ans =t[p1].包含右端点的最大后缀和 - t[p2].包含左端点的最小前缀和。</li><li>如果砍的一刀在左半边，则t[p].ans = t[p1].包含右端点的答案 -t[p2].包含左端点的最小前缀和。</li><li>如果砍的一刀在右半边，则t[p].ans = t[p1].包含右端点的最大后缀和 +t[p2].包含左端点的答案。</li><li>所以t[p].ans就是在上面几种情况取max。发现用到了“包含右端点的最大后缀和rmax”，“包含左端点的最小前缀和lmin”，“包含右端点的答案rans”，“包含左端点的答案lans”，rmax和lmin很好维护，现在来看lans和rans如何维护。</li><li>先考虑t[p].lans。此时i是卡死的就在l上，考虑j的位置。如果j左半边，则t[p].lans= t[p1].lans。如果j在右半边，则考虑砍的一刀位置，如果砍在mid,mid+1中间，则t[p].lans = t[p1].sum -t[p2].lmin；如果砍在左半边，则t[p].lans = t[p1].包含左右端点的答案 -t[p2].lmin；如果砍在右半边，则t[p].lans = t[p1].sum + t[p2].lans。</li><li>t[p].rans同理。发现在维护这俩的时候还用到了"包含左右端点的答案lrans"。</li><li>现在考虑t[p].lrans。因为i，j都定死了，所以只需考虑砍的一刀的位置。如果砍在mid,mid+1中间，则t[p].lrans= t[p1].sum - t[p2].sum。如果砍在左半边，则t[p].lrans = t[p1].lrans -t[p2].sum。如果砍在右半边，则t[p].lrans = t[p1].sum + t[p2].lrans。</li></ul></li></ul><h4 id="树状数组">树状数组</h4><ul><li><a href="https://www.acwing.com/problem/content/109/">107.超快速排序 - AcWing题库</a><ul><li>求逆序对。</li></ul></li><li><a href="https://www.acwing.com/problem/content/243/">241. 楼兰图腾- AcWing题库</a><ul><li>简单的求每个数之前比它大的数的个数。</li></ul></li><li><a href="https://www.acwing.com/problem/content/245/">244.谜一样的牛 - AcWing题库</a><ul><li>最后一头牛的高度是确定的，在确定最后一头牛高度后，倒数第二头牛的高度也确定了，依次类推。假设现在要求第i头牛的高度，则若数组c的区间和[1,k] = 比第i头牛矮的牛数量 + 1，则第i头牛的高度为k（最开始每个位置的c[i] =1）。</li><li>区间和查询用树状数组，找高度时配合二分。找到该牛高度k后，upd(x,-1)。</li></ul></li></ul><h4 id="字典树">字典树</h4><ul><li><a href="https://www.acwing.com/problem/content/837/">835.Trie字符串统计 - AcWing题库</a><ul><li>板子题，字典树空间一般不知道开多少合适，建议用vector。就比如这题，开个vector&lt;Node&gt;a。Node结构体里放指向信息，这题的指向信息有26个，就在Node里开一个alpha[26]。</li><li>从根节点编号0出发，若a[0].alpha[k] =0，那就新开一个点，a[0].alpha[k] = ++dex,a.push_back(tmp)即可。然后编号跳到a[0].alpha[k]，继续依次类推。</li><li>通过这种方法，就不需要考虑空间应该开多大了。</li></ul></li><li><a href="https://www.acwing.com/problem/content/145/">143.最大异或对 - AcWing题库</a><ul><li>思考每个数的二进制形式，将每个数的二进制形式insert到字典树中（字典树就两个指向信息p[0/1]），然后对于每个数，依次扫二进制的每一位数k，在字典树里找a[p].nxt[k^1]是否存在，存在p就指向它，不存在就指向a[p].nxt[k]。在过程中统计答案求最大值即可。</li></ul></li><li><ahref="https://www.acwing.com/problem/content/description/258/">256.最大异或和 - AcWing题库</a><ul><li>涉及到区间异或运算，所以尝试是否可以前缀和/差分转化为单点运算，发现是可以的。考虑维护前缀异或数组，s[i]= a[1] ^ a[2] ... ^ a[i]，这样a[p] ^ a[p + 1] ^ a[p + 2] ^ ... ^ a[n] =s[n] ^ s[l - 1]。所以所求为x ^ s[n] ^ s[p - 1]。(x ^s[n])是一个定值C，所以就是在[l - 1, r - 1]内找一个数s[i]，使得s[i] ^C最大。所以就是可持久化Trie树。</li><li>可持久化Trie树就是每次添加一条链，具体算法是p = root[now], q =root[now - 1]。然后p的所有子节点除了新链上的点，复制q的节点，然后p =t[p][k] = ++dex, q = t[q][k]。再递归进行直至把这条链添加进Trie树。</li></ul></li></ul><h3 id="模拟">模拟</h3><ul><li><a href="https://www.acwing.com/problem/content/1496/">1494.银行排队 - AcWing题库</a><ul><li>还行的一道模拟题，考虑时间轴，每个人要等的时间 = 到他的时间 -他到的时间。用一个优先队列维护正在办理业务的人，按照谁先结束排序。</li><li>通过这题可以学到priority_queue是可以自定义排序规则的，只需要重载&lt;号（类型一定要是结构体不能是pair）</li></ul></li><li><a href="https://www.acwing.com/problem/content/1559/">1557.说话方式 - AcWing题库</a><ul><li>坑点比较多，有可能有ab:cc/a:::bcc/a:aa:b...的情况。</li><li>通过这题可以学到map也是可以排序的。只需要vector&lt;PAIR&gt;vec(mp.begin(),mp.end())，即可把mp转换成一个vector。然后用sort对vector排序即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1488/">1486.排队等候 - AcWing题库</a><ul><li>跟“银行排队”那题比较像，这题多了一个“等待区”的概念，而且没有了具体的时间。所以不像上一题好写。所以学会自己给自己增加条件，用一个循环模拟时间线（因为17点下班所以复杂度不会很高）。然后对于当前第T秒，先把每个窗口办理完手续的人赶出去，然后再依次把人放进等待区，分配到对应的窗口。</li><li>这题坑点是即使一个人它开始办理业务的时间超过了17点，它也要分配到对应的窗口，因为对于他自己，是不知道前面的人需要多久的，所以他肯定会排进某个窗口的队里。</li></ul></li></ul><h3 id="dp">DP</h3><h4 id="背包">背包</h4><ul><li><p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题- AcWing题库</a></p><ul><li>01背包，复杂度O(n * m)，一维倒序</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/3/">3.完全背包问题 - AcWing题库</a></p><ul><li>完全背包，复杂度O(n * m)，一维正序</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/4/">4.多重背包问题 I - AcWing题库</a></p><ul><li>朴素多重背包，复杂度O(n * m * s)，当成01背包做</li></ul></li><li><p><ahref="https://www.acwing.com/problem/content/description/5/">5.多重背包问题 II - AcWing题库</a></p><ul><li>二进制优化多重背包，复杂度O(n * m * logs)</li><li>原理即用1、2、...、exp、s - exp凑出[1, s]总中任意一个数</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/6/">6.多重背包问题 III - AcWing题库</a></p><ul><li>单调队列优化多重背包，复杂度O(n * v_max),v_max为物品中最大的体积</li><li>先列出递推表达式，然后把j - v, j - 2v, ...r的表达式也一起列出来。然后画个数轴，发现是个滑动区间。</li></ul><p><img src="3.png" /></p><ul><li>那么三重循环，第一枚举物品，第二枚举余数（从0到v-1），第三从r枚举到m，每次+=v，同时开始滑动。</li><li>更新的时候注意w的数量，假设更新f[j]用到了f[k]，那么f[k]的w的数量就是(j- k) / v * w。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/9/">9.分组背包问题 - AcWing题库</a></p><ul><li>多重背包是看选0个、还是1个、2个。分组背包就是看选第1个、还是第2个。第一重枚举组，第二重枚举体积，第三重枚举组内物品。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/11/">11.背包问题求方案数 - AcWing题库</a></p><ul><li>这题不是求“恰好装满某容量的方案数”，如果是求前面这个问题的话用一个计数数组跑一遍01背包即可，g[0]= 1。</li><li>这题是求最优选法的方案，所以计数数组含义仍然不变，g[i]表示恰好装好容量为i的方案数，把f数组含义变一下，f[i]表示<strong>恰好</strong>用容量i的包装出的最优价值。这样的话，就需要memset(f,-0x3f, sizeof f), f[0] = 0。然后跑一遍01即可。最后统计的时候在f[1 ~m]中找出最优价值，然后再在g[1 ~ m]中统计最优价值的方案数之和。</li></ul></li><li><p><ahref="https://www.acwing.com/problem/content/description/12/">12.背包问题求具体方案 - AcWing题库</a></p><ul><li>求具体方案。用二维背包去求，先跑一遍二维01。再去逆推出方案。</li><li>注意因为字典序从小到大，所以做01时要倒着做，这样最后选的最后字典序最小的，逆推的时候就可以从最小的开始。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/1595/">1593.整数分解 - AcWing题库</a></p><ul><li>很巧的一道题。对于样例，背包体积容量169(m)，重量容量5(k)。物品个数是其约数个数n，每个物品的价值是约数的p次方，体积是约数的p次方，重量是1。按字典序大输出，即做完全背包时按约数从小到大，这样倒序找方案的时候就是从大到小。</li></ul></li></ul><h4 id="树形dp">树形dp</h4><ul><li><a href="https://www.acwing.com/problem/content/10/">10.有依赖的背包问题 - AcWing题库</a><ul><li>f(i,j)：i为根节点，容量为j时所能装出的最大方案。考虑如何划分，如果x是根节点，如果考虑x儿子节点内部的选择方式的话，方案太多，不好划分。所以考虑按照容量划分，即枚举给每个儿子节点分配多少的容量。</li><li>坑点1：俩重循环，第一重j从m -v[x]到0倒序，之所以倒序是因为对某儿子，容量只会分配给它一次。</li><li>坑点2：自己是必选的，而且只能选1次，所以要倒序枚举：<code>for (int i = m; i &gt;= v[x]; i--) f[x][i] = f[x][i - v[x]] + w[x];</code></li><li>坑点3：因为自己是必选的，如果自己不选，儿子选了也没用，所以要：<code>for (int i = 0; i &lt; v[x]; i++) f[x][i] = 0;</code></li></ul></li></ul><h3 id="图论">图论</h3><h4 id="最短路">最短路</h4><ul><li><a href="https://www.acwing.com/problem/content/1497/">1495.公共自行车管理 - AcWing题库</a><ul><li>题意稍长但不难懂，看完之后第一反应是多关键字最短路。但是除了距离可以在做dij时维护，“发送的自行车最小数量”和“带回车辆最小数量”是无法在dij的时候维护的。因为这两个量需要知道整段路径的信息后才可求出来，不具有最优子结构。</li><li>所以这题思路就是先dij，然后枚举所有最短路，找出符合条件最优的一条。</li><li>dfs过程中维护参数sum表示从起点走到x时路上所有站点需求变化量之和，这样直到到达终点前，每一步若<code>sum &lt; 0，min_carry = max(min_carry, -sum)</code>，到达终点即可求出“发送的自行车最小数量”。“带回车辆最小数量”= sum + 发送的自行车最小数量。</li></ul></li></ul><h4 id="树">树</h4><ul><li><a href="https://www.acwing.com/problem/content/1499/">1497.树的遍历 - AcWing题库</a><ul><li>经典题。给出中序和后序，后序的最后一个点肯定是root，所以在中序里找到root的位置，然后中序的左半边就是左子树，右半边就是右子树。（从而可算出左右子树节点数量）因为后序是左右根，所以后序序列的[起始,起始 + 左子树数量 - 1]是左子树，[起始 + 左子树数量 - 1 + 1,结束]是右子树。这样就分别在中序和后序序列中得到了左右字数，然后递归即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1529/">1527.判断二叉搜索树 - AcWing题库</a><ul><li>经典题。本质上和上一题一样，因为这题的树是二叉搜索树。而BST的中序遍历就是元素从小到大排序。所以它的中序遍历相当于已经告诉你了。然后它又告诉了你前序遍历。那么根据这俩序列，按照上一题的方法，就可以构造出树了。</li><li>跟上一题不同的是，这里的元素可能会重复。其实问题不大，因为题目中说“左子树上所有结点的值均小于它的根结点的值”，所以若x在中序遍历中出现多次，找最左边的即可。</li><li>然后这题让我们输出后序遍历，其实在构造的时候，在dfs的return前加一句ans[++dex]= root，即可得到后序遍历。</li><li>最后这题还有个翻转机制，翻转其实就是中序遍历reverse一下即可，然后找最左边的变成找最右边的，其余都一样。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1602/">1600.完全二叉树 - AcWing题库</a><ul><li>要求判断一棵树是否是完全二叉树。完全二叉树有一个很好的性质，就是可以存到一个长度为n的序列中。假设当前节点编号是x，则父节点编号为x/2，左儿子编号为x* 2，右儿子编号为x * 2 +1，所以检测一棵树是不是完全二叉树，只需按照上述方法把树编号建到序列中。最后检查1~ n序列中有无空的位置即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1552/">1550.完全二叉搜索树 - AcWing题库</a><ul><li>这题很好的结合了完全二叉树和二叉搜索树的特点。前者特点是可用一个数组来存，后者特点是中序遍历为有序。所以以1作为根节点，然后用<em>2,</em>2+1的方式，对树作中序遍历，然后将递增的数字填进相应的位置即可。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;信息学竞赛刷题笔记&lt;/p&gt;</summary>
    
    
    
    <category term="3. 竞赛" scheme="http://error666.top/categories/3-%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>FROST—Fast row-stochastic optimization with uncoordinated step-sizes</title>
    <link href="http://error666.top/2023/12/04/FROST%E2%80%94Fast-row-stochastic-optimization-with-uncoordinated-step-sizes/"/>
    <id>http://error666.top/2023/12/04/FROST%E2%80%94Fast-row-stochastic-optimization-with-uncoordinated-step-sizes/</id>
    <published>2023-12-04T11:49:40.000Z</published>
    <updated>2024-07-19T18:30:02.524Z</updated>
    
    <content type="html"><![CDATA[<p>中文翻译是：非协调步长行随机优化</p><p>个人认为在仔细研读了Distributed那篇文章后，再看这篇文章时，会对双随机、列随机、行随机的算法分别有哪些有一个很好的认识。</p><span id="more"></span><hr /><h3 id="abstract">Abstract</h3><p>本文讨论了构造不出双随机权值的有向图上的分布优化问题。</p><p>现有算法大多采用推和共识算法，利用列随机权值来克服这一问题。列随机权值的形成要求每个代理(至少)知道其输出度，这在诸如基于广播的通信协议中可能是不切实际的。</p><p>与此相反，我们描述了一种适用于不要求出度知识的有向图的快速行随机优化算法。</p><p>该方法的实现很简单，因为每个代理在本地为传入的信息分配权重，并在本地选择合适的步长。我们证明了对于光滑且强凸函数，在最大步长为正且足够小的前提下，算法线性收敛到最优解。</p><hr /><h3 id="introduction">1. Introduction</h3><p>第2节阐述了问题和假设。第3节回顾了使用双随机或列随机权值的相关算法，并展示了这些类型算法分析背后的直觉。在第4节中，我们提供了本文提出的主要算法FROST。在第5节中，我们发展了FROST的收敛性质。第6节给出了仿真结果，第7节总结了本文。</p><p>下面是Notation：</p><p>对于行随机矩阵<spanclass="math inline">\(\underline{A}\)</span>，<spanclass="math inline">\(\pi_r,1_n\)</span>分别是其左右Perron特征向量，满足<spanclass="math inline">\(\pi_r^T1_n = 1\)</span></p><p>对于列随机矩阵<span class="math inline">\(\underline{B}\)</span>，<span class="math inline">\(1_n,\pi_c\)</span>分别是其左右Perron特征向量，满足<spanclass="math inline">\(1_n^T\pi_c = 1\)</span></p><p><span class="math inline">\(\|\|_F\)</span>是Frobenius范数，<spanclass="math inline">\(\|\|_2\)</span>是欧几里得范数，<spanclass="math inline">\(\|\|\)</span>也是一个范数，具体含义看具体那部分的文章</p><p><span class="math inline">\({\otimes}\)</span>表示Kronecker积。</p><hr /><h3 id="problem-formulation">2. Problem formulation</h3><p>如果 j 连向 i ，则<span class="math inline">\((i, j) \in\mathcal{E}\)</span> 另外，目标是最小化总花费，即： <spanclass="math display">\[\min_{\mathbf{x}}F(\mathbf{x})\triangleq\frac{1}{n}\sum_{i=1}^{n}f_{i}(\mathbf{x})\]</span></p><h4 id="assumption-1">Assumption 1</h4><p>图G是无向联通图。</p><h4 id="assumption-2">Assumption 2</h4><p>图G是有向强连通图。</p><h4 id="assumption-3">Assumption 3</h4><p><spanclass="math inline">\(f_i\)</span>是凸函数，且具有有界次梯度。</p><h4 id="assumption-4">Assumption 4</h4><p><spanclass="math inline">\(f_i\)</span>是光滑，且强凸的。（光滑定义：具有连续的导数）</p><p>即满足以下式子： <span class="math display">\[\left\|\nabla f_i(\mathbf{x})-\nabla f_i(\mathbf{y})\right\|_2\leql\|\mathbf{x}-\mathbf{y}\|_2 \\f_i(\mathbf{y})\geq f_i(\mathbf{x})+\nablaf_i(\mathbf{x})^\top(\mathbf{y}-\mathbf{x})+\frac{\mu}{2}\|\mathbf{x}-\mathbf{y}\|_2^2\]</span> 第一个就是导数满足Lipschitz连续，所以<spanclass="math inline">\(f_i\)</span>肯定光滑。</p><p>第二个就是凸函数的定义，因为有不等号右边最后一项的存在，所以<spanclass="math inline">\(f_i\)</span>是个强凸函数。</p><h4 id="assumption-5">Assumption 5</h4><p>网络中的每个玩家都知道自己的编号。</p><h4 id="assumption-6">Assumption 6</h4><p>每个玩家知道它的出度。</p><hr /><h3 id="补充">补充</h3><p>看到这里。我想先停一下。来看一道题：假设每个玩家有一个初始值xi。如果他们都想知道所有玩家初始值的平均值是多少，应该怎么做？</p><p>如果图是平衡的，则用平均一致性算法即可。即类似于：<spanclass="math inline">\(\tilde{\sigma}_i^{k+1}=\sum_{j=1}^Na_{ij}\tilde{\sigma}_j^k\)</span>。</p><p>如果图不平衡，则采用推和算法。 <span class="math display">\[\begin{aligned}&amp;\nu_{k+1}^{i} =\sum_{j=1}^nb_{ij}\nu_k^j,  \\&amp;\mathbf{x}_{k+1}^{i} =\sum_{j=1}^nb_{ij}\mathbf{x}_k^j  \\&amp;\mathbf{z}_{k+1}^{i} =\frac{\mathbf{x}_{k+1}^i}{\nu_{k+1}^i},\end{aligned}\]</span> 每一个点维护两个值：x、v（都是一维的）。所谓推，就是点 j把值xj / 出度推给邻居，把权重vj / 出度推给邻居。所谓和，就是点 i把所有邻居 j 推来的值加一起得到vi，把所有邻居 j推来的权重加一起得到xi。</p><p>注意到，对于任意时刻k，有：<spanclass="math inline">\(\frac{\sum{x_i}}{\sum{v_i}} = \frac{x1 + x2 + ...+ xn}{n} = avg\)</span></p><p>当迭代的次数足够大时，信息已经在网络中充分流转。第 i 个点的<spanclass="math inline">\(x_i\)</span>会收敛到<spanclass="math inline">\(n[\boldsymbol{\pi}_c]_i * avg\)</span>，<spanclass="math inline">\(v_i\)</span>会收敛到<spanclass="math inline">\(n[\pi_c]_i\)</span>，所以<spanclass="math inline">\(\frac{x_i}{v_i} = avg\)</span>。（<spanclass="math inline">\(\pi_c\)</span>是列随机矩阵的右Perron特征向量）</p><p>即每个点的xi / vi都收敛到全局平均值。</p><p>这是一维的情况。</p><p>如果每个玩家的初始值是一个向量xi（权重vi仍然不变初始值为1），则一样的，经过推和算法后，每个玩家的zi都收敛到avg（此时avg就是一个向量）。</p><p>在推和共识上稍加改动，就可以得到下面这个算法： <spanclass="math display">\[\begin{aligned}&amp;\nu_{k+1}^{i} =\sum_{j=1}^nb_{ij}\nu_k^j,  \\&amp;\mathbf{x}_{k+1}^{i}=\sum_{j=1}^nb_{ij}\mathbf{x}_k^j-\alpha_k\nablaf_i\left(\mathbf{z}_k^i\right),  \\&amp;\mathbf{z}_{k+1} =\frac{\mathbf{x}_{k+1}^i}{\nu_{k+1}^i},\end{aligned}\]</span> 下面这个算法只在更新x时加了一个梯度项。</p><p>这样的话，当迭代次数足够多时，第 i 个点的<spanclass="math inline">\(x_i\)</span>会收敛到<spanclass="math inline">\([\boldsymbol{\pi}_c]_i * x^*\)</span>，<spanclass="math inline">\(v_i\)</span>会收敛到<spanclass="math inline">\(n[\pi_c]_i\)</span>，所以<spanclass="math inline">\(\frac{x_i}{v_i} = x^*\)</span>。</p><h3 id="personal-summary">Personal Summary</h3><p>首先是由推和协议衍生出来的算法，推和协议用列随机矩阵可以求出全局平均值（如果玩家动作是动态更新的话，更新sigma时记得+x[i]- xx[i]）。</p><p>因此套一个梯度下降就可以解决聚合游戏问题。</p><p>如果已知最优解都会收敛到一个值的话，可以直接在推和协议中修改加一个梯度项，使得收敛到最优解。为了加快速度，还可以将普通的梯度项改为考虑全局的梯度项。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;中文翻译是：非协调步长行随机优化&lt;/p&gt;
&lt;p&gt;个人认为在仔细研读了Distributed那篇文章后，再看这篇文章时，会对双随机、列随机、行随机的算法分别有哪些有一个很好的认识。&lt;/p&gt;</summary>
    
    
    
    <category term="1. 科研" scheme="http://error666.top/categories/1-%E7%A7%91%E7%A0%94/"/>
    
    
  </entry>
  
</feed>
