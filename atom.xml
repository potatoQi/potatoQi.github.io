<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Error_666</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-24T16:24:54.900Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Error_666</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络自学笔记</title>
    <link href="http://example.com/2024/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/06/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2024-06-22T12:20:35.000Z</published>
    <updated>2024-06-24T16:24:54.900Z</updated>
    
    <content type="html"><![CDATA[<p>参考视频：<ahref="https://www.bilibili.com/video/BV1c4411d7jb?p=4&amp;spm_id_from=pageDriver&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0">计算机网络微课堂-湖科大教书匠</a></p><span id="more"></span><h3 id="一.-导论">一. 导论</h3><ol type="1"><li><p>网络、互联网、因特网</p><p>网络由若干<strong>结点</strong>和连接这些结点的<strong>链路</strong>组成。</p><p>结点可以是手机/主机/打印机/交换机，链路可以是有线/无线。</p><p>多个网络通过<strong>路由器</strong>连接起来，形成<strong>互联网(internet)</strong>。<strong>因特网(Internet)</strong>是最大的互联网。</p><p>互联网的通信协议可以是任意的，因特网的通信协议是TCP/IP协议。</p></li><li><p>因特网的组成</p><p>由边缘部分和核心部分组成。边缘部分就是所有连接在因特网的主机，核心部分就是大量网络和连接这些网路的路由器组成。为连入核心部分的边缘部分提供数据交换服务。</p></li><li><p>三种交换方式</p><ol type="1"><li><p>电路交换</p><ul><li><p>定义：就是很多设备连接到交换机上，交换机感性理解就是有许多入口和出口，它可以指定某个入口的信号发送到某个出口，这样，多个设备就可以同时互不干扰的发送信号了。交换机又可以与交换机相连，扩大网络范围。</p></li><li><p>电路交换的步骤：</p><ol type="1"><li>建立连接（给通信俩主机分配一条物理通信线路）</li><li>传输信号（这条物理通信线路一直被占用）</li><li>释放连接（归还通信资源）</li></ol></li><li><p>电路交换的优缺点</p><ul><li>优点：延迟小，通信线路都双方专属了，能不小吗。而且数据是有序的。</li><li>缺点：建立连接时间长；无法做到很多台主机之间同时相互通信（因为俩俩主机通信时就会占用一条通信线路，但是没有那么多通信线路）</li></ul></li></ul></li><li><p>报文交换</p><ol type="1"><li>定义：就是不建立连接了，也就是不锁死一条通信线路了。而是直接把<strong>报文(发送的数据)</strong>发送到交换机上，然后交换机存储转发给下一个交换机，一直到接收方收到报文为止。</li><li>报文交换的优缺点<ol type="1"><li>优点：无需建立连接；动态分配线路</li><li>缺点：引入了转发时延；需要较大的缓存空间(报文可能很大)</li></ol></li></ol></li><li><p>分组交换</p><ol type="1"><li><p>定义：就是所谓的边缘部分和核心部分，发送方将报文发送到其所连网络中，通过路由器不断的转发，最终转发到接收方中。</p></li><li><p>分组交换步骤</p><ol type="1"><li>构造分组：先讲报文划分成若干个等长的数据段，在每个数据段前加上元数据，这些元数据叫首部。</li><li>存储转发：路由器在拿到分组后，根据首部进行查表转发，找到合适的转发接口，然后转发给下一个路由器</li><li>还原报文：接收方在收到分组后，去掉首部，将数据段组合还原出报文</li></ol><ul><li>Note：对于同一报文的不同分组，分组的路由路径不一定相同，而且分组到达接收者的顺序不一定与发送时的顺序相同。</li></ul></li><li><p>分组交换的优缺点</p><ol type="1"><li>优点：无需建立连接；简化了存储管理（因为对报文进行了切片，所以路由器的缓存区只需固定即可，不论报文多大都可以切片为分组后转发出去）；减小重发数据量（假设传输过程中出错了，报文交换就要重新发送整个报文，但分组交换只需重发出错的那个分组即可）</li><li>缺点：引入了转发时延；更多的元数据信息（切完片后每个分组都有首部）；还原报文时复杂</li></ol></li></ol></li></ol></li><li><p>计算机网络的性能指标</p><ol type="1"><li><p>速率</p><ol type="1"><li>8bit = 1B(byte)，kb = <spanclass="math inline">\(2^{10}\)</span>B</li><li>bit/s (b/s, bps)（速率的单位都是bit，其余的速率单位也要换算为bit来求解）</li><li>kb/s = <span class="math inline">\(10^3\)</span> b/s</li><li>mb/s = <span class="math inline">\(10^6\)</span> b/s</li><li>Gb/s = <span class="math inline">\(10^9\)</span> b/s</li><li>Tb/s = <span class="math inline">\(10^{12}\)</span> b/s</li></ol><ul><li>例题：有一个待发送的数据块，大小为100 MB，网卡的发送速率为100Mbps，则网卡发送完该数据块需要多长时间?</li><li>100 mbps =<span class="math inline">\(10^6\)</span> b/s</li><li>100MB = <span class="math inline">\(2^{20} \cdot 2^3\)</span> =<span class="math inline">\(2^{23}\)</span> b</li><li>所以t = <span class="math inline">\(\frac{2^{23}}{10^6} =8.388608\)</span> s</li></ul></li><li><p>带宽</p><ol type="1"><li>带宽在模电里的定义：即某段频率区间的宽度</li><li>带宽在计网中的定义：即最大传输速率，基本单位为b/s，与速率的单位一样</li></ol></li><li><p>吞吐量</p><ol type="1"><li>定义：表示单位时间内通过某个网络（或信道、接口）的数据量</li><li>吞吐量的上限就是带宽。</li></ol></li><li><p>时延</p><ol type="1"><li>定义：网络时延 = 发送时延 + 传播时延 + 处理时延</li><li>其中，发送时延是计算机将信息发送到网络中的时延，传播时延是网络的信息传播到路由器的时延，处理时延是路由器存储转发的时延</li></ol><ul><li>例题：<img src="1.png" /></li><li>发送时延 = <span class="math inline">\(\frac{100MB}{1Mb / s} =\frac{100 * 2^{30} * 8}{10^6 b/s} = 838.8608s\)</span></li><li>传播时延 = <span class="math inline">\(\frac{1000 * 1000m}{2 * 10^8m/s} = 0.005s\)</span></li></ul></li><li><p>时延带宽积</p><ol type="1"><li>定义：时延带宽积 = 传播时延 * 带宽</li><li>把带宽想象成横截面积，传播时延想象为长度，则乘积就是管道的长度。也就是若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个bit。</li></ol></li><li><p>往返时间</p><ol type="1"><li>定义：双向交互一次所需的时间</li></ol></li><li><p>利用率</p><ol type="1"><li>信道利用率：表示信道有百分之几的时间是被利用的（有数据通过）</li><li>网络利用率：全网络的信道利用率的加权平均</li></ol><ul><li>Note：信道利用率并非越高越好，因为利用率越高，传播时延就越高。</li><li>如果令<spanclass="math inline">\(D_0\)</span>为网络空闲时的时延，<spanclass="math inline">\(D\)</span>为当前的时延，利用率为<spanclass="math inline">\(U\)</span>。则有公式：<spanclass="math inline">\(D = \frac{D_0}{1 - U}\)</span></li></ul></li><li><p>丢包率</p><ol type="1"><li>定义：在一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率</li><li>分组丢失的主要两种情况<ol type="1"><li>分组在传输过程中出现误码，被结点丢弃</li><li>分组在到达分组交换机被丢弃，因为其缓存容量满了</li></ol></li></ol></li></ol></li></ol><h3 id="二.-计算机网络体系结构总览">二. 计算机网络体系结构总览</h3><ol type="1"><li><p>计网体系结构的分类</p><ol type="1"><li>OSI体系结构（法律上的国际标准，但没商用）</li><li>TCP/IP体系结构（事实上的国际标准，已商用）</li><li>原理体系结构（用来教学用的体系结构，是在TCP/IP体系结构上的展开）<ul><li>物理层、数据链路层、网络层、运输层、应用层</li></ul></li></ol></li><li><p>分层的必要性</p><ol type="1"><li>物理层：你需要考虑用什么线(光纤/双绞线)去传输信号，用怎样的物理接口、使用什么信号表示0和1，这些都是物理层要考虑的问题。当把物理层解决的时候，我们就可以实现把信号从本机上发射出去了。</li><li>数据链路层：考虑下面这个场景，一条总线，然后连出很多分线到各个主机上。那么，假设其中一台主机向总线发送了数据，那么他的目标主机咋知道流过的bit流是否是发送给自己的？以及，如果协调各个主机发送的信号争用总线的问题？这些都是数据链路层要解决的问题（提前剧透一下，数据链路层引入了MAC的概念，用于区别网络中的主机）。当解决了数据链路层，我们用可以实现一个网络中的信号传输了。</li><li>网络层：此时视角来到了很很多路由器、网络、主机的大网络。此时，我们面临着如何标识各网络中各主机的问题（剧透：引入IP地址），以及分组如何选择从源点到目的地的路径。这些问题都划分到网络层去解决。解决了网络层，那么数据就可以在大网络里相互传递了。</li><li>运输层：在解决网络层的基础上，假设出现了丢包，或者主机接收到分组后，它咋知道是给QQ？还是给微信？所以，这些都是运输层要考虑的问题。当解决了运输层的时候，就已经可以实现进程之间网络的通信了。</li><li>应用层：这一层就是各种应用的协议，比如万维网的http协议，电子邮件的smtp协议，文件传输的ftp协议，通过各种协议+进程间的交互来完成特定的网络应用。</li></ol></li><li><p>分层思想举例</p><p><img src="2.png" /></p><ul><li>首先，你打开浏览器进程，然后发送一个访问请求，应用层按照http协议构建一个http请求报文，然后丢给运输层。</li><li>运输层在http报文的首部添加一个tcp首部，为了区分应用进程和可靠传输，此时成为tcp数据报。</li><li>网络层在tcp数据报添加一个ip首部，为了使ip数据报在互联网上运行，此时成为ip数据报。</li><li>数据链路层在ip数据报添加一个首部和尾部ETH，为了让其在一个网络/链路上传输，此时成为帧。</li><li>物理层在帧前加前导码，然后传输</li></ul></li><li><p>计网体系结构专用术语</p><ul><li>专业术语来源于OSI的七层协议体系结构，但也适用于TCP/IP的四层体系结构和五层协议原理体系结构。</li></ul><p><img src="4.png" /></p><ol type="1"><li><p>实体</p><ol type="1"><li>实体定义：任何可发送或接收信息的硬件或软件进程</li><li>对等实体定义：收发双方相同层次中的实体</li></ol></li><li><p>协议</p><ol type="1"><li><p>定义：控制两个对等实体进行<strong>逻辑通信</strong>的规则的集合。</p><ul><li>比如http协议是控制在应用层的俩对等实体进行通信的规则。tcp/udp协议就是运输层的协议，ip就是网络层的协议</li></ul></li><li><p>协议的三要素</p><ol type="1"><li><p>语法：定义所交换信息的格式，例如IP协议所添加的ip数据报格式如下：</p><p><img src="3.png" /></p></li><li><p>语义：定义收发双方所要完成的操作</p><ul><li>就是收到报文后双方要做的动作。以http协议为例，接收方收到http请求报文后，先查找，然后返回一个响应报文。</li></ul></li><li><p>同步：定义收发双方的时序关系</p></li></ol></li></ol></li><li><p>服务</p><ol type="1"><li>定义：在协议的控制下，两个对等实体间的逻辑通信使得本层能向上一层提供服务。要实现本层协议，还需要使用下面一层所提供的服务。</li></ol><ul><li>Note：协议是“水平”的，服务是“垂直”的</li></ul></li><li><p>服务访问点</p><ul><li>定义：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区别不同的服务类型。（目前还没搞懂，以后再来填坑）</li><li>数据链路层的服务访问点为帧的“类型”字段</li><li>网络层的服务访问点为IP数据报首部中的“协议字段”</li><li>运输层的服务访问点为“端口号”</li></ul></li><li><p>服务原语</p><ol type="1"><li>定义：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。（没搞懂，以后来填坑）</li></ol></li><li><p>协议数据单元PDU</p><ol type="1"><li>定义：对等层次之间的数据包称为该层的协议数据单元</li></ol><ul><li>物理层的PDU：比特流</li><li>数据链路层的PDU：帧</li><li>网络层的PDU：IP数据报</li><li>运输层的PDU：TCP报文段</li><li>应用层的PDU：报文</li></ul></li><li><p>服务数据单元SDU</p><ol type="1"><li>定义：同一系统内，层与层之间交换的数据包称为服务数据单元</li></ol><ul><li>Note：多个SDU可以合成为一个PDU，一个SDU也可以划分为几个PDU</li></ul></li></ol></li></ol><h3 id="习题课">习题课</h3><p>待填坑... ...</p><h3 id="三.">三.</h3>]]></content>
    
    
    <summary type="html">&lt;p&gt;参考视频：&lt;a
href=&quot;https://www.bilibili.com/video/BV1c4411d7jb?p=4&amp;amp;spm_id_from=pageDriver&amp;amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0&quot;&gt;计算机网络微课堂-湖科大教书匠&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>2024上半年算法竞赛游记</title>
    <link href="http://example.com/2024/06/22/2024%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%B8%B8%E8%AE%B0/"/>
    <id>http://example.com/2024/06/22/2024%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E6%B8%B8%E8%AE%B0/</id>
    <published>2024-06-21T16:49:09.000Z</published>
    <updated>2024-06-22T18:45:43.644Z</updated>
    
    <content type="html"><![CDATA[<p>内容包括：ccpc全国邀请赛（山东）、ccpc重庆市塞、ccpc四川省赛</p><span id="more"></span><h3 id="ccpc全国邀请赛山东">ccpc全国邀请赛（山东）</h3><p>赛后没有第一时间写游记，题目忘了。</p><p>酒店不错，比赛场地很大队伍很多，中午的塔斯汀很好吃，题目也能给我们这些菜鸡做对个五六道。</p><p>我记得有俩签到，一个二分，一个模拟。</p><p>然后一个贪心，做过类似的题：<ahref="https://www.acwing.com/problem/content/907/">区间选点</a></p><p>一个普通的最小生成树变式，一个涉及到后缀和的思维题，一个找规律填空题。</p><p>我们应该是做了6题，最后是铜。</p><p>尽力了，从高二以来已经3年没打算法了，这个结果对我来说挺满意。</p><h3 id="ccpc重庆市赛">ccpc重庆市赛</h3><p>赛后没有第一时间写游记，题目忘了。</p><p>志愿者培训没做好，在比赛的时候发出了“讨论请安静点！”的逆天言论，以及比赛开始后才一个个发纸质版题目，差评。以及测评网站用的一个免费的网站，比赛中出现了账号无法登录的问题，差评。</p><p>仨签到。</p><p>然后一个前缀和，做过类似的题，牛客训练赛里的，找不到了。</p><p>然后一个贪心题+简单dfs题。</p><p>还有一题队友写的，不知道是啥算法的题，好像是一道思维题。</p><p>最后金尾。</p><p>遗憾的是有一题hash+二分+dfs的题做了很久没调出来，事后证明思路是正确的，debug能力差了点没弄出来，可惜。</p><h3 id="ccpc四川省赛">ccpc四川省赛</h3><p>赛后没有第一时间写游记，题目忘了。</p><p>场地偏小但凑合，中午的食物质量正常，比赛发的衣服不错，赛后奖品还行。</p><p>但是是上半年发挥最差的一场。</p><p>上去先把仨签到迅速切了，此时的我们是金的排名。</p><p>后面4个小时一题没开出来，难蚌。</p><p>我和另一个队友卡在一个非常非常简单的计算几何，另一个队友卡在一道简单的贪心。</p><p>如果状态好的话，就是5题，银首。</p><p>但世界上没那么多如果，菜就是菜了，最后铜。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;内容包括：ccpc全国邀请赛（山东）、ccpc重庆市塞、ccpc四川省赛&lt;/p&gt;</summary>
    
    
    
    <category term="3. 竞赛" scheme="http://example.com/categories/3-%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>Matlab基础</title>
    <link href="http://example.com/2024/04/25/Matlab%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/04/25/Matlab%E5%9F%BA%E7%A1%80/</id>
    <published>2024-04-24T16:53:52.000Z</published>
    <updated>2024-04-26T15:45:27.353Z</updated>
    
    <content type="html"><![CDATA[<p>学习Matlab，一方面是数模需要，另一方面是Matlab +FigureBest绘制出来的图片非常精美。科研绘图时会用到，所以就学习一下。</p><span id="more"></span><h3 id="界面">界面</h3><p>clear：清空工作区</p><p>clc：清除命令行窗口</p><p>；：语句后加分号结果不显示到命令行中，不加会显示到命令行中</p><p>F5：运行</p><p>ctrl + enter：分块运行</p><p>%%：分块分割注释</p><p>ctrl + r：添加多行注释</p><p>ctrl + t：取消多行注释</p><p>ctrl + 0：跳转到命令行窗口</p><p>ctrl + shift + 0：跳转到编辑窗口</p><p>ctrl + 2：跳转到工作目录窗口</p><p>ctrl + 3：跳转到工作区</p><p><ahref="https://ww2.mathworks.cn/help/index.html">Matlab官方文档</a>：查询各种所需功能&amp; 函数</p><p>填写函数参数时按tab：打开参数提示功能，ctrl + down展开提示</p><h3 id="运算">运算</h3><ul><li><p>特殊变量：ans、pi、inf、-inf</p></li><li><p>数据类型：数字、字符串、矩阵</p></li><li><p>运算符：</p><ol type="1"><li>基本运算符：+、-、*、/、^（乘方）</li><li>常用预算符：abs()、mod(x,y)、sqrt()、exp()、log()、log2()、log10()、round()</li></ol></li></ul><h3 id="矩阵">矩阵</h3><p>Note：下标从1开始</p><ol type="1"><li>矩阵的创建<ol type="1"><li>直接输入：用[]作为标识符，同一行用,分隔，不同行用;分隔</li><li>用预设函数创建：<ol type="1"><li>zeros(x, y)：生成x行y列全0矩阵</li><li>ones(x, y)：生成x行y列全1矩阵</li><li>eye(x)：生成x行x列的单位阵</li><li>rand(x, y)：生成x行y列的矩阵，每个元素在(0, 1)内</li><li>randi([imin, imax], x, y)：生成x行y列的矩阵，每个元素在[imin,imax]内</li><li>randn(x, y)：生成x行y列的矩阵，每个元素服从标准正态分布</li></ol></li><li>导入本地数据创建：<ul><li>支持格式：txt、dat、csv、xls、... ...</li><li>导入方法：在菜单栏选择导入数据即可</li></ul></li></ol></li><li>矩阵的修改<ul><li>A(2, 3) = 0：单点修改</li><li>A(2, :) = 0：第2行全部变为0</li><li>A([1, 2], [1, 2, 3]) = 0：第1、2行的第1、2、3列改为0</li></ul></li><li>矩阵的运算<ol type="1"><li>M1 + M2：对应元素相加</li><li>M + c：矩阵M每个元素加上c</li><li>M1 * M2：矩阵乘法</li><li>M * c：矩阵M每个元素乘上c</li><li>M1 .* M2：矩阵M1、M2对应元素相乘</li><li>M1 ./ M2：矩阵M1、M2对应元素相除</li><li>M ^ c：矩阵M的幂运算</li><li>M'：矩阵M的转置</li><li>inv(M)：矩阵M求逆</li><li>diag(diag(M))：M的对角矩阵</li></ol></li></ol><h3 id="程序结构">程序结构</h3><ol type="1"><li><p>global全局变量</p><ul><li>定义时global声明一次，函数内使用前声明一次</li></ul></li><li><p>if-elseif-else-end</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (... &amp;&amp; ...)</span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">elseif</span> (... &amp;&amp; ...)</span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>for-end</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = x:y <span class="comment">%循环变量i从x到y</span></span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li><li><p>自定义函数</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">res</span> = <span class="title">fun_name</span><span class="params">(var1, var2, ...)</span></span></span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun_name</span><span class="params">()</span></span></span><br><span class="line">    <span class="comment">% TODO</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="图像">图像</h3><ol type="1"><li>axis<ol type="1"><li>axis([xmin, xmax, ymin, ymax])：生成指定坐标范围</li><li>axis equal：x/y轴使用相同的比例</li></ol></li><li>subplot<ol type="1"><li>subplot(n, m,id)：将figure分割为n*m个区域，当前使用第id个区域进行绘图</li></ol></li><li>plot<ol type="1"><li>hold on：使得多个plot画出的线在一个图上</li><li>plot(X, Y)：画出点(x1, y1), (x2, y2), ...并连线</li><li>plot(Y)：画出(1, y1), (2, y2), ...并连线</li><li>plot(x, y, '.')：画坐标点(x, y)</li></ol></li><li>title<ol type="1"><li>title('xxx')：起名</li></ol></li><li>xlabel/ylabel<ol type="1"><li>xlabel('xxx')</li></ol></li><li>legend<ol type="1"><li>legend('name1', 'name2', ...)：图例</li></ol></li><li>改样式<ul><li>交给FigureBest</li></ul></li></ol><hr /><h3 id="实战">实战</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear all; <span class="comment">% 相比于clear, clear all可以清除global变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 定义变量</span></span><br><span class="line"><span class="keyword">global</span> Iter_Num n x r r1 r2 alpha <span class="built_in">beta</span> v s y a ans_x ans_y s_x s_y xx vv ss yy;</span><br><span class="line">Iter_Num = <span class="number">1000</span>;</span><br><span class="line">n = <span class="number">5</span>;</span><br><span class="line">x = <span class="built_in">zeros</span>(<span class="number">1</span>, n);</span><br><span class="line">r = <span class="built_in">zeros</span>(<span class="number">1</span>, n);</span><br><span class="line">r1 = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>];     <span class="comment">% 5个预设点的x坐标</span></span><br><span class="line">r2 = [<span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">3</span>];     <span class="comment">% 5个预设点的y坐标</span></span><br><span class="line">alpha = <span class="number">0.01</span>;</span><br><span class="line"><span class="built_in">beta</span> = <span class="number">0.01</span>;</span><br><span class="line">v = <span class="built_in">diag</span>(<span class="built_in">ones</span>(<span class="number">1</span>, n));</span><br><span class="line">s = phi(x);</span><br><span class="line">y = <span class="built_in">zeros</span>(<span class="number">1</span>, n);</span><br><span class="line">a = [</span><br><span class="line">    <span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">     <span class="number">1</span>/<span class="number">3</span>, <span class="number">1</span>/<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>/<span class="number">3</span>;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">0</span>;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">    ];</span><br><span class="line">ans_x = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">% ans_x[i][j]表示第i个点第j次迭代的x坐标</span></span><br><span class="line">ans_y = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">% ans_y[i][j]表示第i个点第j次迭代的y坐标</span></span><br><span class="line">s_x = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">1</span>);   <span class="comment">% s_x[i][j]表示第i个点第j次迭代x坐标的sigma</span></span><br><span class="line">s_y = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">1</span>);   <span class="comment">% s_y[i][j]表示第i个点第j次迭代y坐标的sigma</span></span><br><span class="line">xx = x;</span><br><span class="line">vv = v;</span><br><span class="line">ss = s;</span><br><span class="line">yy = y;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 开始迭代</span></span><br><span class="line">solve();</span><br><span class="line">fprintf(<span class="string">&#x27;经过%d轮迭代, 最终F(x)收敛到: %f\n&#x27;</span>, Iter_Num, cal(Iter_Num));</span><br><span class="line">draw_1(); <span class="comment">% F_k的比率图</span></span><br><span class="line">draw_2(); <span class="comment">% 画演示图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%下面是画图子函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw_2</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">global</span> Iter_Num;</span><br><span class="line">    <span class="built_in">figure</span> (<span class="number">2</span>);</span><br><span class="line">    subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">    draw_2_sub(<span class="number">1</span>);</span><br><span class="line">    subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">    draw_2_sub(Iter_Num / <span class="number">2</span>);</span><br><span class="line">    subplot(<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    draw_2_sub(Iter_Num);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw_2_sub</span><span class="params">(iter_num)</span></span></span><br><span class="line">    <span class="built_in">hold</span> on;</span><br><span class="line">    <span class="keyword">global</span> n r1 r2 ans_x ans_y;</span><br><span class="line">    axis([<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">10</span>]);</span><br><span class="line">    <span class="built_in">plot</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">        <span class="built_in">plot</span>(ans_x(<span class="built_in">i</span>, iter_num), ans_y(<span class="built_in">i</span>, iter_num), <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">plot</span>([r1(<span class="number">1</span>), r1(<span class="number">2</span>), r1(<span class="number">3</span>), r1(<span class="number">5</span>), r1(<span class="number">4</span>), r1(<span class="number">1</span>)], [r2(<span class="number">1</span>), r2(<span class="number">2</span>), r2(<span class="number">3</span>), r2(<span class="number">5</span>), r2(<span class="number">4</span>), r2(<span class="number">1</span>)], <span class="string">&#x27;Marker&#x27;</span>,<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;Color&#x27;</span>, <span class="string">&#x27;red&#x27;</span>);</span><br><span class="line">    sum_x = <span class="number">0</span>;</span><br><span class="line">    sum_y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">        sum_x = sum_x + ans_x(<span class="built_in">i</span>, iter_num);</span><br><span class="line">        sum_y = sum_y + ans_y(<span class="built_in">i</span>, iter_num);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">plot</span>(sum_x / n, sum_y / n, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">    xlabel(<span class="string">&#x27;$x_1$&#x27;</span>, <span class="string">&#x27;Interpreter&#x27;</span>, <span class="string">&#x27;latex&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;$x_2$&#x27;</span>, <span class="string">&#x27;Interpreter&#x27;</span>, <span class="string">&#x27;latex&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw_1</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">figure</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">global</span> Iter_Num;</span><br><span class="line">    F_best = <span class="number">18.874999999999645</span>;</span><br><span class="line">    error = [];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : (Iter_Num - <span class="number">1</span>)</span><br><span class="line">        error = [error, <span class="built_in">abs</span>(cal(<span class="built_in">i</span> + <span class="number">1</span>) - F_best) / <span class="built_in">abs</span>(cal(<span class="built_in">i</span>) - F_best)];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">plot</span>(error);</span><br><span class="line">    xlabel(<span class="string">&#x27;Iteration k&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;$\frac&#123;f_&#123;k+1&#125; - f^*&#125;&#123;f_k - f^*&#125;$&#x27;</span>, <span class="string">&#x27;Interpreter&#x27;</span>, <span class="string">&#x27;latex&#x27;</span>, <span class="string">&#x27;FontSize&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面是计算子函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">res</span> = <span class="title">cal</span><span class="params">(iter_num)</span></span></span><br><span class="line">    <span class="keyword">global</span> n ans_x r1 ans_y r2 s_x s_y;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">        sum = sum + <span class="number">0.5</span> * ((ans_x(<span class="built_in">i</span>, iter_num) - r1(<span class="built_in">i</span>)) ^ <span class="number">2</span> + (ans_y(<span class="built_in">i</span>, iter_num) - r2(<span class="built_in">i</span>)) ^ <span class="number">2</span>)...</span><br><span class="line">            + <span class="number">0.5</span> * ((ans_x(<span class="built_in">i</span>, iter_num) - <span class="number">5</span>) ^ <span class="number">2</span> + (ans_y(<span class="built_in">i</span>, iter_num) - <span class="number">5</span>) ^ <span class="number">2</span>)...</span><br><span class="line">            + ((s_x(<span class="built_in">i</span>, iter_num) - <span class="number">5</span>) ^ <span class="number">2</span> + (s_y(<span class="built_in">i</span>, iter_num) - <span class="number">5</span>) ^ <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    res = sum;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">global</span> Iter_Num n xx ss ans_x ans_y s_x s_y;</span><br><span class="line">    init(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> T = <span class="number">1</span> : Iter_Num</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">            upd_x(<span class="built_in">i</span>);</span><br><span class="line">            ans_x(<span class="built_in">i</span>, T) = xx(<span class="built_in">i</span>);</span><br><span class="line">            upd_v(<span class="built_in">i</span>);</span><br><span class="line">            upd_s(<span class="built_in">i</span>);</span><br><span class="line">            s_x(<span class="built_in">i</span>, T) = ss(<span class="built_in">i</span>);</span><br><span class="line">            upd_y(<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        backup();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    init(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> T = <span class="number">1</span> : Iter_Num</span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : n</span><br><span class="line">            upd_x(<span class="built_in">i</span>);</span><br><span class="line">            ans_y(<span class="built_in">i</span>, T) = xx(<span class="built_in">i</span>);</span><br><span class="line">            upd_v(<span class="built_in">i</span>);</span><br><span class="line">            upd_s(<span class="built_in">i</span>);</span><br><span class="line">            s_y(<span class="built_in">i</span>, T) = ss(<span class="built_in">i</span>);</span><br><span class="line">            upd_y(<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        backup();</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upd_y</span><span class="params">(i)</span></span></span><br><span class="line">    <span class="keyword">global</span> a ss yy y <span class="built_in">beta</span> n;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : n</span><br><span class="line">        sum = sum + a(<span class="built_in">i</span>, <span class="built_in">j</span>) * ss(<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    yy(<span class="built_in">i</span>) = y(<span class="built_in">i</span>) + <span class="built_in">beta</span> * (ss(<span class="built_in">i</span>) - sum);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upd_s</span><span class="params">(i)</span></span></span><br><span class="line">    <span class="keyword">global</span> a s ss x xx vv n v;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : n</span><br><span class="line">        sum = sum + a(<span class="built_in">i</span>, <span class="built_in">j</span>) * s(<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ss(<span class="built_in">i</span>) = sum + phi(xx(<span class="built_in">i</span>)) / vv(<span class="built_in">i</span>, <span class="built_in">i</span>) - phi(x(<span class="built_in">i</span>)) / v(<span class="built_in">i</span>, <span class="built_in">i</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upd_v</span><span class="params">(i)</span></span></span><br><span class="line">    <span class="keyword">global</span> n a v vv;</span><br><span class="line">    sum = <span class="built_in">zeros</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span> : n</span><br><span class="line">        sum = sum + a(<span class="built_in">i</span>, <span class="built_in">j</span>) * v(<span class="built_in">j</span>, :);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    vv(<span class="built_in">i</span>, :) = sum;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upd_x</span><span class="params">(i)</span></span></span><br><span class="line">    <span class="keyword">global</span> xx x alpha r n y s v;</span><br><span class="line">    xx(<span class="built_in">i</span>) = x(<span class="built_in">i</span>) - alpha * ((x(<span class="built_in">i</span>) - r(<span class="built_in">i</span>)) + (x(<span class="built_in">i</span>) - <span class="number">5</span>) + (<span class="number">1</span> / n) * (y(<span class="built_in">i</span>) + <span class="number">2</span> * (s(<span class="built_in">i</span>) - <span class="number">5</span>) / n / v(<span class="built_in">i</span>, <span class="built_in">i</span>)));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">backup</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">global</span> x v s y xx vv ss yy</span><br><span class="line">    x = xx;</span><br><span class="line">    v = vv;</span><br><span class="line">    s = ss;</span><br><span class="line">    y = yy;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">(op)</span></span></span><br><span class="line">    <span class="keyword">global</span> n x r v s y xx vv ss yy r1 r2</span><br><span class="line">    x = randi([<span class="number">1</span>, <span class="number">5</span>], <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        r = r1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        r = r2;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    v = <span class="built_in">diag</span>(<span class="built_in">ones</span>(<span class="number">1</span>, n));</span><br><span class="line">    s = phi(x);</span><br><span class="line">    y = <span class="built_in">zeros</span>(<span class="number">1</span>, n);</span><br><span class="line">    xx = x;</span><br><span class="line">    vv = v;</span><br><span class="line">    ss = s;</span><br><span class="line">    yy = y;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">res</span> = <span class="title">phi</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="keyword">global</span> n;</span><br><span class="line">    res = x / n;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>经过FigureBest美化后的图片：</p><p><img src="1.png" /></p><p><img src="2.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习Matlab，一方面是数模需要，另一方面是Matlab +
FigureBest绘制出来的图片非常精美。科研绘图时会用到，所以就学习一下。&lt;/p&gt;</summary>
    
    
    
    <category term="2. 技能栈" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/"/>
    
    <category term="Matlab" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/Matlab/"/>
    
    
  </entry>
  
  <entry>
    <title>各种工具使用手册</title>
    <link href="http://example.com/2024/04/25/%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <id>http://example.com/2024/04/25/%E5%90%84%E7%A7%8D%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</id>
    <published>2024-04-24T16:28:29.000Z</published>
    <updated>2024-06-30T18:22:44.700Z</updated>
    
    <content type="html"><![CDATA[<p>工具能大大提升效率。所以掌握有必要掌握一些常用工具。</p><span id="more"></span><h3 id="一.-chatgpt">一. ChatGPT</h3><h4 id="如何订阅gpt4-plus">如何订阅GPT4 PLUS？</h4><ol type="1"><li>去<a href="https://chat.openai.com/">官网链接(openai.com)</a>注册一个OpenAI账号并登录（建议通过Google邮箱注册）</li><li>注册过程中，需要用到手机号验证，使用<ahref="https://sms-activate.org/cn">SMS-Activate</a>解决</li><li>1、2步完成后，就可以使用ChatGPT服务了，但是只能使用3.5而且有次数限制。点击升级，会看到一个支付界面，界面里要填银行卡相关信息。银行卡只能使用美国的。所以在<ahref="https://www.fomepay.com/">FOMEPay</a>上购买一张虚拟美国银行卡，往里充钱。然后将卡号信息填到刚才的界面中即可。</li><li>充值成功，可正常使用ChatGPT4</li></ol><p>（注意，充值过程尽量要全程使用美国IP的梯子！）</p><h4 id="如何使用">如何使用？</h4><p>想怎么用怎么用，推荐几个插件：</p><ol type="1"><li>WebPilot：帮助ChatGPT联网搜索信息</li><li>Wolfram：科学计算，图标绘制</li><li>Tutory：可以帮你制定任意领域的学习路线</li><li>Ai Tool Hunt：找插件的插件</li><li>MixerBox Scholar：可以访问一些学术资源</li></ol><hr /><h3 id="二.-vs-code">二. VS Code</h3><p>VS Code作为最常用的IDE，掌握其使用方法以及相关插件十分必要。</p><p>而且这玩意还可以通过Github同步配置，所以配置一次，永久享用。</p><p>而且VS Code里有终端，于是写项目配合git使用很方便。</p><h4 id="快捷键">快捷键</h4><ul><li>ctrl + ,：设置</li><li>ctrl + shift + p：命令面板</li><li>ctrl + p：最近文件列表</li><li>ctrl + j：切出下面板（用来在代码和终端输入间跳转）</li><li>ctrl + b：隐藏/显示目录</li><li>ctrl + shift + n：新建vscode窗口</li><li>ctrl + 1/2/3：分屏/不同分屏中跳转</li><li>ctrl + alt + right/left：将文件移动到不同分屏中</li><li>alt + ijkl/[]：上下左右/HOME,END（自己改的键）</li><li>alt + up/down：行移动</li></ul><h4 id="插件">插件</h4><h5 id="code-runner">code runner</h5><ul><li>ctrl + alt + n：编译运行程序</li><li>ctrl + c：退出当前命令（死循环时退出运行）</li></ul><h5 id="wsl">WSL</h5><ul><li>直接在本地vscode登入进wsl子系统中的vscode</li><li>或者在wsl中输入code .进入vscode界面</li></ul><h5 id="git-graph">Git Graph</h5><ul><li>装了之后，直接在vscode中就可以查看提交/分支状态</li><li>可以查看每次commit的id/author/date/parents/与上一次commit的不同之处<ul><li>查看与任意一次commit的不同之处：先点一个，再按住ctrl点另一个</li></ul></li></ul><h5 id="todo-tree">Todo Tree</h5><ul><li>TODO表示待办，FIXME表示写了一半还没写完，BUG表示这段程序有问题，HACK表示这段程序可以优化，NOTE表示想法</li><li>这个插件除了方便写注释，还可以充当打标签的作用</li></ul><h5 id="bookmarks">Bookmarks</h5><ul><li>打标签，当程序很长的时候，用鼠标跳转很不方便，用书签跳转就很快。</li></ul><h5 id="jupyter">Jupyter</h5><ul><li>无需安装jupyter notebook即可在vscode实现相同功能</li><li>Esc + M：markdown模式</li><li>Esc + Y：代码模式</li><li>ctrl + enter：运行</li><li>Esc + D, D：删除该单元</li><li>Esc + B：在下方添加一个单元</li><li>Esc + A：在上方添加一个单元</li><li>Esc + L：显示行号</li></ul><h5 id="draw.io-integration">Draw.io Integration</h5><ul><li>画流程图</li></ul><hr /><h3 id="三.-sai2">三. SAI2</h3><p>SAI2的最最最基本使用（我不玩板绘）。主要用来方便授课。</p><p>因为最近接了一个线上一对一的算法家教，所以买了一块数位板（高漫1060pro）方便授课，然后下了个SAI2。</p><p>首先改板子的映射区，这个型号的板子对我来说太大了，手移动距离太多很累。所以把板子工作区域改小。记得去官方下驱动。</p><p>然后是改板子的快捷键，我板子的快捷键从上到下分别是：（对应着SAI2里的功能）</p><ul><li>选中、剪切</li><li>复制、粘贴</li><li>画笔、橡皮</li><li>ctrl、shift</li><li>文字、ESC</li><li>合并图层、画面居中</li></ul><p>所以设置好快捷键后，基本上只需要打开SAI2，然后在板子上操作就好了。不怎么需要去SAI2里操作了。</p><p>说一下SAI2的操作逻辑，首先是文字，每次输入文字SAI2都会新建一个图层，所以在输入完文字后要按ESC+ 合并图层，才能将文字和原本内容合并到同一图层中。</p><p>然后是粘贴，在你选中、复制、粘贴后，粘贴的内容会新开一个图层。所以需要按住ctrl移动到恰当位置后，按下合并图层，才能实现粘贴的内容和原内容在同一图层中。</p><p>最后是操作时遇到的一些问题：</p><ol type="1"><li>为什么切换到画笔后，写不出东西？<ul><li>可能是因为你选中了某个区域，没有取消就切换到画笔模式了。所以可以先按剪切后，再切换到画笔模式即可正常工作。</li></ul></li></ol><hr /><h3 id="四.-adobe-illustrator">四. Adobe illustrator</h3><p>通俗的理解，Adobeillustrator就是针对于矢量图的画图工具。发英文期刊/会议，配图格式经常要求是矢量图且质量比较高。所以matplotlib/Matlab+ Adobe illustrator + MathType就足以制作论文的配图。</p><h4 id="界面">界面</h4><ul><li>视图 -&gt; 标尺：打开标尺</li><li>右键标尺：选择标尺单位</li><li>视图 -&gt; 智能参考线：打开自动吸附功能</li><li>文件 -&gt; 存储：即保存，格式有eps等</li><li>文件 -&gt; 导出：即导出，格式有jpg/png等</li><li>文件 -&gt; 置入：插入图片到该画板</li><li>窗口 -&gt; 描边：里面有更多关于描边的参数（例如画箭头/虚线）</li></ul><h4 id="操作">操作</h4><ul><li>鼠标中键：移动</li><li>alt + 滚轮：放大/缩小</li><li>双击对象：对象进入隔离模式，防止操作时误操作到其它对象</li></ul><h4 id="工具栏">工具栏</h4><ul><li>空心箭头（普通选择）<ul><li>单击对象：用于选择然后移动/放大/缩小/旋转<ul><li>右键：编组/取消编组</li></ul></li><li>按住ctrl：显示所有锚点，点击锚点可编辑锚点</li><li>按shift + 单击其它对象：可多选其它对象</li><li>按alt + 拖动：可复制一份对象出来</li></ul></li><li>形状工具<ul><li>右键可以选择画不同的形状，按住shift可画标准化图形</li><li>矩形、椭圆、多边形、星形、直线</li></ul></li></ul><h4 id="属性图层库">属性/图层/库</h4><ul><li>属性：调节对象的属性，比如改变位置/设置颜色/填充</li></ul><h3 id="五.-origin">五. Origin</h3><p>画图神器。我觉得比matlab那一套方便多了，图形化的操作更加容易上手，不会把时间浪费在很多无意义的细节上。</p><p>Origin的组织结构：项目(.opju) -&gt; 文件夹 -&gt;book(数据)/graph(图)</p><p>对于book，使用内置python编程导入数据（菜单栏 -&gt; 连接 -&gt;.py），下面是一个导入的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wks = op.new_sheet()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    wks.from_list(i * <span class="number">2</span>, ans_x[i])</span><br><span class="line">    wks.from_list(i * <span class="number">2</span> + <span class="number">1</span>, ans_y[i])</span><br></pre></td></tr></table></figure><p>对于graph，其组织结构为：画布 -&gt; 图层(坐标轴) -&gt; 点/线。</p><p>上面是简单概念介绍，下面将对操作细节进行更多的阐述：</p><ol type="1"><li>A + 鼠标拖拽滚轮：实现页面的移动 + 放大/缩小</li><li>右上角有抗锯齿功能</li><li>最后画完图后，菜单栏 -&gt; 格式 -&gt;调整页面至图层大小，可以把白边裁掉。<ul><li>建议对于宽度选择边界为5，对于高度选择紧凑</li></ul></li><li>画风格类似的图时，可以使用复制风格功能</li><li>画子图时，建议先把每一张图画好，再使用“菜单栏 -&gt; 图 -&gt;合并图表”完成子图绘制</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;工具能大大提升效率。所以掌握有必要掌握一些常用工具。&lt;/p&gt;</summary>
    
    
    
    <category term="杂项" scheme="http://example.com/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理实验笔记</title>
    <link href="http://example.com/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</id>
    <published>2024-03-28T13:12:34.000Z</published>
    <updated>2024-06-21T17:40:39.924Z</updated>
    
    <content type="html"><![CDATA[<p>用Verilog实现一个简易RISC-V指令集CPU软核。</p><p>本次实验是重庆大学2022级弘深计算机拔尖班计算机组成原理的实验项目。</p><span id="more"></span><h3 id="一.-想说的话">一. 想说的话</h3><p>在开始做实验之前，首先要对CPU的物理结构和数据是如何在regfile,data_memory, instr_memory、alu中传输的有比较清晰的认知。建议观看视频: <ahref="https://www.bilibili.com/video/BV1wi4y157D3?p=1">从0到1设计一台计算机</a>，掌握理论知识。</p><p>在看完视频后，可以先跟着这个<ahref="https://www.bilibili.com/video/BV1pK4y1C7es?p=1&amp;vd_source=ca9a71bb3c1806ce48ae27d95e4e8bd0">教你写一个简单的CPU</a>视频，实现一个简单的MIPS指令集CPU软核，掌握实践知识。不用完全写对，跟着写一遍知道各个模块是如何互相运作的即可。因为视频中没有测试文件测试各个模块，都是一口气写下来的。所以最终版仿真是跑不起来的，因为存在诸多bug。</p><p>然后，最好在系统学习完一遍计组的理论知识（尤其是流水线冒险）后，再去写RISC-V指令集的软核。或者边学边做也行。我就是在全部写完后，才去学的计组理论知识，所以写出来的软核在冒险那一块是存在几个bug的，已经懒得调了。到时候下半年参加龙芯杯的时候反正也要再一个cpu，把这个遗憾留到龙芯杯解决就是了。</p><h3 id="二.-思路">二. 思路</h3><p>有啥思路？拿到设计图干就完事了，把线连好就行了，没啥难度。</p><p>代码已开源：<ahref="https://github.com/potatoQi/RISCV_CPU_Chongqing-University-Computer-Organization-Principles-Course-Project">RISCV_CPU(ChongqingUniversity Computer Organization Principles Course Project)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;用Verilog实现一个简易RISC-V指令集CPU软核。&lt;/p&gt;
&lt;p&gt;本次实验是重庆大学2022级弘深计算机拔尖班计算机组成原理的实验项目。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="计算机组成原理" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>2024华为软件精英挑战赛游记</title>
    <link href="http://example.com/2024/03/24/2024%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%E6%B8%B8%E8%AE%B0/"/>
    <id>http://example.com/2024/03/24/2024%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%E6%B8%B8%E8%AE%B0/</id>
    <published>2024-03-24T03:44:25.000Z</published>
    <updated>2024-03-29T17:51:52.018Z</updated>
    
    <content type="html"><![CDATA[<p>初赛正式赛35名，遗憾离场，略微可惜。</p><span id="more"></span><h3 id="第一周">第一周</h3><p>参加这个比赛也是心血来潮。一方面想着现在已经大二了，保研之前要丰富一下自己的简历，另一方面我还从没参加过企业举办的大型赛事，而且去看了下历年的题目，都是用算法去解决实际问题，对我来说蛮有吸引力。所以拉上我们班一位同学就去参加了。（比赛要求三个人所以去网上又找了一个重邮研二的）</p><p>报了名之后就没管了，一直到赛题发布的那一天。</p><p>第一眼看到赛题感觉有点难蚌，我之前去看了22、23年的华为软挑真题，认为23年既然已经考过这种控制机器人移动做任务的题目，那么24年考这个的概率就不大了。24考的题应该更接近于22年这种调度问题。没成想，24年居然还是机器人移动（当然也是包括调度问题的）。</p><p>第一天，看了看题目，下午和队友在线上开了个会，每个人分别讲了讲自己对赛题的理解。大致确定下了本题核心任务：调度+ 控制。</p><p>调度即为考虑机器人搬哪些货物，去哪个泊位；船去哪个泊位，什么时候回家，什么时候转运。调度问题为了简单起见，都是选择的编码难度最容易的调度方式。即机器人选最贵的物品，机器人选有船要来且最近的泊位，船满了就走先不考虑转运情况。</p><p>控制即操控机器人在最短时间内走到目标点。因为地图数据规模不大，所以我们选用每一步每一个机器人bfs一遍的策略。</p><p>晚上，我根据上面的思路，写了一个文字框架以及如何维护关键参数的思路：</p><p><img src="1.png" /></p><p>写完框架后就摆烂了几天，主要那几天刚好事特别多... ...</p><p>最后在周末的时候，拉着我同学，花了大概2个多小时，一起对着上面的文字框架实现了一个基本的代码框架。并确定好了分工，他负责最短路算法以及机器人的运动，我负责船以及泊位的调度部分。</p><p>（P.S.考虑到因为第三个队友跟我们不在同一个学校，不方便同时维护一份代码，所以让他根据自己想法写一个版本，无需受我写的文字框架的约束。兵分两路策略。）</p><h3 id="第二周">第二周</h3><p>到了比赛第二个星期，首先星期一星期二熬大夜把我负责的部分写完了。然后周末同学把他负责的那一部分也写完了。可是不能跑，机器人跑了几百帧就卡死了。于是周末的两个晚上，继续熬大夜，修复代码中的小BUG。最后成功让代码跑起来了，第一次有分。</p><p><img src="2.png" /></p><p>跑出分说明代码框架已经没问题了，但是仍然存在跑了几百帧后几个机器人撞一块再也不动的情况。说明碰撞部分还是存在BUG。</p><p>于是我改变了原先解决碰撞的策略，在原先只有等待机制的情况下，引入失控机制：</p><ol type="1"><li>俩机器人即将碰撞时，其中一个机器人进行等待模式，另一个机器人继续动</li><li>俩机器人若在同一个地方死锁，其中一个机器人进入等待模式，另一个机器人进入失控模式</li><li>等待模式的机器人原地不动，失控模式的机器人乱走</li></ol><p>最后解决了碰撞问题，确定了我们组的baseline代码，8w分。</p><p><img src="3.png" /></p><h3 id="第三周">第三周</h3><p>最忙的一周。几乎每天都熬到3、4点。主要问题就是优化baseline。其实优化之处还是非常多的。我按照我们的代码版本顺序来讲讲每个版本优化了哪些地方吧。</p><ul><li><p>v1.0</p><ul><li>baseline版本</li></ul></li><li><p>v2.0</p><ul><li>机器人挑选物品由原先的挑最贵的，变为挑val（物品价值） /dis（机器人与物品的最短距离）最大的</li><li>机器人由原先的锁定泊位，改为了锁定泊位的具体坐标</li></ul></li><li><p>v3.0</p><ul><li><p>我同学想出了一个“革命性”的优化，不用每一步都对每个机器人求最短路，只需在机器人每次改变目标点时或者碰撞后求一个最短路就好了。将时间由原先的几乎一半时间都掉帧，优化到了几乎不掉帧</p></li><li><p>完善了失控机制，原地等待wait_max_tim帧后同样进入失控状态，解决死锁</p></li><li><p>调整了失控策略，由原先的4个方向顺序去搜变为4个方向随机数去走，避免来回踱步</p></li><li><p>新增更换目标机制，若机器人road_tim帧内没到达目标，则会更换目标，解决死锁</p></li></ul></li><li><p>v3.5</p><ul><li>规范了v3.0的代码风格和缩进</li><li>略微调整了参数</li></ul></li><li><p>v4.0</p><ul><li>初始时令每个机器人去到离他自己最近的泊位，将十个机器人分配到十个泊位上，避免陷入局部最优解</li><li>改变了机器人确定目标泊位的策略：由原先的去已blocked的最近泊位改为去最近的泊位</li><li>增加了船转运的功能，如果超过最低容量且一定时间内没装载，则去别的泊位装货</li></ul></li><li><p>v5.0</p><ul><li>每个泊位里新增了一个队列q，可以统计泊位上的货物情况</li><li>优化了船挑选目标泊位的策略，由原先的去最大价值泊位变成去能取到最大价值的泊位</li></ul></li><li><p>v6.0</p><ul><li>增加了泊位聚类功能，可设置距离阈值控制聚类范围（这是个负优化，悲）</li><li>增加了船排队功能，可设置每个泊位最多等待船数</li></ul></li></ul><p>当写完这7个版本的代码后，还剩2天就正式赛了。此时的代码在练习赛排行榜处于44名。于是剩下两天试图继续优化代码，可是我们写了很多优化最后都是负优化并无很大提升。于是最后一天用ChatGpt写了一个python调参程序开始炼丹。</p><h3 id="正式赛">正式赛</h3><p>正式赛在第三周的周六。上午队友交了一发13名。后面大家陆陆续续起床了，排名就被刷到20多名了。正式赛这一天我们继续改了改泊位的调度思路，可是没啥正优化。最后排名被刷到30名。最后几个小时没有啥思路了，于是对着两个地图开始炼丹。最后交了几发提升了几千分，封榜前，排名上升到了29名（笑。</p><p>周天晚8点多去看了看晋级名单，35名。看来差一点。</p><p><img src="4.png" /></p><h3 id="后记">后记</h3><p>第一次参加软挑，然后蛮有收获的。首先，第一次维护那么长（臭）的代码，接近1k行代码。极大了提高了我编码和debug能力。其次让我知道了面向对象的重要性。下次再写这种大型项目最好用面向对象。其次，团队之间的合作也是非常重要的，就像这次比赛有两个突破性的难点都是我同学大佬想出来的。</p><p>最后，希望大家身体健康，学业顺利！</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;初赛正式赛35名，遗憾离场，略微可惜。&lt;/p&gt;</summary>
    
    
    
    <category term="3. 竞赛" scheme="http://example.com/categories/3-%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理自学笔记</title>
    <link href="http://example.com/2024/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-26T17:06:20.000Z</published>
    <updated>2024-06-21T17:26:18.957Z</updated>
    
    <content type="html"><![CDATA[<p>资料来源：课件、黑书</p><span id="more"></span><h3 id="一.-alu算术逻辑单元">一. ALU算术逻辑单元</h3><ol type="1"><li>基础知识<ol type="1"><li>对于无符号数，那么每一位都是可以用来表示数据的。比如64的无符号数max值为2^ 64 - 1</li><li>对于有符号数，<strong>统一采用补码形式存储在计算机中。</strong><ol type="1"><li>原因如下：<ol type="1"><li>如果最高位为符号位，其余位采用原码表示，那么0就有0 000...00和1000...00两种表示方法，不能唯一确定，不好</li><li>那么取个反呢？也就是最高位仍是符号位，如果想表示一个正数x的相反数，就直接把x的二进制全部取反即可。<ol type="1"><li>取反本质上就相当于INT_MAX - x，那么正数范围x是0 ~INT_MAX，则取反也是一一对应的，所以可以用x取反的方式得到x的相反数，也就得到了-0~ -INT_MAX的负数表示。</li><li>但是老问题仍然存在，对于+0，其二进制全部取反后得到1111...11。所以0仍然存在两种表示方法，这不好</li></ol></li><li>为了解决这个问题，取反后加1就好了。本质上就是-(INT_MAX - x +1)。对于+0，是0 000...00，对于-0，仍然是0 000...00。此时，正数范围x是0 ~INT_MAX。当x取0的时候，-0表示为0 000.00，当x取INT_MAX时，-x表示为1000...01。你会发现1000...00这个数没被用到。所以多出来的这个二进制数，我们用它来表示-(INT_MAX+1)</li></ol></li><li>对于正数，符号位为0，其余位该咋样咋样，跟原码一样。所以64位的最大值为2^ 63 - 1</li><li>对于负数，其二进制是其相反数全部取反+1。64位的负数范围本应是[-INT_MAX,-0]，但因为1000...00这个数没人对应。所以用它来对应-(INT_MAX+1)。所以负数范围是[-(INT_MAX+1),-0]</li></ol></li></ol></li><li>加法溢出（减法溢出同理）<ol type="1"><li>正数 + 负数，不会溢出</li><li>正数 + 正数，符号位为1，溢出</li><li>负数 + 负数，符号位为0，溢出</li></ol></li><li>乘法<ol type="1"><li>朴素法：本质就是二进制分解，将乘数二进制分解，每次看最后一位是不是1，若是，往结果里加上一个被乘数（注意，每分解一次被乘数就要左移一位）</li><li>优化法：本质还是二进制分解，但聪明的就是把结果和乘数写一起，初始化的时候在乘数(结果)的前面预留x位（x为被乘数的位数），然后每次检查结果最后一位，若是1，从最高位开始加上一个被乘数，然后结果右移一位，被乘数x2；若是0，则结果直接右移一位，被乘数x2</li></ol></li><li>除法（建议多练几个样例练练手）<ol type="1"><li>恢复除数法朴素法<ol type="1"><li>除数低位补0，然后被除数对着除数减，减成功就在结果顶一个1出去，没成功就顶一个0出去。直到除数变为1时结束</li></ol></li><li>恢复除数法优化法<ol type="1"><li>除数不动，然后被除数高位补0，然后高位对着除数减，减成功了就往被除数屁股后塞个1进来，没成功就往被除数屁股后塞个0进来。直到原本的被除数都被减过一遍后（最后一次比较完后高位<strong>减完后，低位左移，塞屁股</strong>然后走人）</li></ol></li><li>加减交替法<ol type="1"><li>初始化是被除数高位补0，然后高四位直接减除数</li><li>之后的每一步，直接看被除数符号位是不是1，是1直接屁股塞个0然后高四位加余数。不是的话屁股塞个1然后高四位减余数。直到原本的被除数都被减过一遍后（最后一次判断完屁股塞什么后，直接<strong>低位左移然后</strong>塞完屁股走人）</li></ol></li></ol></li><li>IEEE754<ol type="1"><li>S是阶符、E是阶码、M是尾数</li><li>单精度<ol type="1"><li>E = e + 127，e是真实指数</li><li><span class="math inline">\(1 \le E \le 254(127 * 2)\)</span></li><li>8位阶码，共32位</li></ol></li><li>双精度<ol type="1"><li>E = e + 1023</li><li><span class="math inline">\(1 \le E \le 2046(1023 * 2)\)</span></li><li>11位阶码，共64位</li></ol></li><li><img src="8.png" /></li><li><img src="9.png" /></li></ol></li></ol><h3 id="二.-指令集isa">二. 指令集ISA</h3><table><colgroup><col style="width: 28%" /><col style="width: 37%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th>R型指令</th><th>I型指令</th><th>S型指令</th></tr></thead><tbody><tr class="odd"><td>add rd rs1 rs2</td><td>addi rd rs1 imm</td><td>sw rs2 imm(rs1)（将rs2里的东西赋值到rs1 + imm里）</td></tr><tr class="even"><td>sub rd rs1 rs2</td><td>subi rd rs1 imm</td><td></td></tr><tr class="odd"><td>and rd rs1 rs2</td><td>andi rd rs1 imm</td><td></td></tr><tr class="even"><td>or rd rs1 rs2</td><td>ori rd rs1 imm</td><td></td></tr><tr class="odd"><td>xor rd rs1 rs2</td><td>xori rd rs1 imm</td><td></td></tr><tr class="even"><td>sll rd rs1 rs2</td><td>slli rd rs1 imm (左移imm位，zero-extend)</td><td></td></tr><tr class="odd"><td>srl rd rs1 rs2 （左移rs2位，zero-extend）</td><td>srli rd rs1 imm（右移imm位，zero-extend）</td><td></td></tr><tr class="even"><td>sra rd rs1 rs2 （右移rs2位，sign-extend）</td><td>srai rd rs1 imm（右移imm位，sign-extend）</td><td></td></tr><tr class="odd"><td>slt rd rs1 rs2 （rs1小于rs2吗，带sign）</td><td>slti rd rs1 imm（rs1小于imm吗，带sign）</td><td></td></tr><tr class="even"><td>sltu rd rs1 rs2（rs1小于rs2吗，不带sign）</td><td>sltiu rd rs1 imm（rs1小于imm吗，不带sign）</td><td></td></tr><tr class="odd"><td></td><td>lw rd imm(rs1)（将rs1 + imm的数据加载到rd里）</td><td></td></tr><tr class="even"><td></td><td>jalr rd imm(rs1)（将pc + 4赋值给rd，pc赋值为rs1 + imm）</td><td></td></tr></tbody></table><table><colgroup><col style="width: 39%" /><col style="width: 29%" /><col style="width: 31%" /></colgroup><thead><tr class="header"><th>B型指令</th><th>U型指令</th><th>J型指令</th></tr></thead><tbody><tr class="odd"><td>beq rs1 rs2 label（若rs1 == rs2，PC被赋值为label）</td><td>lui rd imm（rd = imm &lt;&lt; 12）</td><td>jal rd imm（rd = PC + 4, PC = PC + imm）</td></tr><tr class="even"><td>bne （not equal）</td><td>auipc rd imm（rd = (imm &lt;&lt; 12) + PC）</td><td></td></tr><tr class="odd"><td>bge （greater or equal）signed</td><td></td><td></td></tr><tr class="even"><td>bgeu （greater or equal）nosigned</td><td></td><td></td></tr><tr class="odd"><td>blt （less than）signed</td><td></td><td></td></tr><tr class="even"><td>bltu （less than）nosigned</td><td></td><td></td></tr></tbody></table><p>I、S、B、U、J，除了I是有/无符号扩展，其余都是有符号扩展，U是先左移12位再有符号扩展</p><ul><li>C转汇编练习<ul><li>x0：固定为0，可写可读但是始终为0</li><li>x1：返回地址寄存器，调用函数的时候自动更新为调用语句的地址</li><li>x10/x11：返回结果寄存器，用来保存函数里计算的值</li><li>x5-7/x28-31：临时寄存器，随便用</li><li>x8-9/x18-27：保存寄存器，在函数调用中需要保存恢复（入栈）</li><li>读取字符是lbu，存储字符是sb</li><li>函数中return的固定格式：jalr x0, 0(x1)</li><li><img src="10.png" /> ppt4(15)</li><li><img src="24.png" /> ppt4(16)</li><li><img src="11.png" /> ppt4(25)</li><li><img src="12.png" /> ppt4(38)</li></ul></li></ul><h3 id="三.-单周期数据通路">三. 单周期数据通路</h3><ol type="1"><li><p>CI：指令数 CPI：每条指令所需的周期数 f：时钟频率 T = <spanclass="math inline">\(\frac{1}{f} \cdot (CI \cdotCPI)\)</span>：时间</p></li><li><p>1GHz = 10^3MHz = 10^9Hz；1ns = 10^3ps = 10^9s</p></li><li><p>1ns = (1 / 1GHz)</p></li><li><p>系统加速比 = <spanclass="math inline">\(\frac{改进前的总时间}{改进后的总时间}\)</span> =<span class="math inline">\(\frac{改进前的总时间}{改进前的总时间 \cdot不可改进部分的占比 + \frac{改进前的总时间 \cdot可改进部分的占比}{改进部分的加速比}}\)</span>，若用吞吐量计算的话就是分子分母反过来-&gt;<spanclass="math inline">\(\frac{改进后的吞吐量}{改进前的吞吐量}\)</span></p></li><li><p>关键路径分析</p><ol type="1"><li><p><img src="13.png" /></p><p>俩寄存器从readdata1/2出来然后进alu运算，得到结果直接传回registers</p></li><li><p><img src="14.png" /></p><p>readdata1是首地址，immgen是偏移量，经alu运算后得到地址，然后ram的readdata读到数据后传回registers，赋值给rd</p></li><li><p><img src="15.png" /></p><p>readdata2是要写入ram的数据，直接流入ram的writedata，readdata1是首地址，immgen是偏移量，经alu运算后得到地址</p></li><li><p><img src="16.png" /></p><p>readdata1/2分别是rs1,rs2，经alu判断是否相等后zero信号给到pc那边的mux。label通过immgen传到mux</p></li></ol></li><li><p>对于寄存器（pc、InstrMem、Registers、DataMem），如果走完全程就加整个的延迟，如果只是往里写东西就只加一个Setup，如果只是读东西就只加一个read。</p><ol type="1"><li>sw的关键路径：pc_read + InstrMem + Registers + ALU + Setup</li></ol></li></ol><h3 id="四.-流水线数据通路">四. 流水线数据通路</h3><ol type="1"><li><p>流水线的五个阶段</p><ol type="1"><li><p>IF：从内存中获取指令</p></li><li><p>ID：指令解码和寄存器读取</p></li><li><p>EX：执行操作或计算地址</p></li><li><p>MEM：访问内存操作数</p></li><li><p>WB：将结果写回寄存器</p><p><img src="17.png" /></p></li></ol></li><li><p>流水线数据通路的延迟</p><ol type="1"><li><p>时钟周期(每个cycle的时间) = max{ lat(IF), lat(ID), lat(EX),lat(MEM), lat(WB) }</p></li><li><p>忽略了流水线的装载和排空</p></li><li><p>忽略了寄存器的建立时间</p><blockquote><p>这里要注意区分时钟周期、延迟的概念：</p><p>对于单周期数据通路，其时钟周期就是它的延迟</p><p>对于流水线数据通路，其时钟周期是max{ 五个阶段的延迟 }，其延迟是sum{五个阶段的延迟 }</p></blockquote></li></ol></li><li><p>画流水线图</p><ol type="1"><li><p>传统流水线图</p><p><img src="18.png" /></p><p>直接IF、ID、EX、MEM、WB五个阶段哐哐往上写就好了</p></li><li><p>资源调度流水线图</p><p><img src="19.png" /></p><p>固定的五套件是IM（instr_memory）、Reg、ALU、DM（data_memory）、Reg。如果写就前半部分标黑，如果读就后半部分标黑，如果都用到了就都标黑。没用到就标白（例如sub、add没用到DM）</p></li><li><p>插气泡的写法</p><p><img src="20.png" /></p></li></ol></li><li><p>冒险</p><ol type="1"><li>结构冒险：就是抢硬件资源，比如若将指令和数据放在一个存储器，那么IF阶段和MEM阶段就会同时用存储器，产生结构冒险</li><li>数据冒险：<ol type="1"><li>产生数据依赖就会产生数据冒险</li><li>三种数据依赖<ol type="1"><li>写后读（RAW）<ol type="1"><li>即前面写的还没更新，后面就读了，结果读出来不符合原本预期</li><li>无lw/sw语句<ol type="1"><li>也就是对于同一个寄存器，WB的CC必须在ID的CC之前，之后就会存在RAW依赖。WB和ID的CC相同是否可行呢？其实是可以的。因为通常默认一个CC内先下降沿再上升沿，下降写，上升读，所以同一个CC内，先写后读，数据是可以正确传递的，所以同一个CC也可以。</li><li>总结解决办法就是写读之间间隔的语句要&gt;=2（不包括它俩），或者插bubble，或者前推</li></ol></li></ol></li><li>读后写（WAR）<ol type="1"><li>即前面还没读到，后面就写进去了，结果读出来不符合原本预期</li><li>因为五级流水读取ID在第二阶段，写WB是第五阶段，所以不会发现读后写的冒险。只有在乱序执行的时候才会出现</li></ol></li><li>写后写（WAW）<ol type="1"><li>假设三条指令前两条写，后一条读，按理说读出来的是最后一条写后的结果，但如果第一个写最后才执行，那么就读出来一个错误的值。</li><li>五级流水仍是顺序执行的，所以不会有WAW冒险。只有在乱序执行的时候才会出现</li></ol></li></ol></li><li>前推MUX控制<ul><li>alu那，俩操作数，有不同的选择</li><li>F0 = (EX/MEM.RegWrite &amp;&amp; EX/MEM.Rd != 0 &amp;&amp; ID/EX.Rs== EX/MEM.Rd) EX/MEM前推到ID/EX.Rs</li><li>F1 = (MEM/WB.RegWrite &amp;&amp; MEM/WB.Rd != 0 &amp;&amp; ID/Ex.Rs== MEM/WB.Rd) MEM/WB前推到ID/EX.Rs</li><li>如果F0=0，F1=0就不前推，不可能俩都为1，其中一个为1就前推对应的阶段到ID/EX.Rs</li></ul></li><li>Load-Use冒险检测<ol type="1"><li>Hazard = (ID/EX.MemRead &amp;&amp; ID/EX.Rd == IF/ID.Rs)</li><li>要从datamemory读东西并且最终要写入的寄存器会被下面的语句用到，那么就存在load-use冒险。</li><li>隔一条的load-use冒险可以前推解决，不间隔的load-use冒险前推解决不了</li></ol></li></ol></li><li>控制冒险：<ol type="1"><li>就是beq指令没执行完前后面的指令不给执行，但是beq到EX/MEM阶段才知道是否执行，而此时后面的三条指令已经塞进来了，所以就会发生控制冒险</li><li>解决方案一：插三条bubble</li><li>解决方案二：如果发现要执行跳转则flushID/IF/EX阶段（因为后面的指令最多执行了ID/IF/EX三个阶段，所以刷新掉即可）<ol type="1"><li>If (EX/MEM.branch &amp; EX/MEM.Zero) IF.Flush=True; ID.Flush=True;EX.Flush=True;</li></ol></li><li>当然，其实beq的俩数比较不需要放在alu后比较，其实readdata刚出来，也就是在ID的结尾就可以比较了。所以我们可以把比较前移至ID阶段<ol type="1"><li>if (IF/ID.IR == beq &amp;&amp; Reg[Rs1] == Reg[Rs2]) IF.Flush =True;</li><li>此时仍会出现冒险，解决方案如下</li><li>解决方案一：插一条bubble</li><li>解决方案二：若发现要执行跳转，则flush掉IF/ID寄存器即可</li></ol></li><li>还有另一种控制冒险，就是jal指令，跟前移后的beq一样，也是到ID阶段就知道跳转地址了，所以也是flush一下ID/EX寄存器即可<ol type="1"><li>if (IF/ID.IR == jal[R]) IF.Flush = True;</li></ol></li><li>在学了flush技巧后，前面我们没解决的load-use冒险也可以用flush技巧来解决了，具体来说如下：<ol type="1"><li>在检测上发生load-use冒险时：Hazard = (ID/EX.MemRead &amp;&amp;ID/EX.Rd == IF/ID.Rs)</li><li>将ID/EX寄存器控制字段flush掉</li><li>阻止PC寄存器更新</li><li>阻止IF/ID寄存器指令字段更新</li></ol></li></ol></li></ol></li><li><p>流水线性能分析</p><ol type="1"><li><p><img src="21.png" /></p></li><li><p>可以发现，多插一个bubble就会多一个时间周期才能完成</p></li><li><p>而且可以发现一个规律，插入bubble后的<spanclass="math inline">\(CPI = 1 +\frac{bubble数}{指令数}\)</span></p></li><li><p>那么下面这题就可以理解了</p><p><img src="22.png" /></p><p>只有beq、jal、ld会产生惩罚，题目说了没有结构冒险，所以只考虑ld。只有40%load，一个load指令会bubble一个周期，所以假设指令数是x，那么bubble数就是0.4x，代入公式：CPI= 1 + 0.4x / x = 1.4，然后T = CPI * 时钟周期 = 1.4 * 1.1 = 1.54</p></li><li><p><img src="23.png" /></p><ul><li>条件分支beq 20%，无条件跳转jal5%。跳转地址在ID阶段解决意味着会延迟一个周期跳转，跳转条件在EX解决意思是到EX/MEM才知道是否要跳转，也就是延迟3个周期跳转。</li><li>那么假设静态预测不跳转，CPI = 1 + 0.05 * 1 + 0.2 * 3 = 1.65</li><li>如果假设静态预测跳转，CPI = 1 + 0.05 * 1 + 0.2 * 1 = 1.25</li></ul></li></ol></li></ol><p>‍</p><h3 id="五.-动态分支预测">五. 动态分支预测</h3><p>考点：根据双模的计数器的状态跳转图、或者历史的预测情况、历史的跳转情况，分析出最近的十次他能预测成果的次数</p><h3 id="六.-cache">六. Cache</h3><ol type="1"><li>AMAT（平均访问时间）<ol type="1"><li><span class="math inline">\(T = p * T_c + (1 - p) * (T_c +T_m)\)</span></li><li>p是命中率，<span class="math inline">\(T_c\)</span>是访问时间，<spanclass="math inline">\(T_m\)</span>是缺失代价访问时间</li></ol></li><li>主存与cache<ol type="1"><li>对于主存地址，俩部分，主存块号m位，块内地址b位。这个地址可以定位到一个存储单元</li><li>对于cache行的内容，tag位 + 有效位 + 脏位 + LRU位 + 数据。</li><li>若想在cache中定位到一个存储单元，需要从主存地址中解析出cache行号和块内地址</li><li>地址映射表 = 标记阵列 = (tag位 + 有效位 + 脏位 + LRU位)</li></ol></li><li>映射方式<ol type="1"><li>直接映射<ol type="1"><li>cache行号 = 主存块号 % cache行数</li><li>其实主存块号对应的cache行号，就是m位主存块号的低c位。高m -c位就作为tag位</li><li>技巧：tag位 = log2(主存容量 / cache容量)</li></ol></li><li>全相联映射<ol type="1"><li>因为全相联是随便放，所以给你一个主存地址，是无法定位到放到cache中的哪一行的</li><li>所以我们将主存地址的m位全部作为tag位</li></ol></li><li>组相联映射<ol type="1"><li>主存m位块号里的低c位就是对应的组号，高m - c位就作为tag位</li><li>可以发现组相联也是无法定位到具体某一行的</li></ol></li></ol></li><li>关联度<ol type="1"><li>定义：一个主存地址可能被存放到cache中的可能位置个数</li><li>关联度越低，命中率越低，判断是否命中的开销越小</li><li>直接映射：1</li><li>全相联映射：cache行数</li><li>组相联映射：组路数</li></ol></li><li>替换算法<ol type="1"><li>LRU：选择近期最久没被实用的块被替换</li><li>算法实现：通过LRU位实现（计数器）</li></ol></li><li>一致性问题<ol type="1"><li>写命中（要修改的存储单元在cache中）<ol type="1"><li>写直达（同时更新cache和主存）</li><li>写返回（更新cache和脏位，当被替换出去的时候再更新主存）</li></ol></li><li>写不命中（要修改的存储单元不在cache中）<ol type="1"><li>写分配法（在主存里更新完后copy一份到cache中）</li><li>写不分配法（在主存里更新完后就结束）</li></ol></li></ol></li></ol><h3 id="六.-汇编补充">六. 汇编补充</h3><ul><li><p>在线RISC-V汇编编写网站：<ahref="https://venus.kvakil.me/">venus</a></p></li><li><p>更多指令细节请参考：<ahref="https://inst.eecs.berkeley.edu/~cs61c/fa23/pdfs/resources/reference-card.pdf">CS61C Reference Card</a></p></li><li><p>RISC-V的大部分指令长度固定，为32位。每条指令都是由32个0/1序列组成。</p></li><li><p>寄存器：RISC-V中，寄存器是处理器内部用于存储数据的小存储单元。它们可以非常快速地被访问和写入，比起访问主内存来说速度要快得多。</p></li><li><p>RISC-V定义了一组32个通用寄存器，编号从0到31。在代码中就是x0, x1,x2, ..., x31。</p><p><img src="1.png" /></p></li></ul><ol type="1"><li><p>R(register)型指令：操作寄存器操作的指令</p><ul><li>格式：<img src="2.png" /></li><li>opcode操作码，rd目标寄存器号，rs1/rs2第一/二个源寄存器号，funct3附加操作码，funct7附加操作码。</li><li>add x3, x1, x2（+）</li><li>sub x3, x1, x2（-）</li><li>and x3, x1, x2（&amp;）</li><li>or x3, x1, x2（|）</li><li>xor x3, x1, x2（^）</li></ul></li><li><p>I(immediate)型指令：寄存器与常数操作的指令</p><ul><li>格式：<img src="3.png" /></li><li>immediate立即数。</li><li>addi x1, x2, 10</li><li>slti x1, x2, 15：如果x2小于15，将x1设置位1。否则设置为0</li><li>andi x1, x2, 0xFF：寄存器与常数进行&amp;操作</li><li>ori x1, x2, 0xFF</li><li>xori x1, x2, 0xFF</li><li>slli x1, x2, 2（将x2左移2位结果存到x1中）</li><li>ld x1, 0(x5)：从内存地址 x5+0 处加载 64 位的值到 x10</li></ul></li><li><p>S(store)型指令：寄存器与内存操作的指令</p><ul><li>格式：<img src="4.png" /></li><li>rs1访存基址寄存器编号，r2源操作数寄存器编号，imm立即数（表示从基址开始的偏移量。</li><li>sw x1, 10(x2)：将x1内容存储到x2为基址，偏移量为10的内存地址中</li></ul></li><li><p>B(branch)型指令：程序的有条件跳转指令</p><ul><li>格式：<img src="5.png" /></li><li>imm立即数：表示要跳转的语句的地址。</li><li>beq x1, x2, label：如果x1==x2，程序跳转到label处</li><li>blt(Branch less than) x1, x2, label：如果x1 &lt;x2，程序跳转到label处</li><li>bgt(Branch greater than) x1, x2, label：如果x1 &gt;x2，程序跳转到label处</li><li>bgtz(Branch greater than zero) x1label：如果x1大于0，程序跳转到label处</li><li>bgez(Branch greater or equal to zero) x1label：如果x1大于等于0，程序跳转到label处</li></ul></li><li><p>J(jump)型指令：程序的无条件跳转指令</p><ul><li>格式：<img src="6.png" /></li><li>也可以叫UJ(Unconditional Jump)指令。</li><li>jr rd：跳转到rd寄存器存的地址那里</li><li>jal x1,offset：跳转到当前指令地址加上offset的位置，并将下一条指令的地址存入x1中</li></ul></li><li><p>U(upper immediate)型指令：将20位立即数加载到寄存器的高位<br /></p><ul><li>格式：<img src="7.png" /></li><li>lui x1 imm：将20位立即数imm加载到x1的高20位，低12位清零</li></ul></li></ol><ul><li>练习题：写一个斐波那契数列程序</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> fib(n<span class="number">-1</span>)+fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">fib</span><span class="operator">:</span></span><br><span class="line">    <span class="variable">addi</span> <span class="variable">sp</span><span class="operator">,</span> <span class="variable">sp</span><span class="operator">,</span> <span class="operator">-</span><span class="number">16</span><span class="type">#</span> 开辟<span class="number">16</span>字节的栈空间</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">ra</span><span class="operator">,</span> <span class="number">0</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 保存函数地址</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">a0</span><span class="operator">,</span> <span class="number">4</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 保存参数<span class="variable">n</span><span class="operator">,</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable">addi</span> <span class="variable">t0</span><span class="operator">,</span> <span class="variable">x0</span><span class="operator">,</span> <span class="number">2</span>        <span class="type">#</span> <span class="variable">t0</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    <span class="variable">blt</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">t0</span><span class="operator">,</span> <span class="type">less_or</span><span class="type">_equal</span><span class="type">_than</span><span class="type">_one</span>    <span class="type">#</span> 如果<span class="variable">n</span> <span class="operator">&lt;=</span> <span class="number">1</span>，直接返回<span class="variable">n</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable">addi</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">1</span>        <span class="type">#</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span></span><br><span class="line">    <span class="variable">jal</span> <span class="variable">ra</span><span class="operator">,</span> <span class="variable">fib</span>            <span class="type">#</span> 执行<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span></span><br><span class="line">    <span class="variable">add</span> <span class="variable">t1</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">x0</span>        <span class="type">#</span> 将<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span>的结果存到<span class="variable">t1</span>中</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">t1</span><span class="operator">,</span> <span class="number">8</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 将结果存到栈中</span><br><span class="line">    </span><br><span class="line">    <span class="variable">lw</span> <span class="variable">a0</span><span class="operator">,</span> <span class="number">4</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 恢复参数<span class="variable">n</span><span class="operator">,</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span></span><br><span class="line">    <span class="variable">addi</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="operator">-</span><span class="number">2</span>        <span class="type">#</span> <span class="variable">a0</span> <span class="operator">=</span> <span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span></span><br><span class="line">    <span class="variable">jal</span> <span class="variable">ra</span><span class="operator">,</span> <span class="variable">fib</span>            <span class="type">#</span> 执行<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">    <span class="variable">add</span> <span class="variable">t2</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">x0</span>        <span class="type">#</span> 将<span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span>的结果存到<span class="variable">t2</span>中</span><br><span class="line">    <span class="variable">sw</span> <span class="variable">t2</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 将结果存到栈中</span><br><span class="line">    </span><br><span class="line">    <span class="variable">lw</span> <span class="variable">t1</span><span class="operator">,</span> <span class="number">8</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 重新把结果读到<span class="variable">t1</span>中</span><br><span class="line">    <span class="variable">lw</span> <span class="variable">t2</span><span class="operator">,</span> <span class="number">12</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 重新把结果读到<span class="variable">t2</span>中</span><br><span class="line">    </span><br><span class="line">    <span class="variable">add</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">t1</span><span class="operator">,</span> <span class="variable">t2</span>        <span class="type">#</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span> <span class="variable">fib</span><span class="punctuation">(</span><span class="variable">n</span> <span class="operator">-</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">    <span class="variable">lw</span> <span class="variable">ra</span><span class="operator">,</span> <span class="number">0</span><span class="punctuation">(</span><span class="variable">sp</span><span class="punctuation">)</span>        <span class="type">#</span> 恢复当前<span class="variable">fib</span>的返回地址</span><br><span class="line">    <span class="variable">addi</span> <span class="variable">sp</span><span class="operator">,</span> <span class="variable">sp</span><span class="operator">,</span> <span class="number">16</span>        <span class="type">#</span> 恢复栈空间</span><br><span class="line">    <span class="variable">jr</span> <span class="variable">ra</span>                <span class="type">#</span> 返回到调用<span class="variable">fib</span>函数的地方</span><br><span class="line">    </span><br><span class="line"><span class="type">less_or</span><span class="type">_equal</span><span class="type">_than</span><span class="type">_one</span><span class="operator">:</span></span><br><span class="line">    <span class="variable">addi</span> <span class="variable">sp</span><span class="operator">,</span> <span class="variable">sp</span><span class="operator">,</span> <span class="number">16</span><span class="type">#</span> 栈空间恢复</span><br><span class="line">    <span class="variable">add</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">a0</span><span class="operator">,</span> <span class="variable">x0</span>    <span class="type">#</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="variable">n</span></span><br><span class="line">    <span class="variable">jr</span> <span class="variable">ra</span>            <span class="type">#</span> 返回</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;资料来源：课件、黑书&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="计算机组成原理" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Python进阶</title>
    <link href="http://example.com/2024/02/24/Python%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2024/02/24/Python%E8%BF%9B%E9%98%B6/</id>
    <published>2024-02-24T08:49:18.000Z</published>
    <updated>2024-04-27T02:25:52.551Z</updated>
    
    <content type="html"><![CDATA[<p>说是进阶，其实就讲了三个数据分析常用包：numpy、pandas、matplotlib</p><span id="more"></span><h3 id="numpy">numpy</h3><ul><li>其实就是列表，但是好处就是速度快、操作方便、许多好用的数学计算接口</li></ul><h4 id="定义">定义</h4><ul><li>通过列表定义<ul><li>a = [0, 1, 2, 3] arr = np.array(a)</li><li>arr = np.array([0, 1, 2, 3])</li></ul></li><li>初始化为全0/1/指定元素<ul><li>np.zeros(5) # 结果为array([0., 0., 0., 0., 0.])</li><li>np.ones(5) # 结果为array([1., 1., 1., 1., 1.])</li><li>.zeros和.ones默认都是小数，改为整数可以写.zeros(5, dtype='int')</li><li>a.fill(3)：将a的所有元素改为3（注意这里a要是一个ndarray类型）</li></ul></li><li>生成整数数列<ul><li>np.arrange(l, r, d)：在[l, r)内，从l开始，每次递增d</li></ul></li><li>生成随机数<ul><li>np.random.rand(10)：生成10个[0, 1)的随机数</li><li>np.random.randn(10)：生成10个服从标准正态分布的随机数</li><li>np.random.randint(l, r, 10)：生成10个在[l, r)范围内的随机整数</li></ul></li></ul><h4 id="属性">属性</h4><ul><li>a.dtype：查看a里元素的类型</li><li>a.shape：返回一个元组，里面元素分别代表每一维元素的数目</li><li>a.ndim：查看维度</li><li>a.size：查看元素个数</li><li>a.astype('float')：返回将a内元素类型转换为float后的结果</li></ul><h4 id="运算">运算</h4><ul><li><p>ndarray支持切片，同时可直接与数字/ndarray进行运算</p></li><li><p>注意复制的时候不能像列表那样用a[:]切片复制，要使用.copy()来复制</p></li><li><p>a + 1：每个元素+1</p></li><li><p>a * 5：每个元素*5</p></li><li><p>a + b：两个ndarray对应元素相加</p></li><li><p>a * b：两个ndarray对应元素相乘</p></li><li><p>a / b：两个ndarray对应元素相除</p></li></ul><h4 id="多维情况">多维情况</h4><ul><li><p>np.zeros((2, 3))：创建2行3列的全零ndarray</p></li><li><p>np.ones((2, 3))：创建2行3列的全一ndarray</p></li><li><p>a.fill(3)：将a全部元素换为3</p></li><li><p>a[1, 2]：访问第1行第2列的元素</p></li><li><p>a[1]：返回第一行，以ndarray形式</p></li></ul><h4 id="常用函数">常用函数</h4><ul><li>np.sort(a)：返回将a排序后的结果</li><li>np.argsort(a)：返回每个元素在排序过后所处的排名（排名从0开始）</li><li>np.sum(a)：求和</li><li>np.max(a)：求最大值</li><li>np.mean(a)：求均值</li><li>np.vstack((a, b))：纵向堆叠</li><li>np.hstack((a, b))：横向堆叠</li><li>np.dstack((a, b))：维度上堆叠</li></ul><h4 id="矩阵运算">矩阵运算</h4><ul><li><p>a.T：转置</p></li><li><p>np.eye(3)：产生一个3*3的单位矩阵</p></li><li><p>np.dot(a, b)：返回俩矩阵相乘的结果</p></li><li><p>np.linalg.det(a)：求矩阵的行列式</p></li><li><p>np.linalg.inv(a)：求矩阵的逆矩阵</p></li><li><p>np.diagonal(a)：提取矩阵的对角线元素，返回一个一维ndarray</p></li><li><p>np.diag(a)：这里a是一个一维ndarray，返回一个以a为对角线元素的矩阵</p></li><li><p>矩阵只保留对角线元素：先np.digonal()，再np.diag()一下即可</p></li></ul><hr /><h3 id="pandas">pandas</h3><ul><li>提供了许多处理数据的接口</li></ul><h4 id="series">Series</h4><ul><li>pd.Series([1, 3, 5, nan,7])：创建一个Series，其实Series跟列表差不多，就是多了一个索引index。列表的索引就是下标0,1, 2, ...，Series索引默认也是0, 1, 2，但是可以自己更改</li><li>a.values：返回a的值</li><li>a.index：返回a的键</li></ul><h4 id="dataframe">DataFrame</h4><ul><li>DataFrame其实就是一个二维数组，但是有表头。行表头叫做columns，列表头叫做index</li><li>a =pd.read_excel('路径')：把一个excel表文件读入到一个dataframe变量中</li><li>a.head()：查看前5行</li><li>a.tail()：查看后5行</li></ul><hr /><h3 id="matplotlib">matplotlib</h3><ul><li>matplotlib 是一个Python 的2D图形包。pyplot封装了很多画图的函数。所以在实际的使用过程中，常常以plt作为 matplotlib.pyplot 的省略。import matplotlib.pyplot as plt</li><li>找参数的网站：https://blog.csdn.net/qq_40481843/article/details/106231257</li><li>plt.plot<ul><li>画函数：plt.plot(x列表, y列表)</li><li>画线段：plt.plot([x1, x2], [y1, y2])</li><li>画点：plt.plot(x, y)</li><li>参数:<ul><li>color：颜色</li><li>marker：点类型</li><li>markersize：点大小</li><li>markeredgewidth：点边宽</li><li>fillstyle：点填充类型</li><li>linestyle：线类型</li><li>linewidth：线宽</li><li>label：图例名字</li></ul></li></ul></li><li>plt.xlabel / plt.title<ul><li>' '里写名称，用$$括起来可写latex</li><li>参数：<ul><li>fontsize：字体大小</li></ul></li></ul></li><li>plt.xlim：改变x轴范围，例如plt.xlim((x1, x2))</li><li>plt.legend<ul><li>啥都不写：以默认配置显示图例</li><li>参数：<ul><li>frameon：True/False（是否显示边框）</li><li>loc：图例显示位置</li><li>fontsize：图例字体大小</li></ul></li></ul></li><li>plt.text<ul><li>plt.text(x, y, 'xxx')</li><li>参数：<ul><li>fontsize：字体大小</li><li>ha：水平对齐方式<ul><li>left：文本左对齐于指定点</li><li>center：文本居中对齐于指定点</li><li>right：文本右对齐于指定点</li></ul></li><li>va：垂直对齐方式<ul><li>top：文本顶部对齐于指定点</li><li>center：文本中部对齐于指定点</li><li>bottom：文本底部对齐于指定点</li></ul></li></ul></li></ul></li><li>plt.savefig：保存图片，例如plt.savefig('fig.eps')</li><li>plt.rcParams<ul><li>改变图片大小（单位为英寸）：plt.rcParams['figure.figsize']=(6.0,4.0)# 默认是(6, 4)</li><li>改变图片保存时清晰度：plt.rcParams['savefig.dpi'] = 100 #默认是100</li><li>改变图片显示的清晰度：plt.rcParams['figure.dpi'] = 100 #默认是100</li><li>Note：改变dpi只对栅格图有效，矢量图无需设置dpi，清晰度都一样的</li></ul></li></ul><hr /><h3 id="sympy">sympy</h3><p>一般使用即from sympy import *。</p><p>启用美化打印：init_printing(use_unicode=True,use_latex=True)。（配合display使用而不是print）</p><h4 id="矩阵相关">矩阵相关</h4><ol type="1"><li><p>定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = symbols(<span class="string">&#x27;x y z&#x27;</span>)</span><br><span class="line">v = Matrix([x, y, z])</span><br><span class="line">M = Matrix([</span><br><span class="line">    [x, y, z],</span><br><span class="line">    [x, y, z],</span><br><span class="line">    [x, y, z]</span><br><span class="line">])</span><br><span class="line">v_norm = symbols(<span class="string">&#x27;\|v\|&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>常用函数</p><ul><li>M.det()：返回M的行列式</li><li>M.inv()：返回矩阵的逆（如果存在）</li><li>M.T：返回转置</li><li>Eq(left, right)：返回left = right这个方程</li><li>solve(eq,goal)：对于eq这个方程(eq是个Eq对象)，求解goal目标变量的取值</li></ul></li><li><p>实战例子</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> *</span><br><span class="line">init_printing(use_unicode=<span class="literal">True</span>, use_latex=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">rho = symbols(<span class="string">&#x27;rho&#x27;</span>)</span><br><span class="line">varrho = symbols(<span class="string">&#x27;varrho&#x27;</span>)</span><br><span class="line">L1, L2, L3 = symbols(<span class="string">&#x27;L_1 L_2 L_3&#x27;</span>)</span><br><span class="line">AI_norm = symbols(<span class="string">&#x27;\|A-I\|&#x27;</span>)</span><br><span class="line">IJ_norm = symbols(<span class="string">&#x27;\|I-J\|&#x27;</span>)</span><br><span class="line">beta = symbols(<span class="string">&#x27;beta&#x27;</span>)</span><br><span class="line"></span><br><span class="line">X = Matrix([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, rho, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, L2 * varrho * AI_norm * IJ_norm + beta * (<span class="number">1</span> + rho), <span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">alpha = symbols(<span class="string">&#x27;alpha&#x27;</span>)</span><br><span class="line">mu = symbols(<span class="string">&#x27;mu&#x27;</span>)</span><br><span class="line">tau = symbols(<span class="string">&#x27;tau&#x27;</span>)</span><br><span class="line"></span><br><span class="line">E = Matrix([</span><br><span class="line">    [-<span class="number">1</span> * mu, L1, L3],</span><br><span class="line">    [varrho * L1 * L3 * (<span class="number">1</span> + tau * varrho * L3) * IJ_norm, varrho * L1 * L3 * IJ_norm, varrho * L3 * L3 *  IJ_norm],</span><br><span class="line">    [varrho * L1 * L2 * (<span class="number">1</span> + varrho * L3) * (<span class="number">1</span> + tau * varrho * L3) * IJ_norm, varrho * L1 * L2 * (<span class="number">1</span> + varrho * L3) * IJ_norm, varrho * L2 * L3 * (<span class="number">1</span> + varrho * L3) * IJ_norm]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">M = X + alpha * E</span><br><span class="line"></span><br><span class="line">I = eye(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">eq = Eq((I - M).det(), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">ans = solve(eq, alpha)</span><br><span class="line"></span><br><span class="line">display(ans)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;说是进阶，其实就讲了三个数据分析常用包：numpy、pandas、matplotlib&lt;/p&gt;</summary>
    
    
    
    <category term="2. 技能栈" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/"/>
    
    <category term="Python" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>Python基础</title>
    <link href="http://example.com/2024/02/23/Python%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2024/02/23/Python%E5%9F%BA%E7%A1%80/</id>
    <published>2024-02-23T15:08:48.000Z</published>
    <updated>2024-03-26T07:46:08.339Z</updated>
    
    <content type="html"><![CDATA[<p>什么？你连基本的Python相关知识都不会？</p><span id="more"></span><h3 id="顺序判断循环">顺序、判断、循环</h3><ol type="1"><li><p>变量类型</p><ol type="1"><li>int、float、str、bool</li><li>list（列表）[1, 2, 3]</li><li>tuple（元组）(1, 2, 3)</li><li>set（集合）{1, 2, 3}</li><li>dict（字典）{1: “python”, “acwing”: 2, 3: 4.0}</li></ol></li><li><p>输入</p><ul><li><p>使用input()函数，input()函数可读入一行内容，返回类型为str。一般配合split()、map()函数使用。</p><ul><li>a = (int)(input()) b =(int)(input())：读入两个整数，一个整数一行。</li><li>a, b = map(int, input().split())：读入两个空格隔开的整数。</li><li>split()会将一行字符串以空格作为分割符分开，返回一个字符串列表。map(func,var)会将func作用于var里的每个元素，返回作用后的var。</li><li>a = list(map(int, input().split())))：读入一行数存到列表a中</li></ul></li><li><p>当不知道读入的行数时，使用下列代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> stdin</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> stdin.readlines():</span><br><span class="line">  <span class="built_in">print</span>(line.strip()) <span class="comment"># strip()是为了去掉行末的回车</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>输出</p><ul><li>print(val1, val2, ...,end='')：输出多个内容默认用空格隔开，可自定义结尾字符<ul><li>round(x, 1)：将x保留1位小数</li><li>print("x = %.2f, y = %.3f" % (x,y))：同样也可以用格式化输出（%分割，后面多个参数的话要用括号括起来）</li><li>格式化输出想输出%的话，写%%</li></ul></li></ul></li><li><p>if/while/for里的变量，在语句外可以访问</p><ul><li><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">    max_value = a</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    max_value = b</span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(max_value)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>条件表达式</p><ol type="1"><li>and、or、not：与或非</li><li>max_value = a if a &gt; b elseb：三目运算符，max_value=a仅当a&gt;b时成立，否则=b</li></ol></li><li><p>运算</p><ol type="1"><li>a, b = b, a：交换两个数</li><li>python支持链式运算，例如if a &gt;= b &gt;= c: ...</li></ol></li><li><p>for循环</p><ol type="1"><li>for c in "abc"：依次输出每个字符</li><li>for i in range(r)：输出0, 1, ..., r - 1</li><li>for i in range(l, r)：输出l, l + 1, ... , r - 1</li><li>for i in range(l, r + 1, 2)：在[l, r]范围内，输出l, l + 2, l + 4,...</li></ol></li></ol><hr /><h3 id="列表">列表</h3><ul><li>初始化<ul><li>用循环 + append初始化</li><li>直接初始化<ul><li>a = [0 for i in range(3 + 1)]：a此时为[0, 0, 0, 0]</li><li>a = [i * i for i in range(3 + 1)]：a此时为[0, 1, 4, 9]</li></ul></li></ul></li><li>切片<ul><li>a[l:r]：返回a[l], a[l+1], ..., a[r-1]（l、r可缺省）</li><li>a[1:]：返回a[1], a[2], ... a[len(a) - 1]</li><li>a[1:3] = [2, 3]：等价于a[1]=2, a[2]=3</li><li>a[1:3] = [0]：等价于a[1]=0，把a[2]删掉</li><li>a[1:3] = []：等价于把a[1]、a[2]删掉</li></ul></li><li>复制<ul><li>不能用等号复制，用等号复制的话相当于新列表只是原列表的一个别名。修改新列表仍会对原列表产生影响。</li><li>用切片复制即可，即b = a[:]</li></ul></li><li>列表的运算<ul><li>列表的加法可以将两个列表拼接起来，得到一个新列表。</li><li>列表乘以一个整数，可以将若干个自身拼接起来，得到一个新列表。</li><li>将列表中的每个元素加上一个1<ul><li>a = [x + 1 for x in a]</li></ul></li></ul></li><li>列表常用函数<ul><li>len(a)：返回列表长度</li><li>a.append(x)：尾部插入x</li><li>a.insert(pos, x)：在pos处插入x</li><li>a.pop()：删除尾部最后一个元素</li><li>a.pop(pos)：删除下标为pos处的元素</li><li>a.reverse()：翻转</li><li>a.sort()：排序<ul><li>a.sort(key=lambda x: (x[1],x[0]))：a是一个列表，列表里的元素也是列表（里头有2个数），想先按照第二关键字排序，相等再按照第一关键字排序，就这样写。（默认是从小到大，从大到小可以加一个负号）</li></ul></li></ul></li></ul><hr /><h3 id="字符串">字符串</h3><ul><li>ord(c)：返回一个字符的ascii码</li><li>chr(a)：返回一个ascii码对应的字符</li><li>注意，虽然字符可以跟整数相互转化，但在Python中字符不能参与数值运算</li><li>使用""直接赋值，使用""" """可以赋值多行</li><li>字符串不能修改，切片也不像列表一样支持写操作</li><li>字符串支持加法、乘法、比较运算</li><li>常用函数<ul><li>len(s)：返回字符串长度</li><li>s.split(sep)：返回一个字符串列表。如果给出了sep就按sep分隔；如果没给出，则会按空格分隔，但连续的空格会被视为单个分隔符，而且会忽略首尾的空白字符。</li><li>s.strip()：返回将首尾的空白字符删除后的结果</li><li>s.replace(old, new)：将s中所有的old子串都改成new</li><li>s.find("abc")：查询某个子串在s中第一次出现的下标；如果不存在，则返回-1。</li><li>s.lower()：将所有大写字母变成小写。</li><li>s.upper()：将所有小写字母变成大写。</li><li>s.join(a)：a是一个字符串列表，这个函数返回将a中的字符用s作为分隔符拼接起来的结果。</li><li>s.startswith(prefix)：判断prefix是否为s的前缀。</li><li>s.endswith(suffix)：判断suffix是否为s的后缀。</li></ul></li></ul><hr /><h3 id="元组">元组</h3><ul><li><p>元组跟列表类似，只是不支持动态添加、删除元素，以及不能修改元素。其余用法类似。</p></li><li><p>元组需要用小括号括起来（也可以不加），中间的元素用逗号隔开。如果初始化只包含一个元素的元组，需要在该元素后添加逗号。</p></li><li><p>元组的解包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">12345</span>, <span class="number">54321</span>, <span class="string">&quot;Hello!&quot;</span></span><br><span class="line">x, y, z = t <span class="comment"># 将元组t解包，将元组内的三个值按顺序赋值给x、y、z</span></span><br><span class="line"></span><br><span class="line">a, b = b, a <span class="comment"># 这句话本质也是元组解包，就是将元组(b, a)解包，分别赋值给a, b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y, x * y <span class="comment"># 函数的返回值本质也是元组的解包</span></span><br><span class="line"></span><br><span class="line">a, b = cal(a, b)</span><br></pre></td></tr></table></figure></li></ul><hr /><h3 id="集合">集合</h3><ul><li><p>创建集合用花括号或set()函数。创建空集合只能用set()，不能用{}，因为{}创建的是空字典。</p></li><li><p>初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">basket = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;pear&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>&#125;  <span class="comment"># 会自动去除重复元素</span></span><br><span class="line"><span class="built_in">print</span>(basket)  <span class="comment"># 重复的元素已经去除了</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">b = <span class="built_in">set</span>(a)  <span class="comment"># 将列表转化成集合，一般是为了去重。</span></span><br><span class="line">c = <span class="built_in">list</span>(b)  <span class="comment"># 将集合转化回列表</span></span><br><span class="line"><span class="built_in">print</span>(b, c)</span><br></pre></td></tr></table></figure></li><li><p>常用函数</p><ul><li>len(a)：返回集合中的元素数量</li><li>a.add(x)：向集合中添加一个元素</li><li>a.remove(x)：删除集合中的x，如果集合中没x则报错</li><li>a.discard(x)：删除集合中的x，如果集合中x不存在也不会管</li><li>x in a：判断x是否在a中</li><li>x not in a：判断x是否不在a中</li></ul></li></ul><hr /><h3 id="字典">字典</h3><ul><li><p>创建字典用花括号或dict()函数。</p></li><li><p>初始化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tel = &#123;<span class="string">&#x27;jack&#x27;</span>: <span class="number">4098</span>, <span class="string">&#x27;sape&#x27;</span>: <span class="number">4139</span>&#125;  <span class="comment"># 创建一个字典</span></span><br><span class="line"><span class="built_in">print</span>(tel)  <span class="comment"># 输出 &#123;&#x27;jack&#x27;: 4098, &#x27;sape&#x27;: 4139&#125;</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">dict</span>()  <span class="comment"># 创建一个空字典</span></span><br><span class="line">a[<span class="number">123</span>] = <span class="string">&quot;abc&quot;</span>  <span class="comment"># 在字典中插入一个key-value对</span></span><br><span class="line">a[<span class="number">456</span>] = <span class="string">&quot;def&quot;</span>  <span class="comment"># 在字典中插入一个key-value对</span></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># 输出 &#123;123: &#x27;abc&#x27;, 456: &#x27;def&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">list</span>(a)  <span class="comment"># 将字典的关键字转化成列表</span></span><br><span class="line"><span class="built_in">print</span>(b)  <span class="comment"># 输出[123, 456]</span></span><br></pre></td></tr></table></figure></li><li><p>常用函数</p><ul><li>len(a)：返回字典中键值对个数</li><li>a[x]：获取关键字x对应的值，如果x不存在，会报异常</li><li>a.get(x)：获取关键字x对应的值，如果x不存在，不会报异常</li><li>a.get(x, y)：获取关键字x对应的值，如果x不存在，会返回默认值y</li><li>del a[x]：删除关键字x对应的元素对</li><li>x in a：字典中是否有x关键字</li><li>x not in a：字典中是否没有x关键字</li><li>a.keys()：返回字典中所有关键字，以列表形式</li><li>a.values()：返回字典中所有值，以列表形式</li><li>a.items()：返回字典中所有键值对，以列表形式，每对键值对是一个元组</li></ul></li></ul><hr /><h3 id="函数">函数</h3><ul><li>函数内定义的变量为局部变量，只能在函数内部使用。当需要修改用全局变量时，需要用global关键字在函数内声明全局变量。</li><li>传参时，传数/str是值传递，列表是引用传递。</li></ul><hr /><h3 id="类">类</h3><ul><li><p>类中函数的第一个参数都是self，用来调用类本身的变量和函数。当调用类中函数的时候，第一个参数self不需要自己传递，Python会自动传递这个参数。</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>:</span><br><span class="line">    hero_count = <span class="number">0</span>  <span class="comment"># 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, level=<span class="number">10</span></span>):  <span class="comment"># 构造函数</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.level = level</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hero %s has been created.&quot;</span> % name)</span><br><span class="line">        Hero.hero_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  <span class="comment"># 定义str()函数的效果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero: %s&quot;</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):  <span class="comment"># 问候</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):  <span class="comment"># 移动</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Move!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_level</span>(<span class="params">self</span>):  <span class="comment"># 获取这个英雄的等级</span></span><br><span class="line">        <span class="keyword">return</span> self.level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_level</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get_level() + <span class="number">1</span>  <span class="comment"># 调用类中的其他函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zeus = Hero(<span class="string">&quot;Zeus&quot;</span>)</span><br><span class="line">athena = Hero(<span class="string">&quot;Athena&quot;</span>, <span class="number">6</span>)</span><br><span class="line">zeus.greet()</span><br><span class="line">athena.move()</span><br><span class="line"><span class="built_in">print</span>(zeus.name, athena.get_level(), athena.next_level())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(zeus), athena)</span><br><span class="line"><span class="built_in">print</span>(Hero.hero_count)</span><br></pre></td></tr></table></figure></li><li><p>每个类可以创建任意多实例。例如上面的Hero类，可以创建zeus和athena等实例。类变量由所有实例共享，一般通过类名访问，例如Hero.hero_count。实例变量与每个具体的实例绑定，一般通过具体实例来访问，例如zeus.name。</p></li><li><p>子类可以继承父类的变量和函数。self可以调用自身和父类中的变量和函数，如果子类和父类的变量或函数重名，优先使用子类的变量和函数。super()可以优先调用父类中的函数。</p></li><li><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hero</span>:</span><br><span class="line">    hero_count = <span class="number">0</span>  <span class="comment"># 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, level=<span class="number">10</span></span>):  <span class="comment"># 构造函数</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.level = level</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hero %s has been created.&quot;</span> % name)</span><br><span class="line">        Hero.hero_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  <span class="comment"># 定义str()函数的效果</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hero: %s&quot;</span> % self.name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):  <span class="comment"># 问候</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">move</span>(<span class="params">self</span>):  <span class="comment"># 移动</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Move!&quot;</span> % self.name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_level</span>(<span class="params">self</span>):  <span class="comment"># 获取这个英雄的等级</span></span><br><span class="line">        <span class="keyword">return</span> self.level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next_level</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.get_level() + <span class="number">1</span>  <span class="comment"># 调用类中的其他函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zeus</span>(<span class="title class_ inherited__">Hero</span>):</span><br><span class="line">    hero_name = <span class="string">&quot;Zeus&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(Zeus.hero_name, level)  <span class="comment"># 通过super()调用父类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!(from child class)&quot;</span> % self.name)  <span class="comment"># 使用的是父类的`name`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Athena</span>(<span class="title class_ inherited__">Hero</span>):</span><br><span class="line">    hero_name = <span class="string">&quot;Athena&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(Athena.hero_name, level)  <span class="comment"># 通过super()调用父类的构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s: Hi!(from child class)&quot;</span> % self.name)  <span class="comment"># 使用的是父类的`name`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zeus = Zeus(<span class="number">6</span>)</span><br><span class="line">athena = Athena(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(zeus.name, athena.level, Hero.hero_count)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>(zeus), <span class="built_in">str</span>(athena))</span><br><span class="line">zeus.greet()</span><br><span class="line">athena.greet()</span><br><span class="line"><span class="built_in">print</span>(zeus.get_level())</span><br></pre></td></tr></table></figure></li><li><p>模块可以自定义，自己新建一个文件夹，里头可以写若干个.py文件，但是一定要有一个空的__init__.py文件，这样Python才知道这个文件夹是一个模块。导入函数可以写：from文件夹名.文件名 import 函数名</p></li></ul><hr /><h3 id="包管理">包管理</h3><ul><li><p>使用conda进行包管理，以下命令使用Anaconda控制台打开</p></li><li><p>conda envlist：查看当前有哪些虚拟环境（*号是当前所处环境）</p></li><li><p>conda activate 环境名：进入某个虚拟环境</p></li><li><p>conda list：查看当前虚拟环境内安装了哪些包</p></li><li><p>conda install 包名：在当前虚拟环境内安装一个包</p></li><li><p>conda create -n xxx python=x.x：创建一个虚拟环境</p></li><li><p>conda remove -n xxx --all：删除一个虚拟环境</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;什么？你连基本的Python相关知识都不会？&lt;/p&gt;</summary>
    
    
    
    <category term="2. 技能栈" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/"/>
    
    <category term="Python" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/Python/"/>
    
    
  </entry>
  
  <entry>
    <title>算法刷题笔记</title>
    <link href="http://example.com/2024/02/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/02/20/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2024-02-19T16:27:02.000Z</published>
    <updated>2024-04-02T05:44:31.462Z</updated>
    
    <content type="html"><![CDATA[<p>信息学竞赛刷题笔记</p><span id="more"></span><h3 id="思维题">思维题</h3><ul><li><p><a href="https://www.acwing.com/problem/content/97/">95.费解的开关 - AcWing题库</a></p><ul><li>经过思考后，发现一个开关按2次与没按没差别。所以对于每个开关，要不就按，要不就不按。继续思考，对于一个开关，它的状态取决于它自己以及上下左右共5个开关按or不按，而且跟顺序无关。</li><li>接着往下想，既然与顺序无关，那我就可以从第一个开始按。假设（1，1）按了，那么......感觉还是不好想。</li><li>这时要学会给自己增加已知信息。假设我第一行开关按or不按已经知道。那么我就可以推出第二行的按法。因为当第一行按完之后，能改变第一行状态的只有第二行（不能再按第一行了，因为按两次等于没按）。所以如果（1，j）是0，那么（2，j）就要按。</li><li>思路就出来了，枚举第一行的按法，然后推出第二行按法，继续推出第三行按法，直至推出第五行按法。此时1-4行都是1了，最后检查第5行是否全是1即可。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/107/">105. 七夕祭- AcWing题库</a></p><ul><li><p>首先很容易看出行和列是独立的问题，而且本质是一样的。所以接下来都讨论列。</p></li><li><p>然后略加思考也可以发现最终每列的数量就是全部列加起来取平均，取不了平均就没解。</p></li><li><p>假设a1, a2, ...,an平均值为avg，假设1号给2号b1个，2号给3号b2个，n号给1号bn个。则所求可表达为：<spanclass="math inline">\(|b_1|+|b_2|+...+|b_n|\)</span>。且有下列方程组成立：<span class="math display">\[a1 - b1 + bn = avg \\a2 - b2 + b1 = avg \\a3 - b3 + b2 = avg \\... \\an - bn + b_{n-1} = avg\]</span></p></li><li><p>整理可得</p></li></ul><p><span class="math display">\[-b_1+b_n = avg - a_1 \\-b_2+b_n = 2avg - (a_1+a_2) \\-b_3+b_n = 3avg - (a_1+a_2+a_3) \\...-b_{n-1}+b_n = (n-1)avg - (a_1+a_2+...+a_{n-1})\]</span></p><ul><li>继续整理</li></ul><p><span class="math display">\[b_1 = -avg + a_1 + b_n \\b_2 = -2avg + (a_1 + a_2) + b_n \\... \\b_{n-1} = -(n-1)avg + (a_1+a_2+...+a_{n-1})\]</span></p><ul><li>继续整理</li></ul><p><span class="math display">\[b_1 = b_n - avg + a_1 \\b_2 = b_n - 2avg + (a_1+a_2) \\...\\b_{n-1} = b_n - (n-1)avg + (a_1+a_2+...+a_{n-1})\]</span></p><ul><li>令x = bn，则所求为：<spanclass="math inline">\(|x-c1|+|x-c2|+...+|x-c_{n-1}|+|x - c_n|,c_n=0\)</span></li><li>一目了然，x取c的中位数时，所求最小。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/1535/">1533. 1的个数 - AcWing题库</a></p><ul><li>考虑每一位能出现多少次1。</li></ul><p><img src="2.png" /></p><ul><li>如上图，考虑d，如果d是0。那么当d这一位取1的话，左边只能是000 ~(abc-1)，右边可以是000 ~ 999。上图都清晰明了了，分情况讨论即可。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/1643/">1641.狼人杀-简单版 - AcWing题库</a></p><ul><li>枚举哪两个人是狼人，那么此时所有人的身份就确定了。然后检查两个条件。(1):是否有且仅有两个人在说谎；(2):俩狼人中是否有且仅有一个人在说谎。若俩条件满足则是一组解。</li></ul></li></ul><h3 id="基础算法">基础算法</h3><h4 id="位运算">位运算</h4><ul><li><a href="https://www.acwing.com/problem/content/92/">90.64位整数乘法 - AcWing题库</a><ul><li>计算a * b %p的结果。O(1)即可得出结果，但是a和b的范围很大会爆longlong。所以要用时间换空间。考虑a* b = a * (b的二进制表示)，例如a * 5 = a * (101) = a * (4 + 0 +1)。于是很容易的想到用logn的时间去分解b，用个中间变量sum对自己做累加（sum初始值为a），这样sum就会等于a，然后等于2a，然后等于4a......。分解b的过程中如果最后一位二进制是1，就ans +=sum即可。这种用加法代替乘法的方法，叫做龟速乘。</li><li>注意，%的优先级比+高。</li></ul></li><li><a href="https://www.acwing.com/problem/content/877/">875. 快速幂 -AcWing题库</a><ul><li>计算<span class="math inline">\(a^b %p\)</span>的结果。思路跟龟速乘一样，都是分解b。考虑<spanclass="math inline">\(a^b = a^{b的二进制形式}\)</span>，例如<spanclass="math inline">\(a^5 = a^{101} = a^{4 + 0 + 1} = a^4 *a^1\)</span>。用while去分解b的二进制，用个中间变量sum对自己做累乘（sum初始值为b），如果分解过程中b的最后一位二进制是1，就ans*= sum即可。</li></ul></li></ul><h4 id="递归分治">递归/分治</h4><ul><li><a href="https://www.acwing.com/problem/content/description/99/">97.约数之和 - AcWing题库</a><ul><li>求<spanclass="math inline">\(a^b\)</span>的所有约数之和。不难想到分解质因数。假设数num分解为<spanclass="math inline">\(p_1^{k1} \cdot p_2^{k2} \cdot ... \cdotp_n^{kn}\)</span>，那么数num的约数的个数就是(k1 + 1) * (k2 + 1) * ... *(kn +1)（相当于每个质数是材料，可以拿0/1/2/...个）。数num的约数之和就是<spanclass="math inline">\((1+p_1+p_1^2+...+p_1^{k1}) \cdot(1+p_2+p_2^2+...+p_2^{k2}) \cdot ... \cdot(1+p_n+p_n^2+...+p_n^{kn})\)</span>。</li><li>上面的数学推导作为一个大学生不难想出。那么这题思路就是先将a分解质因数，然后将每个质数的次数乘b。然后求<spanclass="math inline">\((1+p_1+p_1^2+...+p_1^{k1}) \cdot(1+p_2+p_2^2+...+p_2^{k2}) \cdot ... \cdot(1+p_n+p_n^2+...+p_n^{kn})\)</span>即可。</li><li>关键<spanclass="math inline">\((1+p_1+p_1^2+...+p_1^{k1})\)</span>怎么求，其实这种看起来有规律的东西都是用递归去加速，根据直觉尝试一下，假设sum= 1, mul = p1，然后while( sum += mul, mul *= mul )。第一次：sum=1+p1,mul=p1<sup>2；第二次：sum=1+p1+p1</sup>2+p1^3, mul = p1^4......你看，这不就出来了。</li><li>递归是俩倍俩倍去递归的，所以最后可能剩一点边角料。假设<spanclass="math inline">\(p_1^{cnt}\)</span>到<spanclass="math inline">\(p_1^{k1}\)</span>还没求，很简单，直接递归调用函数cal(p1,k1-cnt) * ksm(p1, cnt)</li><li>这题坑点较多，注意b有可能为0。注意a可能为0/1。</li></ul></li><li><a href="https://www.acwing.com/problem/content/100/">98. 分形之城 -AcWing题库</a><ul><li>一道找规律模拟题，挺恶心的。本质上就是给一个数num，找出其对应的坐标（x,y）。观察后不难发现，num会落到4个区，其中2、3区的区内坐标就等于上一个等级的对应数的坐标。1区的区内坐标等于上一个等级的对应数的坐标沿[左上到右下对角线]对称的坐标。4区的区内坐标等于上一个等级的对应数的坐标沿[右上到左下对角线]对称的坐标。</li></ul></li></ul><h4 id="前缀和差分">前缀和/差分</h4><ul><li><a href="https://www.acwing.com/problem/content/101/">99. 激光炸弹 -AcWing题库</a><ul><li>简单二维前缀和</li></ul></li><li><a href="https://www.acwing.com/problem/content/102/">100. 增减序列- AcWing题库</a><ul><li>差分题。最关键的一步是要联想到看一看差分数组。做题多就有经验了，这种区间操作问题一般要想到转换为差分数组，然后区间操作问题就转为端点修改问题。</li><li>将a转化为差分数组b后，这题就变成了，将b2~bn全部变为0的最少次数是多少？在最少次数的前提下，b1有多少种取值方式？每一次区间操作等价于将<spanclass="math inline">\(b_i\)</span>加或减1，<spanclass="math inline">\(b_j\)</span>加或减1（i &lt; j &amp;&amp; 1 &lt;= i&lt;= n &amp;&amp; 2 &lt;= j &lt;= n + 1）</li><li>然后由于贪心思想，尽可能将b2~bn中的正负数抵消掉。剩下抵消不掉的数的绝对值+1其实就是b1的不同取值个数。因为剩下不能凑对抵消的只能通过和b1或者<spanclass="math inline">\(b_{n+1}\)</span>凑对来抵消。选择用b1凑对多少次，b1就有多少种取值方式。</li></ul></li></ul><h4 id="二分">二分</h4><ul><li><ahref="https://www.acwing.com/problem/content/description/104/">102.最佳牛围栏 - AcWing题库</a><ul><li>看到平均数就想到整体减平均数，假设答案是一个数，然后每个数减掉这个数，那么只要找出一段区间长度&gt;=f的区间和&gt;=0就可以了。只要找出这样的区间。说明答案还可以更大，如果找不出，答案就要减小。所以二分答案即可。</li><li>关键是如何找到“一段区间长度&gt;=f的区间和&gt;=0”，如果没有区间长度限制O(n)扫一遍用最大连续子段和即可。主要有区间限制，那么就多开一个数组minn[i]表示截止到0~i位置中sum[i]中的最小值即可。（其实这也是最大连续子段和的另一种做法）</li></ul></li><li><a href="https://www.acwing.com/problem/content/1484/">1482. 进制 -AcWing题库</a><ul><li>首先将已知进制的数转为十进制。然后枚举另一个数的进制即可。但是另一个数的进制可能非常大。而且满足进制数越大，转换后的数就越大。所以可以二分。二分右边界是多少呢？极端一点，假设第二个数是10，第一个数是target进制。那么右端点至少要到（第一个数拉满的target进制转为的十进制）才行。</li><li>坑点：如果当前数为tar进制，那么当前数的每一位数都要在[0,tar)中。</li></ul></li></ul><h4 id="排序">排序</h4><ul><li><ahref="https://www.acwing.com/problem/content/description/115/">113.特殊排序 - AcWing题库</a><ul><li>本质上就是裸排序题，用归并或者快排把&lt;号换成题中的compare即可。</li></ul></li></ul><h3 id="贪心">贪心</h3><ul><li><ahref="https://www.acwing.com/problem/content/description/1519/">1517.是否加满油 - AcWing题库</a><ul><li>很多细节的贪心模拟题。</li><li>思路就是在当前加油站，在最远能行驶的距离之内找到第一个价钱比当前加油站低的加油站，然后开过去。如果找不到，就找价钱最少的，然后在当前加油站加满油开过去。如果一个加油站都找不到，就输出无解。</li></ul></li></ul><h3 id="数学">数学</h3><ul><li><a href="https://www.acwing.com/problem/content/1588/">1586.连续因子 - AcWing题库</a><ul><li>用分解因数的方法去枚举连续因子的开头，然后对于每个开头，看看最多能连多少个，取个max即可。</li></ul></li></ul><h3 id="数据结构">数据结构</h3><h4 id="链表">链表</h4><ul><li><ahref="https://www.acwing.com/problem/content/description/828/">826.单链表 - AcWing题库</a><ul><li>其实上链表的模拟题几乎都可以用数组去做。</li><li>其实用数组模拟的思路很暴力，假设有N次操作，那么就实例化N个结构体对象。给每次操作分配一个node，每个node里有l,r,x。然后按照题目要求改变node的l、r即可。（l、r初始为-1，a[0]为虚拟头节点）</li></ul></li></ul><h4 id="并查集">并查集</h4><ul><li><a href="https://www.acwing.com/problem/content/1252/">1250.格子游戏 - AcWing题库</a><ul><li>乍一看题目觉得很复杂，但实际上想到把二维转为一维就简单了。给每一个二维坐标赋予一个独一的一维坐标。每次一条边就是将两个点merge起来。如果一条边的两个点已经在一个集合里面了，说明产生了环。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1254/">1252.搭配购买 - AcWing题库</a><ul><li>将所有捆绑在一起的东西看作一个物品，然后01背包即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/239/">237.程序自动分析 - AcWing题库</a><ul><li>对于一组约束，将相等条件都用并查集并起来。然后依次检查不相等条件的两个点是否在同一集合中，如果在就是NO。全部检查完没问题就是YES。</li></ul></li><li><a href="https://www.acwing.com/problem/content/241/">239. 奇偶游戏- AcWing题库</a><ul><li>这题涉及到区间问题，都应该往是否可以转换成“前缀和数组和差分数组上的区间俩端点“问题这个方向思考。这题考虑前缀和数组sum，区间[l,r]有偶数个1说明sum[r]与sum[l - 1]的奇偶性相同，区间[l,r]有奇数个1说明sum[r]与sum[l - 1]的奇偶性不同。</li><li>看出这个后这题就好做了，二分M，每次检查前mid个条件是否满足。显然满足当且仅当是一个二分图，那么用染色法就检查前mid个条件形成的图是不是一个二分图即可。</li><li>这题其实我还这样想过，就是用的[程序自动分析]这题的思路：二分M，每次检查前mid个条件是否满足。检查方法使用并查集，先将前mid个条件中相同条件的俩元素并起来，再检查前mid个条件中不相同条件的俩元素是否在同一集合，在就return0。都检查完了没问题就return 1。</li><li>但上面这样想是错的，因为这题是有个隐藏条件的，任意一个元素，它不是奇数，就是偶数。所以上面并查集的做法是无法做到保证只有两个集合的。例如下面这个例子：</li><li><img src="1.png" /></li><li>通过三句红话其实可以推出这些条件无法共存（不是二分图）。但是上面的并查集做法是检查不出来的。</li><li>如果要用并查集的话要用这种思路：维护d[x]，表示x与父亲的奇偶性（如果俩点奇偶性相同则为0，不相同则为1）。在更新fat[x]的时候顺便更新一下d[x]，那么更新完后d[x]就成为了x与祖先的奇偶性。</li></ul></li><li><a href="https://www.acwing.com/problem/content/240/">238.银河英雄传说 - AcWing题库</a><ul><li>跟上一题一样维护d[x]，表示x到父亲的距离。也是在更新fat[x]时顺便更新一下d[x]即可，更新完后d[x]就成为了x到祖先的距离。</li><li>这题在merge时会用到并查集大小信息，所以还要多维护一个siz[x]。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1555/">1553. 用Swap(0, i) 操作进行排序 - AcWing题库</a><ul><li>很巧妙的解法，没做过很难想出来。</li><li>如果当前位置i上的数是x，那么x向i连一条边。最终形成的图是一个个环。最终想到达到的目的就是n个自环。考虑交换操作会对这个图产生什么影响。如果0跟不在一个环的数交换，那么两个环会合并。如果0跟在一个环的数交换，那么环会分裂成两个。贪心的想，先把所有跟0不在一个环的环合并到0这个环上，然后再一个一个元素分裂出去形成自环即可。那么用并查集维护一下就好了。</li></ul></li></ul><h4 id="对顶堆">对顶堆</h4><ul><li><a href="https://www.acwing.com/problem/content/108/">106.动态中位数 - AcWing题库</a><ul><li>将数分为较大的一部分和较小的一部分。而且保证较大一部分的数的数量在偶数时与较小一部分的数的数量相等，在奇数时较大一部分的数的数量比较小一部分数的数量大1。</li><li>用小根堆b维护较大的一部分，大根堆a维护较小的一部分。每次一进来一个数t，先与b.top()（也就是较大一部分中的最小的数）比较，如果比b.top()小，则把t插入a中。反之，把t插入b中。</li><li>然后就要保证两个堆之间的数量关系。维护一下即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1545/">1543. 栈 -AcWing题库</a><ul><li>相对于上面一题，就多了一个删除操作。</li><li>使用multiset，这玩意内部是自动从小到大排序的。支持插入、删除、用迭代器访问，两个堆分别用俩multiset代替就行了。</li><li>删除要a.erase(a.find(x))，而不是a.erase(x)，后者会把所有x全删掉。</li></ul></li></ul><h4 id="优先双端队列">优先/双端队列</h4><ul><li><a href="https://www.acwing.com/problem/content/1543/">1541.世界首富 - AcWing题库</a><ul><li>把每个人的信息都用结构体记录下来，然后对于每个查询，二分找到左右端点，然后对区间内的点重新sort一遍。这种做法时间过不去，因为n有1e5。极端情况每次查询都要对1e5个元素重新sort。</li><li>看题目年龄最多200，所以考虑以年龄作为索引。相当于每个年龄开一条链，然后把对应年龄人的信息链上去。</li><li>输出规定年龄区间内前m个人的信息，其实就是一个多路合并问题。用一个优先队列解决。</li><li>（P.S.vector类型可以定义为pair/struct，写一个排序函数cmp即可。但是priority_queue里若想实现自己定义的规则，不要用pair最好用struct，而且不是写排序函数，而是写一个重载&lt;的规则，注意规则内部大于要变小于，小于要变大于）</li></ul></li></ul><h4 id="线段树">线段树</h4><ul><li><a href="https://www.acwing.com/problem/content/1275/">1273.天才的记忆 - AcWing题库</a><ul><li>区间查询最大值。</li></ul></li><li><a href="https://www.acwing.com/problem/content/248/">242.一个简单的整数问题 - AcWing题库</a><ul><li>区间修改，单点查询。</li></ul></li><li><a href="https://www.acwing.com/problem/content/244/">243.一个简单的整数问题2 - AcWing题库</a><ul><li>区间修改，区间查询。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1279/">1277.维护序列 - AcWing题库</a><ul><li>区间修改（乘法加法），区间查询。</li><li>假设sum' = sum * a + b，那么加一个数sum' + c = sum * a + (b +c)，相当于加法标记加了个c；乘一个数sum' * c = sum * ac +(bc)，相当于加法和乘法标记都自乘了个c。所以就这样维护俩标记即可，然后按照sum= sum * mul + add的规则去更新sum即可。</li><li>但如果假设sum' = (sum + a) * b，那么加一个数sum' + c = sum * b + ab+ c，你看，就不好可持续性维护了。</li><li>这题注意build初始化时每个t[p]的mul标记都要初始化为1。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1277/">1275. 最大数- AcWing题库</a><ul><li>动态维护后L个数中的最大值，可以发现数组的数量是只会增加不会减少的，而且数组元素数量最多增长到2e5。所以对数组下标建一颗线段树维护区间最大值即可。单点修改+ 区间查询。</li></ul></li><li><a href="https://www.acwing.com/problem/content/246/">245.你能回答这些问题吗 - AcWing题库</a><ul><li>考虑t[p]的最大子段和sm如何转移：max(t[p1].sm, t[p2].sm,跨过mid的最大子段和)。跨过mid的最大子段和 = t[p1]的最大后缀和 +t[p2]的最大前缀和。</li><li>所以t[p]需要维护最大子段和sm，最大前缀和lm，最大后缀和rm，在维护lm,rm时还会用到区间和sum。</li><li>查询区间[l, r]时，ask函数应返回一个Tree类型，当l &lt;= mid &lt;=r（mid = (t[p].l + t[p].r) / 2）时，可以通过子树t1,t2表示出状态。如果不返回Tree类型的话，就没有子树t1,t2的信息，状态不好表示出来。</li></ul></li><li><a href="https://www.acwing.com/problem/content/247/">246.区间最大公约数 - AcWing题库</a><ul><li>由更相减损术可知gcd(a, b) = gcd(a, b -a)。次公式可扩展到多个变量：gcd(a, b, c, d) = gcd(a, b - a, c - b, d -c)，这其实就是差分形式。所以可以线段树维护原数组的差分数组的区间gcd和区间和，那么操作1就是单点修改（单点修改那可以完全不用考虑懒标记问题了很舒服），操作2求gcd(A[l],A[l + 1], A[l + 2], ..., A[r]) = gcd(A[l], A[l + 1] - A[l], A[l + 2] -A[l + 1], ..., A[r] - A[r - 1]) = gcd(差分数组[1 ~ l]之和，差分数组[l +1到r]的gcd)。</li><li>这题有俩小细节，第一差分单点修改r +1有可能到n外边去，第二查询时如果l = r则要特判下。</li></ul></li><li><a href="https://www.acwing.com/problem/content/249/">247.亚特兰蒂斯 - AcWing题库</a><ul><li>扫描线算法，扫描线算法是个比较死的算法，因为其有一个特殊性质：线段是成对出现的。</li><li>做法两种，我喜欢这种：维护区间最小值min和区间最小值的长度minlen。这样，如果t[1].min= 0，则被覆盖的长度 = 全部长度 - t[1].minlen。如果t[1].min !=0，则被覆盖的长度 =全部长度。区间最小值和区间最小值长度都非常好维护，区间修改就是给最小值打个懒标记即可，不用管minlen，因为最小值加一个数减一个数仍然是最小值，minlen不会变。</li><li>上面就是扫描线的做法。所以扫描线很简单，关键这题的细节处理有点点小麻烦。</li><li>一，坐标都是小数，所以需要离散化处理成整数才能建线段树。二，t[p]管理的实际区间为getVal(t[p].r+ 1) -getVal(t[p].l)，因为只有这样，线段树的子节点才可以初始化minlen，不然minlen不好初始化。三，离散化的俩函数getRank,getVal的参数类型要注意。</li></ul></li><li><a href="https://ac.nowcoder.com/acm/contest/67742/H">H-Tokitsukazeand Power Battle (hard)_2024牛客寒假算法基础集训营2</a><ul><li>是“最大区间和”的变形题。</li><li>考虑i，j的位置，如果i，j都在mid左边是一种情况，即t[p].ans =t[p1].ans。如果i，j都在mid右边是一种情况，即t[p].ans =t[p2].ans。如果i，j分布在mid两边，则需要考虑x(即中间砍的那一刀)的位置。</li><li>如果砍的一刀在mid, mid + 1之间，则t[p].ans =t[p1].包含右端点的最大后缀和 - t[p2].包含左端点的最小前缀和。</li><li>如果砍的一刀在左半边，则t[p].ans = t[p1].包含右端点的答案 -t[p2].包含左端点的最小前缀和。</li><li>如果砍的一刀在右半边，则t[p].ans = t[p1].包含右端点的最大后缀和 +t[p2].包含左端点的答案。</li><li>所以t[p].ans就是在上面几种情况取max。发现用到了“包含右端点的最大后缀和rmax”，“包含左端点的最小前缀和lmin”，“包含右端点的答案rans”，“包含左端点的答案lans”，rmax和lmin很好维护，现在来看lans和rans如何维护。</li><li>先考虑t[p].lans。此时i是卡死的就在l上，考虑j的位置。如果j左半边，则t[p].lans= t[p1].lans。如果j在右半边，则考虑砍的一刀位置，如果砍在mid,mid+1中间，则t[p].lans = t[p1].sum -t[p2].lmin；如果砍在左半边，则t[p].lans = t[p1].包含左右端点的答案 -t[p2].lmin；如果砍在右半边，则t[p].lans = t[p1].sum + t[p2].lans。</li><li>t[p].rans同理。发现在维护这俩的时候还用到了"包含左右端点的答案lrans"。</li><li>现在考虑t[p].lrans。因为i，j都定死了，所以只需考虑砍的一刀的位置。如果砍在mid,mid+1中间，则t[p].lrans= t[p1].sum - t[p2].sum。如果砍在左半边，则t[p].lrans = t[p1].lrans -t[p2].sum。如果砍在右半边，则t[p].lrans = t[p1].sum + t[p2].lrans。</li></ul></li></ul><h4 id="树状数组">树状数组</h4><ul><li><a href="https://www.acwing.com/problem/content/109/">107.超快速排序 - AcWing题库</a><ul><li>求逆序对。</li></ul></li><li><a href="https://www.acwing.com/problem/content/243/">241. 楼兰图腾- AcWing题库</a><ul><li>简单的求每个数之前比它大的数的个数。</li></ul></li><li><a href="https://www.acwing.com/problem/content/245/">244.谜一样的牛 - AcWing题库</a><ul><li>最后一头牛的高度是确定的，在确定最后一头牛高度后，倒数第二头牛的高度也确定了，依次类推。假设现在要求第i头牛的高度，则若数组c的区间和[1,k] = 比第i头牛矮的牛数量 + 1，则第i头牛的高度为k（最开始每个位置的c[i] =1）。</li><li>区间和查询用树状数组，找高度时配合二分。找到该牛高度k后，upd(x,-1)。</li></ul></li></ul><h4 id="字典树">字典树</h4><ul><li><a href="https://www.acwing.com/problem/content/837/">835.Trie字符串统计 - AcWing题库</a><ul><li>板子题，字典树空间一般不知道开多少合适，建议用vector。就比如这题，开个vector&lt;Node&gt;a。Node结构体里放指向信息，这题的指向信息有26个，就在Node里开一个alpha[26]。</li><li>从根节点编号0出发，若a[0].alpha[k] =0，那就新开一个点，a[0].alpha[k] = ++dex,a.push_back(tmp)即可。然后编号跳到a[0].alpha[k]，继续依次类推。</li><li>通过这种方法，就不需要考虑空间应该开多大了。</li></ul></li><li><a href="https://www.acwing.com/problem/content/145/">143.最大异或对 - AcWing题库</a><ul><li>思考每个数的二进制形式，将每个数的二进制形式insert到字典树中（字典树就两个指向信息p[0/1]），然后对于每个数，依次扫二进制的每一位数k，在字典树里找a[p].nxt[k^1]是否存在，存在p就指向它，不存在就指向a[p].nxt[k]。在过程中统计答案求最大值即可。</li></ul></li><li><ahref="https://www.acwing.com/problem/content/description/258/">256.最大异或和 - AcWing题库</a><ul><li>涉及到区间异或运算，所以尝试是否可以前缀和/差分转化为单点运算，发现是可以的。考虑维护前缀异或数组，s[i]= a[1] ^ a[2] ... ^ a[i]，这样a[p] ^ a[p + 1] ^ a[p + 2] ^ ... ^ a[n] =s[n] ^ s[l - 1]。所以所求为x ^ s[n] ^ s[p - 1]。(x ^s[n])是一个定值C，所以就是在[l - 1, r - 1]内找一个数s[i]，使得s[i] ^C最大。所以就是可持久化Trie树。</li><li>可持久化Trie树就是每次添加一条链，具体算法是p = root[now], q =root[now - 1]。然后p的所有子节点除了新链上的点，复制q的节点，然后p =t[p][k] = ++dex, q = t[q][k]。再递归进行直至把这条链添加进Trie树。</li></ul></li></ul><h3 id="模拟">模拟</h3><ul><li><a href="https://www.acwing.com/problem/content/1496/">1494.银行排队 - AcWing题库</a><ul><li>还行的一道模拟题，考虑时间轴，每个人要等的时间 = 到他的时间 -他到的时间。用一个优先队列维护正在办理业务的人，按照谁先结束排序。</li><li>通过这题可以学到priority_queue是可以自定义排序规则的，只需要重载&lt;号（类型一定要是结构体不能是pair）</li></ul></li><li><a href="https://www.acwing.com/problem/content/1559/">1557.说话方式 - AcWing题库</a><ul><li>坑点比较多，有可能有ab:cc/a:::bcc/a:aa:b...的情况。</li><li>通过这题可以学到map也是可以排序的。只需要vector&lt;PAIR&gt;vec(mp.begin(),mp.end())，即可把mp转换成一个vector。然后用sort对vector排序即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1488/">1486.排队等候 - AcWing题库</a><ul><li>跟“银行排队”那题比较像，这题多了一个“等待区”的概念，而且没有了具体的时间。所以不像上一题好写。所以学会自己给自己增加条件，用一个循环模拟时间线（因为17点下班所以复杂度不会很高）。然后对于当前第T秒，先把每个窗口办理完手续的人赶出去，然后再依次把人放进等待区，分配到对应的窗口。</li><li>这题坑点是即使一个人它开始办理业务的时间超过了17点，它也要分配到对应的窗口，因为对于他自己，是不知道前面的人需要多久的，所以他肯定会排进某个窗口的队里。</li></ul></li></ul><h3 id="dp">DP</h3><h4 id="背包">背包</h4><ul><li><p><a href="https://www.acwing.com/problem/content/2/">2. 01背包问题- AcWing题库</a></p><ul><li>01背包，复杂度O(n * m)，一维倒序</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/3/">3.完全背包问题 - AcWing题库</a></p><ul><li>完全背包，复杂度O(n * m)，一维正序</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/4/">4.多重背包问题 I - AcWing题库</a></p><ul><li>朴素多重背包，复杂度O(n * m * s)，当成01背包做</li></ul></li><li><p><ahref="https://www.acwing.com/problem/content/description/5/">5.多重背包问题 II - AcWing题库</a></p><ul><li>二进制优化多重背包，复杂度O(n * m * logs)</li><li>原理即用1、2、...、exp、s - exp凑出[1, s]总中任意一个数</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/6/">6.多重背包问题 III - AcWing题库</a></p><ul><li>单调队列优化多重背包，复杂度O(n * v_max),v_max为物品中最大的体积</li><li>先列出递推表达式，然后把j - v, j - 2v, ...r的表达式也一起列出来。然后画个数轴，发现是个滑动区间。</li></ul><p><img src="3.png" /></p><ul><li>那么三重循环，第一枚举物品，第二枚举余数（从0到v-1），第三从r枚举到m，每次+=v，同时开始滑动。</li><li>更新的时候注意w的数量，假设更新f[j]用到了f[k]，那么f[k]的w的数量就是(j- k) / v * w。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/9/">9.分组背包问题 - AcWing题库</a></p><ul><li>多重背包是看选0个、还是1个、2个。分组背包就是看选第1个、还是第2个。第一重枚举组，第二重枚举体积，第三重枚举组内物品。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/11/">11.背包问题求方案数 - AcWing题库</a></p><ul><li>这题不是求“恰好装满某容量的方案数”，如果是求前面这个问题的话用一个计数数组跑一遍01背包即可，g[0]= 1。</li><li>这题是求最优选法的方案，所以计数数组含义仍然不变，g[i]表示恰好装好容量为i的方案数，把f数组含义变一下，f[i]表示<strong>恰好</strong>用容量i的包装出的最优价值。这样的话，就需要memset(f,-0x3f, sizeof f), f[0] = 0。然后跑一遍01即可。最后统计的时候在f[1 ~m]中找出最优价值，然后再在g[1 ~ m]中统计最优价值的方案数之和。</li></ul></li><li><p><ahref="https://www.acwing.com/problem/content/description/12/">12.背包问题求具体方案 - AcWing题库</a></p><ul><li>求具体方案。用二维背包去求，先跑一遍二维01。再去逆推出方案。</li><li>注意因为字典序从小到大，所以做01时要倒着做，这样最后选的最后字典序最小的，逆推的时候就可以从最小的开始。</li></ul></li><li><p><a href="https://www.acwing.com/problem/content/1595/">1593.整数分解 - AcWing题库</a></p><ul><li>很巧的一道题。对于样例，背包体积容量169(m)，重量容量5(k)。物品个数是其约数个数n，每个物品的价值是约数的p次方，体积是约数的p次方，重量是1。按字典序大输出，即做完全背包时按约数从小到大，这样倒序找方案的时候就是从大到小。</li></ul></li></ul><h4 id="树形dp">树形dp</h4><ul><li><a href="https://www.acwing.com/problem/content/10/">10.有依赖的背包问题 - AcWing题库</a><ul><li>f(i,j)：i为根节点，容量为j时所能装出的最大方案。考虑如何划分，如果x是根节点，如果考虑x儿子节点内部的选择方式的话，方案太多，不好划分。所以考虑按照容量划分，即枚举给每个儿子节点分配多少的容量。</li><li>坑点1：俩重循环，第一重j从m -v[x]到0倒序，之所以倒序是因为对某儿子，容量只会分配给它一次。</li><li>坑点2：自己是必选的，而且只能选1次，所以要倒序枚举：<code>for (int i = m; i &gt;= v[x]; i--) f[x][i] = f[x][i - v[x]] + w[x];</code></li><li>坑点3：因为自己是必选的，如果自己不选，儿子选了也没用，所以要：<code>for (int i = 0; i &lt; v[x]; i++) f[x][i] = 0;</code></li></ul></li></ul><h3 id="图论">图论</h3><h4 id="最短路">最短路</h4><ul><li><a href="https://www.acwing.com/problem/content/1497/">1495.公共自行车管理 - AcWing题库</a><ul><li>题意稍长但不难懂，看完之后第一反应是多关键字最短路。但是除了距离可以在做dij时维护，“发送的自行车最小数量”和“带回车辆最小数量”是无法在dij的时候维护的。因为这两个量需要知道整段路径的信息后才可求出来，不具有最优子结构。</li><li>所以这题思路就是先dij，然后枚举所有最短路，找出符合条件最优的一条。</li><li>dfs过程中维护参数sum表示从起点走到x时路上所有站点需求变化量之和，这样直到到达终点前，每一步若<code>sum &lt; 0，min_carry = max(min_carry, -sum)</code>，到达终点即可求出“发送的自行车最小数量”。“带回车辆最小数量”= sum + 发送的自行车最小数量。</li></ul></li></ul><h4 id="树">树</h4><ul><li><a href="https://www.acwing.com/problem/content/1499/">1497.树的遍历 - AcWing题库</a><ul><li>经典题。给出中序和后序，后序的最后一个点肯定是root，所以在中序里找到root的位置，然后中序的左半边就是左子树，右半边就是右子树。（从而可算出左右子树节点数量）因为后序是左右根，所以后序序列的[起始,起始 + 左子树数量 - 1]是左子树，[起始 + 左子树数量 - 1 + 1,结束]是右子树。这样就分别在中序和后序序列中得到了左右字数，然后递归即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1529/">1527.判断二叉搜索树 - AcWing题库</a><ul><li>经典题。本质上和上一题一样，因为这题的树是二叉搜索树。而BST的中序遍历就是元素从小到大排序。所以它的中序遍历相当于已经告诉你了。然后它又告诉了你前序遍历。那么根据这俩序列，按照上一题的方法，就可以构造出树了。</li><li>跟上一题不同的是，这里的元素可能会重复。其实问题不大，因为题目中说“左子树上所有结点的值均小于它的根结点的值”，所以若x在中序遍历中出现多次，找最左边的即可。</li><li>然后这题让我们输出后序遍历，其实在构造的时候，在dfs的return前加一句ans[++dex]= root，即可得到后序遍历。</li><li>最后这题还有个翻转机制，翻转其实就是中序遍历reverse一下即可，然后找最左边的变成找最右边的，其余都一样。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1602/">1600.完全二叉树 - AcWing题库</a><ul><li>要求判断一棵树是否是完全二叉树。完全二叉树有一个很好的性质，就是可以存到一个长度为n的序列中。假设当前节点编号是x，则父节点编号为x/2，左儿子编号为x* 2，右儿子编号为x * 2 +1，所以检测一棵树是不是完全二叉树，只需按照上述方法把树编号建到序列中。最后检查1~ n序列中有无空的位置即可。</li></ul></li><li><a href="https://www.acwing.com/problem/content/1552/">1550.完全二叉搜索树 - AcWing题库</a><ul><li>这题很好的结合了完全二叉树和二叉搜索树的特点。前者特点是可用一个数组来存，后者特点是中序遍历为有序。所以以1作为根节点，然后用<em>2,</em>2+1的方式，对树作中序遍历，然后将递增的数字填进相应的位置即可。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;信息学竞赛刷题笔记&lt;/p&gt;</summary>
    
    
    
    <category term="3. 竞赛" scheme="http://example.com/categories/3-%E7%AB%9E%E8%B5%9B/"/>
    
    
  </entry>
  
  <entry>
    <title>FROST—Fast row-stochastic optimization with uncoordinated step-sizes</title>
    <link href="http://example.com/2023/12/04/FROST%E2%80%94Fast-row-stochastic-optimization-with-uncoordinated-step-sizes/"/>
    <id>http://example.com/2023/12/04/FROST%E2%80%94Fast-row-stochastic-optimization-with-uncoordinated-step-sizes/</id>
    <published>2023-12-04T11:49:40.000Z</published>
    <updated>2024-02-19T16:34:50.165Z</updated>
    
    <content type="html"><![CDATA[<p>中文翻译是：非协调步长行随机优化</p><p>个人认为在仔细研读了Distributed那篇文章后，再看这篇文章时，会对双随机、列随机、行随机的算法分别有哪些有一个很好的认识。</p><span id="more"></span><hr /><h3 id="abstract">Abstract</h3><p>本文讨论了构造不出双随机权值的有向图上的分布优化问题。</p><p>现有算法大多采用推和共识算法，利用列随机权值来克服这一问题。列随机权值的形成要求每个代理(至少)知道其输出度，这在诸如基于广播的通信协议中可能是不切实际的。</p><p>与此相反，我们描述了一种适用于不要求出度知识的有向图的快速行随机优化算法。</p><p>该方法的实现很简单，因为每个代理在本地为传入的信息分配权重，并在本地选择合适的步长。我们证明了对于光滑且强凸函数，在最大步长为正且足够小的前提下，算法线性收敛到最优解。</p><hr /><h3 id="introduction">1. Introduction</h3><p>第2节阐述了问题和假设。第3节回顾了使用双随机或列随机权值的相关算法，并展示了这些类型算法分析背后的直觉。在第4节中，我们提供了本文提出的主要算法FROST。在第5节中，我们发展了FROST的收敛性质。第6节给出了仿真结果，第7节总结了本文。</p><p>下面是Notation：</p><p>对于行随机矩阵<spanclass="math inline">\(\underline{A}\)</span>，<spanclass="math inline">\(\pi_r,1_n\)</span>分别是其左右Perron特征向量，满足<spanclass="math inline">\(\pi_r^T1_n = 1\)</span></p><p>对于列随机矩阵<span class="math inline">\(\underline{B}\)</span>，<span class="math inline">\(1_n,\pi_c\)</span>分别是其左右Perron特征向量，满足<spanclass="math inline">\(1_n^T\pi_c = 1\)</span></p><p><span class="math inline">\(\|\|_F\)</span>是Frobenius范数，<spanclass="math inline">\(\|\|_2\)</span>是欧几里得范数，<spanclass="math inline">\(\|\|\)</span>也是一个范数，具体含义看具体那部分的文章</p><p><span class="math inline">\({\otimes}\)</span>表示Kronecker积。</p><hr /><h3 id="problem-formulation">2. Problem formulation</h3><p>如果 j 连向 i ，则<span class="math inline">\((i, j) \in\mathcal{E}\)</span> 另外，目标是最小化总花费，即： <spanclass="math display">\[\min_{\mathbf{x}}F(\mathbf{x})\triangleq\frac{1}{n}\sum_{i=1}^{n}f_{i}(\mathbf{x})\]</span></p><h4 id="assumption-1">Assumption 1</h4><p>图G是无向联通图。</p><h4 id="assumption-2">Assumption 2</h4><p>图G是有向强连通图。</p><h4 id="assumption-3">Assumption 3</h4><p><spanclass="math inline">\(f_i\)</span>是凸函数，且具有有界次梯度。</p><h4 id="assumption-4">Assumption 4</h4><p><spanclass="math inline">\(f_i\)</span>是光滑，且强凸的。（光滑定义：具有连续的导数）</p><p>即满足以下式子： <span class="math display">\[\left\|\nabla f_i(\mathbf{x})-\nabla f_i(\mathbf{y})\right\|_2\leql\|\mathbf{x}-\mathbf{y}\|_2 \\f_i(\mathbf{y})\geq f_i(\mathbf{x})+\nablaf_i(\mathbf{x})^\top(\mathbf{y}-\mathbf{x})+\frac{\mu}{2}\|\mathbf{x}-\mathbf{y}\|_2^2\]</span> 第一个就是导数满足Lipschitz连续，所以<spanclass="math inline">\(f_i\)</span>肯定光滑。</p><p>第二个就是凸函数的定义，因为有不等号右边最后一项的存在，所以<spanclass="math inline">\(f_i\)</span>是个强凸函数。</p><h4 id="assumption-5">Assumption 5</h4><p>网络中的每个玩家都知道自己的编号。</p><h4 id="assumption-6">Assumption 6</h4><p>每个玩家知道它的出度。</p><hr /><h3 id="补充">补充</h3><p>看到这里。我想先停一下。来看一道题：假设每个玩家有一个初始值xi。如果他们都想知道所有玩家初始值的平均值是多少，应该怎么做？</p><p>如果图是平衡的，则用平均一致性算法即可。即类似于：<spanclass="math inline">\(\tilde{\sigma}_i^{k+1}=\sum_{j=1}^Na_{ij}\tilde{\sigma}_j^k\)</span>。</p><p>如果图不平衡，则采用推和算法。 <span class="math display">\[\begin{aligned}&amp;\nu_{k+1}^{i} =\sum_{j=1}^nb_{ij}\nu_k^j,  \\&amp;\mathbf{x}_{k+1}^{i} =\sum_{j=1}^nb_{ij}\mathbf{x}_k^j  \\&amp;\mathbf{z}_{k+1}^{i} =\frac{\mathbf{x}_{k+1}^i}{\nu_{k+1}^i},\end{aligned}\]</span> 每一个点维护两个值：x、v（都是一维的）。所谓推，就是点 j把值xj / 出度推给邻居，把权重vj / 出度推给邻居。所谓和，就是点 i把所有邻居 j 推来的值加一起得到vi，把所有邻居 j推来的权重加一起得到xi。</p><p>注意到，对于任意时刻k，有：<spanclass="math inline">\(\frac{\sum{x_i}}{\sum{v_i}} = \frac{x1 + x2 + ...+ xn}{n} = avg\)</span></p><p>当迭代的次数足够大时，信息已经在网络中充分流转。第 i 个点的<spanclass="math inline">\(x_i\)</span>会收敛到<spanclass="math inline">\(n[\boldsymbol{\pi}_c]_i * avg\)</span>，<spanclass="math inline">\(v_i\)</span>会收敛到<spanclass="math inline">\(n[\pi_c]_i\)</span>，所以<spanclass="math inline">\(\frac{x_i}{v_i} = avg\)</span>。（<spanclass="math inline">\(\pi_c\)</span>是列随机矩阵的右Perron特征向量）</p><p>即每个点的xi / vi都收敛到全局平均值。</p><p>这是一维的情况。</p><p>如果每个玩家的初始值是一个向量xi（权重vi仍然不变初始值为1），则一样的，经过推和算法后，每个玩家的zi都收敛到avg（此时avg就是一个向量）。</p><p>在推和共识上稍加改动，就可以得到下面这个算法： <spanclass="math display">\[\begin{aligned}&amp;\nu_{k+1}^{i} =\sum_{j=1}^nb_{ij}\nu_k^j,  \\&amp;\mathbf{x}_{k+1}^{i}=\sum_{j=1}^nb_{ij}\mathbf{x}_k^j-\alpha_k\nablaf_i\left(\mathbf{z}_k^i\right),  \\&amp;\mathbf{z}_{k+1} =\frac{\mathbf{x}_{k+1}^i}{\nu_{k+1}^i},\end{aligned}\]</span> 下面这个算法只在更新x时加了一个梯度项。</p><p>这样的话，当迭代次数足够多时，第 i 个点的<spanclass="math inline">\(x_i\)</span>会收敛到<spanclass="math inline">\([\boldsymbol{\pi}_c]_i * x^*\)</span>，<spanclass="math inline">\(v_i\)</span>会收敛到<spanclass="math inline">\(n[\pi_c]_i\)</span>，所以<spanclass="math inline">\(\frac{x_i}{v_i} = x^*\)</span>。</p><h3 id="personal-summary">Personal Summary</h3><p>首先是由推和协议衍生出来的算法，推和协议用列随机矩阵可以求出全局平均值（如果玩家动作是动态更新的话，更新sigma时记得+x[i]- xx[i]）。</p><p>因此套一个梯度下降就可以解决聚合游戏问题。</p><p>如果已知最优解都会收敛到一个值的话，可以直接在推和协议中修改加一个梯度项，使得收敛到最优解。为了加快速度，还可以将普通的梯度项改为考虑全局的梯度项。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;中文翻译是：非协调步长行随机优化&lt;/p&gt;
&lt;p&gt;个人认为在仔细研读了Distributed那篇文章后，再看这篇文章时，会对双随机、列随机、行随机的算法分别有哪些有一个很好的认识。&lt;/p&gt;</summary>
    
    
    
    <category term="1. 论文" scheme="http://example.com/categories/1-%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>5. 凸函数的定义</title>
    <link href="http://example.com/2023/11/19/5-%E5%87%B8%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89/"/>
    <id>http://example.com/2023/11/19/5-%E5%87%B8%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89/</id>
    <published>2023-11-19T10:03:32.000Z</published>
    <updated>2024-02-19T16:38:09.573Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了凸函数的四种定义：直接定义、降维定义、一阶可微下的定义、二阶可微下的定义。以及补充了若A为对称矩阵条件下，<spanclass="math inline">\(x^TAx \ge 0 \iff A \succeq 0\)</span>的证明。</p><span id="more"></span><p><img src="1.png" /></p><p><img src="2.png" /></p><p><img src="3.png" /></p><p><img src="4.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍了凸函数的四种定义：直接定义、降维定义、一阶可微下的定义、二阶可微下的定义。以及补充了若A为对称矩阵条件下，&lt;span
class=&quot;math inline&quot;&gt;&#92;(x^TAx &#92;ge 0 &#92;iff A &#92;succeq 0&#92;)&lt;/span&gt;的证明。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="凸优化" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>4. 保凸运算</title>
    <link href="http://example.com/2023/11/19/4-%E4%BF%9D%E5%87%B8%E8%BF%90%E7%AE%97/"/>
    <id>http://example.com/2023/11/19/4-%E4%BF%9D%E5%87%B8%E8%BF%90%E7%AE%97/</id>
    <published>2023-11-19T10:03:11.000Z</published>
    <updated>2024-02-19T16:38:05.748Z</updated>
    
    <content type="html"><![CDATA[<p>介绍了4种不改变集合凸性的运算：集合交、仿射函数、透视函数、线性分数函数。</p><span id="more"></span><p><img src="1.png" /></p><p><img src="2.png" /></p><p><img src="3.png" /></p><p><img src="4.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍了4种不改变集合凸性的运算：集合交、仿射函数、透视函数、线性分数函数。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="凸优化" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E5%87%B8%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>数学知识补充</title>
    <link href="http://example.com/2023/10/31/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/"/>
    <id>http://example.com/2023/10/31/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</id>
    <published>2023-10-31T15:51:42.000Z</published>
    <updated>2024-02-19T16:35:25.898Z</updated>
    
    <content type="html"><![CDATA[<p>论文中涉及到许多基础数学知识，但是在论文里单独展开篇幅太长了。所以统一在这篇blog里记录。</p><span id="more"></span><h3 id="lipschitz连续">Lipschitz连续</h3><p>先看连续的定义：函数<spanclass="math inline">\(f(x)\)</span>在点<span class="math inline">\(x =x_0\)</span>连续<span class="math inline">\(\iff\)</span> <spanclass="math inline">\(\lim_{x \rightarrow x_0}f(x) = f(x_0) \iff \forall\varepsilon&gt;0, \exists\delta = \delta(\varepsilon)&gt;0\)</span>,使得当<span class="math inline">\(|x - x_0| &lt;\delta\)</span>时，有<span class="math inline">\(|f(x) - f(x_0)| &lt;\varepsilon\)</span></p><p>在此定义中，<span class="math inline">\(\delta\)</span>不仅与<spanclass="math inline">\(\varepsilon\)</span>有关，而且与<spanclass="math inline">\(x_0\)</span>有关，应记为<spanclass="math inline">\(\delta = \delta(x_0,\varepsilon)\)</span>。也就是说，对于同一个<spanclass="math inline">\(\varepsilon\)</span>，在不同的<spanclass="math inline">\(x_0\)</span>处，使<spanclass="math inline">\(|f(x) - f(x_0)| &lt;\varepsilon\)</span>的x取值范围可以差得很多。</p><p>所以我们自然会问，对于<span class="math inline">\(\forall \varepsilon&gt; 0\)</span>，是否存在只与<spanclass="math inline">\(\varepsilon\)</span>有关的<spanclass="math inline">\(\delta\)</span>，使得对于区间中任意两点<spanclass="math inline">\(x_1, x_2\)</span>，只要满足<spanclass="math inline">\(|x_1 - x_2| &lt; \delta\)</span>，就成立<spanclass="math inline">\(|f(x_1) - f(x_2)| &lt; \varepsilon\)</span>？</p><p>这就引出了一致连续的定义：设函数<spanclass="math inline">\(f(x)\)</span>在区间X上有定义，若<spanclass="math inline">\(\forall \varepsilon &gt; 0, \exists\delta =\delta(\varepsilon) &gt; 0\)</span>，使得对于区间X中的任意两点<spanclass="math inline">\(x_1, x_2\)</span>，只要满足<spanclass="math inline">\(|x_1 - x_2| &lt; \delta\)</span>，就成立<spanclass="math inline">\(|f(x_1) - f(x_2)| &lt;\varepsilon\)</span>，则称函数<spanclass="math inline">\(f(x)\)</span>在区间X上一致连续。</p><p>可以发现一致连续是比连续更强的一个条件。接下来要讲的Lipschitz连续，是比一致连续还要强的一个条件。</p><p>先给出Lipschitz连续的定义：设函数<spanclass="math inline">\(f(x)\)</span>在区间X上有定义，若存在<spanclass="math inline">\(L &gt; 0\)</span>，使得对于区间X中的任意两点<spanclass="math inline">\(x_1, x_2\)</span>，都满足<spanclass="math inline">\(|f(x_1) - f(x_2)| \le L|x_1 -x_2|\)</span>，则称<spanclass="math inline">\(f(x)\)</span>在区间X上是Lipschitz连续。</p><blockquote><p>下面证明Lipschitz连续是比一致连续更强的一个条件：</p><p>证明：<span class="math inline">\(\forall \varepsilon &gt;0\)</span>，取<span class="math inline">\(\delta = \frac{\varepsilon}{L}&gt; 0\)</span>，则<span class="math inline">\(\forall x_1, x_2 \inX\)</span>，当<span class="math inline">\(|x_1 - x_2| &lt;\delta\)</span>时，<span class="math inline">\(|f(x1) - f(x_2)| \leL|x_1 - x_2| &lt; L\delta = L \cdot \frac{\varepsilon}{L} =\varepsilon\)</span>，得证。</p></blockquote><h3 id="矩阵范数">矩阵范数</h3><h4 id="矩阵范数定义">1. 矩阵范数定义</h4><p>矩阵范数的定义如下：</p><p>若函数<span class="math inline">\(f: R^{n \times n} \rightarrowR\)</span>满足：</p><ol type="1"><li>正定性：<span class="math inline">\(f(A) \ge 0, \forall A \in R^{n\times n}\)</span>，等号当且仅当<span class="math inline">\(A =0\)</span>成立</li><li>齐次性：<span class="math inline">\(f(\alpha A) = |\alpha| \cdotf(A), \forall A \in R^{n \times n}, \alpha \in R​\)</span></li><li>三角不等式：<span class="math inline">\(f(A \pm B) \le f(A) + f(B),\forall A, B \in R^{n \times n}\)</span></li><li>相容性：<span class="math inline">\(f(AB) \le f(A) \cdot f(B),\forall A, B \in R^{n \times n}\)</span></li></ol><p>则将<span class="math inline">\(f(x)\)</span>称为<spanclass="math inline">\(R^{n \times n}\)</span>上的范数，记作<spanclass="math inline">\(\|\cdot\|\)</span></p><p>还有一条性质，有些矩阵范数也是满足的，即与向量的相容性：</p><p><span class="math inline">\(f(Ax) \le f(A) \cdot f(x), \forall A \inR^{n \times n}, x \in R^{n}\)</span></p><h4 id="算子从属范数">2. 算子(从属)范数</h4><p>矩阵范数跟向量范数一样，有很多种。但大多数情况都是用的算子(从属)范数中的二范数（谱范数）。</p><p>先来介绍一下算子范数</p><p>定义：设<span class="math inline">\(\|\cdot\|\)</span>是<spanclass="math inline">\(R^n\)</span>上的任意一个范数，若对<spanclass="math inline">\(\forall A \in R^{n \times n}\)</span>满足 <spanclass="math display">\[\|A\| = max_{x \ne 0} \frac{\|Ax\|}{\|x\|} = max_{\|x\| = 1} \|Ax\|\]</span> 则矩阵范数<spanclass="math inline">\(\|\cdot\|\)</span>称为从属于向量范数的矩阵范数。也叫由向量范数诱导出来的算子范数。</p><p>算子范数肯定是满足矩阵范数的四条定义的，而且它还满足与向量的相容性！（证明网上一大堆略）</p><p>另外，对于所有的矩阵算子范数，它们都是等价的。俩矩阵范数等价的定义如下：</p><p>俩矩阵范数<spanclass="math inline">\(\|\cdot\|_\alpha\)</span>与<spanclass="math inline">\(\|\cdot\|_\beta\)</span>等价，当且仅当存在两个正数<spanclass="math inline">\(d_1, d_2\)</span>，使得对于任意矩阵A，都有<spanclass="math inline">\(d_1\|A\|_\beta \le \|A\|_\alpha \led_2\|A\|_\beta\)</span></p><p>一般我们推导不常用范数的有界性时，先推容易算的范数的有界性，再用所有范数等价这条性质来放缩。</p><h4 id="矩阵二范数谱范数">3. 矩阵二范数（谱范数）</h4><p>如果算子范数角标取2，就变成了谱范数： <span class="math display">\[\|A\|_2 = max_{x \ne 0} \frac{\|Ax\|_2}{\|x\|_2} = max_{\|x\|_2 = 1}\|Ax\|_2\]</span>矩阵A的谱范数的实际意义是”矩阵A能将向量放大的最大倍数“。在数值上为矩阵A的最大奇异值（<spanclass="math inline">\(\sqrt{\lambda_{max}(A^TA)}\)</span>）。</p><p>那为啥要叫谱范数呢？它跟谱半径又有什么关系呢？</p><p>先回忆一下矩阵谱半径的定义：<spanclass="math inline">\(\rho(A)=\max\{|\lambda|:\lambda\in\lambda(A)\}\)</span></p><p>当<spanclass="math inline">\(A\)</span>为对称矩阵时，其特征值的绝对值就是它的奇异值。所以有<spanclass="math inline">\(\rho(A) = \sqrt{\lambda_{max}(A^TA)} =\|A\|_2\)</span></p><p>这就是为什么矩阵二范数别称叫谱范数的原因hhhh。</p><h4 id="几个与谱半径有关的定理">4. 几个与谱半径有关的定理</h4><h5 id="section">4.1</h5><p>定理：谱半径小于等于任意一种范数</p><p>证明：设<spanclass="math inline">\(\lambda\)</span>为A的特征值，则<spanclass="math inline">\(A\alpha =\lambda\alpha\)</span>，两边同时取范数得<spanclass="math inline">\(\|A\alpha\| = \|\lambda\alpha\|\)</span>。</p><p>由于算子范数满足与向量的相容性和齐次性，所以有：<spanclass="math inline">\(\|A\alpha\| = |\lambda|\|\alpha\| \le\|\alpha\|\|A\|\)</span></p><p>同除<span class="math inline">\(\|\alpha\|\)</span>，得：<spanclass="math inline">\(|\lambda| \le \|A\|\)</span></p><p>所以<span class="math inline">\(\rho(A) = |\lambda|_{max} \le\|A\|\)</span>，得证。</p><h5 id="section-1">4.2</h5><p>定理：<spanclass="math inline">\(\lim_{k\to\infty}A^k=0\Leftrightarrow\rho(A)&lt;1\)</span></p><p>充分性：因为<span class="math inline">\(\rho(A) &lt;1\)</span>，所以必然可以找到一个矩阵范数，s.t. <spanclass="math inline">\(\|A\| &lt; 1\)</span>。</p><p>所以<span class="math inline">\(\|A^k\| \le \|A\|^k\)</span>，当<spanclass="math inline">\(k \rightarrow \infty\)</span>时，<spanclass="math inline">\(\|A^k\| \le \|A\|^k \rightarrow 0\)</span>。</p><p>又因为矩阵范数满足正定性，所以<spanclass="math inline">\(\lim_{k\to\infty}A^k=0\)</span></p><p>必要性（反证法）：假设<span class="math inline">\(\rho(A) \ge1\)</span>，设<span class="math inline">\(\lambda\)</span>为满足<spanclass="math inline">\(|\lambda| \ge 1\)</span>的特征值，假设<spanclass="math inline">\(\alpha\)</span>为对应的特征向量，则有<spanclass="math inline">\(A^k\alpha = \lambda^k\alpha\)</span></p><p>两边取范数，得：<spanclass="math inline">\(\left\|A^k\alpha\right\|=\left\|\lambda^k\alpha\right\|=\left|\lambda^k\right|\left\|\alpha\right\|\geq\left\|\alpha\right\|\)</span></p><p>又因为<spanclass="math inline">\(\|A^k\alpha\|\leq\|A^k\|\|\alpha\|\)</span></p><p>所以<span class="math inline">\(\|A^k\|\|\alpha\| \ge\|\alpha\|\)</span></p><p>同除，得：<span class="math inline">\(\|A^k\| \ge 1\)</span></p><p>与<spanclass="math inline">\(\lim_{k\to\infty}A^k=0\)</span>矛盾，所以假设不成立，所以<spanclass="math inline">\(\rho(A) &lt; 1\)</span>，得证。</p><h5 id="section-2">4.3</h5><p>设<span class="math inline">\(A \in R^{n \timesn}\)</span>，则有：</p><ol type="1"><li><p><span class="math inline">\(\sum_{k=0}^{\infty}A^{k}\)</span>收敛可推出 <span class="math inline">\(\rho(A) &lt; 1\)</span></p></li><li><p>当<spanclass="math inline">\(\sum_{k=0}^{\infty}A^{k}\)</span>收敛时，它将收敛于：<span class="math display">\[\sum_{k=0}^{\infty}A^{k} = (I - A)^{-1}\]</span> 而且存在一种算子范数<spanclass="math inline">\(\|\cdot\|\)</span>，使得 <spanclass="math display">\[\|(I-A)^{-1}-\sum_{k=0}^mA^k\|\leq\frac{\|A\|^{m+1}}{1-\|A\|}, m \in\mathbb{N}\]</span></p></li></ol><p>证明：第一条很容易证明，当收敛时它的第无穷项肯定是收敛于0的，然后由4.2即可推出。</p><p>下面证明第二条：</p><p>因为<span class="math inline">\(\rho(A) &lt; 1\)</span>，所以<spanclass="math inline">\(I - A\)</span>的特征值<spanclass="math inline">\(1 - \lambda \ne 0\)</span>，因此<spanclass="math inline">\(|I - A| \ne 0\)</span>，所以<spanclass="math inline">\(I - A\)</span>可逆。</p><p>又因为<spanclass="math inline">\((I-A)(I+A+\ldots+A^k)=I-A^{k+1}\)</span></p><p>所以<spanclass="math inline">\((I+A+\ldots+A^k)=(I-A)^{-1}(I-A^{k+1})\)</span></p><p>又因为<span class="math inline">\(k \rightarrow 0\)</span>时，<spanclass="math inline">\(A^{k+1} \rightarrow 0\)</span></p><p>所以<spanclass="math inline">\((I+A+\ldots+A^k)=(I-A)^{-1}\)</span></p><p>即<spanclass="math inline">\(\sum_{k=0}^{\infty}A^k=(I-A)^{-1}\)</span></p><h4 id="总结">5. 总结</h4><p>介绍了矩阵范数。重点讲解了矩阵二范数（谱范数）。以及介绍了与谱半径相关的定理。</p><ol type="1"><li>定理1是将谱半径与矩阵范数联系起来</li><li>定理2讨论了矩阵阶乘收敛问题</li><li>定理3讨论了矩阵阶乘数列之和收敛问题</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;论文中涉及到许多基础数学知识，但是在论文里单独展开篇幅太长了。所以统一在这篇blog里记录。&lt;/p&gt;</summary>
    
    
    
    <category term="1. 论文" scheme="http://example.com/categories/1-%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Linear convergence in optimization over directed graphs with row-stochastic matrices</title>
    <link href="http://example.com/2023/10/31/Linear-convergence-in-optimization-over-directed-graphs-with-row-stochastic-matrices/"/>
    <id>http://example.com/2023/10/31/Linear-convergence-in-optimization-over-directed-graphs-with-row-stochastic-matrices/</id>
    <published>2023-10-31T15:26:13.000Z</published>
    <updated>2024-02-19T16:34:53.580Z</updated>
    
    <content type="html"><![CDATA[<p>标题：Linear convergence in optimization over directed graphs withrow-stochastic matrices</p><p>中文翻译：行随机矩阵有向图优化的线性收敛性</p><span id="more"></span><h3 id="abstract">Abstract</h3><p>本文研究的是一个多智能体网络（有向图）上的分布式优化问题，其中目标函数是每个玩家成本函数的总和。</p><p>现存的在有向图上的分布式优化算法都至少需要每个玩家知道其邻居的出度。但本文不需要。而且最佳收敛速度为<spanclass="math inline">\(O(\mu^{k}), 0 &lt; \mu &lt; 1, k\)</span> is thenumber of 迭代。</p><p>前提是目标函数为强凸函数，且具有Lipschitz连续梯度。</p><h3 id="introduction">1. Introduction</h3><p>近年来出现了许多分布式优化方法，最初的方法是基于梯度下降，这种方法直观且计算简单，但由于算法使用的步长逐渐减小，通常速度较慢。证明了任意凸函数的收敛速度为<spanclass="math inline">\(O(\frac{\lnk}{\sqrt{k}})\)</span>，强凸函数的收敛速度为<spanclass="math inline">\(O(\frac{\ln k}k)\)</span>。</p><p>后来，发展出基于拉格朗日对偶变量的方法，例如分布式对偶分解[15]、分布式实现交替方向乘法器[16- 18]。对于强凸函数收敛速度将达到<spanclass="math inline">\(O(\mu^k)\)</span>，缺点是计算代价比较高。</p><p>再后来，为了兼顾收敛速度和计算简易性，一些分布式算法在保持步长不变的前提下，不使用对偶变量。例如分布式Nesterov-based方法，对于任意满足有界和Lipschitz梯度的凸函数，收敛速度达到<spanclass="math inline">\(O(\frac{\ln k}{k^2})\)</span>。还例如[20],[21]中的方法，用固定步长和历史梯度信息实现了对一般凸函数<spanclass="math inline">\(O(\frac{1}{k})\)</span>，强凸函数<spanclass="math inline">\(O(\mu^k)\)</span>的收敛速度。</p><p>但是上面这些方法都是在基于无向图或者权重平衡图上考虑的。但是实际中更多的是权重不平衡有向图的情况，所以这篇论文就是来解决这个问题的。</p><p>怎么解决呢？一般分布式优化中通常需要双随机矩阵，可是有向图中得不到双随机矩阵，只能得到行随机矩阵或者列随机矩阵。本文提出的算法参考了[36]。</p><p>Notation：</p><ul><li><p>小写字母是标量，小写粗体是向量，大写字母是矩阵</p></li><li><p>The spectral radius of a matrix A is <spanclass="math inline">\(\rho(A)\)</span>。谱半径就是A的特征值绝对值的最大值</p></li><li><p><span class="math inline">\(\lambda_{i}(A)\)</span> denotes the<span class="math inline">\(i-th\)</span> largest eigenvalue ofA.</p></li><li><p>对于一个最简的行随机矩阵A，将其特征值1的右特征向量记为<spanclass="math inline">\(1_n\)</span>，左特征向量记为<spanclass="math inline">\(\pi ^T\)</span>，使得<spanclass="math inline">\(\pi ^T \cdot 1_n = 1\)</span>。</p></li><li><p><spanclass="math inline">\(\|\cdot\|\)</span>被定义为一个特殊的矩阵范数，在Lemma2中会讲到</p></li><li><p><spanclass="math inline">\(\|\cdot\|_2\)</span>就是普通的向量或者矩阵的二范数</p></li><li><p>有性质： <span class="math display">\[\begin{aligned}c&#39;\|\cdot\|\leq\|\cdot\|_2\leq c\|\cdot\|\\d&#39;\|\cdot\|_2\leq\|\cdot\|\leq d\|\cdot\|_2\end{aligned} \\c&#39;, c, d&#39;, d\,are\,some\,positive\,constants\]</span></p></li><li><p>更多关于向量和矩阵范数的知识，参考[37]</p></li></ul><h3 id="problem-assumptions-algorithm">2. Problem, Assumptions,Algorithm</h3><p>Problem：</p><p>把问题描述为一个强连通有n个玩家的有向图：<spanclass="math inline">\(\mathcal{G}=(\mathcal{V},\mathcal{E})\)</span>。注意若<spanclass="math inline">\((i, j) \in \mathcal{E}\)</span>，则<spanclass="math inline">\(j\)</span>可以发信息给<spanclass="math inline">\(i\)</span>。定义<spanclass="math inline">\(\mathcal{N}_i^{in}\)</span>为<spanclass="math inline">\(i\)</span>自己加上<spanclass="math inline">\(i\)</span>的邻居，这个集合也就是能发信息给<spanclass="math inline">\(i\)</span>的玩家集合。</p><p>我们要的目标函数是这个：<spanclass="math inline">\(min\,f(\mathbf{x})=\sum_{i=1}^nf_i(\mathbf{x})\)</span></p><p>需要注意<spanclass="math inline">\(f_i\)</span>是凸且可微的，并且只有玩家<spanclass="math inline">\(i\)</span>知道。</p><p>Assumption 1：有向图是强连通的。</p><p>Assumption 2：每个<spanclass="math inline">\(f_i\)</span>是可微且强凸的。且对x导数（梯度）具有Lipschitz连续。具体来说，<spanclass="math inline">\(f_i\)</span>满足如下两个定义：</p><blockquote><p><spanclass="math inline">\(f_i(\mathbf{x}_1)-f_i(\mathbf{x}_2)\leq\nablaf_i(\mathbf{x}_1)^\top(\mathbf{x}_1-\mathbf{x}_2)-\frac{s}{2}\|\mathbf{x}_1-\mathbf{x}_2\|_2^2\)</span>，s是正整数</p><p><span class="math inline">\(\|\nabla f_i(\mathbf{x}_1)-\nablaf_i(\mathbf{x}_2)\|_2\leql\|\mathbf{x}_1-\mathbf{x}_2\|_2\)</span>，l是正整数</p></blockquote><p>因为<span class="math inline">\(f\)</span>是所有<spanclass="math inline">\(f_i\)</span>之和，所以<spanclass="math inline">\(f\)</span>也是满足强凸和Lipschitz梯度连续的，也就是满足上面那俩式子。显然常数分别为<spanclass="math inline">\(ns, nl\)</span>。</p><p>Algorithm： <span class="math display">\[\begin{gathered}\mathbf{x}_{k+1,i}=\sum_{j=1}^{n}a_{ij}\mathbf{x}_{k,j}-\alpha\mathbf{z}_{k,i},\left.\left(\begin{matrix}{1}{\mathrm{a}}\\\end{matrix}\right.\right) \\\mathbf{y}_{k+1,i} =\sum_{j=1}^{n}a_{ij}\mathbf{y}_{k,j}, (1\mathrm{b})\\\mathbf{z}_{k+1,i} =\sum_{j=1}^{n}a_{ij}\mathbf{z}_{k,j}+{\frac{\nablaf_{i}(\mathbf{x}_{k+1,i})}{[\mathbf{y}_{k+1,i}]_{i}}}-{\frac{\nablaf_{i}(\mathbf{x}_{k,i})}{[\mathbf{y}_{k,i}]_{i}}}\left.\left(\begin{matrix}{1}{\mathrm{c}}\\\end{matrix}\right.\right)\end{gathered}\]</span> <span class="math inline">\(a_{ij}\)</span> 满足下面这个条件：<span class="math display">\[a_{ij}=\begin{cases}&amp;&gt;0,&amp;j\in\mathcal{N}_i^\mathrm{in},\\&amp;0,&amp;\mathrm{otw.},\end{cases}\quad\sum_{j=1}^na_{ij}=1,\foralli\]</span></p><p><span class="math inline">\(\alpha &gt; 0\)</span> is a constantstep-size</p><p><span class="math inline">\(\nablaf_{i}(\mathbf{x}_{k,i})\in\mathbb{R}^{p}\)</span> is the gradient of<span class="math inline">\(f_i\)</span> at <spanclass="math inline">\(x_{k, i}\)</span></p><p><span class="math inline">\(x_0\)</span> is arbitrary, <spanclass="math inline">\(\mathbf{y}_{0,i}=\mathbf{e}_i, \quad\mathbf{z}_{0,i}=\nabla f_i(\mathbf{x}_{0,i})\)</span></p><p>上面的算法中</p><p>根据[38]中的Perron-Frobenius定理，(1b)将收敛到矩阵A的左特征向量<spanclass="math inline">\(\pi ^T\)</span>。</p><p>(1c)使用(1b)来缩放梯度，从而消除了行随机矩阵引起的不平衡。</p><p>而且，为了简化证明，其实可以把<span class="math inline">\(x_{k, i},z_{k, i}, \nablaf_i(x_{k,i})\)</span>,$看成一维的。只要一维的得证了，后续套一个Kroneckerproduction notation就可以把p维的证出来了。</p><p>为了简化表达，我们定义下面式子： <span class="math display">\[\begin{aligned}\mathbf{x}_{k}&amp; =[x_{k,1},\cdots,x_{k,n}]^{\top},  \\\mathbf{Z}_{k}&amp; =[z_{k,1},\cdots,z_{k,n}]^{\top},  \\\nabla\mathbf{f}_{k}&amp; =\left[\nabla f_1(x_{k,1}),\cdots,\nablaf_n(x_{k,n})\right]^\top,  \\Y_{k}&amp; =[\mathbf{y}_{k,1},\cdots,\mathbf{y}_{k,n}]^\top,  \\\widetilde{Y}_{k}&amp; =\operatorname{diag}(Y_k).\end{aligned}\]</span> 则algorithm 1可以写成以下形式： <span class="math display">\[\begin{gathered}\mathbf{x}_{k+1}= A\mathbf{x}_{k}-\alpha\mathbf{z}_{k}, (2\mathrm{a}) \\Y_{k+1}= AY_{k}, (2\mathrm{b}) \\\mathbf{z}_{k+1}= A\mathbf{z}_{k}+\widetildeY_{k+1}^{-1}\nabla\mathbf{f}_{k+1}-\widetildeY_{k}^{-1}\nabla\mathbf{f}_{k}, \text{(2c)}\end{gathered}\]</span></p><h3 id="main-results">3. Main results</h3><p>定义：<spanclass="math inline">\(Y_\infty=\lim_{k\to\infty}Y_k\)</span></p><p>因为<span class="math inline">\(Y_k = AY_{k-1} = A^2Y_{k-2} =...\)</span></p><p>所以<spanclass="math inline">\(\operatorname*{lim}_{k\to\infty}Y_{k}=\operatorname*{lim}_{k\to\infty}A^{k}\)</span>（<spanclass="math inline">\(Y_1=I_n\)</span>）</p><p>又由[38]中的Perron-Frobenius定理，<spanclass="math inline">\(Y_k\)</span>将收敛到<spanclass="math inline">\(1_n\pi ^ T\)</span></p><p>即<spanclass="math inline">\(Y_\infty=\lim\limits_{k\to\infty}Y_k=\operatorname*{lim}\limits_{k\to\infty}A^k=1_n\pi^T\)</span>继续定义： <span class="math display">\[\begin{aligned}\mathbf{x}^{*}&amp; =x^{*}\mathbf{1}_{n},  \\\widehat{\mathbf{x}}_{k}&amp; =Y_{\infty}\mathbf{x}_{k},  \\\widehat{z}_{k}&amp; =Y_{\infty}\mathbf{z}_{k},  \\\nabla\mathbf{f}^{*}&amp; =[\nabla f_{1}(x^{*}),\cdots,\nablaf_{n}(x^{*})]^{\top},  \\\nabla\widehat{\mathbf{f}}_{k}&amp;=\frac{1}{n}\mathbf{1}_{n}\mathbf{1}_{n}^{\top}\left[\nablaf_{1}(\widehat{x}_{k}),...,\nabla f_{n}(\widehat{x}_{k})\right]^{\top},\end{aligned}\]</span></p><p><span class="math display">\[\begin{aligned}&amp;\tau=\left\|A-I_{n}\right\|_{2}, \\&amp;\epsilon=\left\|I_{n}-Y_{\infty}\right\|_{2}, \\&amp;\eta=\operatorname*{max}\left(\left|1-\alphanl\right|,\left|1-\alpha ns\right|\right)\end{aligned}\]</span></p><p><span class="math inline">\(l, s\)</span>出自这： $$f_i(_1)-f_i(_2)f_i(_1)^(_1-_2)-|_1-_2|_2^2$，s是正整数 \</p>|f_i(_1)-f_i(_2)|_2l|_1-_2|_2$，l是正整数 <span class="math display">\[继续定义：\]</span><span class="math display">\[\begin{aligned}&amp;y=\operatorname*{sup}_{k}\left\|Y_{k}\right\|_{2}, \\&amp;\widetilde{y}=\operatorname*{sup}_{k}\left\|\widetilde{Y}_{k}^{-1}\right\|_{2}.\end{aligned}\]</span><p>$$</p><h4 id="lemma-1">Lemma 1</h4><p><span class="math inline">\(\left\|Y_k-Y_\infty\right\|_2\leqT\gamma_1^k,\quad\forall k.\quad(3) \\ 0 &lt; \gamma &lt; 1 \, and \, 0&lt; T &lt; \infty\)</span></p><p>推导参考[22]</p><h4 id="lemma-2">Lemma 2</h4><p>For any <span class="math inline">\(a \in \mathbb{R^n}\)</span>,define <spanclass="math inline">\(\widehat{\mathbf{a}}=Y_{\infty}\mathbf{a}\)</span>.Then there exists <span class="math inline">\(0&lt;\sigma&lt;1\)</span>such that <span class="math display">\[\left\|A\mathbf{a}-\widehat{\mathbf{a}}\right\|\leq\sigma\left\|\mathbf{a}-\widehat{\mathbf{a}}\right\|\qquad (4)\]</span> Proof:</p><p>由[38]中的Perron-Frobenius定理，得<spanclass="math inline">\(\rho(A)=1\)</span> and every eigenvalue of A otherthan 1 is strictly less than <spanclass="math inline">\(\rho(A)\)</span>。</p><p>We now have： <span class="math display">\[\begin{array}{rcl}AY_\infty&amp;=&amp;A\mathbf{1}_n\pi^\top&amp;=&amp;\mathbf{1}_n\pi^\top&amp;=&amp;Y_\infty,\\Y_\inftyY_\infty&amp;=&amp;\mathbf{1}_n\pi^\top\mathbf{1}_n\pi^\top&amp;=&amp;\mathbf{1}_n\pi^\top&amp;=&amp;Y_\infty,\end{array}\]</span> and thus <spanclass="math inline">\(AY_{\infty}-Y_{\infty}Y_{\infty}\)</span> is azero matrix. Therefore, <span class="math display">\[A\mathbf{a}-Y_\infty\mathbf{a}\quad=\quad(A-Y_\infty)(\mathbf{a}-Y_\infty\mathbf{a}).\]</span></p><blockquote><p>右边打开：Aa - AYa - Ya + Y^2a = Aa - AYa - Ya + Ya = Aa - AYa = Aa -Ya = 左边</p></blockquote><p>所以 <span class="math display">\[\left\|A\mathbf{a}-Y_\infty\mathbf{a}\right\|\quad\leq\quad\left\|A-Y_\infty\right\|\left\|\mathbf{a}-Y_\infty\mathbf{a}\right\|,\quad\left(5\right)\]</span> 又<span class="math inline">\(\|A - Y_\infty\| &lt; 1\)</span><strong><u>为啥</u></strong></p><p>所以</p><p><spanclass="math inline">\(\left\|A\mathbf{a}-\widehat{\mathbf{a}}\right\|\leq\sigma\left\|\mathbf{a}-\widehat{\mathbf{a}}\right\|\)</span>，<spanclass="math inline">\(\sigma=\left\|A-Y_{\infty}\right\|\)</span>，且<spanclass="math inline">\(0 &lt; \sigma &lt; 1\)</span></p><h4 id="lemma-3">Lemma 3</h4><p>There exists some constant <spanclass="math inline">\(\widetilde{T}\)</span> such that the followinginequalities hold for all k &gt;= 1 <span class="math display">\[(a)\left\|\widetilde{Y}_k^{-1}-\widetilde{Y}_\infty^{-1}\right\|_2\leq\widetilde{y}^2\widetilde{T}\gamma_1^k\\(b)\left\|\widetilde{Y}_{k+1}^{-1}-\widetilde{Y}_{k}^{-1}\right\|_{2}\leq2\widetilde{y}^{2}\widetilde{T}\gamma_{1}^{k}\]</span> Proof:</p><p>先推(a) <span class="math display">\[\begin{aligned}\left\|\tilde{Y}_{k}^{-1}-\tilde{Y}_{\infty}^{-1}\right\|_{2}&amp;\leq\left\|\tilde{Y}_{k}^{-1}\right\|_{2}\left\|\tilde{Y}_{k}-\tilde{Y}_{\infty}\right\|_{2}\left\|\tilde{Y}_{\infty}^{-1}\right\|_{2},  \\&amp;\leq\tilde{y}^{2}\widetilde{T}\gamma_{1}^{k},\end{aligned}\]</span> 第一个不等号推导见“Distributed Nash Equilibrium Seekingfor...”的Lemma 1证明</p><p>第二个不等号用了<spanclass="math inline">\(\widetilde{y}\)</span>的定义和Lemma 1</p><p>再推(b)，用推(a)一样的方法，先推出：</p><p><spanclass="math inline">\(\left\|\widetilde{Y}_{k+1}^{-1}-\widetilde{Y}_{k}^{-1}\right\|_2\le \|\widetilde{Y}_{k+1}\| \cdot \|\widetilde{Y}_{k}^{-1}\| \cdot\|\widetilde{Y}_{k+1} - \widetilde{Y}_k\| \le \widetilde{y}^2 \cdot\|\widetilde{Y}_{k+1} - \widetilde{Y}_k\|\)</span></p><p>又<span class="math inline">\(\|\widetilde{Y}_{k+1} -\widetilde{Y}_k\| = \|\widetilde{Y}_{k+1} - \widetilde{Y}_{\infty}\ -(\widetilde{Y}_{k} - \widetilde{Y}_{\infty})\| \le \|\widetilde{Y}_{k+1}- \widetilde{Y}_{\infty}\| + \|\widetilde{Y}_{k} -\widetilde{Y}_{\infty}\| \le 2\widetilde{T}\gamma_{1}^{k}\)</span></p><p>所以</p><p><spanclass="math inline">\(\left\|\widetilde{Y}_{k+1}^{-1}-\widetilde{Y}_{k}^{-1}\right\|_2\le 2\widetilde{y}^2\widetilde{T}\gamma_{1}^{k}\)</span>，得证。</p><p>剩下来的内容不继续看了，因为需要的知识已经找到了，就是Lemma 3</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;标题：Linear convergence in optimization over directed graphs with
row-stochastic matrices&lt;/p&gt;
&lt;p&gt;中文翻译：行随机矩阵有向图优化的线性收敛性&lt;/p&gt;</summary>
    
    
    
    <category term="1. 论文" scheme="http://example.com/categories/1-%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>数字逻辑实验笔记</title>
    <link href="http://example.com/2023/10/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/23/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-23T04:40:07.000Z</published>
    <updated>2024-02-19T16:39:28.220Z</updated>
    
    <content type="html"><![CDATA[<p>这一部分主要是verilog语法，比较简单。</p><span id="more"></span><h3 id="两种声明方式">两种声明方式</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AND4(a, b, out);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">assign</span> out = a &amp; b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AND4(<span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a, <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] b, <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] out);</span><br><span class="line">    <span class="keyword">assign</span> out = a &amp; b;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="数据类型">数据类型</h3><p>掌握wire和reg即可。</p><p>wire就是对应着电路里的线。reg就是对应着电路里的寄存器。</p><p>常量用parameter定义，例如parameter width = 3;但是常量也可以重定义，例如下面这个例子：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> adder(a, b, sum);</span><br><span class="line">    <span class="keyword">parameter</span> time_delay = <span class="number">5</span>, time_count = <span class="number">10</span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> top;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">2</span>:<span class="number">0</span>] a1, b1;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] sum1;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] a2, b2;</span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] sum2;</span><br><span class="line">    adder <span class="variable">#(4, 8) AD1(a1, b1, sum1)</span>;    <span class="comment">//time_delay=4, time_count=8</span></span><br><span class="line">    adder <span class="variable">#(12) AD2(a2, b2, sum2)</span>;    <span class="comment">//time_delay=12, time_count=10</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="数据的表达方式">数据的表达方式</h3><p><位宽>'<进制><数字>：4'b0101 / 4‘h5</p><p><进制><数字>：位宽一般默认是32位。h5</p><p><数字>：位宽默认32位，进制默认为十进制。5</p><h3 id="拼接运算符">拼接运算符</h3><p>{a, b[3:0], w, 3'b101} 等价于 {a, b[3], b[2], b[1], b[0], w, 1'b1,1'b0, 1'b1}</p><p>{4{w}} 等价于 {w, w, w, w}</p><p>{b, 3{a, b}} 等价于 {b, a, b, a, b, a, b}</p><h3 id="赋值语句">赋值语句</h3><p>assign只能对wire类型赋值。assign的作用通常就是把reg的结果用一个wire接收。</p><p>initial里对reg变量赋初值。</p><p>always里的=(阻塞赋值)/&lt;=(非阻塞赋值)对always块里的reg类型赋值。</p><p>always语句</p><p>always @ (clk) //只要clk发生变化就触发 always @ (posedge clk)//clk上升沿触发（从0-&gt;1触发）</p><p>always @ (negedge clk) //clk下降沿触发（从1-&gt;0触发）</p><p>always @ (*) //always块内任何输入信号变化了就触发</p><h3 id="条件语句">条件语句</h3><p>条件语句只能用于always或initial内部。只需要掌握if-else和case语句即可。</p><p>if-else语句：跟C++一样，只不过多条语句时将{}换成begin-end</p><p>case语句：有case/casex/casez可以选择。casex就是分支表达式中可以有?作为通配符。</p><h3 id="循环语句">循环语句</h3><p>一般循环语句都是用来写仿真文件的。因为循环次数不确定的循环语句是不能被综合的！</p><p>所以一般用循环语句来写源代码都是用for循环</p><hr /><p>接下来的内容就是实验了，实验代码自己手撸的。而且只学了基本语法就开干了，所以代码自我感觉很丑不优美。</p><h3 id="实验一">实验一</h3><p><img src="1.png" /></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> demo02_verilog #(<span class="keyword">parameter</span> W1 = <span class="number">1</span>, W2 = <span class="number">3</span>) (</span><br><span class="line">    <span class="keyword">input</span> [(W1 - <span class="number">1</span>) : <span class="number">0</span>] sw15, sw14,</span><br><span class="line">    <span class="keyword">input</span> [(W2 - <span class="number">1</span>) : <span class="number">0</span>] in1, in2, in3, in4,</span><br><span class="line">    <span class="keyword">output</span> [(W2 - <span class="number">1</span>) : <span class="number">0</span>] ld</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">//错误代码：assign ld = (~sw15 &amp; ~sw14 &amp; in1) | (~sw15 &amp; sw14 &amp; in2) | (sw15 &amp; ~sw14 &amp; in3) | (sw15 &amp; sw14 &amp; in4);</span></span><br><span class="line">    <span class="keyword">assign</span> ld = sw15 ? (sw14 ? in4 : in3) : (sw14 ? in2 : in1);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="实验二">实验二</h3><p><img src="2.png" /></p><ul><li>top.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top(a, b, t, e, l1, l2, l3, clk, reset, an, led);</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">output</span> t, e;</span><br><span class="line">    <span class="keyword">output</span> l1, l2, l3;  <span class="comment">//控制负数亮灯</span></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] out;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">input</span> clk, reset;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] an;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>] led;</span><br><span class="line">    </span><br><span class="line">    add <span class="variable">#(4) f1(.a(a), .b(b), .out(out), .t(t), .e(e))</span>;</span><br><span class="line">    show(<span class="variable">.clk</span>(clk), <span class="variable">.reset</span>(reset),</span><br><span class="line">         <span class="variable">.hex0</span>(out), <span class="variable">.hex2</span>(b), <span class="variable">.hex3</span>(a),</span><br><span class="line">         <span class="variable">.an</span>(an), <span class="variable">.sseg</span>(led), <span class="variable">.l1</span>(l1), <span class="variable">.l2</span>(l2), <span class="variable">.l3</span>(l3));</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>add.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进位不影响补码运算的正确性，溢出影响正确性，溢出的本质就是超过了位宽能表达的范围</span></span><br><span class="line"><span class="keyword">module</span> add (a, b, out, t, e);</span><br><span class="line">    <span class="keyword">parameter</span> W = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">input</span> [W-<span class="number">1</span>:<span class="number">0</span>] a, b;</span><br><span class="line">    <span class="keyword">output</span> [W-<span class="number">1</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">output</span> t, e;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [W-<span class="number">1</span>:<span class="number">0</span>] a_, b_; <span class="comment">//补码</span></span><br><span class="line">    <span class="keyword">reg</span> [W-<span class="number">1</span>:<span class="number">0</span>] out_;   <span class="comment">//运算后的补码</span></span><br><span class="line">    <span class="keyword">reg</span> [W-<span class="number">1</span>:<span class="number">0</span>] out;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] i;</span><br><span class="line">    <span class="keyword">reg</span> t = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">reg</span> tt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> @ (*) <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">//都转为补码</span></span><br><span class="line">        a_ = a;</span><br><span class="line">        b_ = b;</span><br><span class="line">        <span class="keyword">if</span> (a_[W-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W - <span class="number">1</span>; i = i + <span class="number">1</span>) a_[i] = ~a[i];</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                    tt = a_[i];</span><br><span class="line">                    a_[i] = a_[i] ^ <span class="number">1</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">1</span>) | (t &amp; (tt | <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    tt = a_[i];</span><br><span class="line">                    a_[i] = a_[i] ^ <span class="number">0</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">0</span>) | (t &amp; (tt | <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> (b_[W-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W - <span class="number">1</span>; i = i + <span class="number">1</span>) b_[i] = ~b[i];</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">begin</span></span><br><span class="line">                    tt = b_[i];</span><br><span class="line">                    b_[i] = b_[i] ^ <span class="number">1</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">1</span>) | (t &amp; (tt | <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                    tt = b_[i];</span><br><span class="line">                    b_[i] = b_[i] ^ <span class="number">0</span> ^ t;</span><br><span class="line">                    t = (tt &amp; <span class="number">0</span>) | (t &amp; (tt | <span class="number">0</span>));</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">//俩补码运算</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            out_[i] = a_[i] ^ b_[i] ^ t;</span><br><span class="line">            t = (a_[i] &amp; b_[i]) | (t &amp; (a_[i] | b_[i]));</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">//检测是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> (a_[W-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; b_[W-<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; out_[W-<span class="number">1</span>] == <span class="number">1</span>) e = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a_[W-<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; b_[W-<span class="number">1</span>] == <span class="number">1</span> &amp;&amp; out_[W-<span class="number">1</span>] == <span class="number">0</span>) e = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> e = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将补码转为原码</span></span><br><span class="line">        <span class="keyword">if</span> (out_[W-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">//变反码</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                a_[i] = out_[i];</span><br><span class="line">                b_[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            tt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                out_[i] = a_[i] ^ b_[i] ^ tt;</span><br><span class="line">                tt = (a_[i] &amp; b_[i]) | (tt &amp; (a_[i] | b_[i]));</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="comment">//变原码</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W - <span class="number">1</span>; i = i + <span class="number">1</span>) out_[i] = ~out_[i];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; W; i = i + <span class="number">1</span>) out[i] = out_[i];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>show.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> show(clk, reset, hex0, hex1, hex2, hex3, an, sseg, l1, l2, l3);</span><br><span class="line">    <span class="keyword">input</span> clk, reset;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">3</span>:<span class="number">0</span>] hex0, hex1, hex2, hex3; <span class="comment">//分别存储4个灯要显示的数字（0-15）</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] an;                    <span class="comment">//控制每个灯是否工作，0为工作</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">6</span>:<span class="number">0</span>] sseg;                  <span class="comment">//存储数字在数码管上的表示</span></span><br><span class="line">    <span class="keyword">output</span> l1, l2, l3;                  <span class="comment">//控制负数亮灯</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">assign</span> l1 = hex3[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> l2 = hex2[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">assign</span> l3 = hex0[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">localparam</span> N = <span class="number">18</span>;</span><br><span class="line">    <span class="keyword">reg</span> [N-<span class="number">1</span>:<span class="number">0</span>] regN;</span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(reset) regN &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> regN &lt;= regN + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] an;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] hex_in;   <span class="comment">//存储当前要展示的数字</span></span><br><span class="line">    <span class="keyword">always</span> @ (*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(regN[N-<span class="number">1</span> : N-<span class="number">2</span>])</span><br><span class="line">            <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b1110</span>; </span><br><span class="line">                hex_in = hex0;  </span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b1101</span>; </span><br><span class="line">                hex_in = hex1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b1011</span>;</span><br><span class="line">                hex_in = hex2;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">begin</span></span><br><span class="line">                an = <span class="number">4&#x27;b0111</span>;</span><br><span class="line">                hex_in = hex3;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] sseg;</span><br><span class="line">    <span class="keyword">always</span>@(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span>(hex_in[<span class="number">2</span>:<span class="number">0</span>])</span><br><span class="line">            <span class="number">4&#x27;h0</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0000001</span>; </span><br><span class="line">            <span class="number">4&#x27;h1</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1001111</span>;</span><br><span class="line">            <span class="number">4&#x27;h2</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0010010</span>;</span><br><span class="line">            <span class="number">4&#x27;h3</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0000110</span>;</span><br><span class="line">            <span class="number">4&#x27;h4</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1001100</span>;</span><br><span class="line">            <span class="number">4&#x27;h5</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0100100</span>;</span><br><span class="line">            <span class="number">4&#x27;h6</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0100000</span>;</span><br><span class="line">            <span class="number">4&#x27;h7</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0001111</span>;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="实验三">实验三</h3><p><img src="3.png" /></p><ul><li>top.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top(clk, A, B, sum, t);</span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">31</span>:<span class="number">0</span>] A, B;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] sum;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Lsm_d1;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Aup_d1, Bup_d1;</span><br><span class="line">    <span class="keyword">reg</span> Carry_d1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span> @ (clk) <span class="keyword">begin</span></span><br><span class="line">        &#123;Carry_d1, Lsm_d1&#125; = A[<span class="number">15</span>:<span class="number">0</span>] + B[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">        Aup_d1 = A[<span class="number">31</span>:<span class="number">16</span>];</span><br><span class="line">        Bup_d1 = B[<span class="number">31</span>:<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">always</span> @ (clk) <span class="keyword">begin</span></span><br><span class="line">        sum[<span class="number">15</span>:<span class="number">0</span>] = Lsm_d1;</span><br><span class="line">        &#123;t, sum[<span class="number">31</span>:<span class="number">16</span>]&#125; = Aup_d1 + Bup_d1 + Carry_d1;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="实验四">实验四</h3><p><img src="4.png" /></p><ul><li>top.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// top 模块：整合时钟分频器和交通灯控制器</span></span><br><span class="line"><span class="keyword">module</span> top(</span><br><span class="line">    <span class="keyword">input</span> clk,        <span class="comment">// 输入：主时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> rst_n,      <span class="comment">// 输入：复位信号</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] light_NS, <span class="comment">// 输出：南北方向交通灯状态</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">2</span>:<span class="number">0</span>] light_EW  <span class="comment">// 输出：东西方向交通灯状态</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> clk_out;  <span class="comment">// 内部线网：用于从时钟分频器传递分频后的时钟</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 实例化时钟分频器模块</span></span><br><span class="line">    clockdivider u1(</span><br><span class="line">        <span class="variable">.clk</span>(clk),</span><br><span class="line">        <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">        <span class="variable">.clk_out</span>(clk_out)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 实例化交通灯控制模块</span></span><br><span class="line">    traffic_light u2(</span><br><span class="line">        <span class="variable">.clk</span>(clk_out),  <span class="comment">// 使用分频后的时钟</span></span><br><span class="line">        <span class="variable">.rst_n</span>(rst_n),</span><br><span class="line">        <span class="variable">.light_NS</span>(light_NS),  <span class="comment">// 南北方向交通灯状态</span></span><br><span class="line">        <span class="variable">.light_EW</span>(light_EW)   <span class="comment">// 东西方向交通灯状态</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>clockdivider.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clockdivider 模块：用于将输入时钟分频</span></span><br><span class="line"><span class="keyword">module</span> clockdivider(</span><br><span class="line">    <span class="keyword">input</span> clk,           <span class="comment">// 输入：原始的高频时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> rst_n,         <span class="comment">// 输入：复位信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> clk_out   <span class="comment">// 输出：分频后的时钟信号</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">parameter</span> DIVISOR = <span class="number">32&#x27;d1666_6667</span>; <span class="comment">// 分频因子</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] counter = <span class="number">32&#x27;d0</span>;        <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时钟分频逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst_n) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位时，重置计数器和输出时钟</span></span><br><span class="line">            counter &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">            clk_out &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 计数器达到分频因子时，翻转输出时钟并重置计数器</span></span><br><span class="line">            <span class="keyword">if</span> (counter == DIVISOR - <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">                clk_out &lt;= ~clk_out;</span><br><span class="line">                counter &lt;= <span class="number">32&#x27;d0</span>;</span><br><span class="line">            <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 否则，计数器递增</span></span><br><span class="line">                counter &lt;= counter + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>traffic_light.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// traffic_light 模块：控制交通灯状态</span></span><br><span class="line"><span class="keyword">module</span> traffic_light(</span><br><span class="line">    <span class="keyword">input</span> clk,           <span class="comment">// 输入：时钟信号</span></span><br><span class="line">    <span class="keyword">input</span> rst_n,         <span class="comment">// 输入：复位信号</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] light_NS, <span class="comment">// 输出：南北方向交通灯状态</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] light_EW  <span class="comment">// 输出：东西方向交通灯状态</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态定义</span></span><br><span class="line">    <span class="keyword">parameter</span> [<span class="number">2</span>:<span class="number">0</span>] GREEN_NS_RED_EW   = <span class="number">3&#x27;b000</span>,</span><br><span class="line">                     YELLOW_NS_RED_EW  = <span class="number">3&#x27;b001</span>,</span><br><span class="line">                     RED_NS_RED_EW_1   = <span class="number">3&#x27;b010</span>,</span><br><span class="line">                     RED_NS_GREEN_EW   = <span class="number">3&#x27;b011</span>,</span><br><span class="line">                     RED_NS_YELLOW_EW  = <span class="number">3&#x27;b100</span>,</span><br><span class="line">                     RED_NS_RED_EW_2   = <span class="number">3&#x27;b101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] state = GREEN_NS_RED_EW; <span class="comment">// 当前状态</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] counter = <span class="number">4&#x27;b0000</span>;       <span class="comment">// 计时器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时钟边沿触发的逻辑</span></span><br><span class="line">    <span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst_n) <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 复位逻辑</span></span><br><span class="line">            state &lt;= GREEN_NS_RED_EW;</span><br><span class="line">            counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            <span class="comment">// 状态转换逻辑</span></span><br><span class="line">            <span class="keyword">case</span> (state)</span><br><span class="line">                GREEN_NS_RED_EW: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b1111</span>) <span class="keyword">begin</span> <span class="comment">// 15时钟周期</span></span><br><span class="line">                        state &lt;= YELLOW_NS_RED_EW;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                YELLOW_NS_RED_EW: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b0011</span>) <span class="keyword">begin</span> <span class="comment">// 3时钟周期</span></span><br><span class="line">                        state &lt;= RED_NS_RED_EW_1;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_RED_EW_1: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b0011</span>) <span class="keyword">begin</span> <span class="comment">// 3时钟周期，短暂的全红状态</span></span><br><span class="line">                        state &lt;= RED_NS_GREEN_EW;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_GREEN_EW: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b1111</span>) <span class="keyword">begin</span> <span class="comment">// 15时钟周期</span></span><br><span class="line">                        state &lt;= RED_NS_YELLOW_EW;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_YELLOW_EW: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b0011</span>) <span class="keyword">begin</span> <span class="comment">// 3时钟周期</span></span><br><span class="line">                        state &lt;= RED_NS_RED_EW_2;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_RED_EW_2: <span class="keyword">begin</span></span><br><span class="line">                    <span class="keyword">if</span> (counter == <span class="number">4&#x27;b0011</span>) <span class="keyword">begin</span> <span class="comment">// 3时钟周期</span></span><br><span class="line">                        state &lt;= GREEN_NS_RED_EW;</span><br><span class="line">                        counter &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">                    <span class="keyword">end</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计数器递增</span></span><br><span class="line">            counter &lt;= counter + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据当前状态更新交通灯输出</span></span><br><span class="line">            <span class="keyword">case</span> (state)</span><br><span class="line">                GREEN_NS_RED_EW: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b010</span>; <span class="comment">// 南北绿灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 东西红灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                YELLOW_NS_RED_EW: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b001</span>; <span class="comment">// 南北黄灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 东西红灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_RED_EW_1: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 南北红灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 东西红灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_GREEN_EW: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 南北红灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b010</span>; <span class="comment">// 东西绿灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_YELLOW_EW: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 南北红灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b001</span>; <span class="comment">// 东西黄灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                RED_NS_RED_EW_2: <span class="keyword">begin</span></span><br><span class="line">                    light_NS &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 南北红灯</span></span><br><span class="line">                    light_EW &lt;= <span class="number">3&#x27;b100</span>; <span class="comment">// 东西红灯</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">endcase</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="大作业">大作业</h3><p><img src="5.png" /></p><figure><img src="6.png" alt="1705202189606" /><figcaption aria-hidden="true">1705202189606</figcaption></figure><figure><img src="7.png" alt="1705202209567" /><figcaption aria-hidden="true">1705202209567</figcaption></figure><ul><li>top.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> top(clk, reset, btn, an, sseg, current_floor, goal_floor);</span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">input</span> reset;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] an;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">6</span>:<span class="number">0</span>] sseg;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] hex_in;        <span class="comment">//存储要显示的楼层数字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">input</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] btn;                 <span class="comment">// 按钮输入</span></span><br><span class="line">    <span class="keyword">output</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] current_floor;      <span class="comment">// 当前楼层（例如01000）</span></span><br><span class="line">    <span class="keyword">output</span>  [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] goal_floor;      <span class="comment">// 呼叫的楼层（例如01000）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">localparam</span> N = <span class="number">18</span>;         <span class="comment">//分频系数(50MHZ/2^16)</span></span><br><span class="line">    <span class="keyword">reg</span> [N-<span class="number">1</span>:<span class="number">0</span>] regN;          <span class="comment">//高两位作为控制信号，低16位为计数器，对时钟进行分频</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(reset) regN &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> regN &lt;= regN + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">solve</span> u1(<span class="variable">.clk</span>(clk),</span><br><span class="line">             <span class="variable">.rst</span>(reset),</span><br><span class="line">             <span class="variable">.btn</span>(btn),</span><br><span class="line">             <span class="variable">.key_pulse</span>(),</span><br><span class="line">             <span class="variable">.current_floor</span>(current_floor),</span><br><span class="line">             <span class="variable">.goal_floor</span>(goal_floor)</span><br><span class="line">             );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">always</span> @ * <span class="keyword">begin</span></span><br><span class="line">       <span class="keyword">case</span>(regN[N-<span class="number">1</span> : N-<span class="number">2</span>])</span><br><span class="line">           <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">               an = <span class="number">4&#x27;b0111</span>; <span class="comment">//选中第1个数码管</span></span><br><span class="line">               hex_in = current_floor;</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">           <span class="number">2&#x27;b11</span>:<span class="keyword">begin</span></span><br><span class="line">               an = <span class="number">4&#x27;b1110</span>;<span class="comment">//选中第四个数码管</span></span><br><span class="line">               hex_in =  goal_floor;</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">       <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">always</span>@ * <span class="keyword">begin</span></span><br><span class="line">       <span class="keyword">case</span>(hex_in)</span><br><span class="line">           <span class="number">5&#x27;b00000</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0000001</span>;</span><br><span class="line">           <span class="number">5&#x27;b00001</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1001111</span>;</span><br><span class="line">           <span class="number">5&#x27;b00010</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0010010</span>;</span><br><span class="line">           <span class="number">5&#x27;b00100</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0000110</span>;</span><br><span class="line">           <span class="number">5&#x27;b01000</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1001100</span>;</span><br><span class="line">           <span class="number">5&#x27;b10000</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b0100100</span>;</span><br><span class="line">           <span class="keyword">default</span>: sseg[<span class="number">6</span>:<span class="number">0</span>] = <span class="number">7&#x27;b1111111</span>;</span><br><span class="line">       <span class="keyword">endcase</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>solve.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">solve</span>(clk, rst, btn, key_pulse, current_floor, goal_floor);</span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">input</span> rst;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] btn;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] current_floor;</span><br><span class="line">    <span class="keyword">output</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] goal_floor; </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">wire</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] key_edge;         <span class="comment">// 按键松开时，其为1，使得cnt清零，产生延时</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] key_lat;           <span class="comment">// 存储上一个触发时的按键值</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] key_now;           <span class="comment">// 存储当前时刻触发的按键值</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst) <span class="keyword">begin</span></span><br><span class="line">            key_now &lt;= &#123;<span class="number">5</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125;;</span><br><span class="line">            key_lat &lt;= &#123;<span class="number">5</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            key_now &lt;= btn;</span><br><span class="line">            key_lat &lt;= key_now;</span><br><span class="line">        <span class="keyword">end</span>    </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">assign</span>  key_edge = key_lat &amp; (~key_now);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//产生20ms延时，当检测到key_edge有效是计数器清零开始计数</span></span><br><span class="line">    <span class="keyword">reg</span>    [<span class="number">17</span>:<span class="number">0</span>] cnt;    </span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst) cnt &lt;= <span class="number">18&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key_edge) cnt &lt;= <span class="number">18&#x27;h0</span>;</span><br><span class="line">        <span class="keyword">else</span> cnt &lt;= cnt + <span class="number">1&#x27;h1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用f1、f2俩变量来控制实现&quot;只用按一次按钮就可以，不用一直按&quot;的效果</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] f1;</span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] f2;</span><br><span class="line">    <span class="comment">// 延时更新f1</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst) f1 &lt;= &#123;<span class="number">5</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;                </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cnt==<span class="number">18&#x27;h3ffff</span>) f1 &lt;= btn;  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// f2随时保持f1的节奏</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst) f2 &lt;= &#123;<span class="number">5</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">else</span> f2 &lt;= f1;             </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 一开始俩都是0000，所以key_pulse不会改变</span></span><br><span class="line">    <span class="comment">// 一直按住某个按键的话，就会出现f2 = 0, f1 = 1的情况，此时key_pulse会翻转为1</span></span><br><span class="line">    <span class="comment">// 如果按住某个按键，然后松开的话，那么会使得cnt重新为0。也就是f1 = 1的情况会延时一段时间，此时f2趁机更新为1。</span></span><br><span class="line">    <span class="comment">// 从而延时这段时间，不会使得key_pulse翻转</span></span><br><span class="line">    <span class="comment">// 当延时到了，就会出现，key_sec更新为0，f2 = 1的情况。此时也不会使得key_pulse翻转</span></span><br><span class="line">    <span class="comment">// 然后重新回到俩都是0的情况</span></span><br><span class="line">    <span class="comment">// 当再按一次时，就会出现如上的情况，从而实现&quot;取消&quot;的功能</span></span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">5</span>-<span class="number">1</span>:<span class="number">0</span>] key_pulse;      <span class="comment">// 处理后的按键状态</span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (rst) key_pulse &lt;= &#123;<span class="number">5</span>&#123;<span class="number">1&#x27;b0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span>                                              </span><br><span class="line">            <span class="keyword">if</span>(~f2[<span class="number">4</span>] &amp; f1[<span class="number">4</span>]) key_pulse[<span class="number">4</span>] &lt;= ~key_pulse[<span class="number">4</span>];    </span><br><span class="line">            <span class="keyword">if</span>(~f2[<span class="number">3</span>] &amp; f1[<span class="number">3</span>]) key_pulse[<span class="number">3</span>] &lt;= ~key_pulse[<span class="number">3</span>];   </span><br><span class="line">            <span class="keyword">if</span>(~f2[<span class="number">2</span>] &amp; f1[<span class="number">2</span>]) key_pulse[<span class="number">2</span>] &lt;= ~key_pulse[<span class="number">2</span>];    </span><br><span class="line">            <span class="keyword">if</span>(~f2[<span class="number">1</span>] &amp; f1[<span class="number">1</span>]) key_pulse[<span class="number">1</span>] &lt;= ~key_pulse[<span class="number">1</span>];  </span><br><span class="line">            <span class="keyword">if</span>(~f2[<span class="number">0</span>] &amp; f1[<span class="number">0</span>]) key_pulse[<span class="number">0</span>] &lt;= ~key_pulse[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">end</span>  </span><br><span class="line">    <span class="keyword">end</span>  </span><br><span class="line">       </span><br><span class="line"></span><br><span class="line">    get_floor u2(<span class="variable">.clk</span>(clk),</span><br><span class="line">                 <span class="variable">.rst</span>(rst),</span><br><span class="line">                 <span class="variable">.key_pulse</span>(key_pulse),</span><br><span class="line">                 <span class="variable">.current_floor</span>(current_floor),</span><br><span class="line">                 <span class="variable">.goal_floor</span>(goal_floor)</span><br><span class="line">                 );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><ul><li>get_floor.v</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> get_floor(clk, rst, key_pulse, current_floor, goal_floor);</span><br><span class="line">    <span class="keyword">input</span> clk;</span><br><span class="line">    <span class="keyword">input</span> rst;</span><br><span class="line">    <span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] key_pulse;    </span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] current_floor;</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] goal_floor; </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        goal_floor = <span class="number">5&#x27;b00001</span>;</span><br><span class="line">        current_floor = <span class="number">5&#x27;b00001</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 时钟分频器：每过1s，clk_out=~clk_out。实现&quot;每一秒钟，电梯移动一层&quot;</span></span><br><span class="line">    <span class="keyword">reg</span> [<span class="number">30</span>:<span class="number">0</span>] cnt = <span class="number">30&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">parameter</span> M = <span class="number">100000000</span>;  <span class="comment">//1s=1000000000ns</span></span><br><span class="line">    <span class="keyword">reg</span> clk_out = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst) clk_out = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (cnt == M-<span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">            clk_out = ~clk_out;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            clk_out = <span class="number">0</span>;</span><br><span class="line">            cnt = cnt + <span class="number">1&#x27;d1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 更新goal_floor</span></span><br><span class="line">    <span class="keyword">always</span> @ (*) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst) goal_floor = <span class="number">5&#x27;b00001</span>;</span><br><span class="line">        <span class="keyword">else</span> goal_floor = key_pulse;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">// 更新current_floor     </span></span><br><span class="line">    <span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk_out <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(rst) current_floor = <span class="number">5&#x27;b00001</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(goal_floor != <span class="number">5&#x27;b00000</span>) <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">if</span>(current_floor &lt; goal_floor)               <span class="comment">//电梯所在楼层低于目标楼层则上升</span></span><br><span class="line">                current_floor = &#123;current_floor[<span class="number">3</span>:<span class="number">0</span>], current_floor[<span class="number">4</span>]&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(current_floor &gt; goal_floor)         <span class="comment">//电梯所在楼层高于目标楼层则下降</span></span><br><span class="line">                current_floor = &#123;current_floor[<span class="number">0</span>], current_floor[<span class="number">4</span>:<span class="number">1</span>]&#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">           </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一部分主要是verilog语法，比较简单。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数字逻辑" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    
  </entry>
  
  <entry>
    <title>数据库自学笔记</title>
    <link href="http://example.com/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-18T16:22:07.000Z</published>
    <updated>2024-02-23T10:18:17.783Z</updated>
    
    <content type="html"><![CDATA[<p>懒得解释了，反正之前没咋认真听过课（其实是去做数据库期末项目了）。今天终于有点时间了抽空看了一下之前的内容，做一下笔记记录一下免得以后忘了。学点东西顺便应付一下期末考试。</p><span id="more"></span><p>upd: (2024/1/14)：这门课满绩了，考试很简单，都是笔记里的东西。</p><hr /><h3 id="数据库基础概念相关">数据库基础概念相关</h3><ol type="1"><li><p>数据(Data)、数据库(DB)、数据库系统(DBS)、数据库管理系统(DBMS)数据定义</p><ol type="1"><li>数据是描述事物的符号记录。</li><li>数据库是指长期存储在计算机内的、有组织的、可共享的大量数据集合。</li><li>数据库系统是指在计算机系统中引入数据库后的系统构成，由数据库、数据库管理系统(及其开发工具)、应用系统、数据库管理员(和用户)构成。</li><li>数据库管理系统是位于用户(应用程序)与操作系统之间的一层数据库管理软件。</li></ol></li><li><p>数据库系统的开发环节</p><p><img src="6.png" /></p><p>​概念设计：通常使用实体-关系模型（ER模型）来表示数据和数据间的关系。</p><p>​逻辑设计：通常是关系模型(还有层次/网状模型)，包括了表/列/数据类型、约束（如主键、外键）等。</p><p>​物理设计：确定如何在物理存储层面上存储数据，包括文件组织、索引结构、数据分布、存储分配等。</p></li><li><p>数据管理的四个发展阶段：手工阶段、程序阶段、文件阶段、数据库阶段</p></li><li><p>数据库、数据库系统、数据库管理系统的功能</p><ol type="1"><li>DB：存储、检索、维护数据</li><li>DBS：管理数据库以及环境、支持用户与数据库交互、控制数据库权限及安全</li><li>DBMS：提供数据定义(DDL)、数据操作(DML)、数据控制(DCL)语言，同时维护数据库，确保数据库的完整性、性能优化和恢复管理</li></ol></li><li><p>概念模型：是对现实世界的系统、概念或其他复杂对象的抽象表示。例如：层次模型(类似树)、网状模型(类似图)、关系模型(现在的数据库模型)、实体-联系模型(不是数据库模型，是一种用于数据库设计的高层次概念模型(ER图)</p></li><li><p>关系模型的完整性约束</p><ol type="1"><li>实体完整性：确保每个表的主键是唯一的，且不允许为NULL。</li><li>参照完整性：如果表A中的某个字段是表B中主键的外键，则表A中所有的外键值必须在表B中有相对应的主键值，或者是NULL。</li><li>域完整性：数据列中的每个值都必须是定义的数据域中的有效值。</li><li>用户定义完整性：是针对特定业务规则定制的约束条件。</li></ol></li><li><p>关系型数据库和非关系型数据库的主要区别是什么？并举出相应的软件产品</p><ul><li>关系数据库是基于关系模型的，数据以表格的形式组织，表格中的行表示记录，列表示属性。常见关系型数据库有MySql、PostgreSQL、SQLServer等；非关系型数据库采用不同的数据组织方式，如文档存储、键值对存储或图形数据库。常见的非关系型数据库有MongoDB、Hbase等。</li></ul></li><li><p>视图（Note：仅在少数简单视图上可以更新数据）</p></li></ol><ul><li>定义：是一种虚拟表，其内容由查询定义，但不在数据库中以存储数据的形式存在。</li><li>特点：<ul><li>虚拟性：视图不存储数据，它是一个查询的结果集。</li><li>逻辑独立性：可以更改底层数据表的结构而不影响视图。</li><li>安全性：可以仅展示用户需要或允许看到的数据。</li><li>简化复杂查询：可以创建视图来简化用户的操作。</li></ul></li></ul><h3 id="数据库范式相关">数据库范式相关</h3><h4id="函数依赖函数依赖集依赖的推导">函数依赖、函数依赖集、依赖的推导</h4><ul><li>函数依赖(FD)。</li></ul><p>假设在一张表中，任意挑俩元组i, j，若发现若<spanclass="math inline">\(A_i = A_j\)</span>，则<spanclass="math inline">\(B_i = B_j\)</span>，则说明属性A可推出B，写作<spanclass="math inline">\(A \rightarrow B\)</span>，称为B依赖于A。</p><ul><li>函数依赖集(FDs)。</li></ul><p>就是一个集合，里头的元素是函数依赖。</p><ul><li>依赖的推导</li></ul><p>三个公理（要记住。这个其实感性理解很好理解）：</p><ol type="1"><li>如果Y是X的子集，则<span class="math inline">\(X \rightarrowY\)</span></li><li>如果<span class="math inline">\(X \rightarrow Y\)</span>，则<spanclass="math inline">\(XZ \rightarrow YZ\)</span></li><li>如果<span class="math inline">\(X \rightarrow Y, Y \rightarrowZ\)</span>，则<span class="math inline">\(X \rightarrow Z\)</span></li></ol><p>两个定理</p><ol type="1"><li>若<span class="math inline">\(X \rightarrow Y, X \rightarrowZ\)</span>，则<span class="math inline">\(X \rightarrow YZ\)</span><ul><li>证明：因为<span class="math inline">\(X \rightarrowY\)</span>，所以<span class="math inline">\(XZ \rightarrowYZ\)</span></li><li>因为<span class="math inline">\(X \rightarrow Z\)</span>，所以<spanclass="math inline">\(X \rightarrow XZ\)</span></li><li>所以<span class="math inline">\(X \rightarrow XZ \rightarrowYZ\)</span></li></ul></li><li>若<span class="math inline">\(X \rightarrow YZ\)</span>，则<spanclass="math inline">\(X \rightarrow Y, X \rightarrow Z\)</span><ul><li>证明：因为Y, Z是YZ子集，所以<span class="math inline">\(YZ\rightarrow Y, YZ \rightarrow Z\)</span></li><li>所以<span class="math inline">\(X \rightarrow YZ \rightarrow Y, X\rightarrow YZ \rightarrow Z\)</span></li></ul></li></ol><p>任何的依赖推导用上面这五条性质一般都可以推出来了。</p><h4 id="候选码非主属性主属性超键">候选码、非主属性、主属性、超键</h4><ul><li>候选码：能唯一标识一个关系的属性集合且集合大小要保证最小<ul><li>注意，一个关系R中可能存在多个候选码</li></ul></li><li>非主属性：只要有一个属性，它不属于任何一个候选码的属性，它就是非主属性</li><li>主属性：只要有一个属性，它属于某一个候选码，它就是主属性</li><li>超键：能唯一标识一个关系的属性集合<ul><li>注意，跟候选码不同的是，候选码的要求是在能唯一标识的基础上，保证集合大小最小。但是超键则无所谓，多大都ok。</li><li>注意，一个关系R中可能存在多个超键</li></ul></li></ul><h4 id="函数依赖集的闭包属性的闭包">函数依赖集的闭包、属性的闭包</h4><p>一般关系都是R表示，关系的函数依赖集一般用F表示。函数依赖集的闭包用<spanclass="math inline">\(F^+\)</span>表示。</p><p>求<spanclass="math inline">\(F^+\)</span>就是用F中的依赖把所有能推出来的依赖都推出来（画树状图+用5条性质去推），就是<spanclass="math inline">\(F^+\)</span>。</p><p>假设有一个属性A，则属性A的闭包写作<spanclass="math inline">\(A^+\)</span>。推<spanclass="math inline">\(A^+\)</span>的方法用“背包材料”的理念。最初背包中只有A这一个材料，所以首先拿A去推，能推出来的东西都放入“背包”中。然后再用背包中的材料（材料可以组合）去推，依次类推。直到没有东西可以放入背包中。</p><p>属性闭包蛮有用的，具体作用有如下2条：</p><ol type="1"><li>判断<span class="math inline">\(X \rightarrow Y\)</span>是否在<spanclass="math inline">\(F^+\)</span>里。<ul><li>正常思路是先写出F+，然后就知道<span class="math inline">\(X\rightarrow Y\)</span>在不在F+里了。但其实可以先写出<spanclass="math inline">\(X^+\)</span>，只要<spanclass="math inline">\(X^+\)</span>里有Y，那么<spanclass="math inline">\(X \rightarrow Y\)</span>就在<spanclass="math inline">\(F^+\)</span>里。</li></ul></li><li>判断某个属性集合是否是超键<ul><li>假设属性集合叫S，那写出<spanclass="math inline">\(S^+\)</span>，如果<spanclass="math inline">\(S^+\)</span>里包含了所有属性，那么属性集合S就是超键。</li></ul></li></ol><p>补充：假定有关系R和函数依赖集F，如何推出候补码？</p><p>观察F，然后使用口诀：“只在左边的一定是，只在右边的一定不是，两边都在的试一试”</p><p>具体来说，如果属性A在F中只出现在箭头的左边，那么A一定属于任意一个候补码。如果属性A在F中只出现在箭头的右边，那么A一定不属于任意一个候补码（即非主属性）。如果在箭头左右都出现过，那就试一试，用属性的闭包去验证一下即可。</p><h4id="无损分解分解后是否保持函数依赖">无损分解、分解后是否保持函数依赖</h4><p>分解一个表有时是很有必要的。假设一个表有属性“学生等级”和“学生评价”。且我们知道，如果一个学生的等级是A、B、C，他的评价分别是优秀、良好、差。如果不分解的话每次记录都要把其等级和评价记下来。但是这显然没必要，只需要记录任意一个就好。因为他们俩只要知道其中一个，另外一个是可以推出来的。</p><p>所以可以将表分解成两张表，第一张记录了其它数据 +学生等级，第二张表记录学生等级 + 学生评价。</p><p>上面这个例子就是解释分解是什么个意思。接下来讨论无损分解。</p><p>无损分解就是说分解成的两个表经过自然连接后可以得到原表。不会有额外数据的增添。</p><p>先讲结论，如果讲表R分解为<span class="math inline">\(R_1,R_2\)</span>，如果​俩表之交能通过FDs推出任意其中一个表，则这必然是一个无损分解。</p><p>这很好感性理解，自然连接本质就是找到俩表相同的公共部分然后连接。所以如果俩表的公共部分可以推出其中一个表，就说明不会有额外数据的增添。看下面这个例子就很好理解。</p><p><img src="1.png" /></p><p>至于分解后是否保持函数依赖，要看F。</p><p>也就是F中的每一对依赖X、Y，必须出现在某个子表<spanclass="math inline">\(R_i\)</span>中。这样就分解后就保持函数依赖。</p><h4 id="bcnf">BCNF</h4><p>BCNF是3.5NF，如果一个关系是3.5NF，那么它必定是3NF。</p><p>如果一个关系R满足BCNF，那么这张表中就不存在“冗余”。所以BCNF是很棒的。</p><p>如果一个关系R不满足BCNF呢？那么就将R分解成若干个子表，使得每个子表都满足BCNF，这样也就不会有冗余了，这样也是很棒的。</p><p>所以问题的关键就是如何判断一个表是否满足BCNF？以及如果一个表不满足BCNF，如何将它分解成满足BCNF的子表？</p><p>先讲第一个问题，如何判断一个表是否满足BCNF。</p><p>假定现在有关系R，函数依赖集F。对于F中每一条关系<spanclass="math inline">\(X \rightarrowY\)</span>，必须满足下面任意一条，则R满足BCNF。</p><ol type="1"><li>X是超键</li><li>X包含Y</li></ol><p>下面讨论第二个问题，如何将一个不满足BCNF的表分解为满足BCNF的若干子表。</p><p>若<span class="math inline">\(X \rightarrowY\)</span>不满足2条规则中任意一条，则将R分解为<spanclass="math inline">\(R_1 = R - Y\)</span>与<spanclass="math inline">\(R_2 = X +Y\)</span>。显然，这是个无损分解（很容易证明，公共部分是X，且X可推出R2）。而且<spanclass="math inline">\(R_1, R_2\)</span>也是满足BCNF的。</p><p>如果有多个依赖不满足规则呢？那就依次分解即可（注意，不同分解顺序带来的结果并不相同不过都是对的）</p><p>综上，在设计自己的数据库时，我们要尽可能的使表都满足BCNF，这样就不会产生数据的冗余。但是BCNF有一个缺点，就是分解后不一定能保持函数的依赖。比如下面这个例子：</p><p><img src="2.png" /></p><p><span class="math inline">\(L \rightarrowK\)</span>不满足规则，所以将R分解为<span class="math inline">\(R_1 = (J,L), R_2 = (L,K)\)</span>。函数依赖有两个，第二个在R2中可得到保持，第一个在R1或R2都不能得到保持，所以分解后没能保持函数依赖。</p><p>这就是BCNF的一个缺点，所以接下来就要介绍3NF。3NF的优点就是它可以保持函数的依赖，但是它的缺点就是仍然会存在一些冗余。</p><h4 id="nf">3NF</h4><p>跟BCNF一样，3NF还是两个灵魂问题：（1）如何判断关系R是否满足3NF（2）如果R不满足3NF，如何将它分解为若干子表使得它们满足3NF</p><p>先来解决第一个问题。</p><p>假定现在有关系R，函数依赖集F。对于F中每一条关系<spanclass="math inline">\(X \rightarrowY\)</span>，必须满足下面任意一条，则R满足3NF。</p><ol type="1"><li>X是超键</li><li>Y被包含在X里</li><li>Y属于候补码（注意不是超键噢）（所以先要求出候补码）</li></ol><p>现在来解决第二个问题。</p><p>分为以下几步：</p><ol type="1"><li>求F最小覆盖集<span class="math inline">\(F_c\)</span><ol type="1"><li>从第一个检查到最后一个，把能用其它依赖推出来的依赖去掉</li><li>从第一个检查到最后一个，把左右边的变量尽量减少</li><li>回到第一步，若第一步去不掉则进入第四步</li><li>对于左边相同的，把右边合并起来</li></ol></li><li>将<spanclass="math inline">\(F_c\)</span>中每一个依赖拿出来组成新表</li><li>求候选码</li><li>看候选码在不在其中一个新表中，不在的话就新加一个表，表的属性就是候选码</li></ol><p>综上，3NF的好处就是可以保持函数依赖（而且也是无损分解），缺点就是会存在点冗余。</p><h4 id="范式总结nf">范式总结（NF）</h4><p>第三范式前面是用“规则”定义出来的，其实它还有另一种定义。</p><ul><li>第一范式（1NF）：每个属性都是原子属性，本质上所有关系的都满足第一范式。</li><li>第二范式（2NF）：在满足第一范式的前提下，满足所有非主属性必须依赖于整个候选码而不能依赖于候选码的部分属性。</li><li>第三范式（3NF）：在满足第二范式的前提下，满足F中不能有非主属性之间的依赖传递。</li></ul><h3 id="数据库存储相关">数据库存储相关</h3><ol type="1"><li><p>文件中记录的表示方式</p><ol type="1"><li>定长记录：每个记录的大小是固定的。每个字段（或属性）在记录中分配有固定数量的字节。这种方式简化了记录的定位和访问，因为可以直接计算出任何记录的位置。</li><li>变长记录：不同记录可能有不同的长度。需要额外的信息来确定记录的确切位置和长度。</li></ol></li><li><p>文件中记录集合的组织方式</p><ol type="1"><li>堆文件：记录在文件空间中任意放置</li><li>顺序文件：按一定的顺序在文件中组织记录</li><li>散列文件：按照散列函数计算值存放相应记录</li><li>多表簇集文件：不同关系表里的记录存放在同一个文件中</li></ol></li><li><p>元数据是指一个关系数据库系统需要维护关于关系的数据。元数据存储在称为“数据字典”或“系统目录”的结构中</p></li><li><p>数据库缓冲区管理器的工作原理</p><ul><li>大致可以概括为以下几个步骤</li></ul><ol type="1"><li>数据页的加载：当需要读取数据时，首先检查所需的数据页是否已经在缓冲区中。如果是，它就直接从缓冲区读取数据，反之则从硬盘上读取数据页，并将其加载到缓冲区中。</li><li>缓冲区的替换策略：由于缓冲区的大小是有限的，当缓冲区满时，缓冲区管理器必须决定哪些数据页被保留，哪些被替换。</li><li>脏页的写回：如果一个数据页在缓冲区中被修改，在它被替换出缓冲区之前，这些更改需要被写回到硬盘上以保持数据的持久性。</li><li>并发控制：缓冲区管理器还需要处理多个事务或操作同时访问同一数据页的情况。这通常涉及锁定机制或乐观并发控制来保证数据的完整性和一致性。</li></ol></li></ol><h3 id="数据库索引相关">数据库索引相关</h3><ol type="1"><li><p>索引分类</p><ol type="1"><li>顺序索引（按照排好的顺序储存搜索码的值，并将每个搜索码与包含该搜索码的记录关联起来。）<ol type="1"><li>主索引(聚集索引)</li><li>辅助索引(非聚集索引)(二级索引)</li></ol></li><li>B+树索引</li><li>散列索引（基于将值平均分布到若干桶中，一个值所属的桶由散列函数决定）<ol type="1"><li>静态索引：就是普通的桶</li><li>动态索引：就是用二进制实现的桶</li></ol></li></ol><ul><li><p>稠密索引就是每条记录都有一个索引指针会指向它，稀疏索引就是只有部分索引会指向它。</p></li><li><p>注意，稀疏索引必须是主索引，二级索引必须是稠密索引。因为主索引的顺序就是记录排列的顺序，所以主索引可以是稀疏索引。但是二级不行，因为二级的索引顺序不是记录排列的顺序，所以如果二级是稀疏索引的话，就有可能无法查到目标数据。所以二级索引必须是稠密索引，稀疏索引必须是主索引。</p></li><li><p>稀疏索引的优点是占用空间小，缺点是速度慢，精确率相对较低；稠密索引的优点是查找效率快，方面插入和删除。缺点是占用空间大。</p></li></ul></li></ol><h3 id="数据库查询有关">数据库查询有关</h3><ol type="1"><li>对于一条SQL语句，先经过<strong>语法分析器</strong>分析语法是否正确，然后经过<strong>翻译器</strong>被翻译为关系代数表达式，这个关系代数表达式再经过<strong>优化器</strong>，得到一个执行计划，最后通过<strong>执行引擎</strong>被执行。</li><li>两个表连接操作的几种实现方法：<ol type="1"><li>嵌套循环连接：<span class="math inline">\(O(n^2)\)</span></li><li>排序-合并连接：<span class="math inline">\(O(nlogn +n)\)</span></li><li>索引连接：<span class="math inline">\(O(nlogn)\)</span></li><li>Hash连接：最好情况下<span class="math inline">\(O(n)\)</span></li></ol></li><li>优化器要做的事：<ol type="1"><li>将关系代数表达式转换为查询树</li><li>对查询树做变换</li><li>生成执行计划</li></ol></li><li>代数优化就是先做选择操作、再做连接操作。物理优化就是优化器决定是采用全盘扫描还是索引扫描，如果采用索引扫描的话是用顺序索引还是B+树索引还是Hash索引。</li></ol><h3 id="数据库事务相关">数据库事务相关</h3><ol type="1"><li><p>事务的基本特性(ACID)（以银行转账为例）</p><ul><li>事务定义：事务是指构成单一逻辑单元的操作集合。</li></ul><ol type="1"><li>A：原子性：事务要么就不执行，那么就执行，不会执行到一半退出去。</li><li>C：一致性：事务的执行不会改变所有钱的总和。</li><li>I：隔离性：尽管可能存在多个事务同时并发执行的情况，但系统保证，每个事务都感觉不到中其它事务在并发的执行。</li><li>D：持久性：一旦事务完成，其对数据库的影响就是持久的。</li></ol></li><li><p>事务状态</p><ul><li><p>活动的：事务执行时的状态</p></li><li><p>部分提交的：最后一条语句执行后</p></li><li><p>提交的：成功完成后</p></li><li><p>失败的：发现不能执行后</p></li><li><p>中止的：事务回滚并且数据库已恢复到事务开始执行前的状态后</p></li><li><p>事务状态图：</p><p><img src="3.png" /></p></li></ul></li><li><p>调度</p><ol type="1"><li><p>调度分类</p><ol type="1"><li>串行调度：一个事务完成后再去执行下一个事务</li><li>并行调度：调度中多个事务的指令在时间上相互交叉地进行</li><li>可串行化调度：这个概念是针对于并行调度的。一个并行调度可能是可串行化调度，也可能不是。如果存在一个串行调度，使得其运行结果等于一个并行调度，则称这个并行调度为可串行化调度。</li></ol></li><li><p>冲突可串行化</p><ol type="1"><li>冲突操作：如果俩操作属于不同事务，且至少有一个wire操作，且作用于相同数据项，则这俩操作是冲突的。</li><li>注意，如果一个并行调度是可串行化调度，那么它就是冲突可串行化的。</li><li>冲突可串行化的判定方法：如果一个并行调度不存在死锁，则可以转换为一个串行调度，也就是这个并行调度是冲突可串行化的。</li><li>并行调度转换为串行调度的方法：先画出调度优先图，然后其拓扑序就是串行调度。</li></ol></li><li><p>调度优先图</p><ul><li><p>这个名字起的很烂，我愿意叫它“死锁图”。是一种用来检测事务调度中是否存在死锁的工具。</p></li><li><p>图中的每一个节点代表一个事务，如果事务A需要等待B释放资源才能进行，则A向B连一条边。如果图中存在环，则存在死锁。</p></li><li><p><img src="4.png" /></p></li><li><p>例如这个图，以数据Y举例，对于所有对Y的read/wire操作，若其时间后有其冲突操作，则俩事务之间连一条边。</p></li></ul></li><li><p>预防死锁的方法</p><ol type="1"><li>wait-die机制：当事务<spanclass="math inline">\(T_i\)</span>申请的数据项当前被<spanclass="math inline">\(T_j\)</span>持有，仅当<spanclass="math inline">\(T_i\)</span>的时间戳小于<spanclass="math inline">\(T_j\)</span>的时间戳时，允许<spanclass="math inline">\(T_i\)</span>等待。否则<spanclass="math inline">\(T_i\)</span>回滚。</li><li>wound-die机制：当事务<spanclass="math inline">\(T_i\)</span>申请的数据项当前被<spanclass="math inline">\(T_j\)</span>持有，仅当<spanclass="math inline">\(T_i\)</span>的时间戳大于<spanclass="math inline">\(T_j\)</span>的时间戳时，允许<spanclass="math inline">\(T_i\)</span>等待。否则，<spanclass="math inline">\(T_j\)</span>回滚。</li></ol></li><li><p>解决死锁的方法</p><ul><li>选择一个或多个事务进行回滚，释放它们所占用的资源。通常会选择代价最小的事务进行回滚，代价的衡量标准可能包括事务的执行时间、所占用资源数量、距离完成的远近等。为了改进，可以采用部分回滚，这要求需要更多的额外信息。</li></ul></li><li><p>可恢复调度 &amp; 无级联调度</p><ul><li>对于调度中的任意俩事务A, B，如果B read 了A之前 wire的同个数据，则事务A必须在事务B之前提交。</li><li>对于调度中的任意俩事务A, B，如果B read 了A之前 wire的同个数据，则事务A必须在事务B的read操作之前提交。</li></ul></li></ol></li><li><p>事务的隔离级别</p><ol type="1"><li><p>读未提交：允许事务read未被其它事务提交的更改</p></li><li><p>读提交：事务只能read已经被提交的更改（数据库的默认隔离级别）</p></li><li><p>可重复读：确保在事务执行期间，如果事务重新读取之前已读取的数据，则会看到相同的数据。</p><ul><li><p>脏读：一个事务读取了另一个事务尚未提交的数据时。</p></li><li><p>不可重复读：事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。因此产生了不可重复读。</p></li><li><p>幻读：与不可重复读类似，它发生在当一个事务T1读取了一系列符合特定条件的行，然后另一个并发事务T2插入或删除了一些符合T1搜索条件的新行并提交。当T1再次执行相同的查询时，它将“神奇地”看到之前不存在的新行（即“幻行”）。</p></li></ul></li><li><p>串行化：调度中事务只能串行运行</p></li></ol><p><img src="5.png" /></p></li></ol><h3 id="数据库锁相关">数据库锁相关</h3><p>为了保证数据的一致性(事务的隔离性)和提高系统的并发处理能力，或者说为了保证应用的有效性，所以引入锁。封锁协议定义了事务如何获取和释放锁的规则。</p><ol type="1"><li><p>锁</p><ol type="1"><li>共享锁(S)：当一个事务想要读取数据时，它会在相应的数据项上放置一个共享锁。共享锁的特点是它允许多个读取事务并发地访问同一个数据项，因为读取操作不会互相冲突。所以如果一个事务获得了数据项的共享锁，则它可read但不能wire该数据项。</li><li>排他锁(X)：当一个数据上了排他锁后，当某事务想要修改或读数据时，它会请求并获得排他锁。只有获得了排他锁，才能对其修改。而且注意，一旦一个数据的排他锁被拿了，那么其它事务就不能获得该数据的排他锁和共享锁，直至其排他锁被归还。</li></ol></li><li><p>封锁协议</p><ol type="1"><li><p>二阶段锁定协议</p><ul><li><p>最常用的就是二阶段锁定协议，即要求每个事务分两个阶段对数据进行锁定和解锁。增长阶段：事务可以获得锁，但不能释放锁。缩减阶段：事务可以释放锁，但不能获得新的锁。</p></li><li><p>二阶段锁定协议特点：</p><ol type="1"><li>把两个阶段的定义抄一遍</li><li>可以保证冲突可串行化：多个事务根据封锁点的顺序进行排序即是可串行化顺序。</li></ol></li><li><p>二阶段锁定协议保证了不会出现脏读的问题。但是不可重复读、死锁、活锁、级联回滚问题仍然可能会出现。另外，虽然两阶段封锁协议保证冲突可串行化，但是冲突可串行化未必符合两阶段封锁。</p></li></ul></li><li><p>严格两阶段封锁协议</p><ul><li>定义：在2PL的基础上，要求事务所持排他锁必须在事务提交后方可释放。这个要求保证了在提交前防止其它事务读这些数据。可以避免出现级联回滚。</li></ul></li><li><p>强两阶段封锁协议</p><ul><li>定义：要求事务提交之前不能释放任何锁。</li></ul></li><li><p>树形协议</p><ul><li>定义：树形协议是一种数据库并发控制机制，用于管理在树状数据结构（如B树索引）上的锁。它规定了事务在获得和释放锁的顺序，以确保在访问树形数据结构的不同部分时维护一致性和隔离性。事务必须按照从根节点到叶节点的顺序来获取锁，并且在向下遍历树时不能返回到已经释放锁的节点。这种方法避免了死锁的发生，因为它不允许事务在树结构中回溯并重新获取锁。</li><li>优点：保证了冲突可串行化；不会产生死锁，不需要回滚；可较早地释放锁，以减少事务间的等待时间，从而可增强调度的并发性。</li><li>缺点：不能保证事务的可恢复性；不能保证不发生级联回滚；可能会给那些根本不访问的数据项加锁，从而增加了锁的开销和额外的等待时间，使并发性降低。</li></ul></li><li><p>多粒度封锁协议</p><ul><li>规则：<ol type="1"><li>引入意向锁，并规定了与S/X锁的兼容性规则</li><li>事务必须首先在高级别上获取意向锁，然后才能在低级别上获取实际的共享或排他锁。</li><li>锁可以在事务的任何时候释放，但一旦释放，事务就不能再在那个级别或更低级别上获取新的锁。</li></ol></li><li>特点：<ol type="1"><li>事务可以根据需要锁定细粒度（如行）或粗粒度（如整个表）的数据，从而提高了系统的并发性。</li><li>通过允许在不同粒度上加锁，多粒度封锁减少了锁冲突的可能性，提高了并发访问的效率。</li></ol></li></ul></li><li><p>锁转换</p><ul><li>定义：允许一个事务在其执行过程中改变已经获得的锁的模式。锁转换分为两种情况：升级和降级。</li></ul></li><li><p>时间戳排序协议</p><ul><li>是数据库并发控制中使用的一种机制，用于在没有使用锁的情况下管理事务的并发执行。它通过为每个事务分配一个唯一的时间戳来确保数据库的一致性和隔离性。</li></ul><p><img src="9.png" /></p></li><li><p>快照隔离</p><ul><li>是数据库系统中一种并发控制方法，它允许事务看到数据库在某一特定时间点的一致性视图。这意味着即使其他事务对数据库进行了修改，一个在快照隔离级别下运行的事务也会看到它开始时数据库的状态，而不会看到这些修改。</li></ul></li></ol></li></ol><h3 id="数据库日志相关">数据库日志相关</h3><ol type="1"><li><p>故障种类</p><ol type="1"><li>事务故障<ol type="1"><li>逻辑错误：如非法输入、找不到数据、溢出或超出资源限制。</li><li>系统错误：系统进入一种不良状态（如死锁），结果事务无法正常执行。</li></ol></li><li>系统崩溃：硬件故障，或者是数据库软件或操作系统的漏洞，导致易失性存储器内容的丢失，并使得事务处理停止。</li><li>磁盘故障：在数据传送操作过程中由于磁头损坏或故障造成磁盘块上的内容丢失。</li></ol></li><li><p>什么是基于日志的恢复机制</p><ul><li>是DBMS中用来保证数据一致性和完整性的一种技术。这种机制依赖于日志文件，它记录了对数据库所做的所有修改。通过redo和undo操作，使得数据库能够在发生故障后恢复到一个一致的状态，保证了即使在系统崩溃后，也不会丢失已提交的数据，并且不会有未完成事务的残留影响。是实现持久性的关键机制。</li></ul></li><li><p>事务和日志的关系</p><ul><li>事务执行依赖于日志来记录和维护操作的历史，而日志则提供了必要的机制来保证事务的完整性和数据库的恢复能力。这种依赖关系是现代数据库系统实现高可靠性和数据一致性的基础。</li></ul></li><li><p>如何根据日志写出恢复日志（看图片+做题吧，懒得讲了）</p><p><img src="7.png" /></p><p><img src="8.png" /></p></li></ol><h3 id="数据库错题相关">数据库错题相关</h3><ol type="1"><li><p><img src="10.png" /></p></li><li><p><img src="11.png" /></p></li><li><p>ER图的时候，n对n中间要新开一张表，左右俩表的主键分别为外键，整体作为主键。</p></li><li><p>写关系代数/SQL的时候如果只是需要ID的话其实很多情况下不用与另一张表自然连接；注意有时候题目会强制让你写笛卡尔积的sql/关系代数；如果写关系代数没思路时，可以试试俩同样的表做自然连接或者groupby或者用“-”</p></li><li><p>3NF时如果被包含记得要删掉</p></li><li><p>求BCNF的俩例子</p></li></ol><p><img src="12.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;懒得解释了，反正之前没咋认真听过课（其实是去做数据库期末项目了）。今天终于有点时间了抽空看了一下之前的内容，做一下笔记记录一下免得以后忘了。学点东西顺便应付一下期末考试。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数据库" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>Distributed Nash Equilibrium Seeking for...</title>
    <link href="http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/"/>
    <id>http://example.com/2023/10/16/Distributed-Nash-Equilibrium-Seeking-for/</id>
    <published>2023-10-16T06:45:10.000Z</published>
    <updated>2024-02-19T16:34:42.189Z</updated>
    
    <content type="html"><![CDATA[<p>标题全称为：Distributed Nash Equilibrium Seeking for AggregativeGames With Directed Communication Graphs</p><p>中文翻译为：在使用有向图结构的聚合博弈中寻找离散式纳什均衡</p><span id="more"></span><h3 id="abstract">Abstract</h3><p>在聚合博弈中寻找分布式纳什均衡的关键点就是聚合博弈采取什么样的图结构。</p><p>若采取无向图或者权衡平衡图结构，则这个问题已经被前人解决。</p><p>如果采取有向图，则这仍然是个无人解决的问题。</p><p>本文解决的是当图结构采取“固定有向图”或者“时变有向图”时的分布式NE寻找问题。</p><p>使用了两种算法来分别解决上面所提到的两种图结构时的分布式NE寻找问题。</p><p>创新点是受凸优化中重球法的启发，向玩家策略的更新规范中引入了“动量项”，使得加速了算法寻找NE的收敛速度。</p><p>对于强连通固定图和b强连通时变图，从理论上证明，如果代价函数和参与人的集合满足一定条件，在步长减小的情况下，参与人的行动将收敛到集合博弈的NE上。</p><p>本文最后将该算法运用于插电式混合动力汽车的能耗控制，检验了算法的正确性。</p><hr /><h3 id="section-1-introduction">Section 1: Introduction</h3><h4 id="研究背景">1-1: 研究背景</h4><ul><li><p>本文研究的是聚合游戏，也就是每个玩家的花费除了依赖自身动作还依赖所有玩家的聚合行为。在聚合游戏中寻找NE是个有挑战性的问题，因为每个玩家只能与自己的邻居通信。</p></li><li><p>在分布式通信计算领域，一些解决聚合游戏中NE寻找问题的分布式算法已经被提出。具体分为“分布式离散时间算法”[6],[7]和“分布式连续时间算法”[8]-[15]</p></li></ul><p>[6]：在这篇文章中，作者专注于研究有向图中的两种特殊的聚合游戏，分别叫做“networkaggregative games” 和 "average aggregative games"。使用"optimal responsestrategy"方法去研究的。而且，在图的加权邻接矩阵为双随机矩阵的条件下，<spanclass="math inline">\(\varepsilon-NE\)</span>在average aggregativegames的寻找得以被解决。</p><p>[7]：在这篇文章中，作者专注于研究无向图中的聚合游戏。并相应提出了几种分布式同步和异步算法。</p><p>[8]：在这篇文章中，作者专注于研究权重平衡有向图中的聚合游戏，其中玩家的dynamicswere described by disturbed first-order systems.为了寻找寻找外部干扰下具有coupled equalityconstraint的聚合游戏的NE，作者在文中提出了一种利用内部模型排斥外部干扰来找NE的分布式算法。同时利用dynamicaverage consensus来估计所有玩家的总和。</p><p>[9]：在这篇文章中，研究了玩家成本函数非光滑，同时玩家动作受到局部可行性约束和线性耦合约束时的情况。具体来说，作者利用微分包含和微分投影算子，提出了一种基于连续时间分布投影的算法来找权重平衡有向图上的非光滑聚合游戏的NE。</p><p>[10]：在这篇文章中，作者研究了无向连通图上具有耦合约束的聚合游戏。</p><p>[11]：结合projected gradient dynamics 和 consensus trackingdynamics，本文讨论了无向连通图上的聚合游戏。</p><p>[12]：结合projected gradient dynamics 和 consensus trackingdynamics，本文讨论了权重平衡有向图上的聚合游戏。</p><p>[13]：研究了存在对通信链路持续攻击的网络上的聚合游戏。其中玩家的动态是受未知时变干扰和未建模项影响的双积分器。</p><p>[14]：研究了聚合游戏在智能电网能耗控制中的运用。其中玩家采用平均共识协议来估计总能耗，并且表明玩家的行为以指数形式收敛于NE。</p><p>[15]：将PHEVs建模成一个无向连通图上的聚合游戏，并对NE的稳定性进行了分析。</p><ul><li>可以发现上面的文章大多都是在无向图或者权重平衡有向图上的工作。在一般有向图上利用分布式离散时间算法来寻找NE仍然是一个未解决的问题。因为难点就在于玩家之间的通信结构不平衡。</li><li>但是到目前为止，关于在不平衡有向图上的分布式优化问题已经被广泛研究。例如下面几篇文章：</li></ul><p>[16]：提出了一种连续时间算法来解决权重不平衡图上的聚合游戏的NE寻找问题。</p><p>[17]：通过结合(子)梯度下降和推和共识协议开发了分布式(子)梯度推算法，其中双随机矩阵的要求可被推广到列随机矩阵。</p><p>[18]：为了不需要提前知道列-随机矩阵的出度，这篇文章仅使用行-随机矩阵，通过估计行-随机矩阵的左Perron特征向量来求解具有不平衡有向图的分布无约束优化问题。</p><p>[19],[20]：通过估计行随机矩阵的左Perron特征向量，研究有向图的分布式约束优化问题。</p><ul><li>所以本文受到上述文章中处理不平衡有向图的方法启发，分别运用行随机矩阵（algorithm1）和列随机矩阵（algorithm2）来研究不平衡有向图上（两种算法分别对应fixed digraph和time-varyingdigraph）的聚合游戏。</li><li>具体来说，通过估计与拓扑相关的行随机矩阵的左特征向量，成功消除了这种拓扑相关行随机矩阵对所有玩家聚合行为估计的不平衡影响。此外，针对时变有向图下的聚集博弈，提出了一种基于推和协议的分布式算法来寻找NE。而且由于玩家的动作受到设定的约束，因此采用投影梯度法根据聚集的局部估计更新玩家的动作。</li><li>另一方面，考虑到步长恒定的投影梯度法只能在存在集合约束的情况下使玩家的动作收敛到NE的一个邻域，所以本文采用步长递减的方法来保证收敛到准确的NE，并且允许参与者采用不协调的步长。</li><li>然而，步长递减也带来了另一个挑战，即收敛速度慢。受到[21]中重球法的启发下，本文在玩家行为更新规律中引入动量项，以加快算法的收敛速度。证明了所提出的步长递减离散NE搜索算法能够保证收敛到精确NE。</li><li>此外，还分析了在步长递减时所提出的NE搜索算法的收敛速度。最后，将所提出的算法应用于有向图上的插电式混合动力汽车系统能耗博弈的求解，数值结果表明，动量项加速了算法的收敛速度。</li></ul><blockquote><p>看了上面的introduction，个人感觉其实就是说：</p><p>不平衡有向图上的聚合问题没人解决，因为玩家之间通信结构不平衡。</p><p>然后本文用[18] ~[20]“估计行随机矩阵左特征向量”的方法解决上面这个难点。</p><p>另外，本文还讨论了时变有向图下的聚集博弈，用的是[17]的方法，但是在他基础上把步长固定改为步长递减从而使NE收敛更精确。另外还加了一个[21]里的重球法中的动量项来加快收敛速度。</p></blockquote><h4 id="大致目录-基础公式">1-2: 大致目录 &amp; 基础公式</h4><p>Section 2：图论的基础结论、问题建模、算法引入</p><p>Section 3、4：算法的收敛性证明</p><p>Section 5：验证算法在插电式混合动力汽车能耗控制的正确性</p><ul><li><span class="math inline">\(\mathbb{R,N_+}\)</span>：分别是实数集和正整数集</li><li><span class="math inline">\(e_i ∈ \mathbb{R^n}\)</span>：n维列向量，其中第i项为1，其余项为0</li><li><span class="math inline">\(1_n ∈ \mathbb{R^n}\)</span>：n维列向量，每一项都是1</li><li><span class="math inline">\(I_n\)</span>：n维单位矩阵</li><li><span class="math inline">\(\|\cdot\|\)</span>：欧几里得范式</li><li><span class="math inline">\(\|x\|_H, H \in \mathbb{R^{n \timesn}}\)</span>：加权范数（weighed norm）（结果为一个常数），定义为：<spanclass="math inline">\(\|x\|_H = \sqrt{x^THx}\)</span></li><li><span class="math inline">\(\Omega \in\mathbb{R^n}\)</span>：n维的非空闭凸集，里面每个元素都是n维列向量</li><li><span class="math inline">\(P_{\Omega}[x]\)</span>: x(<spanclass="math inline">\(\Omega\)</span>外一点)在<spanclass="math inline">\(\Omega\)</span>上的投影点(结果为一个n维列向量),定义为: <span class="math inline">\(P_{\Omega}[x] = argmin_{y \in\Omega}\|x - y\| = y^*, y^* \in \Omega\)</span><ul><li>具有非扩张性，即：<spanclass="math inline">\(\|P_{\Omega}[x]-P_{\Omega}[z]\| \le\|x-z\|\)</span></li></ul></li><li><spanclass="math inline">\([x]_i\)</span>：x这个n维向量中的第i项</li><li><spanclass="math inline">\(H_{ij}\)</span>：矩阵H的i行j列那个元素</li></ul><hr /><h3 id="section-2-preliminary-knowledge">Section 2: Preliminaryknowledge</h3><h4 id="图理论">2-1: 图理论</h4><p><span class="math inline">\(\mathcal{N}=\{1, 2, ...,N\}\)</span>：玩家集合</p><p><span class="math inline">\(\varepsilon(k) \subseteq \{(i, j), i, j\in \mathcal{N}\}\)</span>：时刻为k时的边集 <spanclass="math inline">\((i, j) \in \varepsilon(k)\)</span> means thatplayer i can receive information from player j at time j.</p><p><span class="math inline">\(\mathcal{G}(k) = \{\mathcal{N},\varepsilon(k)\}\)</span>：时刻为k时的图</p><p><span class="math inline">\(N^{in}_{i}(k) = \{i\} \cup \{j | (j, i)\in \varepsilon(k)\}\)</span>：时刻为k时，点i的入点集合</p><p><span class="math inline">\(N^{out}_{i}(k) = \{i\} \cup \{j | (i, j)\in \varepsilon(k)\}\)</span>：时刻为k时，点i的出点集合</p><p><spanclass="math inline">\(d_i^k=|N^{out}_{i}(k)|\)</span>：时刻为k时，点i的出度</p><p>strongly connected fixed digraph：强连通有向图。即任意俩点可通</p><p>For the time-varying digraph <spanclass="math inline">\(\mathcal{G}(k), \{\mathcal{G}(k)\}\)</span> issaid to be B-strongly connected if there exists a <spanclass="math inline">\(B \in \mathbb{N_+}\)</span> such that the uniondigraph <spanclass="math inline">\(\cup_{t=kB}^{(k+1)B}\mathcal{G}(t)\)</span> isstrongly connected for any <span class="math inline">\(k \in\mathbb{N_+}\)</span>换句话说，如果一定时间段内的所有时变图的并（边并起来，边权不相加）为强连通，则这些时变图的集合是B-连通的。</p><p>后面依次类推。</p><h4 id="问题建模">2-2: 问题建模</h4><p>每个玩家的动作集合定义为<spanclass="math inline">\(\Omega_i\)</span>，动作定义为<spanclass="math inline">\(x_i\)</span>。每个玩家的花费函数定义为<spanclass="math inline">\(J_i(x), x = [x_1, x_2, ...,x_n]^T\)</span>，通过这个表达式可以看出来，每个玩家的花费函数跟所有玩家的动作相关。</p><p><span class="math inline">\(J_i(x)\)</span>还有几种等价的定义：</p><p>定义1：<span class="math display">\[J_i(x) = f_i(x_i, \sigma(x)), \\\sigma(x)=\sum_{j=1}^{N}\phi_{j}(x_j) \qquad (1)\]</span></p><p>定义2：<span class="math inline">\(J_i(x)=J_i(x_i, x_{-i}),x_{-i}=[x_1, ..., x_{i-1}, x_{i+1}, ..., x_n]\)</span></p><p>要解决的问题是最小化每一个玩家的花费函数，即：</p><p><span class="math inline">\(min \, f_i(x_i, \sigma(x)), \forall{i}\in \mathcal{N} \qquad (2)\)</span></p><p>实际上就是求一个纳什均衡问题，因为纳什均衡就是任何一个玩家改变它的动作都不能使得它的花费函数更小。如果纳什均衡的观点表达上面的式子，就是：</p><p>假如<span class="math inline">\(x^*\)</span>是NE，当且仅当<spanclass="math inline">\(J_i(x_i^*, x_{-i}^*) \le J_i(x_i, x_{-i}^*),\forall{x_i} \in \Omega_i, \forall{i} \in \mathcal{N}\)</span></p><blockquote><p>Note that the players in the considered game have no knowledge of theaggregation <span class="math inline">\(\sigma(x)\)</span> due to theprivacy of <span class="math inline">\(\phi_j(x_j), j \in\mathcal{N}\)</span>。</p><p>也就是说，<spanclass="math inline">\(\phi_i(x_i)\)</span>函数是每个人特有的，只有自己知道，别人不知道。但是可以通过有向图与邻居交换信息。</p></blockquote><p>下面是论文的几个假设，论文解决的问题都是基于这几个假设作为前提的。</p><h5 id="assumption-1">Assumption 1</h5><ul><li>论文讨论的图不是一般有向图，而是两类。分别是固定有向图（fixeddigraph）和时变有向图（time-varying digraph）。</li><li>而且fixed digraph一定满足强连通，time-varyingdigraph一定满足B-强连通。</li></ul><h5 id="assumption-2">Assumption 2</h5><ul><li><p>对于所有玩家的动作集合<spanclass="math inline">\(\Omega_{i}\)</span>，都是非空、紧致、凸的。</p></li><li><p>定义<span class="math inline">\(\Omega_{-i}=\Omega_{1} \times\Omega_{2} \times ... \times \Omega_{i-1} \times \Omega_{i+1} \times ...\times \Omega_{N}\)</span>。More over, for given <spanclass="math inline">\(x_{-i} \in \Omega_{-i}, J_i(x_i, x_{-i})\)</span>is convex about <span class="math inline">\(x_i\)</span> on <spanclass="math inline">\(\Omega_{i}\)</span></p></li><li><p><span class="math inline">\(J_i(x_i, x_{-i})\)</span>对<spanclass="math inline">\(x\)</span>连续可微，<spanclass="math inline">\(\phi_i(x_i)\)</span>对<spanclass="math inline">\(x_i\)</span>连续可微。</p><ul><li>定义<span class="math inline">\(\nabla_z{f(z,y)}\)</span>为对z求一阶偏导</li><li>按照此定义，将<span class="math inline">\(J_i(x_i,x_{-i})\)</span>对<spanclass="math inline">\(x_i\)</span>求导，将得到<spanclass="math inline">\(\nabla_{x_i}J_i(x_i, x_{-i}) =\nabla_{x_i}f_i(x_i,\sigma(x)) + \nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)\)</span>。这里实际上是有点歧义的，作者想表达的意思就是关注玩家i的动作对其花费函数的影响。</li><li>定义<span class="math inline">\(\Gamma(x)=[\nabla_{x_1}J_1(x_1,x_{-1}), ..., \nabla_{x_N}J_N(x_N,x_{-N})]^T\)</span>，即每个玩家花费函数对自身动作求导组成的一个列向量</li><li>定义<span class="math inline">\(G_i(x_i, \tilde{\sigma_i}) =\nabla_{x_i}f_i(x_i, \sigma(x))|_{\sigma(x)=\tilde{\sigma_i}} +\nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)|_{\sigma(x)=\tilde{\sigma_i}}\)</span>。不是把每个花费函数对动作求导嘛，这里就是把求导结果里的<spanclass="math inline">\(\sigma(x)\)</span>赋值为<spanclass="math inline">\(\tilde{\sigma_i}\)</span>了。</li></ul></li></ul><h5 id="assumption-3">Assumption 3</h5><ul><li><spanclass="math inline">\(\Gamma(x)\)</span>满足下列俩条件之一：</li><li><span class="math inline">\(\Gamma(x)\)</span>在<spanclass="math inline">\(\Omega\)</span>上是严格单调的，也就是说，<spanclass="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,\forall{x, x&#39;} \in \Omega, x \ne x&#39;\)</span></li><li><span class="math inline">\(\Gamma(x)\)</span>在<spanclass="math inline">\(\Omega\)</span>上是强单调的，也就是说，存在一个常数<spanclass="math inline">\(\mu &gt; 0\)</span>使得<spanclass="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) \ge\mu\|x-x&#39;\|^2, \forall{x, x&#39;} \in \Omega, x \nex&#39;\)</span></li></ul><h5 id="assumption-4">Assumption 4</h5><ul><li><p>The mapping <span class="math inline">\(G_i(x_i, \sigma) isL_1-Lipschitz\)</span> continuous with repect to <spanclass="math inline">\(\sigma \in \mathbb{R}\)</span> and <spanclass="math inline">\(\phi_i(x_i)\)</span> is <spanclass="math inline">\(L_2-Lipschitz\)</span> continuous with repect to<span class="math inline">\(x_i \in \Omega_i\)</span> for all <spanclass="math inline">\(i \in \mathcal{N}\)</span>, i.e.,</p></li><li><p>(<span class="math inline">\(L_1, L_2\)</span> are two positiveconstants) <span class="math display">\[\begin{aligned}\|G_i(x_i,\sigma_1)-G_i(x_i,\sigma_2)\|_2&amp;\leL_1\left\|\sigma_1-\sigma_2\right\|,&amp;\forall\sigma_1,\sigma_2\in\mathbb{R},\\\|\phi_i(z_1)-\phi_i(z_2)\|&amp;\leL_2\left\|z_1-z_2\right\|,&amp;\forall z_1,z_2\in\Omega_i,\end{aligned}\]</span></p></li></ul><h4 id="算法引入">2-3: 算法引入</h4><h5id="algorithm-1-ne-seeking-with-row-stochastic-adjacency-matrix">Algorithm1 NE Seeking With Row-Stochastic Adjacency Matrix</h5><ul><li>Initialization: <span class="math inline">\(x_i^0=x_i^1 \in\Omega_i, v_i^1=e_i, \tilde\sigma_i^1=\phi_i(x_i^1)\)</span></li><li>for <span class="math inline">\(k \in \mathbb{N}_+\)</span> do<ul><li>for each player <span class="math inline">\(i \in\mathcal{N}\)</span> do<ul><li><span class="math inline">\(x_i^{k+1}=P_{\Omega_i}[x_i^k -\alpha_i^kG_i(x_i^k, \tilde\sigma_i^k) + \lambda_i(x_i^k-x_i^{k-1})]\qquad (3a)\)</span></li><li><span class="math inline">\(v_i^{k+1}=\sum_{j=1}^Na_{ij}v_j^k \qquad(3b)\)</span></li><li><spanclass="math inline">\(\tilde{\sigma}_{i}^{k+1}=\sum_{j=1}^{N}a_{ij}\tilde{\sigma}_{j}^{k}+\frac{\phi_{i}\left(x_{i}^{k+1}\right)}{\left[v_{i}^{k+1}\right]_{i}}-\frac{\phi_{i}\left(x_{i}^{k}\right)}{\left[v_{i}^{k}\right]_{i}}\qquad (3c)\)</span></li></ul></li><li>end for</li></ul></li><li>end for</li></ul><p>行随机邻接矩阵记为<spanclass="math inline">\(A=[a_{ij}]\)</span>，其中<spanclass="math inline">\(a_{ii}&gt;0\)</span>，且若<spanclass="math inline">\((j, i) \in \varepsilon\)</span>则<spanclass="math inline">\(a_{ij}&gt;0\)</span>, 否则<spanclass="math inline">\(a_{ij}=0\)</span>。另外，行随机矩阵的特征就是每一行元素和为1。</p><p><spanclass="math inline">\(x_i^k\)</span>表示第i个玩家在时刻k的动作</p><p><span class="math inline">\(v_i^k \in\mathbb{R}^N\)</span>用来estimate the left eigenvector <spanclass="math inline">\(v\)</span> associated with eigenvalue <spanclass="math inline">\(1\)</span> of the matrix A.</p><p><span class="math inline">\(\tilde\sigma_i^k\)</span> be the playeri's estimate on the aggregation <spanclass="math inline">\(\sigma(x_k)\)</span> at iteration <spanclass="math inline">\(k\)</span>, <spanclass="math inline">\(x_k=[x_1^k, ..., x_N^k]^T\)</span></p><p><spanclass="math inline">\(\alpha_i^k\)</span>表示步长，它遵循下面三个限制：</p><ol type="1"><li>每个玩家在任意时刻的步长都是大于0的，且对于每个玩家，其<spanclass="math inline">\(\{\alpha_i^k\}\)</span>单调不增加</li><li><spanclass="math inline">\(\sum_{k=1}^{\infty}\alpha_{i}^{k}=\infty,\sum_{k=1}^{\infty}(\alpha_{i}^{k})^{2}&lt;\infty\)</span></li><li><spanclass="math inline">\(\sum\limits_{k=1}^{\infty}(\overline{\alpha}_{k}-\underline{\alpha}_{k})&lt;\infty,\text{where}\overline{\alpha}_{k}=\max\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\text{and}\underline{\alpha}_{k}=\min\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}.\)</span></li></ol><p>在algorithm 1中，玩家使用非精确梯度<spanclass="math inline">\(G_i(x_i^k,\tilde\sigma_i^k)\)</span>来更新自身动作。为了消除不精确梯度带来的误差，引入递减的步长而不是固定的步长，从而保证精确收敛到NE。另外，动量项<spanclass="math inline">\(\lambda_i(x_i^k-x_i^{k-1})]\)</span>可以加速算法的收敛，<spanclass="math inline">\(0&lt;\lambda_i&lt;1\)</span>是动量参数。以上就是对于(3a)的解释。</p><p>在(3c)中的第二项和第三项，其存在的目的是为了解决矩阵<spanclass="math inline">\(A\)</span>可能不是列随机的问题。</p><p>可以看出，(3b)和(3c)都用到了<spanclass="math inline">\(a_{ij}\)</span>，所以algorithm 1只适用于fixeddigraph。</p><h5id="algorithm-2-ne-seeking-with-column-stochastic-adjacency-matrix">Algorithm2 NE Seeking With Column-Stochastic Adjacency Matrix</h5><p>这个算法是针对time-varyingdigraph的。在算法2中，每个玩家需要知道自己在每次交流中的出度，因为不同时刻每个点的出度会变化。</p><ul><li>Initialization: <spanclass="math inline">\(x_{i}^{0}=x_{i}^{1}\in\Omega_{i},y_{i}^{1}=1,\tilde{\sigma}_{i}^{1}=\phi_{i}(x_{i}^{1})\)</span></li><li>for <span class="math inline">\(k \in \mathbb{N}_+\)</span> do<ul><li>for each player <span class="math inline">\(i \in\mathcal{N}\)</span> do<ul><li><span class="math inline">\(w_i^{k+1}=\sum_{j\inN_i^{in}(k)}\frac{\tilde{\sigma}_j^k}{d_j^k} \qquad (4a)\)</span></li><li><span class="math inline">\(y_i^{k+1}=\sum_{j\inN_i^{in}(k)}\frac{y_j^k}{d_j^k} \qquad (4b)\)</span></li><li><span class="math inline">\(z_i^{k+1}=\frac{w_i^{k+1}}{y_i^{k+1}}\qquad (4c)\)</span></li><li><spanclass="math inline">\(x_i^{k+1}=P_{\Omega_i}\left[x_i^k-\alpha_i^kG_i(x_i^k,Nz_i^{k+1})+\lambda_i(x_i^k-x_i^{k-1})\right]\qquad (4d)\)</span></li><li><spanclass="math inline">\(\tilde{\sigma}_i^{k+1}=w_i^{k+1}+\phi_i\left(x_i^{k+1}\right)-\phi_i\left(x_i^k\right)\qquad (4e)\)</span></li></ul></li><li>end for</li></ul></li><li>end for</li></ul><p>可以发现，这里求<spanclass="math inline">\(x_i^{k+1}\)</span>第二项<spanclass="math inline">\(G_i\)</span>中并没用<spanclass="math inline">\(\tilde\sigma_i^k\)</span>，而是用的<spanclass="math inline">\(Nz_i^{k+1}\)</span>。z是w跟y的比值，w与y又与点的入点和(入点的出度)有关。</p><blockquote><p>Note: 在algorithm 1中，若把"若<span class="math inline">\((j, i) \in\varepsilon\)</span>则<spanclass="math inline">\(a_{ij}&gt;0\)</span>"改为“若<spanclass="math inline">\((j, i) \in \varepsilon\)</span>则<spanclass="math inline">\(a_{ij}=\frac{1}{d_j^k}\)</span>”，则(3c)与(4e)等价</p></blockquote><hr /><h3 id="section-3-convergence-analysis-of-algorithm-1">Section 3:Convergence analysis of algorithm 1</h3><h4 id="theorem-1">3-1: Theorem 1</h4><p>条件：</p><ol type="1"><li><p>采用固定有向图结构</p></li><li><p><span class="math inline">\(\nabla_{x_i}J_i(x_i, x_{-i})=\nabla_{x_i}f_i(x_i, \sigma(x)) + \nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)\)</span></p><p><span class="math inline">\(\Gamma(x)=[\nabla_{x_1}J_1(x_1, x_{-1}),..., \nabla_{x_N}J_N(x_N, x_{-N})]^T\)</span></p><p><span class="math inline">\(G_i(x_i, \tilde{\sigma_i}) =\nabla_{x_i}f_i(x_i, \sigma(x))|_{\sigma(x)=\tilde{\sigma_i}} +\nabla_{\sigma}f_i(x_i, \sigma(x)) \,\nabla_{x_i}\phi_i(x_i)|_{\sigma(x)=\tilde{\sigma_i}}\)</span></p></li><li><p><spanclass="math inline">\((\Gamma(x)-\Gamma(x&#39;))^T(x-x&#39;) &gt; 0,\forall{x, x&#39;} \in \Omega, x \ne x&#39;\)</span></p></li><li><p><span class="math display">\[\begin{aligned}\|G_i(x_i,\sigma_1)-G_i(x_i,\sigma_2)\|_2&amp;\leL_1\left\|\sigma_1-\sigma_2\right\|,&amp;\forall\sigma_1,\sigma_2\in\mathbb{R},\\\|\phi_i(z_1)-\phi_i(z_2)\|&amp;\leL_2\left\|z_1-z_2\right\|,&amp;\forall z_1,z_2\in\Omega_i,\end{aligned}\]</span></p></li><li><p>对于<spanclass="math inline">\(\alpha\)</span>步长，满足下面三条性质(C1-C3)</p><ol type="1"><li><spanclass="math inline">\(\{\alpha_i^k\}\)</span>不严格递减，且<spanclass="math inline">\(\alpha_i^k&gt;0\)</span></li><li><spanclass="math inline">\(\sum_{k=1}^{\infty}\alpha_{i}^{k}=\infty,\sum_{k=1}^{\infty}(\alpha_{i}^{k})^{2}&lt;\infty\)</span></li><li><spanclass="math inline">\(\sum\limits_{k=1}^{\infty}(\overline{\alpha}_{k}-\underline{\alpha}_{k})&lt;\infty,\text{where}\overline{\alpha}_{k}=\max\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\text{and}\underline{\alpha}_{k}=\min\limits_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}.\)</span></li></ol></li><li><p><spanclass="math inline">\(\begin{matrix}0&amp;&lt;&amp;\lambda_i&amp;&lt;&amp;\frac{\sqrt{2}}{2}\end{matrix}\)</span></p></li></ol><p>结论：all players' actions converge to the unique NE <spanclass="math inline">\(x^*\)</span> under algorithm 1.</p><h4 id="preliminary-analysis-about-algorithm-1">3-2: Preliminaryanalysis about algorithm 1</h4><p>先来求一下algorithm 1里的<spanclass="math inline">\(v_i^k\)</span></p><p>定义：<spanclass="math inline">\(\left.V_{k}=\left[\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\ldots,v_{N}^{k}}\end{array}\right.\right]^{T}\)</span></p><p>所以<span class="math inline">\(v_i^{k+1}=\sum_{j=1}^Na_{ij}v_j^k\qquad (3b)\)</span>等价于<spanclass="math inline">\(V_{k+1}=AV_{k}\qquad (5)\)</span></p><p>因为<span class="math inline">\(V_1 = [v_1, v_2, ..., v_N]^T =I_N\)</span>，即<span class="math inline">\(v_i =e_i\)</span>（条件）</p><p>所以<spanclass="math inline">\(\lim_{k\to\infty}V_k=\operatorname*{lim}_{k\to\infty}A^{k-1}V_1=\operatorname*{lim}_{k\to\infty}A^{k}\)</span></p><p>因为A是行随机矩阵，所以显然<spanclass="math inline">\(1_n\)</span>是特征值为1时的一个特征向量。</p><p>所以得出<spanclass="math inline">\(\operatorname*{lim}_{k\to\infty}A^{k}=1_Nv^T\)</span>（根据Perron-Frobenius定理）, where <spanclass="math inline">\(v\)</span> 是A关于特征值1的左特征向量且<spanclass="math inline">\(v\)</span>每一项大于0，且<spanclass="math inline">\(v^T1_N=1\)</span>。</p><p>所以<spanclass="math inline">\(\lim_{k\to\infty}\left.V_{k}=\left[\begin{array}{ccc}{v_{1}^{k},v_{2}^{k},\ldots,v_{N}^{k}}\end{array}\right.\right]^{T}= 1_Nv^T\)</span>。又<span class="math inline">\(1_Nv^T=[v, v, ...,v]^T\)</span>。</p><p>也就是说，当k趋近于无穷大时，每个玩家的<spanclass="math inline">\(v_i\)</span>都收敛于<spanclass="math inline">\(v\)</span>。</p><p>再来求一下algorithm 1里的<spanclass="math inline">\(\tilde{\sigma}_{i}^{k}\)</span></p><p>首先<spanclass="math inline">\(V_k\)</span>对角线上的元素都是正的，通过<spanclass="math inline">\(V_{k+1}=AV_{k}\)</span>可看出。首先<spanclass="math inline">\(V_1\)</span>是单位阵肯定对角线为正，然后A的对角线元素都是正的（这是algorithm1引入时提到的条件）。所以他俩乘出来的对角线也是正的。不断递推，对角线上都是正的。</p><p>所以现在我定义一个<spanclass="math inline">\(\left.\hat{V}_k=\operatorname{diag}\left(\begin{bmatrix}v_1^k\end{bmatrix}\right._1,\begin{bmatrix}v_2^k\end{bmatrix}_2,\ldots,\begin{bmatrix}v_N^k\end{bmatrix}_N\right)\)</span></p><p>上面这个<spanclass="math inline">\(\hat{V}_k\)</span>其实就是取了<spanclass="math inline">\(V_k\)</span>的对角线，其余地方都是0。</p><p>因为前面说了对角线都是正的嘛，所以<spanclass="math inline">\(\hat{V_k}\)</span>是满秩可逆的。而且我们知道最终<spanclass="math inline">\(V_k\)</span>是收敛的，所以<spanclass="math inline">\(\hat{V_k}\)</span>最终也是收敛的。</p><p>最后我再定义<spanclass="math inline">\(\tilde{\sigma}_{k}=\left[\tilde{\sigma}_{1}^{k},\tilde{\sigma}_{2}^{k},\ldots,\tilde{\sigma}_{N}^{k}\right]^{T}\)</span>和<spanclass="math inline">\(\phi_k =\left[\phi_{1}(x_{1}^{k}),\phi_{2}(x_{2}^{k}),\ldots,\phi_{N}(x_{N}^{k})\right]^{T}\)</span></p><p>则<spanclass="math inline">\(\tilde{\sigma}_{i}^{k+1}=\sum_{j=1}^{N}a_{ij}\tilde{\sigma}_{j}^{k}+\frac{\phi_{i}\left(x_{i}^{k+1}\right)}{\left[v_{i}^{k+1}\right]_{i}}-\frac{\phi_{i}\left(x_{i}^{k}\right)}{\left[v_{i}^{k}\right]_{i}}\qquad (3c)\)</span>可改写为：</p><p><spanclass="math inline">\(\tilde{\sigma}_{k+1}=A\tilde{\sigma}_k+\hat{V}_{k+1}^{-1}\Phi_{k+1}-\hat{V}_k^{-1}\Phi_k\qquad (6)\)</span></p><h4 id="lemmas">3-3: Lemmas</h4><p>为了接下来的叙述方便，定义<spanclass="math inline">\(V_{\infty}=\lim\limits_{k\to\infty}V_{k}=1_{N}v^{T}\)</span>和<spanclass="math inline">\(\hat{V}_{\infty}=\operatorname{diag}([v]_1,\ldots,[v]_N)\)</span></p><h5 id="lemma-1">Lemma 1</h5><p>因为<spanclass="math inline">\(\hat{V}_{k}\)</span>是收敛的，所以会有<spanclass="math inline">\(\|\hat{V}_{k}^{-1}\|\leq \varrho, \varrho &gt;0\)</span></p><blockquote><p>矩阵的二范式从几何意义上来说就是单位圆在经过矩阵变换后离原点最远的距离。假设要求<spanclass="math inline">\(\|A\|\)</span>，则先求<spanclass="math inline">\(A^TA\)</span>，然后再求<spanclass="math inline">\(A^TA\)</span>的特征值，取最大的特征值开方就是矩阵A的二范数</p></blockquote><p>引理1：<spanclass="math inline">\(\|\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1}\|\leq\varrho^{2}\gamma\theta^{k},k \in \mathbb{N_+}, \gamma &gt; 0, 0 &lt; \theta &lt; 1, \varrho &gt;0\)</span></p><p>证明：</p><p>因为<span class="math inline">\((\hat{V_k}^{-1})(\hat{V_k} -\hat{V}_\infty)(\hat{V}_\infty^{-1}) =(\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1})\)</span></p><p>两边取范数，得：<spanclass="math inline">\(\|\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1}\| =\|(\hat{V_k}^{-1})(\hat{V_k} - \hat{V}_\infty)(\hat{V}_\infty^{-1})\|\le \|\hat{V_k}^{-1}\|\|\hat{V_k} -\hat{V}_\infty\|\|\hat{V}_\infty^{-1}\|\)</span></p><p>定义<span class="math inline">\(\varrho ={sup}_{k}\left\|\widetilde{V}_{k}^{-1}\right\|_{2}\)</span>，则<spanclass="math inline">\(\|\hat{V_k}^{-1}\|\|\hat{V}_\infty^{-1}\| \le\varrho^2\)</span></p><p>又<span class="math inline">\(\|\hat{V}_k - \hat{V}_\infty\| \le\gamma\theta^{k}\)</span>, [17]。</p><p>所以<spanclass="math inline">\(\|\hat{V}_{k}^{-1}-\hat{V}_{\infty}^{-1}\| \le\varrho^{2}\gamma\theta^{k}\)</span>，得证。</p><h5 id="lemma-2">Lemma 2</h5><p>引理2：<spanclass="math inline">\(V_{\infty}\tilde{\sigma}_{k}=V_{\infty}\hat{V}_{k}^{-1}\Phi_{k},k \in \mathbb{N_+}\)</span></p><p>证明如下：</p><p><img src="1.png" /></p><h5 id="lemma-3">Lemma 3</h5><p>先来点前置知识</p><p>因为<spanclass="math inline">\(\operatorname*{lim}_{k\to\infty}\left(A-1_{N}v^{T}\right)^{k}=\operatorname*{lim}_{k\to\infty}A^{k}-1_{N}v^{T}=0\)</span>（这个极限推导可以先放着不管），所以根据谱半径的知识，可以知道<spanclass="math inline">\(\rho(A-1_Nv^T)~&lt;~1\)</span></p><p>又因为<span class="math inline">\(\rho(A-1_Nv^T) \le \|A -1_Nv^T\|\)</span></p><p>所以必然存在一个矩阵范数<spanclass="math inline">\(\|\cdot\|_\epsilon\)</span>，使得<spanclass="math inline">\(\rho(A-1_{N}v^{T})\leq\|A-1_{N}v^{T}\|_{\epsilon}\leq\rho(A-1_{N}v^{T})+\epsilon&lt;1\)</span></p><p>另外，又因为所有的矩阵范式都是等价的，所以有：</p><p><span class="math inline">\(\|\cdot\|_{\epsilon}\leqc\|\cdot\|\)</span> and <span class="math inline">\(\|\cdot\|\leqd\|\cdot\|_{\epsilon}\)</span></p><p>接下来再定义两个东西</p><p><span class="math inline">\(\rho_1=\left\|A-1_Nv^T\right\|_\epsilon,\rho_1 &lt; 1 \qquad (7)\)</span></p><p><span class="math inline">\(\rho_2=\left\|I_N-1_Nv^T\right\| \qquad(8)\)</span></p><p>引理3：Under Assumption 1(a), 2 and 4, <spanclass="math inline">\(\|\tilde{\sigma}_i^k-v^T\tilde{\sigma}_k\|\)</span>is bounded, i.e., there exists a constant <spanclass="math inline">\(\hat{C} &gt; 0\)</span> such that <spanclass="math inline">\(\|\tilde{\sigma}_{i}^{k}-v^{T}\tilde{\sigma}_{k}\|\leq\hat{C}\)</span></p><p>证明如下：</p><p><img src="5.png" /></p><p><img src="6.png" /></p><h5 id="lemma-4">Lemma 4</h5><p>引理4：<spanclass="math inline">\(\|G_i\left(x_i^k,\sigma(x_k)\right)\|\le M,\|G_i(x_i^k, \tilde{\sigma}_i^k) \| \le M, M &gt; 0\)</span></p><p>证明如下：</p><p><img src="2.png" /></p><h5 id="lemma-5">Lemma 5</h5><p>定义<spanclass="math inline">\(\overline{\lambda}=\max_{j\in\mathcal{N}}\{\lambda_j\}\)</span>，若<spanclass="math inline">\(0&lt;\overline{\lambda}&lt;\frac{\sqrt{2}}2\)</span>，则下面三条性质将会满足：</p><ol type="a"><li><p><spanclass="math inline">\(\left\|x_{i}^{k+1}-x_{i}^{k}\right\|\leqM\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s},\forallk\in\mathbb{N}_{+}\)</span></p></li><li><p><spanclass="math inline">\(\lim\limits_{k\to\infty}\left\|x_{i}^{k+1}-x_{i}^{k}\right\|=0\)</span></p></li><li><p><spanclass="math inline">\(\sum_{k=1}^{\infty}\|x_{i}^{k+1}-x_{i}^{k}\|^{2}&lt;\infty\)</span></p></li></ol><p>where <span class="math inline">\(M\)</span> is given in Lemma 4, and<spanclass="math inline">\(\overline{\alpha}_{k}=\max_{j\in\mathcal{N}}\{\alpha_{j}^{k}\}\)</span></p><p>证明如下：</p><p><img src="3.png" /></p><p><img src="4.png" /></p><p>补充：因为所有动作<spanclass="math inline">\(x_i^k\)</span>都属于compact的<spanclass="math inline">\(\Omega_i\)</span>，所以<spanclass="math inline">\(\{x_k\}\)</span>是有界的，又由Lemma5(b)和柯西收敛准测可容易推出<spanclass="math inline">\(\{x_k\}​\)</span>是收敛的。</p><h5 id="lemma-6">Lemma 6</h5><ol type="a"><li><p>For any <span class="math inline">\(k \geq 2\)</span>, one has<spanclass="math display">\[\left\|\tilde{\sigma}_{k}-V_{\infty}\tilde{\sigma}_{k}\right\|\leqdc\rho_{1}^{k-1}\left\|\tilde{\sigma}_{1}-1_{N}v^{T}\tilde{\sigma}_{1}\right\|+D_1\sum_{l=1}^{k-1}\rho_1^{k-l-1}\beta_l+D_2\sum_{l=1}^{k-1}\rho_1^{k-l-1}\theta^l\qquad (9)\]</span>where <spanclass="math inline">\(D_{1}=dc\rho_{2}\varrhoL_{2}\sqrt{N}M,D_{2}=2dc\rho_{2}C\varrho^{2}\gamma,\beta_l=\sum_{s=1}^{l}\overline{\lambda}^{l-s}\overline{\alpha}_{s}\)</span>and<spanclass="math inline">\(0&lt;\theta&lt;1\)</span> is given in Lemma1.</p></li><li><p>For step-size sequence <spanclass="math inline">\(\{\alpha_i^k\}\)</span> satisfying conditionsC1-C3, one has <spanclass="math inline">\(\sum_{k=1}^{\infty}\overline{\alpha}_{k}\left\|\tilde{\sigma}_{k}-V_{\infty}\tilde{\sigma}_{k}\right\|&lt;\infty\)</span></p></li></ol><p>证明如下：</p><p><img src="7.png" /></p><p><img src="8.png" /></p><h4 id="proof-of-theorem-1">3-4: Proof of theorem 1</h4><p><img src="9.png" /></p><p><img src="10.png" /></p><p><img src="11.png" /></p><p><img src="12.png" /></p><p><img src="13.png" /></p><p><img src="14.png" /></p><p><img src="15.png" /></p><p><img src="16.png" /></p><h4 id="theorem-2">3-5: Theorem 2</h4><p>在满足Assumption 1(a), 2, 3(b) and 4的前提下。令<spanclass="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}=\alpha_{k}\)</span>。且<spanclass="math inline">\(0&lt;\lambda_i&lt;\frac{\sqrt{2}}{2}\)</span>，则<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速率为<spanclass="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span>。 <spanclass="math display">\[q_t=\frac{\sum\limits_{k=1}^t\alpha_k\|x_k-x^*\|^2}{\sum\limits_{k=1}^t\alpha_k}\]</span> 证明：暂略</p><h4 id="convergence-rate-analysis-of-algorithm-1">3-6: Convergence rateanalysis of algorithm 1</h4><p>如果<spanclass="math inline">\(\Gamma(x)\)</span>是强单调，且步长满足<spanclass="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}\)</span>。则可以分析algorithm1的收敛速率。</p><p>结论就是<span class="math inline">\(x_k\)</span>收敛到<spanclass="math inline">\(x^*\)</span>的速率与<spanclass="math inline">\(q_t\)</span>收敛到0的速率相同。证明如下：</p><p><img src="17.png" /></p><hr /><h3 id="section-4-convergence-analysis-of-algorithm-2">Section 4:Convergence analysis of algorithm 2</h3><p>对于之前的algorithm 2中的公式(4a) - (4c)，用矩阵表示如下： <spanclass="math display">\[\begin{aligned}&amp;w_{k+1} =A\left(k\right)\tilde{\sigma}_{k},  \\&amp;y_{k+1} =A\left(k\right)y_{k},  \\&amp;z_{i}^{k+1} =\frac{w_{i}^{k+1}}{y_{i}^{k+1}},\quad i=1,\ldots,N,&amp; (24)\end{aligned}\]</span> (4e)则可以表达为以下形式：</p><p><spanclass="math inline">\(\tilde{\sigma}_{k+1}=A\left(k\right)\tilde{\sigma}_{k}+\Phi_{k+1}-\Phi_{k},\quad(25)\)</span></p><p>其中A矩阵是一个列随机矩阵，如果点j连向i，则A(i, j) = 1 /(点j的出度)。如果j不连向i，则A(i, j) = 0。</p><p>定义<spanclass="math inline">\(\epsilon_{k}=[\epsilon_{1}^{k},\ldots,\epsilon_{N}^{k}]^{T}=\Phi_{k+1}-\Phi_{k}\)</span>，这个是。再定义<spanclass="math inline">\(\epsilon_{i}^{k}=\phi_{i}(x_{i}^{k+1})-\phi_{i}(x_{i}^{k})\)</span>。</p><p>因为A是列随机矩阵，所以<spanclass="math inline">\(1_{N}^{T}A({k})=1_{N}^{T}\)</span>。所以(25)左右同乘一个<spanclass="math inline">\(1_N^T\)</span>，然后移项得到递推式，通过递推式可得<spanclass="math inline">\(1_{N}^{T}\tilde{\sigma}_{k} - 1_N^T\phi_k =1_N^T\tilde{\sigma}_1 - 1_N^T\phi_1 = 0\)</span></p><p>所以<span class="math inline">\(1_N^T\tilde{\sigma}_k = 1_N^T\phi_k =\phi_1(x_1^k) + \phi_2(x_2^k) + ... + \phi_n(x_n^k) =\sigma(x_k)\)</span></p><h4 id="lemmas-1">4-1: Lemmas</h4><h5 id="lemma-7">Lemma 7</h5><p>定理：在满足Assumptions 1(b), 2, 4的前提下，there exists a constant<span class="math inline">\(\tilde{M} &gt; 0\)</span>, s.t, <spanclass="math inline">\(\|G_{i}(x_{i}^{k},\sigma(x_{k}))\|\leq\tilde{M}\)</span>and <spanclass="math inline">\(\|G_{i}(x_{i}^{k},Nz_{i}^{k+1})\|\leq\tilde{M}\)</span></p><p>证明：</p><p>Lemma 4已经证出了<spanclass="math inline">\(\left\|G_i\left(x_i^k,\sigma(x_k)\right)\right\|\leqM_1\)</span>，所以<spanclass="math inline">\(\|G_{i}(x_{i}^{k},\sigma(x_{k}))\|\leq\tilde{M}\)</span>就不用证了。主要证后面那个。</p><p><spanclass="math display">\[\begin{Vmatrix}G_i(x_i^k,Nz_i^{k+1})\end{Vmatrix}\le\begin{Vmatrix}G_i(x_i^k,Nz_i^{k+1})-G_i(x_i^k,1_N^T\tilde{\sigma}_k)\end{Vmatrix}+\left\|G_{i}(x_{i}^{k},1_{N}^{T}\tilde{\sigma}_{k})\right\|\\ \qquad \le L_{1}\left\VertNz_{i}^{k+1}-1_{N}^{T}\tilde{\sigma}_{k}\right\Vert+\left\VertG_{i}(x_{i}^{k},1_{N}^{T}\tilde{\sigma}_{k})\right\Vert \]</span></p><p>显然，<spanclass="math inline">\(\|G_{i}(x_{i}^{k},1_{N}^{T}\tilde{\sigma}_{k})\|\)</span>就是<spanclass="math inline">\(\|G_i(x_i^k,\sigma(x_k))\|\)</span>，所以其有界。</p><p>由[17, lemma 1(a)]可知，k &gt;=2 时，有：</p><p><spanclass="math inline">\(\left|z_{i}^{k+1}-\frac{1_{N}^{T}\tilde{\sigma}_{k}}{N}\right|\le\frac{8}{\delta}\Bigg(\iota^{k-1}\|\tilde{\sigma}_{1}\|_{1}+\sum_{s=1}^{k-1}\iota^{k-s-1}\|\epsilon_{s}\|_{1}\Bigg)\quad (26)\)</span></p><p>with <span class="math inline">\(\delta &gt; 0, 0 &lt; \iota &lt;1\)</span></p><p>因为<span class="math inline">\(\|\epsilon_{s}\|_{1}\leN\|\epsilon_{s}\|=N\|\Phi_{s+1}-\Phi_{s}\|\leq2NC\)</span></p><p>所以不难证出：<spanclass="math inline">\(L_{1}\left\|Nz_{i}^{k+1}-1_{N}^{T}\tilde{\sigma}_{k}\right\|\)</span>有界</p><p>所以<span class="math inline">\(\|G_i(x_i^k,Nz_i^{k+1})\|\)</span>有界，即<spanclass="math inline">\(\parallel G_i(x_i^k,Nz_i^{k+1})\parallel \le\tilde{M}_2\)</span></p><p>令<span class="math inline">\(\tilde{M} = max (M_1,\tilde{M}_2)\)</span>，得证。</p><blockquote><p>Note: 如果<spanclass="math inline">\(\overline{\lambda}=\operatorname*{max}_{j\in\mathcal{N}}\{\lambda_{j}\}\)</span>satisfies <span class="math inline">\(0 &lt; \overline{\lambda} &lt;\frac{\sqrt{2}}{2}\)</span>，则Lemma5中的结论和证明过程仍然成立，只需要将其中涉及到的M换成<spanclass="math inline">\(\tilde{M}\)</span></p></blockquote><h5 id="lemma-8">Lemma 8</h5><p>定理：如果<spanclass="math inline">\(\overline{\lambda}=\max_{j\in\mathcal{N}}\{\lambda_{j}\}\)</span>satisfies <span class="math inline">\(0 &lt; \overline{\lambda} &lt;\frac{\sqrt{2}}{2}\)</span>，且<spanclass="math inline">\(\alpha_i^k\)</span> satisfies conditionsC1-C3。则<spanclass="math inline">\(\lim_{k\rightarrow\infty}\epsilon_{i}^{k}=0\)</span>，且<spanclass="math inline">\(\sum_{k=1}^\infty\overline{\alpha}_k\|\epsilon_i^k\|&lt;\infty\)</span></p><p>证明：</p><p>由于上面的Note存在，所以Lemma 5的结论可以直接用于Lemma 8的证明。</p><p>先证第一个：</p><p>因为<span class="math inline">\(\phi_i(x_i)\)</span>是L2-Lipschitzcontinuous，所以<span class="math inline">\(\|\epsilon_{i}^{k}\|\leL_{2}\|x_{i}^{k+1}-x_{i}^{k}\|\)</span></p><p>而且由Lemma 5(b)知：<spanclass="math inline">\(\lim_{k\to\infty}\|x_{i}^{k+1}-x_{i}^{k}\|=0\)</span></p><p>所以<spanclass="math inline">\(\lim_{k\to\infty}\epsilon_{i}^{k}=0\)</span></p><p>再证第二个：</p><p>由Lemma 5(a)知：<spanclass="math inline">\(\left\|x_i^{k+1}-x_i^k\right\|\leqM\sum_{s=1}^k\overline{\lambda}^{k-s}\overline{\alpha}_s\)</span></p><p>所以：<span class="math inline">\(\overline{\alpha}_k||\epsilon_i^k||\le\overline{\alpha}_{k}L_{2}\tilde{M}\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s}\leL_{2}\tilde{M}\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s}^{2}\)</span></p><p>又根据[31 Lemma 3.1(b)]，可得到：<spanclass="math inline">\(\sum_{k=1}^{\infty}\overline{\alpha}_{k}||\epsilon_{i}^{k}||\leqL_{2}\tilde{M}\sum_{k=1}^{\infty}\sum_{s=1}^{k}\overline{\lambda}^{k-s}\overline{\alpha}_{s}^{2}&lt;\infty\)</span></p><blockquote><p>Note：通过Lemma 8证明的这两个结论，通过[17 Lemma1]，可以进一步证明出：</p><p><spanclass="math inline">\(\lim\limits_{k\to\infty}\left\|z_i^{k+1}-\frac{1_N^T\tilde{\sigma}_k}{N}\right\|=0,\sum\limits_{k=1}^{\infty}\overline{\alpha}_k\left\|z_i^{k+1}-\frac{1_N^T\tilde{\sigma}_k}{N}\right\|&lt;\infty\)</span></p><p>因为<spanclass="math inline">\(1_{N}^{T}\tilde{\sigma}_{k}\)</span>就是<spanclass="math inline">\(\sigma\left(x_{k}\right)\)</span></p><p>所以<spanclass="math inline">\(\sum_{k=1}^{\infty}\overline{\alpha}_{k}\left\VertNz_{i}^{k+1}-\sigma(x_{k})\right\Vert &lt; \infty\)</span></p><p>上面这个公式在algorithm 2的收敛分析中有作用。</p></blockquote><h4 id="theorem-3">4-2: Theorem 3</h4><p>定理：在满足Assumptions 1(b), 2, 3(a), 4，以及<spanclass="math inline">\(0 &lt; \lambda_i &lt;\frac{\sqrt{2}}{2}\)</span>，以及C1-C3的条件下。所有玩家的动作最终会收敛到<spanclass="math inline">\(x^*\)</span></p><p>证明：</p><p><img src="18.png" /></p><p><img src="19.png" /></p><h4 id="theorem-4">4-3: Theorem 4</h4><p>定理：在Assumptions 1(b), 2, 3(b), 4 are satisfied 的前提下，令<spanclass="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}=\alpha_{k}\)</span>，且<spanclass="math inline">\(0 &lt; \lambda_i &lt;\frac{\sqrt{2}}{2}\)</span>。则<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速率为<spanclass="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span> <spanclass="math display">\[q_t=\frac{\sum\limits_{k=1}^t\alpha_k\|x_k-x^*\|^2}{\sum\limits_{k=1}^t\alpha_k}\]</span> 证明：需要参考[17 Corollary 3]和Theorem 2的证明。</p><blockquote><p>Note：如果<spanclass="math inline">\(\Gamma(x)\)</span>是强单调且步长满足<spanclass="math inline">\(\alpha_i^k=\frac1{\sqrt{k}}\)</span>，则可分析algorithm2的收敛速度。结论也是<span class="math inline">\(x_k\)</span>收敛到<spanclass="math inline">\(x^*\)</span>的速率与<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速率相同。</p></blockquote><hr /><h3 id="section-5-energy-consumption-control-of-phevs">Section 5: Energyconsumption control of PHEVs</h3><p>每个PHEV就是一个玩家。第 i 个PHEV的电量消耗为<spanclass="math inline">\(x_i, x_i \in [x_i^{min},x_i^{max}]\)</span>。每台车的成本函数<spanclass="math inline">\(J_i\)</span>定义为： <span class="math display">\[J_i(x_i,x_{-i})=x_i\left(a\sigma(x)+b\right)+p_o\left(\kappa_i\left(1-\frac{x_i}{x_i^{\max}}\right)^2+d_i\right)\qquad (30)\]</span> a &gt; 0，<spanclass="math inline">\(\sigma(x)=\sum_{i=1}^N{x_i}\)</span>，<spanclass="math inline">\(p_0\)</span>是油价，<spanclass="math inline">\(\kappa_{i}\)</span>是油价的换算系数，<spanclass="math inline">\(d_i\)</span>是第 i 台车所需的基本油量。</p><p>总结一下，按照我的理解，上面那个式子就是每台车的花费函数嘛。花费分为俩部分：电费、油费。电费不仅跟自己的耗电量有关，也跟所有人的耗电量有关，所以是第i台车的电费是两者相乘。对于油费，首先一台车的油量分为两部分，第一是<spanclass="math inline">\(x_i^{max} -x_i\)</span>剩下的用油来跑，第二是一台车最起码要存储的油量<spanclass="math inline">\(d_i\)</span>。分别就对应着上面括号里的两项。乘个油价就为油费了。</p><p>这个实际问题建模后显然满足Assumption 2,4。而且值得注意的是，其成本函数还具有一个势函数<spanclass="math inline">\(F(x)\)</span>： <span class="math display">\[\begin{aligned}F(x)&amp;=\frac12\sum_{i=1}^Nax_i\left(\sigma(x)-x_i\right)+\sum_{i=1}^N\left(ax_i^2+bx_i\right)\\&amp;+\sum_{i=1}^Np_o\left(\kappa_i\left(1-\frac{x_i}{x_i^{\max}}\right)^2+d_i\right)\qquad(31)\end{aligned}\]</span> （势函数就是指，对于所有i，有：<spanclass="math inline">\(\frac{\partial{J}_{i}(x)}{\partialx_{i}}=\frac{\partial{F}(x)}{\partial x_{i}}\)</span>）</p><p>接下来，来验证这个建模满足Assumption 3(a)。即<spanclass="math inline">\(\Gamma(x)\)</span>在<spanclass="math inline">\(\Omega\)</span>上是严格单调的。</p><h4 id="lemma-9">Lemma 9</h4><p>定理：如果<span class="math inline">\(N &gt; 3\)</span>且a满足：<span class="math display">\[a&lt;\min_{i\in\mathcal{N}}\frac{2p_{o}\kappa_{i}}{\left(N-3\right)\left(x_{i}^{\max}\right)^{2}}\]</span> 则势函数<spanclass="math inline">\(F(x)\)</span>是严格凸的。</p><p>证明：</p><p>先求<spanclass="math inline">\(\nabla^2F(x)\)</span>，不难求出，其对角元素为<spanclass="math inline">\(2a+\frac{2p_{o}\kappa_{i}}{(x_{i}^{\operatorname*{max}})^{2}}\)</span>，非对角元素为<spanclass="math inline">\(a\)</span>。因为<span class="math inline">\(N &gt;3\)</span>且a满足<spanclass="math inline">\(a&lt;\min_{i\in\mathcal{N}}\frac{2p_{o}\kappa_{i}}{\left(N-3\right)\left(x_{i}^{\max}\right)^{2}}\)</span>，所以<spanclass="math inline">\(\nabla^2F(x)\)</span>是一个严格对角占优矩阵（严格对角占有矩阵就是对于每一行其对角线上元素的绝对值大于该行中其它所有元素绝对值之和）。所以由[30]中的Gershgorin’sdisctheorem可知<spanclass="math inline">\(\nabla^2F(x)\)</span>是一个正定矩阵。那么凸函数的第四种定义即可知道<spanclass="math inline">\(F(x)\)</span>是一个严格凸函数。证毕。</p><p>所以，这个建模在满足<span class="math inline">\(N &gt; 3,a&lt;\min_{i\in\mathcal{N}}\frac{2p_{o}\kappa_{i}}{\left(N-3\right)\left(x_{i}^{\max}\right)^{2}}\)</span>的时候，就满足<spanclass="math inline">\(F(x)\)</span>是个凸函数，即：<spanclass="math inline">\((x-y)^{T}(\nabla F(x)-{\nabla F(y)})&gt;0, x \ney\)</span> 。又因为<spanclass="math inline">\(\frac{\partial{J}_{i}(x)}{\partialx_{i}}=\frac{\partial{F}(x)}{\partial x_{i}}\)</span>，所以Assumption3(a)满足（这里的<spanclass="math inline">\(F(x)\)</span>其实就是Assumption 3中的<spanclass="math inline">\(\Gamma(x)\)</span>）。</p><p>至此，满足了Assumption 1, 2, 3(a), 4。只要控制好动量系数满足<spanclass="math inline">\(0&lt;\lambda_i&lt;\frac{\sqrt{2}}2\)</span>，以及步长系数<spanclass="math inline">\(\lambda_i\)</span>满足C1-C3，那么这个建模就满足Algorithm1、2的使用条件了。</p><h4 id="numerical-simulations">Numerical simulations</h4><p>下面，分别通过两个实际的数值模拟来验证Algorithm 1、2。</p><p>考虑有8台车，5种不同类型的车分别用不同颜色表示。每台车的具体参数见下表：</p><p><img src="26.png" /></p><p>先来验证Algorithm 1。</p><p><img src="20.png" /></p><p>可以看到，这个图是强连通的且不是一个权重平衡图。通过计算，<spanclass="math inline">\(x^* =[17.6859,17.6859,15.5682,15.5682,12.5484,12.5484, 16.587,16.3481]\)</span>。</p><p>设置步长为<spanclass="math inline">\(\alpha_{i}^{k}=\frac{1}{k^{0.6}}+\frac{1}{k^{1.2}}\)</span>。</p><p>Fig 2是在不同<spanclass="math inline">\(\lambda_i\)</span>下，使用Algorithm 1收敛到<spanclass="math inline">\(x^*\)</span>的迭代次数。</p><p><img src="21.png" /></p><p>可以看到，加了动量项收敛速度确实会快一些。而且动量系数越大速度越快。而且虽然理论要求<spanclass="math inline">\(0&lt;\lambda_i&lt;\frac{\sqrt{2}}2\)</span>，但是<spanclass="math inline">\(\frac{\sqrt{2}}{2} &lt; \lambda_i &lt;1\)</span>时在数值仿真中仍然可以收敛。</p><p>再来验证Algorithm 2。</p><p><img src="22.png" /></p><p>如图Fig. 3，考虑车子的通信图周期性地在Fig. 3中的两个状态中切换。</p><p>Fig. 4是在不同<spanclass="math inline">\(\lambda_i\)</span>下，使用Algorithm 2收敛到<spanclass="math inline">\(x^*\)</span>的迭代次数。</p><p><img src="23.png" /></p><p>可以发现，加了动量项收敛速度确实会快一些。而且动量系数越大速度越快。而且<spanclass="math inline">\(\lambda_i\)</span>也是可以大于<spanclass="math inline">\(\frac{\sqrt{2}}{2}\)</span> ，小于1。</p><p>最后通过数值模拟证明一下<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速率为<spanclass="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span>。</p><p>下面两幅图就是分别用了Algorithm 1和2（<spanclass="math inline">\(\alpha_{i}^{k}=\frac{1}{\sqrt{k}}, \lambda_i =0.6\)</span>）。其中<span class="math inline">\(c_t = \frac{\lnt}{\sqrt{t}}\)</span>。</p><p><img src="24.png" /></p><p><img src="25.png" /></p><p>可以发现，迭代次数越多的时候，<spanclass="math inline">\(q_t\)</span>与<spanclass="math inline">\(c_t\)</span>的比值越接近1。也就通过数值模拟证明了在Algorithm1或2下，它俩收敛到0的速度是一样的。</p><hr /><h3 id="section-6-conclusion">Section 6: Conclusion</h3><p>本文提出了两种算法分别解决固定有向图和时变有向图上的NE寻找问题（且图不需要权重平衡）。这俩算法分别是基于行随机矩阵左特征向量估计法、列随机矩阵推和法。</p><p>而且为了加速算法收敛，算法1、2中均加入了动量项。</p><p>但是算法中采用的是学习率递减到0的方式，这种方式会导致收敛速度较慢，这是本算法的不足。</p><p>最后，本文作者认为，进一步研究“在聚合游戏中采用分布式算法加速寻找NE”将是一件很有趣的课题。</p><hr /><h3 id="personal-summary">Personal summary</h3><h4 id="分布式发展历史">分布式发展历史</h4><p>这篇文章是我在分布式领域看的第一篇文章，所以在这里写点关于分布式算法优化领域的发展过程：</p><blockquote><p>1960s，Everett Dantzig, Wolfe and Benders思考了关于严格凸问题的拉格朗日松弛和线性规范的分解方法。（分解方法是为了将大型优化问题分解为小问题）</p><p>后来，拉格朗日松弛和Hestenes, Powell andMiele发展的增广拉格朗日技术相结合，解决了一些凸但非严格凸的问题。可以理解为现代ADMM算法的前身。</p><p>2000年初，出现了为了适应大规模数据的分布式算法，例如SGD（分布式随机梯度下降）。</p><p>2010年初，为了解决大规模机器学习问题，出现了ADMM（交替方向乘子法）等算法。</p><p>至今，分布式优化算法在算法效率、鲁棒性、以及适应动态和不确定环境方面取得了显著进展。出现了更加高效的分布式在线优化方法，以及能够适应网络拓扑变化和通信不确定性的算法。</p></blockquote><h4 id="文章总结">文章总结</h4><p>本文就是研究了一种特殊的博弈——聚合博弈。</p><p>每个玩家的花费不仅跟自身动作有关，还跟其他人的动作有关。</p><p>本论文设计了两种算法，在作者规定的特定条件下，可以使得每个人的花费尽可能低。分别用于固定有向图和时变有向图。</p><p>文章内容为：算法介绍、算法的正确性证明、收敛速度分析、在PHEVs上的应用。</p><h5 id="算法介绍">算法介绍</h5><p><strong>Algorithm 1</strong> <span class="math display">\[\begin{gathered}x_i^0=x_i^1\in\Omega_i,v_i^1=e_i,\tilde{\sigma}_i^1=\phi_i(x_i^1) \\x_{k+1}=P_{\Omega_{i}}[x_{k}-\alpha_{k}G_{i}(x_{k},\tilde{\sigma}_{k})+\lambda_{i}(x_{k}-x_{k-1})]\\V_{k+1}=AV_k \\\tilde{\sigma}_{k+1}=A\tilde{\sigma}_k+\hat{V}_{k+1}^{-1}\Phi_{k+1}-\hat{V}_{k}^{-1}\Phi_{k}\end{gathered}\]</span> 目的就是为了把<spanclass="math inline">\(x_k\)</span>收敛到<spanclass="math inline">\(x^*\)</span>。使得玩家动作为<spanclass="math inline">\(x^*\)</span>时，每个玩家的花费最少。</p><p>因为动作<span class="math inline">\(x_i\)</span>会对花费<spanclass="math inline">\(J_i\)</span>产生影响，故定义<spanclass="math inline">\(G_i\)</span>为<spanclass="math inline">\(J_i\)</span>对<spanclass="math inline">\(x_i\)</span>求导，用来评估<spanclass="math inline">\(x_i\)</span>对<spanclass="math inline">\(J_i\)</span>产生的影响。</p><p>那么<span class="math inline">\(x_i^{k+1}\)</span>就可以通过<spanclass="math inline">\(x_i^k\)</span>和<spanclass="math inline">\(G_i(x_i^k,\tilde{\sigma}_i^k)\)</span>来更新。</p><p><span class="math inline">\(\tilde{\sigma}_i^k\)</span>是什么？</p><p>需要注意的是，花费函数<spanclass="math inline">\(J_i\)</span>除了要知道<spanclass="math inline">\(i\)</span>玩家的动作<spanclass="math inline">\(x_i\)</span>，还需要知道所有玩家的输出函数<spanclass="math inline">\(\phi_i\)</span>。所以定义<spanclass="math inline">\(\sigma(x)\)</span>为所有玩家的输出函数之和。但是因为每个玩家没有上帝视角，所以<spanclass="math inline">\(\sigma(x)\)</span>是未知的，所以我们可以用<spanclass="math inline">\(\tilde\sigma_i\)</span>来代替<spanclass="math inline">\(\sigma(x)\)</span>。即每个玩家都有一个对<spanclass="math inline">\(\sigma(x)\)</span>的评估函数<spanclass="math inline">\(\tilde\sigma_i\)</span>（这个评估函数也是需要迭代更新的，最终要收敛于<spanclass="math inline">\(\sigma(x)\)</span>）</p><p>至于<spanclass="math inline">\(V_k\)</span>，个人目前觉得是一个辅助矩阵，在迭代更新<spanclass="math inline">\(\tilde\sigma_k\)</span>时会用到。</p><p>至于<spanclass="math inline">\(\lambda_i\)</span>，是动量项，加速收敛用的。</p><p><strong>Algorithm 2</strong> <span class="math display">\[\begin{gathered}\\x_i^0=x_i^1\in\Omega_i,y_i^1=1,\tilde{\sigma}_i^1=\phi_i(x_i^1) \\w_{k+1}=A\left(k\right)\tilde{\sigma}_{k} \\y_{k+1}=A\left(k\right)y_{k} \\z_i^{k+1}=\frac{w_i^{k+1}}{y_i^{k+1}} \\x_{k+1}=P_{\Omega_i}\left[x_k-\alpha_kG_i(x_k,Nz_{k+1})+\lambda_i(x_k-x_{k-1})\right]\\\begin{aligned}\tilde{\sigma}_{k+1}=w_{k+1}+\phi_i\left(x_{k+1}\right)-\phi_i\left(x_k\right)\end{aligned}\end{gathered}\]</span> w是多余的，可以把<spanclass="math inline">\(w_{k+1}\)</span>那里合并到最后一个公式。</p><p>本质就是推和协议。y是权重，<spanclass="math inline">\(\sigma\)</span>是基于权重的平均值。</p><p>经过迭代后，<span class="math inline">\(z =\frac{\sigma}{y}\)</span>就是<spanclass="math inline">\(\phi\)</span>的平均值。</p><p>但是因为<spanclass="math inline">\(\phi\)</span>初值不是定值，所以最后公式倒数俩项就是动态更新<spanclass="math inline">\(\sigma\)</span></p><h5 id="算法正确性证明">算法正确性证明</h5><p>本文大篇幅都是在证这个。</p><p>本质就是证<span class="math inline">\(x_k\)</span>最终收敛于<spanclass="math inline">\(x^*\)</span>。即<span class="math inline">\(\|x_k- x^*\|^2 \rightarrow 0\)</span>。</p><p>具体内容过多不好总结 ，具体看下文证明。</p><p>证明过程主要用到了：矩阵范数性质、范数的放缩、Cauchy-Schwarz。</p><h5 id="收敛速度分析">收敛速度分析</h5><p>在作者规定的更多特定条件下（条件比它提出的俩算法更严格），Algorithm1、2的收敛速度跟<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速度一样： <spanclass="math display">\[q_t=\frac{\sum\limits_{k=1}^t\alpha_k\|x_k-x^*\|^2}{\sum\limits_{k=1}^t\alpha_k}\]</span> 而<spanclass="math inline">\(\{q_t\}\)</span>收敛到0的速度经证明为：<spanclass="math inline">\(O(\frac{\ln t}{\sqrt{t}})\)</span></p><h5 id="在phevs上的应用">在PHEVs上的应用</h5><p>这个部分论文中也没给出实现代码，只给出了数值模拟的结果和效果图。所以我自己复现了一遍论文的算法。</p><p><strong>Algorithm 1的数值仿真</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Algorithm 1的数值仿真</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">n = <span class="number">8</span></span><br><span class="line">x_best = [-<span class="number">1</span>, <span class="number">17.6859</span>, <span class="number">17.6859</span>, <span class="number">15.5682</span>, <span class="number">15.5682</span>, <span class="number">12.5484</span>, <span class="number">12.5484</span>, <span class="number">16.587</span>, <span class="number">16.3481</span>]</span><br><span class="line">x_min = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">x_max = [-<span class="number">1</span>, <span class="number">27.5</span>, <span class="number">27.5</span>, <span class="number">34.2</span>, <span class="number">34.2</span>, <span class="number">40.6</span>, <span class="number">40.6</span>, <span class="number">28.8</span>, <span class="number">35.7</span>]</span><br><span class="line">x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">p_0 = <span class="number">5.6</span></span><br><span class="line">a = <span class="number">0.004</span></span><br><span class="line">b = <span class="number">0.1</span></span><br><span class="line">k = [-<span class="number">1</span>, <span class="number">4.6</span>, <span class="number">4.6</span>, <span class="number">3.7</span>, <span class="number">3.7</span>, <span class="number">3.4</span>, <span class="number">3.4</span>, <span class="number">4.0</span>, <span class="number">3.9</span>]</span><br><span class="line">d = [-<span class="number">1</span>, <span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>]</span><br><span class="line">alpha = <span class="number">2</span></span><br><span class="line">A = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">1</span> / <span class="number">3</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>]</span><br><span class="line">]   <span class="comment"># 这里因为论文中没明确指定具体的值，只说是行随机，所以对于每行有值的位置我直接平均分了</span></span><br><span class="line">v = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">]</span><br><span class="line">sigma = [-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    sigma.append(x[i])</span><br><span class="line"></span><br><span class="line">xx = copy.deepcopy(x)</span><br><span class="line">xxx = copy.deepcopy(x)</span><br><span class="line">vv = copy.deepcopy(v)</span><br><span class="line">ssigma = copy.deepcopy(sigma)</span><br><span class="line"></span><br><span class="line"><span class="comment">#-----------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">i, x, sigma</span>):</span><br><span class="line">    <span class="keyword">return</span> a * (sigma + x) + b  - <span class="number">2</span> * p_0 * k[i] / x_max[i] * (<span class="number">1</span> - x / x_max[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_x</span>(<span class="params">i, vec</span>):</span><br><span class="line">    x[i] = xx[i] - alpha * G(i, xx[i], ssigma[i]) + vec * (xx[i] - xxx[i])</span><br><span class="line">    <span class="keyword">if</span> x[i] &lt; x_min[i]: x[i] = x_min[i]</span><br><span class="line">    <span class="keyword">if</span> x[i] &gt; x_max[i]: x[i] = x_max[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_v</span>(<span class="params">i</span>):</span><br><span class="line">    vvv = copy.deepcopy(vv)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            vvv[j][l] *= A[i][j]</span><br><span class="line">    res = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> += vvv[l][j]</span><br><span class="line">        res.append(<span class="built_in">sum</span>)</span><br><span class="line">    v[i] = res</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_sigma</span>(<span class="params">i</span>):</span><br><span class="line">    add_1 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        add_1 += ssigma[j] * A[i][j]</span><br><span class="line">    add_2 = x[i] / v[i][i]</span><br><span class="line">    add_3 = xx[i] / vv[i][i]</span><br><span class="line">    sigma[i] = add_1 + add_2 - add_3</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    <span class="keyword">global</span> x, alpha, v, sigma, xx, xxx, vv, ssigma</span><br><span class="line">    x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">    alpha = <span class="number">2</span></span><br><span class="line">    v = [</span><br><span class="line">        [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">    ]</span><br><span class="line">    sigma = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        sigma.append(x[i])</span><br><span class="line">    xx = copy.deepcopy(x)</span><br><span class="line">    xxx = copy.deepcopy(x)</span><br><span class="line">    vv = copy.deepcopy(v)</span><br><span class="line">    ssigma = copy.deepcopy(sigma)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm_1</span>(<span class="params">iter_num, vec</span>):</span><br><span class="line">    <span class="keyword">global</span> xx, xxx, vv, ssigma, alpha</span><br><span class="line">    init()</span><br><span class="line">    res = []</span><br><span class="line">    sum_1 = <span class="number">0</span></span><br><span class="line">    sum_2 = <span class="number">0</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 计算差距值</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> += (x[i] - x_best[i]) ** <span class="number">2</span></span><br><span class="line">        res.append(<span class="built_in">sum</span> ** <span class="number">0.5</span>)</span><br><span class="line">        <span class="comment"># 计算qt的分子（这里的alpha注意步长设置为1/sqrt(j)）</span></span><br><span class="line">        sum_1 += (<span class="number">1</span> / j ** <span class="number">0.5</span>) * <span class="built_in">sum</span></span><br><span class="line">        sum_2 += (<span class="number">1</span> / j ** <span class="number">0.5</span>)</span><br><span class="line">        q.append(sum_1 / sum_2)</span><br><span class="line">        <span class="comment"># Algorithm 1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            upd_x(i, vec)</span><br><span class="line">            upd_v(i)</span><br><span class="line">            upd_sigma(i)</span><br><span class="line">        xxx = copy.deepcopy(xx)</span><br><span class="line">        xx = copy.deepcopy(x)</span><br><span class="line">        vv = copy.deepcopy(v)</span><br><span class="line">        ssigma = copy.deepcopy(sigma)</span><br><span class="line">        alpha = <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">0.6</span> + <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">1.2</span></span><br><span class="line">    <span class="keyword">return</span> res, q</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results</span>(<span class="params">iter_num, vecs, vecs_name</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, iter_num):</span><br><span class="line">        x.append(i)</span><br><span class="line">        y.append(i)</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(vecs)):</span><br><span class="line">        y = algorithm_1(iter_num, vecs[T])[<span class="number">0</span>]</span><br><span class="line">        plt.plot(x, y, label=vecs_name[T])</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;Iterations k&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;||xk - x*||&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        <span class="built_in">print</span>(vecs_name[T], end=<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span>%y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">vecs = [<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>]</span><br><span class="line">vecs_name = [<span class="string">&#x27;vec=0.0&#x27;</span>, <span class="string">&#x27;vec=0.2&#x27;</span>, <span class="string">&#x27;vec=0.4&#x27;</span>, <span class="string">&#x27;vec=0.6&#x27;</span>, <span class="string">&#x27;vec=0.8&#x27;</span>]</span><br><span class="line">plot_results(<span class="number">1000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">2000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">3000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">4000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">5000</span>, vecs, vecs_name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results_convergence_1</span>(<span class="params">iter_num</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    z = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, iter_num + <span class="number">1</span> + <span class="number">1</span>): <span class="comment"># 第一项ct是0，所以从第二项开始</span></span><br><span class="line">        x.append(i)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        z.append(math.log(i) / (i ** <span class="number">0.5</span>))</span><br><span class="line">    y = algorithm_1(iter_num, <span class="number">0.6</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># qt的图像</span></span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        经过调整参数为(x_min + x_max) / 2, 初始差距值已经比论文还低一些</span></span><br><span class="line"><span class="string">        但是qt始终无法收敛到0, 这是为什么呢?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        当迭代次数很大时, 分子中的差距值已经很小, 所以导致分子比分母小许多, 所以假设论文中的迭代次数是8w次, 我比它多10倍,</span></span><br><span class="line"><span class="string">        比它多那么多后, 即使我刚开始迭代时的分子很大, 分子也会被后面10倍迭代次数的分母追上来。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这是用来画qt / ct的图像</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num):</span><br><span class="line">        y[i] = y[i] / z[i]</span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x[<span class="number">1</span>:], y[<span class="number">1</span>:])</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;qt / ct&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_results_convergence_1(<span class="number">80000</span>)</span><br></pre></td></tr></table></figure><p>效果图如下：（最后一张图，第一行数字是qt的收敛值，第二行数字是qt/ct的收敛值）</p><p><img src="27.png" /></p><p><strong>Algorithm 2的数值仿真</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Algorithm 2的数值仿真</span></span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line">n = <span class="number">8</span></span><br><span class="line">x_best = [-<span class="number">1</span>, <span class="number">17.68591179305579</span>, <span class="number">17.68591178894396</span>, <span class="number">15.568177079669734</span>, <span class="number">15.568176869116588</span>,</span><br><span class="line">            <span class="number">12.54841009221712</span>, <span class="number">12.548433755340588</span>, <span class="number">16.50869895275612</span>, <span class="number">16.348072510972873</span>]</span><br><span class="line">x_min = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">x_max = [-<span class="number">1</span>, <span class="number">27.5</span>, <span class="number">27.5</span>, <span class="number">34.2</span>, <span class="number">34.2</span>, <span class="number">40.6</span>, <span class="number">40.6</span>, <span class="number">28.8</span>, <span class="number">35.7</span>]</span><br><span class="line">x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">p_0 = <span class="number">5.6</span></span><br><span class="line">a = <span class="number">0.004</span></span><br><span class="line">b = <span class="number">0.1</span></span><br><span class="line">k = [-<span class="number">1</span>, <span class="number">4.6</span>, <span class="number">4.6</span>, <span class="number">3.7</span>, <span class="number">3.7</span>, <span class="number">3.4</span>, <span class="number">3.4</span>, <span class="number">4.0</span>, <span class="number">3.9</span>]</span><br><span class="line">d = [-<span class="number">1</span>, <span class="number">0.7</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.8</span>, <span class="number">0.6</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>]</span><br><span class="line">alpha = <span class="number">2</span></span><br><span class="line">A_1 = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">]</span><br><span class="line">A_2 = [</span><br><span class="line">    [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> / <span class="number">2</span>],</span><br><span class="line">]</span><br><span class="line">A = copy.deepcopy(A_1)</span><br><span class="line">sigma = [-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    sigma.append(x[i])</span><br><span class="line">w = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">y = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">z = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">xx = copy.deepcopy(x)</span><br><span class="line">xxx = copy.deepcopy(x)</span><br><span class="line">ssigma = copy.deepcopy(sigma)</span><br><span class="line">yy = copy.deepcopy(y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    <span class="keyword">global</span> x, alpha, sigma, w, y, z, xx, xxx, ssigma, yy</span><br><span class="line">    x = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        x[i] = (x_min[i] + x_max[i]) / <span class="number">2</span></span><br><span class="line">    alpha = <span class="number">2</span></span><br><span class="line">    sigma = [-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        sigma.append(x[i])</span><br><span class="line">    w = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    y = [-<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">    z = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    xx = copy.deepcopy(x)</span><br><span class="line">    xxx = copy.deepcopy(x)</span><br><span class="line">    ssigma = copy.deepcopy(sigma)</span><br><span class="line">    yy = copy.deepcopy(y)</span><br><span class="line"></span><br><span class="line"><span class="comment">#----------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_w</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">sum</span> += A[i][j] * ssigma[j]</span><br><span class="line">    w[i] = <span class="built_in">sum</span>    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_y</span>(<span class="params">i</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">sum</span> += A[i][j] * yy[j]</span><br><span class="line">    y[i] = <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_z</span>(<span class="params">i</span>):</span><br><span class="line">    z[i] = w[i] / y[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">G</span>(<span class="params">i, x, sigma</span>):</span><br><span class="line">    <span class="keyword">return</span> a * (sigma + x) + b  - <span class="number">2</span> * p_0 * k[i] / x_max[i] * (<span class="number">1</span> - x / x_max[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_x</span>(<span class="params">i, vec</span>):</span><br><span class="line">    x[i] = xx[i] - alpha * G(i, xx[i], n * z[i]) + vec * (xx[i] - xxx[i])</span><br><span class="line">    <span class="keyword">if</span> x[i] &lt; x_min[i]: x[i] = x_min[i]</span><br><span class="line">    <span class="keyword">if</span> x[i] &gt; x_max[i]: x[i] = x_max[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">upd_sigma</span>(<span class="params">i</span>):</span><br><span class="line">    sigma[i] = w[i] + x[i] - xx[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">algorithm_2</span>(<span class="params">iter_num, vec</span>):</span><br><span class="line">    <span class="keyword">global</span> A, A_1, A_2, w, ssigma, y, yy, z, x, xx, alpha, xxx, sigma</span><br><span class="line">    init()</span><br><span class="line">    res = []</span><br><span class="line">    sum_1 = <span class="number">0</span></span><br><span class="line">    sum_2 = <span class="number">0</span></span><br><span class="line">    q = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 计算差距</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">sum</span> += (x[i] - x_best[i]) ** <span class="number">2</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> ** (<span class="number">0.5</span>)</span><br><span class="line">        res.append(<span class="built_in">sum</span>)</span><br><span class="line">        <span class="comment"># 计算qt的分子（这里的alpha注意步长设置为1/sqrt(j)）</span></span><br><span class="line">        sum_1 += (<span class="number">1</span> / j ** <span class="number">0.5</span>) * <span class="built_in">sum</span> * <span class="built_in">sum</span></span><br><span class="line">        sum_2 += (<span class="number">1</span> / j ** <span class="number">0.5</span>)</span><br><span class="line">        q.append(sum_1 / sum_2)</span><br><span class="line">        <span class="comment"># 选择矩阵</span></span><br><span class="line">        <span class="keyword">if</span> j % <span class="number">2</span>: A = copy.deepcopy(A_1)</span><br><span class="line">        <span class="keyword">else</span>: A = copy.deepcopy(A_2)</span><br><span class="line">        <span class="comment"># Algorithm 2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            upd_w(i)</span><br><span class="line">            upd_y(i)</span><br><span class="line">            upd_z(i)</span><br><span class="line">            upd_x(i, vec)</span><br><span class="line">            upd_sigma(i)</span><br><span class="line">        <span class="comment"># 更新状态</span></span><br><span class="line">        xxx = copy.deepcopy(xx)</span><br><span class="line">        xx = copy.deepcopy(x)</span><br><span class="line">        yy = copy.deepcopy(y)</span><br><span class="line">        ssigma = copy.deepcopy(sigma)</span><br><span class="line">        alpha = <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">0.6</span> + <span class="number">1</span> / (j + <span class="number">1</span>) ** <span class="number">1.2</span></span><br><span class="line">    <span class="keyword">return</span> res, q</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results</span>(<span class="params">iter_num, vecs, vecs_name</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, iter_num):</span><br><span class="line">        x.append(i)</span><br><span class="line">        y.append(i)</span><br><span class="line">    <span class="keyword">for</span> T <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(vecs)):</span><br><span class="line">        y = algorithm_2(iter_num, vecs[T])[<span class="number">0</span>]</span><br><span class="line">        plt.plot(x, y, label=vecs_name[T])</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;Iterations k&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;||xk - x*||&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        <span class="built_in">print</span>(vecs_name[T], end=<span class="string">&#x27;: &#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%.2f&#x27;</span>%y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line">vecs = [<span class="number">0.0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>]</span><br><span class="line">vecs_name = [<span class="string">&#x27;vec=0.0&#x27;</span>, <span class="string">&#x27;vec=0.2&#x27;</span>, <span class="string">&#x27;vec=0.4&#x27;</span>, <span class="string">&#x27;vec=0.6&#x27;</span>, <span class="string">&#x27;vec=0.8&#x27;</span>]</span><br><span class="line">plot_results(<span class="number">1000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">2000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">3000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">4000</span>, vecs, vecs_name)</span><br><span class="line">plot_results(<span class="number">5000</span>, vecs, vecs_name)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_results_convergence_2</span>(<span class="params">iter_num</span>):</span><br><span class="line">    x = []</span><br><span class="line">    y = []</span><br><span class="line">    z = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, iter_num + <span class="number">1</span> + <span class="number">1</span>): <span class="comment"># 第一项ct是0，所以从第二项开始</span></span><br><span class="line">        x.append(i)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num + <span class="number">1</span>):</span><br><span class="line">        z.append(math.log(i) / (i ** <span class="number">0.5</span>))</span><br><span class="line">    y = algorithm_2(iter_num, <span class="number">0.6</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># qt的图像</span></span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x, y)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        经过调整参数为(x_min + x_max) / 2, 初始差距值已经比论文还低一些</span></span><br><span class="line"><span class="string">        但是qt始终无法收敛到0, 这是为什么呢?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        当迭代次数很大时, 分子中的差距值已经很小, 所以导致分子比分母小许多, 所以假设论文中的迭代次数是8w次, 我比它多10倍,</span></span><br><span class="line"><span class="string">        比它多那么多后, 即使我刚开始迭代时的分子很大, 分子也会被后面10倍迭代次数的分母追上来。</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这是用来画qt / ct的图像</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, iter_num):</span><br><span class="line">        y[i] = y[i] / z[i]</span><br><span class="line">    <span class="built_in">print</span>(y[iter_num - <span class="number">1</span>])</span><br><span class="line">    plt.plot(x[<span class="number">1</span>:], y[<span class="number">1</span>:])</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;qt / ct&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">plot_results_convergence_2(<span class="number">80000</span>)</span><br></pre></td></tr></table></figure><p>效果图如下：（最后一张图，第一行数字是qt的收敛值，第二行数字是qt/ct的收敛值）</p><p><img src="28.png" /></p><hr /><p>这篇blog发表于2023.10.16，现在是2023.12.4，看了2个月，目前算是告一段落了。</p><p>分布式领域读的第一篇论文，挺有趣的，算是跨过了一道入门槛。</p><p>接下来阅读论文的速度就要加快了。同时要去原理上去思考为什么这样做以及还可以怎样去优化。</p><p>假如您正在阅读这篇blog，如发现错误，恳请在评论区中指出。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;标题全称为：Distributed Nash Equilibrium Seeking for Aggregative
Games With Directed Communication Graphs&lt;/p&gt;
&lt;p&gt;中文翻译为：在使用有向图结构的聚合博弈中寻找离散式纳什均衡&lt;/p&gt;</summary>
    
    
    
    <category term="1. 论文" scheme="http://example.com/categories/1-%E8%AE%BA%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="http://example.com/2023/10/14/Linux%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/10/14/Linux%E5%9F%BA%E7%A1%80/</id>
    <published>2023-10-14T10:08:55.000Z</published>
    <updated>2024-03-04T16:21:49.883Z</updated>
    
    <content type="html"><![CDATA[<ul><li>这篇文章涉及到的都是本人用到的知识，没用到的我都没写。</li><li>学会这些算是一个计算机学生的基本素养吧。</li></ul><span id="more"></span><ul><li>比如以后进厂打工可嫩会接触到Linux环境，那么<strong>tmux、nano、Linux常用命令</strong>，总得会吧。</li><li>然后工作或者租算力服务器或者连学校服务器，可能会用到<strong>SSH</strong>吧，所以ssh也总得会吧。</li><li>然后因为自己平时也可能会写工程，所以<strong>Git、类github软件</strong>总得会用吧。</li><li>然后可能偶尔在Linux或者Win下写点脚本来批处理文件，所以<strong>shell语法</strong>也得会一点吧。</li><li>最后是docker，到时候别人传一个docker给你，你都不会配环境，这说不过去，所以<strong>docker</strong>也得会用吧。</li></ul><hr /><h3 id="tmux">tmux</h3><p>学这个是为了可以在一个终端里开多个屏来工作，提高生产效率。</p><ul><li>tmux ls：显示所有session列表</li><li>tmux attach -t [id]：进入到某个session中</li><li>tmux：新建一个session并进入</li><li>ctrl + b, s：显示session、window、pane树形结构</li><li>ctrl + d：删除当前pane/window/session</li><li>ctrl + b, d：在不删除session的前提下退出tmux</li><li>ctrl + b, %：左右分屏</li><li>ctrl + b, "：上下分屏</li><li>ctrl + b, ↑←↓→：在pane中切换</li><li>ctrl + b不松开 + ↑←↓→：调整当前pane大小</li><li>ctrl +b，[：进入复制模式，在此模式下按上下左右可控制光标移动。按q退出该模式</li></ul><h3 id="nanovim">nano/vim</h3><p>学这个是为了在Linux系统下处理文本。本质上就是学如何用记事本。</p><p>关于vim我能不用尽量不用，但是迫不得已的时候使用的时候还是要会它的基本操作。按Esc回到命令模式，命令模式下dd删除本行，:wq保存退出，:q!强制退出，i进入编辑模式。下面是关于nano的操作</p><p>另外，在/etc/nanorc里可以配置nano</p><ul><li>ctrl + x：退出</li><li>ctrl + o：保存</li><li>ctrl + k：剪切</li><li>ctrl + u：粘贴</li><li>alt +6：复制</li><li>alt + u：撤销</li><li>alt +a：开启选中模式（注意这个快捷键与微信截图冲突了，记得把vx的改了）</li><li>alt + m：开始鼠标模式</li><li>alt + shift + 3：开启行号</li><li>ctrl + a：回到行首；ctrl + e：回到行末；alt + /：跳转到文末；alt +：跳转到开头</li><li>ctrl + shift + v：将windows文本复制到nano/vim/shell里</li></ul><hr /><h3 id="linux常用命令">Linux常用命令</h3><h4 id="系统状况">系统状况</h4><ul><li>top：查看所有进程的信息<ul><li>输入M：按使用内存排序</li><li>输入P：按使用CPU排序</li><li>输入q：退出</li></ul></li><li>df -h：查看硬盘使用情况</li><li>free -h：查看内存使用情况</li><li>du -sh：查看当前目录所占硬盘空间<ul><li>du -sh 文件名：查看当前目录下某文件所占硬盘空间</li></ul></li><li>ps aux：查看所有进程</li><li>kill -9 pid：杀死编号为pid的进程</li><li>ping www.baidu.com：检查是否联网</li></ul><h4 id="文件检索">文件检索</h4><ul><li>find path -name "filename"：在某个路径下搜索目标文件</li><li>grepxxx：从stdin中读入若干行参数，如果某行包括xxx，则输出该行，否则忽略该行</li><li>xargs：从stdin接受数据，并以空格分割形式转换为命令行参数<ul><li>例如，find . -name "*.cpp" | xargscat，读取当前目录下所有.cpp文件的内容</li><li>find . -name "*.cp" | xargs cat | grep"cout"：找出当前目录下的.cpp文件中所有包含cout的行</li></ul></li><li>wc -l filename：统计文件的行数<ul><li>wc既可以接收文件名参数，也可以从stdin读入内容</li><li>find . -name "*.cpp" | wc -l：统计当前目录下有多少个.cpp文件</li><li>find . -name "*.cpp" | xargs wc-l：统计当前目录下每个.cpp文件有多少行</li></ul></li></ul><h4 id="工具">工具</h4><ul><li>|：管道符<ul><li>将前一个command的<strong>stdout</strong>重定向到后一个command的<strong>stdin</strong></li><li>在文件检索中经常用到</li></ul></li><li>history：展示历史操作<ul><li>history 数字：展示最后num条操作</li></ul></li><li>tar -zcvf xxx.tar.gz 文件1 文件2：压缩</li><li>tar -zxvf xxx.tar.gz：解压</li><li>diff xxx yyy：比较xxx与yyy的不同点</li><li>sudo apt update：更新可用软件包列表</li><li>sudo apt install 包名：安装</li></ul><hr /><h3 id="ssh">ssh</h3><p>这个ssh以后自己租服务器的时候用得上。就是学会如何登录，以及主机和服务器之间如何传文件即可。</p><ul><li><p>ssh user@hostname：登录</p></li><li><p>在~/.ssh/config里写配置文件，格式如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host name1</span><br><span class="line">    HostName IP地址</span><br><span class="line">    User 用户名</span><br></pre></td></tr></table></figure><p>那么在下次使用服务器时，就可以ssh name1来登录</p></li><li><p>ssh-keygen：创建密钥（密钥文件存储在~/.ssh/下）</p></li><li><p>ssh-copy-id服务器别名：向服务器添加自己的公钥，这样以后登录服务器可以免密登录</p></li><li><p>scp source destinatino：跟cp一样，本机与服务器传文件</p><ul><li>例如scp /etc/nanorc 服务器别名:/etc/nanorc</li><li>注意在传文件夹时要加-r，而且-r必须紧跟在scp后</li></ul></li></ul><hr /><h3 id="git">git</h3><ul><li>git config --global user.name xxx：设置全局用户名</li><li>git config --global user.email xxx@xxx.com：设置全局邮箱地址</li><li>上述信息都会记录在~/.gitconfig文件中</li><li>git init：将当前目录配置成git仓库，信息记录在.git文件夹中</li><li>git status：查看仓库状态</li><li>git add xx：将xx文件添加到暂存区<ul><li>git add .：将全部改动添加到暂存区</li></ul></li><li>git rm --cached xx：将xx改动从暂存区中移出</li><li>git commit -m "备注信息"：将暂存区中的内容提交到当前分支</li><li>git log：查看当前分支从根到HEAD指针的所有版本<ul><li>git log --oneline：简洁显示</li></ul></li><li>git relog：查看HEAD指针的移动历史</li><li>git reset --hard HEAD~：回滚到上一个版本<ul><li>git reset --hard HEAD~~：回滚到上两个版本</li><li>git reset --hard 版本号(7位hash值)：回滚到目标版本</li></ul></li><li>git remote add origingit@git.acwing.com:Error666/test.git：将本地仓库与acgit绑定</li><li>git push -u origin master：将本地仓库推送到acgit上<ul><li>第一次需要向上面这么写，至于用master还是main，用gitbranch查看本地分支。是什么就用什么。以后推送直接git push即可</li></ul></li><li>更多有关git的命令：<ahref="https://www.acwing.com/file_system/file/content/whole/index/content/2932078/">传送门</a></li></ul><hr /><h3 id="shell">shell</h3><p>shell语言主要学来用来批处理文件的，比如建立多个文件夹，改名多个文件夹啥的。学完后在window里也用得上。比如打竞赛出题的数据的时候，就可以用shell写个脚本统一创建文件/改名。在windows里用git的gitbash运行脚本即可。</p><h4 id="基本">基本</h4><ul><li>su - root/zhou：换用户</li><li>mkdir/touch/cp/mv/rm/cat：基本操作</li><li>chmod +x+x+x[filename]：给权限（3个x对应user,group,others，如果只给user写1个x即可）<ul><li>chmod +x dirname -R：递归的给权限</li></ul></li><li>.sh为shell脚本后缀，在文件里第一行应为#!/bin/bash。执行方式有两种，bash filename.sh或者./filename.sh</li><li>echo：输出<ul><li>加参数-e：可在输出内容中识别转移字符，例如echo -e "hello"。</li><li>加参数echo默认会输出换行，在结尾处加（要加-e）</li><li>echo ${a[@]}：输出数组中的数，以一行形式</li><li>echo ${a[@]:1:n}：输出数组下标为1 ~ n的数</li></ul></li><li>“”：可将有空格的名字看作一个整体</li></ul><h4 id="变量">变量</h4><ul><li>变量=xxx：定义变量</li><li>${变量}：使用变量</li><li>$0, $1, $2, ...：为传入的参数（$0为文件名）</li><li>$#：传入的参数个数</li><li>$?：返回上一条command的exit code</li><li>`command`：返回command的stdout（不支持嵌套）</li><li>$(command)：作用同``，但是支持嵌套</li></ul><h4 id="运算">运算</h4><ul><li>expr $a +/- $b：进行a±b的运算</li><li>expr $a \* $b：进行a*b的运算</li><li>expr $a / $b：进行a/b的运算</li><li>expr $a % $b：进行a%b的运算</li><li>()可以改变优先级，但要加\转义，同时记得打括号</li></ul><h4 id="循环">循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span>法一</span></span><br><span class="line">for var in val1 val2 val3</span><br><span class="line">do</span><br><span class="line">  ....</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span>法二</span></span><br><span class="line">for var in `seq 1 10`</span><br><span class="line">do</span><br><span class="line">  ...</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span>法三</span></span><br><span class="line">for var in &#123;1..10&#125;/&#123;10..1&#125;/&#123;a..z&#125;/&#123;z..a&#125;    # 这种写法&#123;&#125;里面只能是常量</span><br><span class="line">do</span><br><span class="line">  ...</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">for</span>法四（跟C++一样，只不过多了层括号）</span></span><br><span class="line">for ((expreesion; condition; expression))</span><br><span class="line">do</span><br><span class="line">  ...</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">while</span></span></span><br><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">  ...</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">break</span>/continue</span></span><br><span class="line">跟C++一样</span><br></pre></td></tr></table></figure><h4 id="判断">判断</h4><ul><li>shell里的if看的是exit code的状态。如果exitcode为0，则为真。否则为假</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="keyword">if</span></span></span><br><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">  ...</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">if-else</span></span><br><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">  ...</span><br><span class="line">else</span><br><span class="line">  ...</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">if-elif-else</span></span><br><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">  ...</span><br><span class="line">elif</span><br><span class="line">then</span><br><span class="line">  ...</span><br><span class="line">else</span><br><span class="line">  ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h4 id="test">test/[ ]</h4><ul><li>[ $a -[参数] $b ]：整数a与b的比较<ul><li>-eq：是否相等（equal）</li><li>-ne：是否不相等（not equal）</li><li>-gt：是否大于（greater than）</li><li>-ge：是否大于等于（greater than or equal）</li><li>-lt：是否小于（less than）</li><li>-le：是否小于等于（less than or equal）</li></ul></li><li>[ -[参数] filename ]：文件类型判断<ul><li>-e：文件是否存在</li><li>-f：是否为文件</li><li>-d：是否为目录</li></ul></li><li>[ -[参数] filename ]：文件权限判断<ul><li>-r：是否可读</li><li>-w：是否可写</li><li>-x：是否可执行</li><li>-s：是否为非空文件</li></ul></li><li>可用&amp;&amp;、||、!拼接</li></ul><h4 id="函数">函数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fun_name() &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用方式：fun_name val1 val2 val3</li><li>函数内部默认参数从1开始，没有0，即$1</li><li>在函数里面return的是exit code。echo的是stdout</li><li>不管在函数还是函数外部直接使用的变量默认都是全局变量，所以若想使用局部变量，需要用local关键字声明</li></ul><h4 id="文件重定向">文件重定向</h4><ul><li>&gt;：将原本输出到stdout的内容以覆盖形式输出到指定文件</li><li>&lt;：原本从stdin读入数据，现在从指定文件中读入数据</li><li>&gt;&gt;：将原本输出到stdout的内容以追加形式输出到指定文件</li></ul><h4 id="其它">其它</h4><ul><li>导入外部脚本：sourcefilename（本质就是将外部脚本粘贴复制到本脚本中）</li><li>更多shell语法：<ahref="https://www.acwing.com/file_system/file/content/whole/index/content/2855883/">传送门</a></li></ul><hr /><h3 id="docker">docker</h3><p>首先要安装docker，搜docker ubuntu，进官网，按照官网指示装就行了。</p><p>然后如果在用docker命令时发现每次都要加sudo权限，可以将当前用户加入到docker用户组中：sudousermod -aG docker $USER。然后退出服务器，重进，即可解决这个问题</p><p>记住，docker中区分image可以用id或者名字（image名字是name:版本号）。区分container可以用id或者name。</p><h4 id="镜像">镜像</h4><ul><li>docker pull 名称：拉取一个镜像</li><li>docker images：列出本地所有镜像</li><li>docker rmi id/名字：删除某个镜像</li><li>docker save -o xxx.tar id/名字：把某个镜像导出</li><li>docker load -i xxx.tar：导入某个镜像</li></ul><h4 id="容器">容器</h4><ul><li>docker ps -a：查看本地的所有容器</li><li>docker create -it 镜像id/名字：利用某镜像创建一个容器</li><li>docker rm id/name：删除某容器</li><li>docker rename name1 name2：重命名容器</li><li>docker start id/name：启动某容器</li><li>docker stop id/name：停止某容器</li><li>docker attach id/name：进入某容器<ul><li>ctrl + d：退出并停止该容器</li><li>ctrl + p, ctrl + q：退出该容器但不停止它</li></ul></li></ul><hr /><h3 id="租服务器-thrift">租服务器 &amp; thrift</h3><p>待填</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;这篇文章涉及到的都是本人用到的知识，没用到的我都没写。&lt;/li&gt;
&lt;li&gt;学会这些算是一个计算机学生的基本素养吧。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="2. 技能栈" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/"/>
    
    <category term="Linux" scheme="http://example.com/categories/2-%E6%8A%80%E8%83%BD%E6%A0%88/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>数字逻辑自学笔记</title>
    <link href="http://example.com/2023/10/06/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/10/06/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2023-10-06T08:57:58.000Z</published>
    <updated>2024-02-23T11:15:01.424Z</updated>
    
    <content type="html"><![CDATA[<p>写于2023/10/6，这门课其实还是有点意思的。但是上个月身体原因一直在关心我自己的身体，所以这门课我全翘掉了，一点没听。现在马上就要实验课了，于是打算在国庆的末尾把这门课学了。目的是能做出几个组合逻辑电路的实验项目。</p><span id="more"></span><p>upd: (2024/1/14)：这门课满绩了，考试很简单，都是笔记里的东西。</p><hr /><p>自学参考的内容为老师ppt、各种网上博客。</p><p>学完后打算去刷题巩固一下，刷题打算在一个up主视频里刷：<ahref="https://www.bilibili.com/video/BV1H54y1k7kM?p=1&amp;vd_source=2501060da9b4bef86e2b8ec8a8d880b5">传送门</a></p><p>最后，如果有朋友打算认真看这篇Blog进行学习的话，为了更好的阅读体验建议开梯子，因为本文有许多图片和一个视频。（存储在github中）</p><p>先放一张各种门的符号图，后面忘了的话可以参考：</p><p><img src="1.png" /></p><p><img src="2.png" /></p><h3 id="一.-组合逻辑电路1">一. 组合逻辑电路(1)</h3><h4 id="概述">1.1. 概述</h4><p>电路分为组合逻辑电路和时序逻辑电路。差别就是组合逻辑电路无记忆功能，时序逻辑电路有。</p><p>描述电路的逻辑功能有以下几种形式：</p><ol type="1"><li>语言描述</li><li>电路图</li><li>逻辑表达式，即y = f(a1, a2, a3, ..., an)</li><li>真值表</li><li>卡诺图</li><li>波形图</li></ol><h4 id="组合逻辑电路的分析-和-逻辑函数的设计方法">1.2.组合逻辑电路的分析 和 逻辑函数的设计方法</h4><ul><li><p><strong>分析</strong>：</p><ul><li><p>即给你一个电路，让你告诉我这个电路是干啥用的。</p></li><li><p>分析一个组合逻辑电路的固定套路很简单：</p><ol type="1"><li>一层一层写出逻辑表达式</li><li>对最后得到的逻辑表达式进行化简<ul><li>化简手段1：卡诺图</li><li>化简手段2：<span class="math inline">\(A + A \cdot B = A 或 A \cdot(A + B) = A\)</span></li><li>化简手段3：<span class="math inline">\(A + \overline{A}B = A + B 或A \cdot (\overline{A} + B) = A \cdot B\)</span></li><li>化简手段4：<span class="math inline">\(\overline{A}\overline{C} +A\overline{B} + \overline{B}\overline{C} = \overline{A}\overline{C} +A\overline{B}\)</span>（对于<spanclass="math inline">\(\overline{B}\overline{C}\)</span>添项即可证明）</li><li>化简手段5：<span class="math inline">\(A \oplus B = \overline{A}B +A\overline{B}\)</span></li><li>化简手段6：<span class="math inline">\(A \odot B = (\overline{A} +B)(A + \overline{B})\)</span></li></ul></li><li>对化简后的逻辑表达式列真值表，观察真值表，观察出此电路的功能</li></ol></li><li><p>例子：</p><p><img src="3.png" /></p><ul><li>T1是个与门，T2是个或门，第一层剩下都是与门，第二层一个或门，第三层一个非门，第四层一个与门，最后一层一个或门。最后通过真值表很容易看出ABC三个输入变量但有两个输出变量。不难想到是一个全加器。A、B是两个加数，C是上一位的进位，F1是当前位，F2是进位。</li><li>还有许多功能电路啦......比如半加器（2输入2输出）、投票表决器（多输入1输出）、奇校验电路（多输入1输出）、一致性电路（多输入1输出）</li></ul></li></ul></li><li><p><strong>设计</strong>：</p><ul><li><p>告诉你一个功能，让你设计出一个电路来实现它。</p></li><li><p>也是有固定套路的：</p><ol type="1"><li><p>分析功能，确定输入输出变量</p><ul><li>确定输入输出变量还是有点讲究的，有时候设计的好了可以大大减少运算量和电路的复杂程度。比如下面两个功能，换做是你，你会怎样设计？</li></ul><p><img src="4.png" /> <img src="5.png" /></p><ul><li>设计的关键其实是做到尽可能的<strong>复用</strong>，即对于不同对象的同一属性，尽量用一个变量表达出来。</li></ul></li><li><p>根据题意，直接构造出电路。或者写出真值表然后写出主析取范式然后再用卡诺图化简后得到最终逻辑表达式</p></li><li><p>根据逻辑表达式，选取一种门电路，画出电路图</p></li></ol></li></ul></li></ul><hr /><h3 id="二.-组合逻辑电路2">二. 组合逻辑电路(2)</h3><p>上一节我们已经可以设计出逻辑表达式。但是具体选用哪一种门电路呢？每一种门电路应该如何设计呢？这一节我们就来学习。</p><h4 id="单输出电路设计">2.1. 单输出电路设计</h4><h5 id="用与非门设计电路">2.1.1. 用与非门设计电路</h5><p>对于逻辑表达式F = ...中的 + 全部换成 <spanclass="math inline">\(\cdot\)</span> 就好了，按照这个思路，只要在 +的头上画两根取反号就行了，最上面那根保留，下面那根负责把 + 换成 <spanclass="math inline">\(\cdot\)</span> 。</p><p>但这样得到的实际电路可能耗材过多，实际中有些式子通过观察还能发现可以化的更简，比如下面这个例子：</p><p><span class="math inline">\(F = A\overline{B} + B\overline{C} +C\overline{D} + D\overline{A} = \overline{\overline{A\overline{B}} \cdot\overline{B\overline{C}} \cdot \overline{C\overline{D}} \cdot\overline{D\overline{A}}}\)</span></p><p>按理说这样就好了，但是还可以化简的。</p><p><span class="math inline">\(\overline{A\overline{B}} \cdot\overline{B\overline{C}} \cdot \overline{C\overline{D}} \cdot\overline{D\overline{A}} = (\overline{A} + B)(\overline{B} +C)(\overline{C} + D)(\overline{D} + A)\)</span></p><p>上面这个东西，学过二项式定理吗？假如我第一项如果挑B，则第二项不能挑<spanclass="math inline">\(\overline{B}\)</span>，只能挑C，那么第三项也只能挑D，依次类推，第四项只能挑A，得到ABCD。同理，如果我第一项挑<spanclass="math inline">\(\overline{A}\)</span>，那么我只能得到<spanclass="math inline">\(\overline{A}\overline{B}\overline{C}\overline{D}\)</span>。</p><p>即：<span class="math inline">\((\overline{A} + B)(\overline{B} +C)(\overline{C} + D)(\overline{D} + A) = ABCD +\overline{A}\overline{B}\overline{C}\overline{D}\)</span></p><p>对上面那玩意再求两次反，得到<spanclass="math inline">\(\overline{\overline{ABCD} \cdot\overline{\overline{A}\overline{B}\overline{C}\overline{D}}}\)</span></p><p>这样子，就得到<span class="math inline">\(F =\overline{\overline{\overline{ABCD} \cdot\overline{\overline{A}\overline{B}\overline{C}\overline{D}}}}\)</span></p><p>总结下来这个第二种方法就是在第一种方法的基础上把内部通过二项式定理进一步化简。</p><h5 id="用或非门设计电路">2.1.2. 用或非门设计电路</h5><p>对于逻辑表达式F = ...中的 <span class="math inline">\(\cdot\)</span>全部换成 + 就好了，按照这个思路，只要在 <spanclass="math inline">\(\cdot\)</span>的头上画两根取反号就行了，最上面那根保留，下面那根负责把 <spanclass="math inline">\(\cdot\)</span> 换成 + 。</p><p>还有第二种通用的方法，就是将F先求对偶，得到<spanclass="math inline">\(F_d\)</span>，这样F就由(xxx) + (xxx) +(xxx)的形式变为(x + x)(x + x)(x +x)的形式了。学过二项式定理吗？同理将<spanclass="math inline">\(F_d\)</span>化简，得到最简“与-或”式(yyy) +(yyy)。再在头上加两根取反，最顶上保留，下面那根为了把 + 变成 <spanclass="math inline">\(\cdot\)</span> ，最后再对偶回去即可。</p><p>上面那段文字是具体过程，流程总结下来如下：</p><ol type="1"><li>对F求对偶<span class="math inline">\(F_d\)</span></li><li>对<spanclass="math inline">\(F_d\)</span>展开，利用二项式原理或者卡诺图，得到最简"与-或"式<spanclass="math inline">\(F_d&#39;\)</span></li><li>对<spanclass="math inline">\(F_d&#39;\)</span>取两次反，最上面保留，下面那根化开，得到<spanclass="math inline">\(F_d&#39;&#39;\)</span></li><li>对<span class="math inline">\(F_d&#39;&#39;\)</span>对偶回去</li></ol><h5 id="用与或非门设计电路">2.1.3. 用与或非门设计电路</h5><p>这个就更简单了，因为给出的函数表达式都是形如F = xyz + xyz +xyz，所以只需要在F头上加两条杠就好了。</p><p>第二种思路就是跟用与非门设计电路的第二种方法一样。加两条杠，最上面不动，下面那个把xyz+ xyz +xyz变成()()()型，然后二项式定理展开即可。（如果是与非门第二种设计思路还要将展开的东西再取两次反）</p><h4 id="多输出电路设计">2.2. 多输出电路设计</h4><p>啊，最直接的想法就是分别把每个输出对应的电路设计出来就好了。但是这样比较憨，当我们化简得到了每个输出对应的逻辑表达式的时候，我们应该能尽可能使每一项<strong>复用</strong>。看下面这个例子：</p><p><img src="6.png" /></p><p>可以发现原<span class="math inline">\(F_1\)</span>中的<spanclass="math inline">\(A\overline{B}\)</span>可以变成<spanclass="math inline">\(A\overline{B}\overline{C}\)</span>，这样就跟<spanclass="math inline">\(F_2\)</span>中的<spanclass="math inline">\(A\overline{B}\overline{C}\)</span>一样了，做到了复用。</p><h4 id="包含无关项的电路设计">2.3. 包含无关项的电路设计</h4><p>其实很简单，看下面这个例子就懂了。</p><p><img src="7.png" /></p><p><img src="8.png" /></p><p>首先我们知道余3码是在8421码的基础上+3得到，因为8421码只有10位，所以余3码也只有10位。而且8421码最小是0000，所以余3码最小是0011（对应十进制数1）。所以这就在输出F中产生了许多无关项d。在画卡诺图时，若不考虑无关项，则把d全置为0；考虑无关项则把d全置为1。最后得到化简后的函数表达式。然后再将这个函数表达式用与非门设计。</p><h4 id="考虑级数的电路设计">2.4. 考虑级数的电路设计</h4><p>也是看一道例题就可以理解了。</p><p><img src="9.png" /></p><p>先用最直接的方法，与或非门直接加两条杠结束。与非门直接加两条杠，下面那条杠化开结束。</p><p>但是这样设计级数会不会多呢？</p><p>如果我们用"与或非门设计电路"中第二种化简方法，试一下：</p><p><span class="math inline">\(F = \overline{\overline{AB +\overline{A}C}} = \overline{\overline{AB} \cdot\overline{\overline{A}C}} = \overline{(\overline{A} + \overline{B})(A +\overline{C})} = \overline{\overline{A}\overline{C} + A\overline{B} +\overline{B}\overline{C}} = \overline{\overline{A}\overline{C} +A\overline{B}}\)</span></p><p>可以发现，这样设计只有3层。但是原来那样直接加两条杠是4层。所以当考虑电路的级数时，在用与或非门设计电路时，可以考虑进一步化简优化电路的级数。</p><p>如果用与非门，就不需要考虑进一步化简了。因为在与非门进一步化简后，还需要再内部再添加两条杠。级数肯定比不继续化简多。</p><h4 id="综合题">2.5. 综合题</h4><ul><li>设计一个组合电路，将8421BCD码变换为余3码。</li></ul><p>先确定输入输出变量，因为8421BCD码是用四个二进制数表示十进制数0~9，所以有四个输入A、B、C、D代表四个二进制数。同理四个输出W、X、Y、Z代表变换后的余3码。</p><p>然后列出真值表，因为BCD只能表示十进制0~9，所以注意表中有无关项d。</p><p><img src="10.png" /></p><p>这里不考虑无关项，所以在后续画卡诺图时都将d置为0。</p><p>因为是四个输出，所以属于多输出电路。所以先画四个卡诺图得到四个逻辑表达式（其实对于Z，发现其很有规律不用画卡诺图都可以知道它就是<spanclass="math inline">\(\overline{D}\)</span>）</p><p>画卡诺图过程省略，得到四个逻辑表达式： <span class="math display">\[W = A + BC + BD \\X = \overline{B}C + \overline{B}D + B\overline{C}\overline{D} \\Y = CD + \overline{C}\overline{D} \\Z = \overline{D}\]</span>此时我们需要思考，是否能做到项的<strong>复用</strong>呢？乍一看没发现能复用的，所以先不考虑复用，继续将式子进一步化简先。先从简单的开始画：</p><p><span class="math inline">\(Z = \overline{D}\)</span></p><p><span class="math inline">\(Y = \overline{C} \oplus D\)</span></p><p><span class="math inline">\(X = \overline{B}(C + D) + B\overline{(C +D)} = B \oplus (C + D) = B \oplus\overline{\overline{C}\overline{D}}\)</span></p><p><span class="math inline">\(W = A + B(C + D) = A +B\overline{\overline{C}\overline{D}}\)</span></p><p>化简后可以发现，<spanclass="math inline">\(\overline{\overline{C}\overline{D}}\)</span>这个东西可以做到复用，真不错。</p><p>接下来就是选择门电路来设计电路了。这里我选择最常用的与非门 +异或门设计电路。根据上面的逻辑表达式直接设计即可（W还需化简一下：<spanclass="math inline">\(W = \overline{\overline{A} \cdot\overline{B\overline{\overline{C}\overline{D}}}}\)</span>）</p><p>最后画出电路：</p><p><img src="11.png" /></p><hr /><h3 id="三.-组合逻辑电路3">三. 组合逻辑电路(3)</h3><h4 id="编码器">3.1 编码器</h4><p>按照我的理解，就是把数字变成二进制数。比如把0 ~8变成3位二进制数，或者0 ~ 15变成4位二进制数。</p><p>编码器分为普通编码器 和 优先编码器。</p><ul><li><strong>普通编码器</strong></li></ul><p>特点：任何时刻只允许输入一个编码信号。</p><p>最常见的普通编码器为8线-3线编码器，如下图：</p><p><img src="12.png" /></p><p>它的真值表如下：</p><p><img src="13.png" /></p><p>可以看出，假如我<spanclass="math inline">\(I_7\)</span>为高电平，则输出111，就是7的二进制。</p><p>那内部电路如何设计呢？根据真值表得出逻辑表达式然后化简，再选用与非门实现即可。</p><p>上面这个是8线-3线普通编码器，那如何实现8421-BCD普通编码器呢？</p><p>很简单，10个输入，4个输出。列出真值表，发现会有无关项。不考虑无关项，根据真值表得出4个输出的逻辑表达式，然后根据卡诺图化简。最后选用与非门实现即可。</p><ul><li><strong>优先编码器</strong></li></ul><p>特点：允许同时输入多个编码信号，只对其中优先权最高的一个进行编码。</p><p>最常见的优先编码器是74148优先编码器，长下面这个样子，需要掌握：</p><p><img src="14.png" /></p><p>这个图有两个要注意的地方，首先就是所有的<spanclass="math inline">\(I\)</span>上面都是有一个取反号的，只是这个图比较小可能看不清晰，然后所有的<spanclass="math inline">\(Y、S\)</span>上面也有取反号。还有就是看到红色箭头的地方了吗？这跟前面的8线-3线普通编码器不一样，这代表低电平有效。</p><p><spanclass="math inline">\(\overline{S}\)</span>为选通输入端，只有当<spanclass="math inline">\(\overline{S} = 0\)</span>时才能正常工作，当<spanclass="math inline">\(\overline{S} =1\)</span>时所有输出端为封锁为高电平。</p><p>​ <img src="15.png" /></p><p><spanclass="math inline">\(\overline{Y_s}\)</span>为选通输出端，当<spanclass="math inline">\(\overline{Y_s} =0\)</span>说明电路正常工作且无编码信号输入（<spanclass="math inline">\(\overline{S} = 0 且所有\overline{I} =1\)</span>）</p><p>​ <img src="16.png" /></p><p><spanclass="math inline">\(\overline{Y_{EX}}\)</span>为扩展端，当<spanclass="math inline">\(\overline{Y_{EX}} =0\)</span>说明电路正常工作且有编码信号输入（<spanclass="math inline">\(\overline{S} = 0\)</span>且存在<spanclass="math inline">\(\overline{I} = 0\)</span>）</p><p>​ <img src="17.png" /></p><p>知道了每个端口的作用，如何只通过输出端判断此时编码器处于什么状态呢？</p><ol type="1"><li><span class="math inline">\(\overline{Y_s} =0\)</span>：电路正常工作且无编码信号输入。（此时<spanclass="math inline">\(\overline{Y_{EX}}\)</span>必为1）</li><li><span class="math inline">\(\overline{Y_{EX}} =0\)</span>：电路正常工作且有编码信号输入。（此时<spanclass="math inline">\(\overline{Y_s}\)</span>必为1）</li><li><span class="math inline">\(\overline{Y_s} = \overline{Y_{EX}} =1\)</span>：电路被阻塞（此时<spanclass="math inline">\(\overline{S}\)</span>必为1）</li></ol><p>最后，74148优先编码器的真值表贴上来，上面所有可能你觉得有困惑的点都可以在这张表中得到解答。</p><p><img src="18.png" /></p><ul><li><strong>练习</strong></li></ul><p>学了上面普通编码器和优先编码器的知识，来写一道题吧！</p><blockquote><p>请用两片74148接成16线-4线优先编码器，将16个低电平输入信号<spanclass="math inline">\(\overline{A_0} \sim\overline{A_{15}}\)</span>编为'0000' ~ '1111'，其中<spanclass="math inline">\(\overline{A_{15}}\)</span>的优先级最高。</p></blockquote><p>首先如果是0 ~7就直接用一片就好了。思考一下，如果是大于7怎么办？可以这样思考：</p><p>15 = 8 + 7</p><p>14 = 8 + 6</p><p>13 = 8 + 5</p><p>12 = 8 + 4</p><p>11 = 8 + 3</p><p>10 = 8 + 2</p><p>9 = 8 + 1</p><p>8 = 8 + 0</p><p>发现规律了吗？如果是0 ~ 7直接用一片就好了，如果是8 ~15就肯定需要用到第二片，但是第二片同样能表达的范围只有0 ~ 7，所以就将8 ~15进行数字拆分。</p><p>如果输入8，则点亮第四位输出（8421中的8），剩下3位二进制输入0</p><p>如果输入9，则点亮第四位输出，剩下3位二进制输入1</p><p>如果输入10，则点亮第四位输出，剩下3位二进制输入2</p><p>... ...</p><p>如果输入15，则点亮第四位输出，剩下3位二进制输入7</p><p>思路就是这样，还有一些小细节我在放答案过后再解释：</p><p><img src="19.png" /></p><p>可以看到<spanclass="math inline">\(G_0、G_1、G_2\)</span>门都采用了与非门的设计，因为两片74148必定只会用到一片的输出（0~ 7用右边那片，8 ~ 15用左边那片）。</p><p>但是如果使得一片工作另一片就停止工作呢？注意左边那片的<spanclass="math inline">\(\overline{Y_s}\)</span>端口，左边那片正常工作且有信号输入时输出1，使得右边那片<spanclass="math inline">\(\overline{S} =1\)</span>，所以右边那片直接被堵塞了。如果左边那片正常工作但没信号输入时输出0，使得右边那片被激活。这样就实现了两片中只能有一片在工作。</p><p>然后<spanclass="math inline">\(Z_3\)</span>就是第四个二进制输出。只要用到左边那片，就输出1。刚好<spanclass="math inline">\(\overline{Y_{EX}}\)</span>就可以实现这个功能，只要电路正常工作并且有信号输入<spanclass="math inline">\(\overline{Y_{EX}}\)</span>就为0，经过一个与非门之后就变成了1。</p><h4 id="译码器">3.2 译码器</h4><p>译码器就是编码器的逆过程。编码器是给它一个数字，输出二进制。译码器就是给它一个二进制，输出一个数字。</p><p>译码器分为二进制译码器（最小项译码器）、二—十进制译码器、显示译码器。其中二进制译码器需要掌握74138译码器。</p><ul><li><strong>二进制译码器（只讲74138译码器）</strong></li></ul><p>74138译码器长这个样子：</p><p><img src="20.png" /></p><p>注意，跟74148解码器不同，这里的三个输入端<spanclass="math inline">\(A\)</span>都是高电平有效，输出端<spanclass="math inline">\(\overline{Y}\)</span>是低电平有效。这里的<spanclass="math inline">\(S、\overline{S}\)</span>是控制芯片是否工作的。</p><p>具体来说，只有当<span class="math inline">\(S_1 = 1 且 \overline{S_2}=0 且 \overline{S_3} =0\)</span>时，电路才处于正常工作状态。其余情况电路都处于被堵塞的状态。</p><p>​ <img src="21.png" /></p><p>74138解码器的真值表如下：</p><p><img src="22.png" /></p><ul><li><strong>二—十进制译码器（只讲7442译码器）</strong></li></ul><p>我觉得二—十进制译码器就是二进制译码器啊......搞不懂为啥还要专门分个类出来。二—十译码器就是说将4个二进制数变成十进制0~ 9。</p><p>二—十进制译码器最常见的就是7442译码器，它的真值表如下：</p><p><img src="23.png" /></p><p>可以看到有伪码的存在，这是为什么呢？因为4个二进制数可以表达0 ~15，但是因为是BCD码，所以我们得到的数范围是0 ~9。所以有一部分的二进制状态没有用到，没用到的地方就称为伪码。</p><ul><li><strong>显示译码器</strong></li></ul><p>啊就是能直观的显示出翻译后信息的译码器。看下面俩图就知道它是什么东西了。</p><p><img src="24.png" /><img src="25.png" /></p><ul><li><strong>练习</strong></li></ul><blockquote><p>试用两片74138组成4线-16线译码器。将输入的4位二进制代码<spanclass="math inline">\(D_3D_2D_1D_0\)</span>译成16个独立的低电平信号<spanclass="math inline">\(\overline{Z_0} \sim\overline{Z_{15}}\)</span>。</p></blockquote><p>有了前面用两块74148组成16线-4线编码器的经验，这题的思考方式是一样的。首先如果只用一块板的话，3个二进制数，可以得到0~ 7。如果大于7怎么办呢？观察一下： <span class="math display">\[(8)_d = (1000)_b \leftrightarrow (0)_d = (000)_b \\(9)_d = (1001)_b \leftrightarrow (1)_d = (001)_b \\(10)_d = (1010)_b \leftrightarrow (2)_d = (010)_b \\..... \leftrightarrow ...\]</span> 发现规律了没？</p><p>只要四位二进制中第四位为0，将剩下3位二进制传给第一块板的三个输入接口。如果第四位二进制为1，那么堵塞第一块版，将剩下3位二进制传给第二块版的三个输入接口。答案如下：</p><p><img src="26.png" /></p><h4 id="用译码器实现逻辑函数">3.3 用译码器实现逻辑函数</h4><p>因为任何逻辑函数均可化成最小项之和的形式。所以可以用译码器实现逻辑函数的电路，很牛逼。看下面这个例子你就懂了。</p><p><img src="27.png" /></p><p>首先先将F化成主析取范式：<span class="math inline">\(F = ABC+AB\overline{C} + A\overline{B}C + \overline{A}BC = m_7 + m_6 + m_5 +m_3\)</span></p><p>意思是说，只要三输入变量按照7、6、5、3的二进制输入，F就是1。否则F就是0。</p><p>好，那我们在74138输出端将<spanclass="math inline">\(\overline{Y_7}、\overline{Y_6}、\overline{Y_5}、\overline{Y_3}\)</span>用与非门连接起来。只要三输入变量输入7、6、5、3二进制其中的一个，那么<spanclass="math inline">\(\overline{Y_7}、\overline{Y_6}、\overline{Y_5}、\overline{Y_3}\)</span>就有一个是0，与非后就得到1。如果三输入变量不属于7、6、5、3二进制中的任何一个，则<spanclass="math inline">\(\overline{Y_7}、\overline{Y_6}、\overline{Y_5}、\overline{Y_3}\)</span>都为1，与非后就得到0。</p><hr /><h3 id="四.-组合逻辑电路4">四. 组合逻辑电路(4)</h3><h4 id="数据分配器">4.1 数据分配器</h4><p>定义：数据传输过程中，有时需要将数据分配到不同的数据通道上。数据分配器也叫多路分配器，简称DEMUX。</p><p>示意图：通过A端口来选择数据输出通道。</p><p><img src="28.png" /></p><p>电路图：</p><p><img src="29.png" /></p><p>这个电路还是蛮简单的。</p><p>提一嘴，前面学到的74138译码器就可以用来作1路-8路数据分配器。内部电路图ppt没给，但是我觉得就跟上面DEMUX的电路图差不多。</p><p><img src="30.png" /></p><h4 id="数据选择器">4.2 数据选择器</h4><p>定义：能够实现从多路数据中选择一路进行传输的电路叫做数据选择器。也叫多路选择器、多路调制器，简称MUX。常见的类型有二选一、四选一、八选一、十六选一。</p><p><img src="31.png" /></p><ul><li><strong>二选一多路选择器</strong></li></ul><p><img src="32.png" /></p><p>w0和w1分别是两路的数据源，然后s是控制器。先看右边的电路图，假设s是0，则f= w0，假设s是1，则f = w1。左边就是二选一MUX的图形符号。</p><ul><li><strong>四选一多路选择器</strong></li></ul><p>先看真值表，根据真值表就可以直接设计电路了。</p><p><img src="33.png" /></p><p>所以根据上面的真值表可以写出逻辑表达式：</p><p><span class="math inline">\(f = w_0\overline{s_1}\overline{s_0} +w_1\overline{s_1}s_0 + w_2s_1\overline{s_0} + w_3s_1s_0\)</span></p><p>下面右图是用非门 + 与门 +或门来实现上面的逻辑表达式，左图是四选一MUX的图形符号</p><p><img src="34.png" /></p><ul><li><strong>更大规模的多路选择器</strong></li></ul><p>可以直接列真值表然后直接构建，也可以用小规模的多路选择器去构建。</p><p>看一个由2选1多路选择器构建的4选1多路选择器，就知道如何构建了。</p><p><img src="35.png" /></p><p>先将w俩俩分组，然后用s0去筛，一下筛掉一半，再用s1去筛，又筛掉一半，最后就选择出来了一路数据。</p><h4 id="数据选择器的运用">4.3 数据选择器的运用</h4><ol type="1"><li><p>2x2纵横开关（是否交换数据传输通道）</p><p><img src="36.png" /></p><ul><li>看图，s是选择器。如果s=0，则y1 = x1, y2 = x2。如果s=1，则y1 = x2，y2= x1。</li></ul></li><li><p>实现逻辑函数</p><ul><li><p>最暴力的想法就是列真值表，输入变量A、B、C就是选择器s。每一行的输出就是数据输入通道，输出通道就是f。例如函数<spanclass="math inline">\(f = \overline{w_1}w_2 +w_1\overline{w_2}\)</span>，用四选一多路选择器的实现如下：</p><p><img src="38.png" /></p></li><li><p>但在暴力的基础上其实可以优化：可以对真值表做一个改动：</p><p><img src="39.png" /></p></li><li><p>这样子输入变量只有一个w1了，它就是选择器。数据输入通道有两个，分别是<spanclass="math inline">\(w_2\)</span>和<spanclass="math inline">\(\overline{w_2}\)</span>，数据输出通道一个为f。用二选一多路选择器实现如下：</p><p><img src="40.png" /></p></li></ul></li><li><p>实现3输入表决器</p><ul><li><p>先列出真值表</p><p><img src="41.png" /></p></li><li><p>对真值表进行优化</p><p><img src="42.png" /></p></li><li><p>此时输入变量两个w1、w2为选择器，数据输入通道4个分别是0、w3、w3、1，数据输出通道1个为f。用4选1多路选择器实现如下：</p><p><img src="43.png" /></p></li></ul></li><li><p>实现3位异或运算</p><ul><li><p>先列出真值表，并优化</p><p><img src="44.png" /></p></li><li><p>此时输入变量两个w1、w2为选择器，数据输入通道4个分别是<spanclass="math inline">\(w_3、\overline{w_3}、\overline{w_3}、w_3\)</span>，数据输出通道一个为f。用4选1多路选择器实现如下：</p><p><img src="45.png" /></p></li></ul></li></ol><hr /><h3 id="五.-组合逻辑电路5">五. 组合逻辑电路(5)</h3><p>这一节比较杂，主要是对第（4）内容的一个补充。具体来说，讲了如下内容：</p><ol type="1"><li>用香农展开定理搭配多路选择器实现逻辑函数</li><li>八选一数据选择器74151</li><li>双四选一数据选择器74153</li><li>数据选择器的更多运用</li></ol><h4 id="用香农展开定理搭配多路选择器实现逻辑函数">5.1用香农展开定理搭配多路选择器实现逻辑函数</h4><ul><li><p>香农展开定理：</p><ul><li><p><span class="math inline">\(f\left(w_{1}, w_{2}, \ldots . .w_{\mathrm{n}}\right)=\overline{w_{1}} f\left(0, w_{2}, \ldots . .w_{\mathrm{n}}\right)+w_{1} f\left(1, w_{2}, \ldots . .w_{\mathrm{n}}\right)\)</span></p><ul><li><p>↑展开一个变量</p></li><li><p>在香农表达式中<spanclass="math inline">\(f\left(0,w_{2}....w_{\mathrm{n}}\right)\)</span>项称为对应于<spanclass="math inline">\(\bar{w}_{\mathrm{1}}\)</span>的<spanclass="math inline">\(f\)</span>的余因子式, 简写做<spanclass="math inline">\(f_{\overline{w}_1}\)</span>。 同样的,<spanclass="math inline">\(f(1,w_2.....w_n)\)</span> 项称为对应于<spanclass="math inline">\(w_{_1}\)</span>的<spanclass="math inline">\(f\)</span>的余因子式,简写做<spanclass="math inline">\(f_{_{w_1}}\)</span>。所以香农展开定理可以简写成：<span class="math display">\[f=\overline{w}_{1}f_{\overline{w}_{1}}+w_{1}f_{w_{1}}\]</span></p></li></ul></li><li><p><span class="math inline">\(f(w_1,w_2,....,w_n)=\\\overline{w_1}\overline{w_2}f(0,0,w_3....w_n)+\overline{w_1}w_2f(0,1,w_3,.....w_n)+w_1\overline{w_2}f(1,0,w_3,.....w_n)+\\ w_1w_2f(1,1,w_3,.....w_n)\)</span></p><ul><li>↑展开多个变量</li></ul></li></ul></li></ul><p>那如何用香农展开定理实现逻辑函数呢？举个例子，比如<spanclass="math inline">\(f=\overline{w}_{1}\overline{w}_{3}+w_{1}w_{2}+w_{1}w_{3}\)</span></p><p>将f以w1用香农展开定理展开，得到<spanclass="math inline">\(f=\overline{w}_1f_{\overline{w}_1}+w_1f_{w_1}=\overline{w}_1(\overline{w}_3)+w_1(w_2+w_3)\)</span></p><p>然后选用二路选择器，w1是选择器，数据输入通道2个分别是<spanclass="math inline">\(\overline{w_3}\)</span>和<spanclass="math inline">\(w_2 +w_3\)</span>，数据输出通道一个为f。实现电路图如下：</p><p><img src="46.png" /></p><p>同理，如果用香农展开定理展开两个变量，则搭配一个四路选择器也可以实现上述函数f。</p><h4 id="八选一数据选择器74151">5.2 八选一数据选择器74151</h4><p>74151MUX的样子和真值表如下图</p><p><img src="47.png" /></p><h4 id="双四选一数据选择器74153">5.3 双四选一数据选择器74153</h4><p>就是俩独立的四路选择器放一起，如图。（个人觉得左图很不直观，下面练习中的74153比较直观）</p><p><img src="48.png" /></p><blockquote><p>练习：如何用74153构建一个74151？</p></blockquote><p>很简单，跟以前练习题一样的套路。只要保证两个四选一板子有且只能有一块板子在工作就行了。看答案吧，很简单。</p><p><img src="49.png" /></p><p>A2还有G1就是为了实现”只能有一个四选一“板子在工作我们自己加上去的电路。</p><h4 id="小补充">5.4 小补充</h4><p>感觉代号多了有点乱了。让我来梳理一下。</p><p>74148是最常见的8线-3线优先编码器。</p><p>74138是最常见的二进制译码器。（3个输入、8个输出）</p><p>数据分配器DEMUX可用74138实现。</p><p>数据选择器MUX有74151（八路）、74153（俩独立四路放一起）</p><h4 id="数据选择器的更多运用">5.5 数据选择器的更多运用</h4><ol type="1"><li><p>与DEMUX实现多路信号分时传送</p><p><img src="50.png" /></p></li><li><p>实现逻辑函数</p><ul><li><p>用MUX实现逻辑函数的方法有许多。</p><ol type="1"><li>直接列真值表实现</li><li>列完真值表，对真值表优化后实现</li><li>用香农展开公式后实现</li><li>列引入变量的卡诺图实现</li></ol></li><li><p>前三种方法前面都介绍过了，这里放一个用第四种方法的例题。</p><p><img src="51.png" /></p></li><li><p>因为74151是八位选择器，所以只能有3个选择变量。所以画卡诺图引入了一个变量。然后8个信号输入端口就输入0/1/D/<spanclass="math inline">\(\overline{D}\)</span>即可。</p></li><li><blockquote><p>练习：请用一片74151实现逻辑函数<spanclass="math inline">\(F(A,B,C,D,E)=A\overline{B}C\overline{D}E+AB\overline{C}\overline{D}\overline{E}+A\overline{B}C\overline{D}\overline{E}+\overline{A}\overline{B}\overline{C}DE+\overline{A}B\overline{C}\overline{D}\overline{E}\)</span></p></blockquote></li><li><p>74151是八路选择器，所以要有三个选择变量。但是这里F有5个，所以第一想法是用香农展开定理展开3个变量，但是这样太麻烦了。所以用第四种方法，引入两个变量进卡诺图即可。</p><p><img src="52.png" /></p></li></ul></li><li><p>数据选择器的扩展</p><ul><li><p>很好理解，看图即可。</p><p><img src="53.png" /></p></li></ul></li></ol><hr /><h3 id="六.-组合逻辑电路6">六. 组合逻辑电路(6)</h3><h4 id="数值比较器">6.1 数值比较器</h4><ul><li><strong>一位数值比较器</strong></li></ul><p>两个1位二进制数A,B相比的情况有以下几种: 1. A&gt;B，则<spanclass="math inline">\(A\overline{B}=1\)</span>，所以可用<spanclass="math inline">\(A\overline{B}\)</span>作为A&gt;B的输出信号<spanclass="math inline">\({Y}_{(A&gt;B)}\)</span> 。<br />2. 同理可用 <span class="math inline">\(\overline{AB}\)</span>作为A&lt;B的输出信号 <span class="math inline">\({Y}_{(A&lt;B)}\)</span>。 3. 同理可用<span class="math inline">\(A \odot B\)</span>作为A=B的输出信号 <span class="math inline">\(Y_{A=B}\)</span></p><p>于是可以设计出如下电路（注意是低电平有效）</p><p><img src="54.png" /></p><ul><li><strong>多位数值比较器</strong></li></ul><p>多位数值比较器的原理就是从高位到低位逐位比较，最常见的是4位比较器14585，下面是其逻辑函数和电路图：</p><p><img src="55.png" /></p><p><img src="56.png" /></p><p>这个图有4个要注意的地方，首先看蓝色箭头的地方，为啥这个地方用与非门呢？很简单，将上面的逻辑表达式进行进一步化简：<span class="math display">\[Y_{A&lt;B} = \overline{\overline{\overline{A_3}B_3} \cdot\overline{\overline{A_3 \oplus B_3}\overline{A_2}B_2} \cdot ...} \,\cdot I_{A&lt;B}  \\= \overline{\overline{\overline{A_3}B_3} \cdot ((A_3 \oplus B_3) +\overline{\overline{A_2}B_2}) \cdot \, ...} \, \cdot I_{A&lt;B}\]</span> 现在知道蓝色箭头为啥用与非门了吧=w=。</p><p>那为啥绿色箭头那要用或门呢？还是看上面化简的式子，注意看第二项，第二项就是或门=w=。</p><p>那为啥棕色箭头用或非门呢？还是化简上面的式子： <spanclass="math display">\[Y_{A=B} = \overline{(A_3 \oplus B_3) + (A_2 \oplus B_2) + (略) + (略)}\, \cdot I_{A=B}\]</span>很清楚吧=w=，就是一个或非门，每一项这里用异或表达了，其实就是图中判断是否每一项是否相等的那个逻辑门。</p><p>那为啥红箭箭头那要用或非门呢？还是化简上面的式子： <spanclass="math display">\[Y_{A&gt;B} = \overline{(Y_{A&lt;B} + Y_{A=B}) + \overline{I_{A&gt;B}}}\]</span> easy。</p><p>还剩一个问题，那三个<spanclass="math inline">\(I\)</span>是干啥的。其实就是用来接收低位上的结果的。这样两块14585就能实现8位数字的比较。如下图：</p><p><img src="57.png" /></p><p>有个问题，为啥左边的<spanclass="math inline">\(Y_{A&gt;B}\)</span>为啥不能连到右边的<spanclass="math inline">\(I_{A=B}\)</span>？</p><p>其实可以，但是图中这样连也没问题。还是用逻辑表达式去解释：<spanclass="math inline">\(Y_{A&gt;B} = \overline{(Y_{A&lt;B} + Y_{A=B}) +\overline{I_{A&gt;B}}}\)</span>，可以发现必须要三者都是0才会使得<spanclass="math inline">\(Y_{A&gt;B}=1\)</span>，所以默认给<spanclass="math inline">\(I_{A&gt;B}\)</span>置为1不影响结果。</p><h4 id="加法器">6.2 加法器</h4><ul><li><strong>半加器</strong></li></ul><p>很简单，真值表、逻辑表达式、图形符号如下图：</p><p><img src="58.png" /></p><ul><li><strong>全加器</strong></li></ul><p>加了一个考虑上一位进位而已，也很简单，真值表、逻辑表达式、图形符号如下：</p><p><img src="59.png" /></p><p>这里解释一下逻辑表达式，因为异或是不进位加法，所以S等于三者异或很合理。然后CO用或连接也很合理，无非就是A、B都是1可以进位，或者CI为1，A、B里任意一个为1也可以进位。</p><ul><li><strong>串行进位加法器</strong></li></ul><p>有了全加器之后，只需要将多个全加器串联起来就可以得到任意多位的加法器了。如下图：</p><p><img src="60.png" /></p><p>虽然这样逻辑和电路都很简单，但是存在一个问题，就是速度过慢，如何解决呢？</p><p>速度关键是慢在进行信号逐级传递的过程，所以要优化这个过程。不难发现，要想知道<spanclass="math inline">\(CI_i\)</span>，只需要知道<spanclass="math inline">\(A_{i-1}A_{i-2}...A_0\)</span>和<spanclass="math inline">\(B_{i-1}B_{i-2}...B_0\)</span>即可。</p><p>个人觉得，这种优化思路就很像把递归函数展开来写了笑死。也有点像并查集路径压缩。</p><ul><li><strong>超前进位加法器</strong></li></ul><p>用上面提到的优化方法做成的加法器就叫做超前进位加法器。下图是74283的超前进位加法器电路图：</p><p><img src="61.png" /></p><p>可以发现光4位加法器电路就那么复杂了，这或许就是空间换时间吧（笑）</p><p>所以当我们需要更多位加法器的时候，可以拿74283超前进位加法器去串联做成一个多位的串行进位加法器。</p><blockquote><p>练习：用一片74283设计将BCD8421码转换成余3码的电路</p></blockquote><p>太简单啦！直接上图：</p><p><img src="62.png" /></p><h4 id="竞争-冒险现象">6.3 竞争-冒险现象</h4><p>啊我懒得打很多字了，这里我放一个up主的视频，看完这道例题就知道什么是竞争-冒险现象了：（up主：海蓬莱）</p><video src="video.mp4" controls="controls"></video><p>视频中的险象就是这里的冒险。官方定义如下 ：</p><p>竞争：一个逻辑门的两个输入端的信号同时向相反方向变化，而变化的时间有差异的现象。</p><p>冒险：由于竞争而使电路输出发生瞬时错误</p><p>注意，有竞争不一定会冒险（如视频中提到的非临界竞争）</p><p>冒险分为两类：</p><ol type="1"><li>0型冒险：即本来是1的变成了0<ul><li>当表达式在一定条件下能化成<span class="math inline">\(F = A +\overline{A}\)</span>时，就会出现0型冒险</li></ul></li><li>1型冒险：即本来是0的变成了1<ul><li>当表达式在一定条件下能化成<span class="math inline">\(F = A \cdot\overline{A}\)</span>时，就会出现1型冒险</li></ul></li></ol><p>如何能消除竞争-冒险现象呢？ppt上给出了三种解决方案：</p><ol type="1"><li><p>接入滤波电容</p></li><li><p>引入选通脉冲</p></li><li><p>修改逻辑表达式</p><ul><li>前俩个反正我是没看懂，这里举个例子说一下第三种方法。比如有逻辑函数<spanclass="math inline">\(F = AB + \overline{A}C\)</span>，当B = C =1时会出现0型冒险。所以可以修改一下逻辑表达式为：<spanclass="math inline">\(F = AB + \overline{A}C +BC\)</span>，这样就不会出现0型冒险了。（为什么要这么修改呢？看下面的卡诺图你就知道了）</li></ul><p><img src="63.png" /></p></li></ol><hr /><h3 id="七.-vivado的基本使用">七. Vivado的基本使用</h3><p>先来了解一下EDA技术：即电子设计自动化，其依赖功能强大的计算机，在EDA工具软件平台上，对以硬件描述语言(HDL)为系统逻辑描述手段完成的设计文件，自动地完成逻辑编译、逻辑化简、逻辑分割、逻辑综合、布局布线，以及逻辑优化和仿真测试，直至物理实现既定的电子设计系统功能。</p><p>以我浅薄的理解，EDA = IDE，Verilog =C++，hhhhh，FPGA是可编程逻辑器件。</p><h4 id="用verilog-hdl设计电路">7.1 用Verilog HDL设计电路</h4><p>写一个模块大致分为以下几步：</p><ol type="1"><li>打开Vivado，创建一个项目（根据自己开发板选型号，我的是xc7a35tcpg236-1）</li><li>新建一个design文件，在里头写程序</li><li>新建一个sim文件，在里头写仿真程序（初始化 + 实例化 +仿真过程代码）</li><li>运行仿真，观察仿真结果是否跟设想一样</li><li>封装IP核，以便此模块以后可被其它项目使用</li></ol><h4 id="用block-design设计电路">7.2 用Block Design设计电路</h4><ol type="1"><li>打开Vivado，创建一个项目</li><li>左侧新建一个Block Design项目</li><li>引入IP核，开始画图</li><li>新建一个sim文件，写仿真程序</li><li>运行仿真，观察仿真结果是否跟设想一样</li></ol><h4 id="用rtl看电路图">7.3 用RTL看电路图</h4><p>点左侧RTL分析即可生成。</p><h4 id="下板">7.4 下板</h4><ol type="1"><li>写好constraint文件（我直接用的老师给的模板文件上修改）</li><li>运行左侧Synthesis</li><li>运行Implementation（记得勾选第二项产生二进制文件，然后选择OpenHardware Manager）</li><li>通过USB连上FPGA</li><li>点击Auto Connect，连接成功后选择ProgramDevice下载刚才的二进制文件</li><li>可以愉快的用板子观察程序结果啦~</li></ol><p>但是断电后程序就会丢失，为了解决这个问题，需要把程序烧录进ROM里：</p><ol type="1"><li>生成bin文件，Tools -&gt; Settings -&gt; Bitstream -&gt;勾选-bin-file* -&gt; OK，左侧GenerateBitstream重新生成bit文件（此时就会生成bin文件）</li><li>右键芯片选择Add Configuration Memory Device，选择合适的闪存型号</li></ol><h4 id="总结">7.5 总结</h4><p>Vivado这个软件其实蛮简单使用的。首先不考虑板子的话，只在电脑上设计电路有两种方法，第一种就是直接创建design文件写，第二种就是用BlockDesign（若某个模块想封装成IP核必须要仿真过先）。然后想看设计的对不对，就创建仿真文件来看。另外，用RTL可以看设计好的电路。</p><p>下板的话就需要通过constraint文件指定管脚，然后左侧Synthesis +Implementation + 生成二进制文件 + 连板子 + Auto Connect + ProgramDevice就可以在板子上观察了。</p><hr /><p>现在是2023/10/28，又准备要做时序逻辑电路的实验了。所以继续把这个自学笔记写完吧hhhh</p><h3 id="八.-触发器">八. 触发器</h3><p>定义：触发器是具有记忆功能的基本逻辑单元，一个触发器可以存储一个二值信号。</p><h4 id="rs触发器">8.1 RS触发器</h4><p><img src="64.png" /></p><p>首先需要知道与非门的特点，对于与非门，如果有一端为0，那么输出就为1。如果两端都为1，那么输出才为0。所以对于上图，如果S=0,R=1，那么Q = 1, Q反馈回去得到<spanclass="math inline">\(\overline{Q}\)</span>=0。如果R=0, Q=1，那么<spanclass="math inline">\(\overline{Q}\)</span>=1，反馈回去得到Q=0。</p><p>其实S为set，R为reset，Q为输出。而且S、R都是低电平有效。所以S=0,R=1的时候，输出将置位为1。R=0,S=1时，输出将reset为0。</p><p>如果S = R = 1呢？按照感性理解就是set和reset都不起效，也就是Q和<spanclass="math inline">\(\overline{Q}\)</span>维持上一个状态。让我们来验证一下，假设Q=0，则反馈回去<spanclass="math inline">\(\overline{Q}\)</span>=1，再反馈回来Q=0。假设Q=1，则反馈回去<spanclass="math inline">\(\overline{Q}\)</span>=0，再反馈回来Q=1。没有问题，就是维持上一个状态。</p><p>如果S = R =0呢？按照感性理解就是set和reset都起效，那必然会存在一个“竞争”问题。也就是存在不唯一性。让我们来验证一下，假设S= R = 0，那么Q和<spanclass="math inline">\(\overline{Q}\)</span>都将会为1。好，假设下一个时刻S= R = 1, 按照上面的分析应该维持原状对吧。但是假如Q先传回去，则<spanclass="math inline">\(\overline{Q}\)</span>=0，再传回来Q=1，新状态Q=1,<span class="math inline">\(\overline{Q}\)</span>=0；假如<spanclass="math inline">\(\overline{Q}\)</span>先传回去，则Q=0,再传回来<span class="math inline">\(\overline{Q}\)</span>=1，新状态Q=0,<spanclass="math inline">\(\overline{Q}=1\)</span>。所以我们是要禁止出现S = R= 0的情况的！因为下一个时刻就会出现<strong>“不唯一性”</strong>。</p><p>经过上面的分析，下面的真值表就十分清楚了：</p><p><img src="65.png" /></p><p>用逻辑表达式<span class="math inline">\(Q^{n+1}=\overline{S} + R(Q^n)\quad ,R + S = 1,\)</span>也可以表示上面的真值表（用卡诺图推）</p><h4 id="钟控触发器">8.2 钟控触发器</h4><p>钟控触发器是在普通触发器上的一个改进。因为有时候我们只希望在某一个信号到来的时候，Q才随R和S改变。而其余时候，都希望Q维持原状，也就是这个触发器被“锁”起来。那么钟控触发器就可以实现这个功能。</p><p>钟控触发器也分为几种：可控R-S触发器、主从式J-K触发器、D型触发器、T型触发器。</p><ul><li><strong>可控R-S触发器</strong></li></ul><p>先来看它的电路图和装置图：</p><p><img src="66.png" /></p><p>可以发现，可控R-S触发器无非就是在R-S触发器的前面加了俩与非门。因为我们知道对于与非门，只要有一端是0，输出就为1。所以当cp为0时，Q将维持原状，触发器被“锁”住。当cp为1时，R、S的输入就可以影响到Q。可是注意，因为多了俩与非门的存在，所以本来对于R、S是低电平有效，现在变成了高电平有效了。也就是S= 1, R = 0时，Q = 1；S = 0, R = 1时，Q = 0；S = R = 0时维持原状；S = R =1时为不稳定态。</p><p>总结来说，cp=0时锁触发器，cp=1时激活触发器，但是会变为高电平有效。</p><p>逻辑表达式为：<span class="math inline">\(Q^{n+1} = S +\overline{R}Q^n \quad ,R \cdot S = 0, CP = 1\)</span></p><ul><li><strong>主从式J-K触发器</strong></li></ul><p>J-K触发器是可控R-S触发器的一个升级版，它的J、K分别对应R、S，而且允许J和K同时取1。同时取1的时候不会引入“竞争”，而是会翻转输出Q的结果。</p><p>具体来说，当cp=0时，触发器被锁住。当cp=1时，触发器激活，J、K高电平有效。J= 1, K = 0时Q = 1；J = 0, K = 1时Q = 0；J = K = 0时保持原状；J = K =1时翻转Q。</p><p>下面是它的逻辑表达式和电路图：</p><p><span class="math inline">\(Q^{n+1}=J\overline{Q^n}+\overline{K}Q^n\quad ,CP = 1\)</span></p><p><img src="67.png" /></p><ul><li><strong>D型触发器</strong></li></ul><p>这个触发器最直观，只有两个输入端：cp和D。D输出什么，这个触发器就存储什么（我已经预感到实验会大量使用到这个触发器了hhhh）。</p><p>详细来说，cp=0时，触发器被锁住。cp=1时，若D = 0，则Q = 0；若D =1，则Q = 1。</p><p>它的电路图如下：（其实所有触发器都是在R-S触发器的基础上在输入端进行改动）</p><p><img src="68.png" /></p><p>这个公式推导挺有趣的。R-S基础触发器的公式是：<spanclass="math inline">\(Q^{n+1}=\overline{S} + R(Q^n)\)</span>。</p><p>然后由图中可以推出，<span class="math inline">\(R = \overline{CP\cdot (\overline{CP \cdot D})} = \overline{CP \cdot \overline{D}} \quad, S = \overline{CP \cdot D}\)</span>。</p><p>将上面的R、S带入原始公式：<span class="math inline">\(Q^{n+1} = CP\cdot D + (\overline{CP} + D)Q^n = D(CP + Q^n) +\overline{CP}Q^n\)</span></p><p><span class="math inline">\(CP=0\)</span>时，<spanclass="math inline">\(Q^{n+1} = DQ^n + Q^n = Q^n\)</span></p><p><span class="math inline">\(CP = 1\)</span>时，<spanclass="math inline">\(Q^{n+1} = D\)</span></p><p>完整公式：<span class="math inline">\(Q^{n+1} = D\cdot CP +\overline{CP}Q^n\)</span></p><ul><li><strong>T型触发器</strong></li></ul><p>这个触发器也是只有两个输入端：cp和T。cp=0时，触发器被锁住。cp=1时，T=0时维持原态，T=1时翻转输出。</p><p>它的电路图如下：</p><p><img src="69.png" /></p><p>可以看出，T触发器就是在J-K触发器的基础上，把J和K变成一个接口T了。所以J-K触发器的公式：<spanclass="math inline">\(Q^{n+1}=J\overline{Q^n}+\overline{K}Q^n\)</span>就应该改为<spanclass="math inline">\(Q^{n+1} = T \oplus Q^n\)</span>。</p><h4 id="总结-1">8.3 总结</h4><p>触发器这块，R-S触发器是最经典的，后续所有的钟控触发器都是由R-S触发器修改得到。所以R-S触发器的公式和电路图要记住：<spanclass="math inline">\(Q^{n+1} = \overline{S} +RQ^n\)</span>。然后它是低电平有效，后续的钟控触发器都是高电平有效。它有两个缺点：</p><ol type="1"><li>没有时钟控制</li><li>R、S不能同时为0</li></ol><p>可控R-S触发器就是在R-S的基础上加了两个与非门，多连了一个CP。公式为<spanclass="math inline">\(Q^{n+1} = S +\overline{R}Q^n\)</span>。解决了缺点2。</p><p>J-K触发器就是在可控R-S触发器的基础上将两个输出连接到J、K输入端，公式为<spanclass="math inline">\(Q^{n+1}=J\overline{Q^n}+\overline{K}Q^n\)</span>。又解决了缺点1。</p><p>D触发器和T触发器背一下就好了，不要求掌握其电路图。D触发器就是CP=1时D是什么，Q就是什么。T触发器就是CP=1时T=0为维持原状，T=1为翻转输出，公式为<spanclass="math inline">\(Q^{n+1} = T \oplus Q^n\)</span></p><hr /><h3 id="九.-时序逻辑电路1">九. 时序逻辑电路(1)</h3><h4 id="概述-1">9.1 概述</h4><p>时序电路一般都是由两个部分构成的：组合电路和存储电路。</p><p>存储电路的输出必须反馈到组合电路的输入端，从而与输入信号一起决定组合电路的输出。</p><p>下面这两张图能很好的解释时序逻辑电路的特点：</p><p><img src="70.png" /></p><p><img src="71.png" /></p><p>时序逻辑电路分类的话有两种分类方式：</p><ul><li><p>按触发器的动作特点分类</p><ol type="1"><li>同步时序逻辑电路（有统一的CP）</li><li>异步时序逻辑电路（无统一的CP）</li></ol></li><li><p>按输出信号的特点分类</p><ol type="1"><li><p>米利型（输出跟输入变量和存储电路有关）</p><p><img src="72.png" /></p></li><li><p>莫尔型（输出只跟存储电路有关）</p><p><img src="73.png" /></p></li></ol></li></ul><h4 id="时序逻辑电路的描述方法">9.2 时序逻辑电路的描述方法</h4><p>从理论上：输出方程(通过输入和现态算输出) + 驱动方程 +状态方程(通过现态算次态)</p><p>从图表上：状态转换表、状态转换图、时序图</p><ul><li><strong>状态转换表</strong></li></ul><p>若将任何一组输入变量及电路初态的取值代入状态方程和输出方程，即可算出电路的次态和现态下的输出值。如此继续下去，把全部的计算结果列成真值表的形式，就得到了状态转换表。</p><p>通过下面这个例子就很容易看懂。左边第一、二个是状态方程，第三个是输出方程。右边是状态转换表。</p><p><img src="74.png" /></p><ul><li><strong>状态转换图</strong></li></ul><p>就是状态转换表形象化的表示。以小圆圈表示电路的各个状态，圆圈中填入存储单元的状态值，圆圈之间用箭头表示状态转换的方向，在箭头旁注明状态转换前的输入变量取值和输出值。</p><p>下面这张图就是上面那个状态转换表的状态转换图，很容易理解。</p><p><img src="75.png" /></p><ul><li><strong>时序图</strong></li></ul><p>就是波形图。</p><hr /><h3 id="十.-时序逻辑电路2">十. 时序逻辑电路(2)</h3><h4 id="同步时序逻辑电路的分析">10.1 同步时序逻辑电路的分析</h4><p>跟分析组合逻辑电路一样，也是画出真值表（状态转换表），然后观察得出功能。</p><p>具体来说，分为下面几步：</p><ol type="1"><li>写出输出方程</li><li>写出驱动方程</li><li>写出状态方程</li><li>根据方程画出状态转换表</li></ol><p>下面用一道例题来感受：</p><p><img src="76.png" /></p><p>输出方程：<span class="math inline">\(Y = Q_0^nQ_2^n\)</span></p><p>驱动方程： <span class="math display">\[J_0 = K_0 = 1 \\J_1 = K_1 = \overline{Q_2^n}Q_0^n \\J_2 = Q_1^nQ_0^n, K_2 = Q_0^n\]</span> 状态方程： <span class="math display">\[Q_0^{n+1} = J_0\overline{Q_0^n} + \overline{K_0}Q_0^n = \overline{Q_0^n}\\Q_1^{n+1} = J_1\overline{Q_1^n} + \overline{K_1}Q_1^n =\overline{Q_2^n}Q_0^n \oplus Q_1^n \\Q_2^{n+1} = J_2\overline{Q_2^n} + K_2Q_2^n = Q_1^nQ_0^n\overline{Q_2^n}+ \overline{Q_0^n}Q_2^n\]</span> 根据状态方程和输出方程写出状态转换表：</p><p>设电路初始状态为<span class="math inline">\(Q_2Q_1Q_0 =000\)</span>，则</p><p><img src="77.png" /></p><p>（注意，当出现循环（红圈）时，即可停下）。</p><p>若有需要，还可以根据状态转换表画出状态转换图和时序图：</p><p><img src="78.png" /></p><p>注意，CP是系统时钟，因为状态转换表中有6条不同的数据，电路又是低电平激发，所以CP需要有6次下沿，所以时序图中CP就有6次下沿信号。</p><h4 id="异步时序逻辑电路的分析">10.2 异步时序逻辑电路的分析</h4><p>异步时序逻辑特点就是所有触发器的CP端并没有完全连接到一起。</p><p>还是以一道例题来讲解：</p><p><img src="79.png" /></p><p>分析跟同步时序逻辑一样的套路，但是多一个“时钟方程”</p><p>时钟方程：</p><p><span class="math inline">\(CP_0 = CP_2 = CP\)</span></p><p><span class="math inline">\(CP_1 = Q_0\)</span></p><p>输出方程：</p><p><span class="math inline">\(Y = Q_2^n\)</span></p><p>驱动方程：</p><p><span class="math inline">\(J_0 = \overline{Q_2^n}, K_0 =1\)</span></p><p><span class="math inline">\(J_1 = K_1 = 1\)</span></p><p><span class="math inline">\(J_2 = Q_1^nQ_0^n, K_2 = 1\)</span></p>状态方程： $$ .{<spanclass="math display">\[\begin{aligned}Q_0^{n+1}&amp;=\overline{Q_2^n}\overline{\mathcal{Q_0}^n}\qquad CP↓有效\\Q_1^{n+1}&amp;=\overline{Q_1^n} \qquad Q_0↓有效\\Q_2^{n+1}&amp;=Q_1^n\mathcal{Q_0}^n\overline{\mathcal{Q_2}^n} \qquadCP↓有效\end{aligned}\]</span><p>.. $$ 有了上面的四个方程，就可以写出状态转换表：</p><p><img src="80.png" /></p><p>注意，因为<span class="math inline">\(Q_1\)</span>的更新是受<spanclass="math inline">\(Q_0\)</span>↓控制的，所以当更新<spanclass="math inline">\(Q_1^{n+1}\)</span>时，应该先更新<spanclass="math inline">\(Q_0^{n+1}\)</span>，然后得出<spanclass="math inline">\(CP_1\)</span>是↑还是↓，然后才能去更新<spanclass="math inline">\(Q_1^{n+1}\)</span>。</p><p>有了状态转换表后就可以画出状态转换图和时序图：</p><p><img src="81.png" /></p><hr /><h3 id="十一.-时序逻辑电路3">十一. 时序逻辑电路(3)</h3><h4 id="同步时序逻辑电路的设计">11.1 同步时序逻辑电路的设计</h4><p>套路为：</p><ol type="1"><li>进行逻辑抽象，并写出逻辑状态转换表，并进行化简合并</li><li>将逻辑状态转换表映射到二进制状态转换表</li><li>根据二进制状态转换表分别求出输出方程和状态方程</li><li>选用一种触发器，根据触发器公式和状态方程推出驱动方程</li><li>根据输出、驱动、状态方程画出电路图</li><li>检查此电路是否有自启动能力</li></ol><p>以一道例题来举例：</p><blockquote><p>试设计一个串行数据检测器。对它的要求是：连续输入三个或三个以上的’1’时输出为’1’，其它情况输出为’0’(试用上边沿JK-FF完成设计)。</p></blockquote><ul><li>逻辑抽象</li></ul><p>令输入数据为输入变量，用X表示。令检测结果为输出变量，用Y表示。设电路在没有输入‘1’以前的状态为S0；输入1个‘1’后电路转入S1状态；连续输入2个‘1’后电路转入S2状态；连续输入3个或3个以上‘1’以后电路转入S3状态。</p><p><img src="82.png" /></p><ul><li>状态化简</li></ul><p>将状态转换表和图化简后如下：（如何化简参考下面的化简教学）</p><p><img src="86.png" /></p><ul><li>状态分配（这一步是将逻辑状态映射到数字状态）</li></ul><p>用二进制表示状态，比如说有4个状态<span class="math inline">\(S_0 -S_2​\)</span>，然后用00表示<spanclass="math inline">\(S_0​\)</span>，01表示<spanclass="math inline">\(S_1​\)</span>，11表示<spanclass="math inline">\(S_2​\)</span>。然后上面那个的表可以改写为：</p><p><img src="87.png" /></p><p>根据这个表，就可以写出输出方程和状态方程：</p><p><img src="88.png" /></p><p>即</p><p><span class="math inline">\(Y = XQ_1^n\)</span></p><p><span class="math inline">\(Q_0^{n+1} = X\)</span></p><p><span class="math inline">\(Q_1^{n+1} = XQ_0^{n}\)</span></p><p>选用JK触发器，结合公式<span class="math inline">\(Q^{n+1} =J\overline{Q^n} + \overline{K}Q^n\)</span>和<spanclass="math inline">\(Q_0^{n+1} = X = X(\overline{Q_0^n} + Q_0^n) =X\overline{Q_0^n} + XQ_0^n\)</span></p><p>可以得到，<span class="math inline">\(J_0 = X, K_0 =\overline{X}\)</span></p><p>同理，可得到<span class="math inline">\(J_1 = XQ_0^n, K_1 =\overline{XQ_0^n}\)</span></p><p>所以，全部方程如下：</p><p>输出方程：<span class="math inline">\(Y = XQ_1^n\)</span></p><p>状态方程： <span class="math display">\[Q_0^{n+1} = X \\Q_1^{n+1} = XQ_0^{n}\]</span> 驱动方程： <span class="math display">\[J_0 = X \qquad K_0 = \overline{X} \\J_1 = XQ_0^n \qquad K_1 = \overline{XQ_0^n}\]</span> 所以根据方程即可画出电路图：</p><p><img src="89.png" /></p><ul><li>检查是否有自启动能力</li></ul><p>因为在映射的时候有一些数字状态没被用到，所以就要将没用到的数字状态代入方程中去看看得到的次态是否仍然是没用到的数字状态。如果是的话说明此电路没有自启动能力。如果次态都可以回到用到的数字状态，那么此电路拥有自启动能力。</p><p>化简教学：</p><ol type="1"><li>次态相同</li></ol><p><img src="83.png" /></p><ol start="2" type="1"><li>次态交错</li></ol><p><img src="84.png" /></p><ol start="3" type="1"><li>次态维持</li></ol><p><img src="85.png" /></p><hr /><h3 id="十二.-时序逻辑电路4">十二. 时序逻辑电路(4)</h3><p>接下来介绍几种常用的时序逻辑电路。</p><h4 id="计数器">12.1 计数器</h4><p>计数器功能就是记录输入脉冲的个数，计数器所能记录的最大脉冲个数称为计数器的“模”。</p><p>计数器有三种分类方式，如图：</p><p><img src="91.png" /></p><p>先来看一个最简单的3位异步二进制加法计数器。</p><p>原理就是用JK触发器实现每次激活后输出Q翻转。第一位的CP连系统时钟，第二位的CP连第一位的输出，第三位的CP连第二位的输出。</p><p>这样子的话，每当第一位从1 -&gt;0时，第二位才会被激活从而翻转，也就实现了“进位”的感觉。</p><p>电路图如下：</p><p><img src="92.png" /></p><p>再来看一下异步二进制减法计数器。（学会了上面的思想这个就很简单了）</p><p>首先二进制减法的规则是：若低位是1，则输入一个脉冲后应当翻转为0。若低位已经是0，则应翻转为1，然后令高位翻转。</p><p>所以根据这个需求，设计就很简单了。所以也是用JK触发器实现翻转功能。然后第一位的CP连系统时钟，第二位的CP连第一位的输出的反，第三位的CP连第二位的输出的反。</p><p>电路图如下：</p><p><img src="93.png" /></p><p>其实还可以用同步时序逻辑去实现加法/减法计数器。但是比较复杂，我觉得考到的概率不大，所以这里就不展开了。</p><hr /><h3 id="十三.-有限状态机设计">十三. 有限状态机设计</h3><p>状态机就跟上面同步时序逻辑电路的设计使用的思想一模一样。就是将现实问题建模成一个个状态，那么整个问题就是在这些状态中转移。</p><hr /><h3 id="复习">复习</h3><ul><li>组合逻辑设计：<ul><li>第一道题：传统方法做组合逻辑设计：即写出逻辑函数表达式然后画电路图</li><li>第二道题：利用已有的逻辑器件实现逻辑函数</li><li>第三道题：利用已有的逻辑器件实现逻辑函数（函数与第二道题一样）</li><li>8421、余3、BCD，有概率前三题会涉及到</li></ul></li><li>异步时序逻辑分析：<ul><li>ppt上有两个例子，把那两个例子搞明白就差不多了</li></ul></li><li>时序逻辑设计：<ul><li>第一道题：设计一个器件</li><li>第二道题：设计一个器件</li><li>第三道题：状态机，上课讲过一些例子，没那么复杂</li><li>代码要写注释</li></ul></li></ul><p><img src="90.png" /></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写于2023/10/6，这门课其实还是有点意思的。但是上个月身体原因一直在关心我自己的身体，所以这门课我全翘掉了，一点没听。现在马上就要实验课了，于是打算在国庆的末尾把这门课学了。目的是能做出几个组合逻辑电路的实验项目。&lt;/p&gt;</summary>
    
    
    
    <category term="4. 大学" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/"/>
    
    <category term="数字逻辑" scheme="http://example.com/categories/4-%E5%A4%A7%E5%AD%A6/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91/"/>
    
    
  </entry>
  
</feed>
